(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three'), require('cannon'), require('pson')) :
	typeof define === 'function' && define.amd ? define(['exports', 'three', 'cannon', 'pson'], factory) :
	(global = global || self, factory(global.Nunu = {}, global.three, global.cannon, global.pson));
}(this, (function (exports, three, cannon, pson) { 'use strict';

	/**
	 * Keyboard instance for input in sync with the running application, internally stores the key transitions provided by the browser.
	 * 
	 * Allow to detect every key press, release event in sync with the app frame update.
	 *
	 * The keyboard object provided by scripts is automatically updated by the runtime handler.
	 * 
	 * @class Keyboard
	 * @module Input
	 * @param {boolean} dontInitialize If true the mouse events are not created.
	 */
	function Keyboard(dontInitialize)
	{
		/**
		 * Array with keyboard keys status.
		 *
		 * @property keys
		 * @type {Array}
		 */
		this.keys = [];

		/**
		 * The actions array serves as a buffer for the key input actions.
		 *
		 * Until the update method is called it stores all the key stroke actions.
		 *
		 * On update the key strokes are updated and the keys array stores the correct values.
		 *
		 * @property actions
		 * @type {Array}
		 */
		this.actions = [];

		var self = this;
		var actions = this.actions;

		/**
		 * Event manager used to handle the keyup, keydown and focus events.
		 *
		 * On each event actions are added to the actions array.
		 *
		 * @property events
		 * @type {EventManager}
		 */
		this.events = new EventManager();
		this.events.add(window, "keydown", function(event)
		{
			actions.push(event.keyCode);
			actions.push(Key.DOWN);
		});
		this.events.add(window, "keyup", function(event)
		{
			actions.push(event.keyCode);
			actions.push(Key.UP);
		});
		this.events.add(window, "focus", function(event)
		{
			self.reset();
		});

		if(dontInitialize !== true)
		{
			this.create();
		}
	}

	Keyboard.prototype = Keyboard;
	Keyboard.prototype.constructor = Keyboard;

	/**
	 * Update key flags synchronously.
	 * 
	 * @method update
	 */
	Keyboard.update = function()
	{
		var end = 0;

		while(this.actions.length > end)
		{
			var key = this.actions.shift();
			var action = this.actions.shift();

			if(this.keys[key] === undefined)
			{
				this.keys[key] = new Key();
			}

			this.keys[key].update(action);

			if(this.keys[key].justReleased || this.keys[key].justPressed)
			{
				this.actions.push(key);
				this.actions.push(Key.RESET);
				end += 2;
			}
		}
	};

	/**
	 * Reset keyboard status to default.
	 *
	 * Does not clean the action list.
	 * 
	 * @method reset
	 */
	Keyboard.reset = function()
	{
		// Reset all keys
		for(var i = 0; i < this.keys.length; i++)
		{
			if(this.keys[i] !== undefined)
			{
				this.keys[i].reset();
			}
		}
	};

	/**
	 * Check if a key is pressed.
	 * 
	 * @method keyPressed
	 * @return {boolean} True is the key is currently pressed
	 */
	Keyboard.keyPressed = function(key)
	{
		return this.keys[key] !== undefined && this.keys[key].pressed;
	};

	/**
	 * Check is a key as just pressed.
	 * 
	 * @method keyJustPressed
	 * @return {boolean} True is the key was just pressed
	 */
	Keyboard.keyJustPressed = function(key)
	{
		return this.keys[key] !== undefined && this.keys[key].justPressed;
	};

	/**
	 * Check if a key was just released.
	 * 
	 * @method keyJustReleased
	 * @return {boolean} True is the key was just pressed
	 */
	Keyboard.keyJustReleased = function(key)
	{
		return this.keys[key] !== undefined && this.keys[key].justReleased;
	};

	/**
	 * Create keyboard events.
	 * 
	 * @method dispose
	 */
	Keyboard.create = function()
	{
		this.events.create();
	};

	/**
	 * Dispose keyboard events.
	 * 
	 * @method dispose
	 */
	Keyboard.dispose = function()
	{
		this.events.destroy();
	};

	/**
	 * TAB key
	 * @attribute TAB
	 * @type {number}
	 */
	Keyboard.TAB = 9;

	/**
	 * ENTER key
	 * @attribute ENTER
	 * @type {number}
	 */
	Keyboard.ENTER = 13;

	/**
	 * SHIFT key
	 * @attribute SHIFT
	 * @type {number}
	 */
	Keyboard.SHIFT = 16;

	/**
	 * CTRL key
	 * @attribute CTRL
	 * @type {number}
	 */
	Keyboard.CTRL = 17;

	/**
	 * ALT key
	 * @attribute ALT
	 * @type {number}
	 */
	Keyboard.ALT = 18;

	/**
	 * CAPS_LOCK key
	 * @attribute CAPS_LOCK
	 * @type {number}
	 */
	Keyboard.CAPS_LOCK = 20;

	/**
	 * ESC key
	 * @attribute ESC
	 * @type {number}
	 */
	Keyboard.ESC = 27;

	/**
	 * SPACEBAR key
	 * @attribute SPACEBAR
	 * @type {number}
	 */
	Keyboard.SPACEBAR = 32;

	/**
	 * PAGE_UP key
	 * @attribute PAGE_UP
	 * @type {number}
	 */
	Keyboard.PAGE_UP = 33;

	/**
	 * PAGE_DOWN key
	 * @attribute PAGE_DOWN
	 * @type {number}
	 */
	Keyboard.PAGE_DOWN = 34;

	/**
	 * END key
	 * @attribute END
	 * @type {number}
	 */
	Keyboard.END = 35;

	/**
	 * HOME key
	 * @attribute HOME
	 * @type {number}
	 */
	Keyboard.HOME = 36;

	/**
	 * INSERT key
	 * @attribute INSERT
	 * @type {number}
	 */
	Keyboard.INSERT = 45;

	/**
	 * DEL key
	 * @attribute DEL
	 * @type {number}
	 */
	Keyboard.DEL = 46;

	/**
	 * LEFT key
	 * @attribute LEFT
	 * @type {number}
	 */
	Keyboard.LEFT = 37;

	/**
	 * RIGHT key
	 * @attribute RIGHT
	 * @type {number}
	 */
	Keyboard.RIGHT = 39;

	/**
	 * UP key
	 * @attribute UP
	 * @type {number}
	 */
	Keyboard.UP = 38;

	/**
	 * DOWN key
	 * @attribute DOWN
	 * @type {number}
	 */
	Keyboard.DOWN = 40;

	/**
	 * NUM0 key
	 * @attribute NUM0
	 * @type {number}
	 */
	Keyboard.NUM0 = 48;

	/**
	 * NUM1 key
	 * @attribute NUM1
	 * @type {number}
	 */
	Keyboard.NUM1 = 49;

	/**
	 * NUM2 key
	 * @attribute NUM2
	 * @type {number}
	 */
	Keyboard.NUM2 = 50;

	/**
	 * NUM3 key
	 * @attribute NUM3
	 * @type {number}
	 */
	Keyboard.NUM3 = 51;

	/**
	 * NUM4 key
	 * @attribute NUM4
	 * @type {number}
	 */
	Keyboard.NUM4 = 52;

	/**
	 * NUM5 key
	 * @attribute NUM5
	 * @type {number}
	 */
	Keyboard.NUM5 = 53;

	/**
	 * NUM6 key
	 * @attribute NUM6
	 * @type {number}
	 */
	Keyboard.NUM6 = 54;

	/**
	 * NUM7 key
	 * @attribute NUM7
	 * @type {number}
	 */
	Keyboard.NUM7 = 55;

	/**
	 * NUM8 key
	 * @attribute NUM8
	 * @type {number}
	 */
	Keyboard.NUM8 = 56;

	/**
	 * NUM9 key
	 * @attribute NUM9
	 * @type {number}
	 */
	Keyboard.NUM9 = 57;

	/**
	 * A key
	 * @attribute A
	 * @type {number}
	 */
	Keyboard.A = 65;

	/**
	 * B key
	 * @attribute B
	 * @type {number}
	 */
	Keyboard.B = 66;

	/**
	 * C key
	 * @attribute C
	 * @type {number}
	 */
	Keyboard.C = 67;

	/**
	 * D key
	 * @attribute D
	 * @type {number}
	 */
	Keyboard.D = 68;

	/**
	 * E key
	 * @attribute E
	 * @type {number}
	 */
	Keyboard.E = 69;

	/**
	 * F key
	 * @attribute F
	 * @type {number}
	 */
	Keyboard.F = 70;

	/**
	 * G key
	 * @attribute G
	 * @type {number}
	 */
	Keyboard.G = 71;

	/**
	 * H key
	 * @attribute H
	 * @type {number}
	 */
	Keyboard.H = 72;

	/**
	 * I key
	 * @attribute I
	 * @type {number}
	 */
	Keyboard.I = 73;

	/**
	 * J key
	 * @attribute J
	 * @type {number}
	 */
	Keyboard.J = 74;

	/**
	 * K key
	 * @attribute K
	 * @type {number}
	 */
	Keyboard.K = 75;

	/**
	 * L key
	 * @attribute L
	 * @type {number}
	 */
	Keyboard.L = 76;

	/**
	 * M key
	 * @attribute M
	 * @type {number}
	 */
	Keyboard.M = 77;

	/**
	 * N key
	 * @attribute N
	 * @type {number}
	 */
	Keyboard.N = 78;

	/**
	 * O key
	 * @attribute O
	 * @type {number}
	 */
	Keyboard.O = 79;

	/**
	 * P key
	 * @attribute P
	 * @type {number}
	 */
	Keyboard.P = 80;

	/**
	 * Q key
	 * @attribute Q
	 * @type {number}
	 */
	Keyboard.Q = 81;

	/**
	 * R key
	 * @attribute R
	 * @type {number}
	 */
	Keyboard.R = 82;

	/**
	 * S key
	 * @attribute S
	 * @type {number}
	 */
	Keyboard.S = 83;

	/**
	 * T key
	 * @attribute T
	 * @type {number}
	 */
	Keyboard.T = 84;

	/**
	 * U key
	 * @attribute U
	 * @type {number}
	 */
	Keyboard.U = 85;

	/**
	 * V key
	 * @attribute V
	 * @type {number}
	 */
	Keyboard.V = 86;

	/**
	 * W key
	 * @attribute W
	 * @type {number}
	 */
	Keyboard.W = 87;

	/**
	 * X key
	 * @attribute X
	 * @type {number}
	 */
	Keyboard.X = 88;

	/**
	 * Y key
	 * @attribute Y
	 * @type {number}
	 */
	Keyboard.Y = 89;

	/**
	 * Z key
	 * @attribute Z
	 * @type {number}
	 */
	Keyboard.Z = 90;

	/**
	 * F1 key
	 * @attribute F1
	 * @type {number}
	 */
	Keyboard.F1 = 112;

	/**
	 * F2 key
	 * @attribute F2
	 * @type {number}
	 */
	Keyboard.F2 = 113;

	/**
	 * F3 key
	 * @attribute F3
	 * @type {number}
	 */
	Keyboard.F3 = 114;

	/**
	 * F4 key
	 * @attribute F4
	 * @type {number}
	 */
	Keyboard.F4 = 115;

	/**
	 * F5 key
	 * @attribute F5
	 * @type {number}
	 */
	Keyboard.F5 = 116;

	/**
	 * F6 key
	 * @attribute F6
	 * @type {number}
	 */
	Keyboard.F6 = 117;

	/**
	 * F7 key
	 * @attribute F7
	 * @type {number}
	 */
	Keyboard.F7 = 118;

	/**
	 * F8 key
	 * @attribute F8
	 * @type {number}
	 */
	Keyboard.F8 = 119;

	/**
	 * F9 key
	 * @attribute F9
	 * @type {number}
	 */
	Keyboard.F9 = 120;

	/**
	 * F10 key
	 * @attribute F10
	 * @type {number}
	 */
	Keyboard.F10 = 121;

	/**
	 * F11 key
	 * @attribute F11
	 * @type {number}
	 */
	Keyboard.F11 = 122;

	/**
	 * F12 key
	 * @attribute F12
	 * @type {number}
	 */
	Keyboard.F12 = 123;

	/**
	 * Key is used by Keyboard, Mouse, etc, to represent a key state.
	 *
	 * @class Key
	 * @module Input
	*/
	function Key()
	{
		/**
		 * Indicates if this key is currently pressed.
		 * @property pressed
		 * @default false
		 * @type {boolean}
		 */
		this.pressed = false;

		/**
		 * Indicates if this key was just pressed.
		 * @property justPressed
		 * @default false
		 * @type {boolean}
		 */
		this.justPressed = false;
		
		/**
		 * Indicates if this key was just released.
		 * @property justReleased
		 * @default false
		 * @type {boolean}
		 */
		this.justReleased = false;
	}

	/**
	 * Down
	 * @attribute DOWN
	 * @type {number}
	 */
	Key.DOWN = -1;

	/**
	 * Up
	 * @attribute UP
	 * @type {number}
	 */
	Key.UP = 1;

	/**
	 * Reset
	 * @attribute RESET
	 * @type {number}
	 */
	Key.RESET = 0;

	Key.prototype.constructor = Key;

	/**
	 * Update Key status based on new key state.
	 * 
	 * @method update
	 */
	Key.prototype.update = function(action)
	{
		this.justPressed = false;
		this.justReleased = false;

		if(action === Key.DOWN)
		{
			if(this.pressed === false)
			{
				this.justPressed = true;
			}
			this.pressed = true;
		}
		else if(action === Key.UP)
		{
			if(this.pressed)
			{
				this.justReleased = true;
			}
			this.pressed = false;
		}
		else if(action === Key.RESET)
		{
			this.justReleased = false;
			this.justPressed = false;
		}
	};

	/**
	 * Set this key attributes manually.
	 * 
	 * @method set
	 */
	Key.prototype.set = function(justPressed, pressed, justReleased)
	{
		this.justPressed = justPressed;
		this.pressed = pressed;
		this.justReleased = justReleased;
	};

	/**
	 * Reset key to default values.
	 * 
	 * @method reset
	*/
	Key.prototype.reset = function()
	{
		this.justPressed = false;
		this.pressed = false;
		this.justReleased = false;
	};

	/**
	 * Mouse instance for sync input the mouse should be updated everytime before.
	 *
	 * Automatically calculates the diff of position between frames.
	 * 
	 * The mouse object provided by scripts is automatically updated by the runtime handler.
	 * 
	 * @class Mouse
	 * @module Input
	 * @param {Component} domElement DOM element to craete the mouse events.
	 * @param {boolean} dontInitialize If true the mouse events are not created.
	 */
	function Mouse(domElement, dontInitialize)
	{
		// Raw data
		this._keys = new Array(5);
		this._position = new three.Vector2(0, 0);
		this._positionUpdated = false;
		this._delta = new three.Vector2(0, 0);
		this._wheel = 0;
		this._wheelUpdated = false;
		this._doubleClicked = new Array(5);

		/**
		 * Array with mouse buttons status.
		 *
		 * @type {array}
		 * @property keys
		 */
		this.keys = new Array(5);

		/**
		 * Mouse position inside of the window (coordinates in window space).
		 *
		 * @type {Vector2}
		 * @property position
		 */
		this.position = new three.Vector2(0, 0);

		/**
		 * Mouse movement (coordinates in window space).
		 *
		 * @type {Vector2}
		 * @property delta
		 */
		this.delta = new three.Vector2(0, 0);

		/**
		 * Mouse scroll wheel movement.
		 *
		 * @type {number}
		 * @property wheel
		 */
		this.wheel = 0;
		
		/**
		 * Indicates a button of the mouse was double clicked.
		 *
		 * @type {Array}
		 * @property doubleClicked
		 */
		this.doubleClicked = new Array(5);

		/**
		 * DOM element where to attach the mouse events.
		 *
		 * @property domElement
		 * @type {Element}
		 */
		this.domElement = (domElement !== undefined) ? domElement : window;

		/**
		 * Canvas attached to this mouse instance used to calculate position and delta in element space coordinates.
		 *
		 * @type {Element}
		 * @property canvas
		 */
		this.canvas = null;
		
		/**
		 * Event manager responsible for updating the raw data variables.
		 *
		 * Diferent events are used depending on the host platform.
		 *
		 * When the update method is called the raw data is reset.
		 *
		 * @property events
		 * @type {EventManager} 
		 */
		this.events = new EventManager();

		// Initialize key instances
		for(var i = 0; i < 5; i++)
		{
			this._doubleClicked[i] = false;
			this.doubleClicked[i] = false;
			this._keys[i] = new Key();
			this.keys[i] = new Key();
		}

		// Self pointer
		var self = this;

		// Scroll wheel
		if(window.onmousewheel !== undefined)
		{
			// Chrome, edge
			this.events.add(this.domElement, "mousewheel", function(event)
			{
				self._wheel = event.deltaY;
				self._wheelUpdated = true;
			});
		}
		else if(window.addEventListener !== undefined)
		{
			// Firefox
			this.events.add(this.domElement, "DOMMouseScroll", function(event)
			{
				self._wheel = event.detail * 30;
				self._wheelUpdated = true;
			});
		}
		else
		{
			this.events.add(this.domElement, "wheel", function(event)
			{
				self._wheel = event.deltaY;
				self._wheelUpdated = true;
			});
		}

		// Touchscreen input events
		if(window.ontouchstart !== undefined || navigator.msMaxTouchPoints > 0)
		{
			// Auxiliar variables to calculate touch delta
			var lastTouch = new three.Vector2(0, 0);

			// Touch start event
			this.events.add(this.domElement, "touchstart", function(event)
			{
				var touch = event.touches[0];

				self.updatePosition(touch.clientX, touch.clientY, 0, 0);
				self.updateKey(Mouse.LEFT, Key.DOWN);

				lastTouch.set(touch.clientX, touch.clientY);
			});

			// Touch end event
			this.events.add(this.domElement, "touchend", function(event)
			{
				self.updateKey(Mouse.LEFT, Key.UP);
			});

			// Touch cancel event
			this.events.add(this.domElement, "touchcancel", function(event)
			{
				self.updateKey(Mouse.LEFT, Key.UP);
			});

			// Touch move event
			this.events.add(document.body, "touchmove", function(event)
			{
				var touch = event.touches[0];
				self.updatePosition(touch.clientX, touch.clientY, touch.clientX - lastTouch.x, touch.clientY - lastTouch.y);
				lastTouch.set(touch.clientX, touch.clientY);
			});
		}

		// Move
		this.events.add(this.domElement, "mousemove", function(event)
		{
			self.updatePosition(event.clientX, event.clientY, event.movementX, event.movementY);
		});

		// Button pressed
		this.events.add(this.domElement, "mousedown", function(event)
		{
			self.updateKey(event.which - 1, Key.DOWN);
		});

		// Button released
		this.events.add(this.domElement, "mouseup", function(event)
		{
			self.updateKey(event.which - 1, Key.UP);
		});

		// Drag start
		this.events.add(this.domElement, "dragstart", function(event)
		{
			self.updateKey(event.which - 1, Key.UP);
		});

		// Mouse double click
		this.events.add(this.domElement, "dblclick", function(event)
		{	
			self._doubleClicked[event.which - 1] = true;
		});

		if(dontInitialize !== true)
		{
			this.create();
		}
	}

	Mouse.prototype = Mouse;
	Mouse.prototype.constructor = Mouse;

	/**
	 * Left mouse button.
	 *
	 * @attribute LEFT
	 * @type {number}
	 */
	Mouse.LEFT = 0;

	/**
	 * Middle mouse button.
	 *
	 * @attribute MIDDLE
	 * @type {number}
	 */
	Mouse.MIDDLE = 1;

	/**
	 * Right mouse button.
	 *
	 * @attribute RIGHT
	 * @type {number}
	 */
	Mouse.RIGHT = 2;

	/**
	 * Back mouse navigation button.
	 *
	 * @attribute BACK
	 * @type {number}
	 */
	Mouse.BACK = 3;

	/**
	 * Forward mouse navigation button.
	 *
	 * @attribute FORWARD
	 * @type {number}
	 */
	Mouse.FORWARD = 4;

	/**
	 * Element to be used for coordinates calculation relative to that canvas.
	 * 
	 * @method setCanvas
	 * @param {Component} canvas Canvas to be attached to the Mouse instance
	 */
	Mouse.setCanvas = function(element)
	{
		this.canvas = element;

		element.mouseInside = false;

		element.addEventListener("mouseenter", function()
		{
			this.mouseInside = true;
		});

		element.addEventListener("mouseleave", function()
		{
			this.mouseInside = false;
		});
	};

	/**
	 * Check if mouse is inside attached canvas (updated async).
	 * 
	 * @method insideCanvas
	 * @return {boolean} True if mouse is currently inside the canvas
	 */
	Mouse.insideCanvas = function()
	{
		return this.canvas !== null && this.canvas.mouseInside;
	};

	/**
	 * Set mouse lock, if true mouse lock will be request, if false the mouse will be released.
	 * 
	 * @method setLock
	 * @param {boolean} value If true pointer lock will be requested for the canvas attached to the Mouse instance
	 */
	Mouse.setLock = function(value)
	{
		if(this.canvas !== null)
		{
			if(value)
			{
				this.canvas.requestPointerLock = this.canvas.requestPointerLock || this.canvas.mozRequestPointerLock || this.canvas.webkitRequestPointerLock;
				if(this.canvas.requestPointerLock !== undefined)
				{
					this.canvas.requestPointerLock();
				}
			}
			else
			{
				if(document.exitPointerLock !== undefined)
				{
					document.exitPointerLock();
				}
				else if(document.mozExitPointerLock !== undefined)
				{
					document.mozExitPointerLock();
				}
				else if(document.webkitExitPointerLock !== undefined)
				{
					document.webkitExitPointerLock();
				}
			}
		}
	};

	/**
	 * Check if mouse button is currently pressed.
	 * 
	 * @method buttonPressed
	 * @param {number} button Button to check status of
	 * @return {boolean} True if button is currently pressed
	 */
	Mouse.buttonPressed = function(button)
	{
		return this.keys[button].pressed;
	};

	/**
	 * Check if Mouse button was double clicked.
	 * 
	 * @method buttonDoubleClicked
	 * @param {number} button Button to check status of
	 * @return {boolean} True if some mouse button was just double clicked
	 */
	Mouse.buttonDoubleClicked = function(button)
	{
		return this.doubleClicked[button];
	};

	/**
	 * Check if a mouse button was just pressed.
	 * 
	 * @method buttonJustPressed
	 * @param {number} button Button to check status of
	 * @return {boolean} True if button was just pressed
	 */
	Mouse.buttonJustPressed = function(button)
	{
		return this.keys[button].justPressed;
	};

	/**
	 * Check if a mouse button was just released.
	 * 
	 * @method buttonJustReleased
	 * @param {number} button Button to check status of
	 * @return {boolean} True if button was just released
	 */
	Mouse.buttonJustReleased = function(button)
	{
		return this.keys[button].justReleased;
	};

	/**
	 * Update mouse position.
	 * 
	 * @method updatePosition
	 * @param {number} x
	 * @param {number} y
	 * @param {number} xDiff
	 * @param {number} yDiff
	 */
	Mouse.updatePosition = function(x, y, xDiff, yDiff)
	{
		if(this.canvas !== null)
		{
			var rect = this.canvas.getBoundingClientRect();
			x -= rect.left;
			y -= rect.top;
		}

		this._position.set(x, y);
		this._delta.x += xDiff;
		this._delta.y += yDiff;
		this._positionUpdated = true;
	};

	/**
	 * Update a mouse button.
	 *
	 * @method updateKey
	 * @param {number} button
	 * @param {number} action
	 */
	Mouse.updateKey = function(button, action)
	{
		if(button > -1)
		{
			this._keys[button].update(action);
		}
	};

	/**
	 * Update mouse buttons state, position, wheel and delta synchronously.
	 * 
	 * @method update
	 */
	Mouse.update = function()
	{
		// Update mouse keys state
		for(var i = 0; i < 5; i++)
		{
			if(this._keys[i].justPressed && this.keys[i].justPressed)
			{
				this._keys[i].justPressed = false;
			}
			if(this._keys[i].justReleased && this.keys[i].justReleased)
			{
				this._keys[i].justReleased = false;
			}

			this.keys[i].set(this._keys[i].justPressed, this._keys[i].pressed, this._keys[i].justReleased);

			// Update mouse double click
			if(this._doubleClicked[i] === true)
			{
				this.doubleClicked[i] = true;
				this._doubleClicked[i] = false;
			}
			else
			{
				this.doubleClicked[i] = false;
			}
		}

		// Update mouse wheel
		if(this._wheelUpdated)
		{
			this.wheel = this._wheel;
			this._wheelUpdated = false;
		}
		else
		{
			this.wheel = 0;
		}

		// Update mouse Position if needed
		if(this._positionUpdated)
		{
			this.delta.copy(this._delta);
			this.position.copy(this._position);

			this._delta.set(0,0);
			this._positionUpdated = false;
		}
		else
		{
			this.delta.x = 0;
			this.delta.y = 0;
		}
	};

	/**
	 * Create mouse events.
	 * 
	 * @method create
	 */
	Mouse.create = function()
	{
		this.events.create();
	};

	/**
	 * Dispose mouse events.
	 * 
	 * @method dispose
	 */
	Mouse.dispose = function()
	{
		this.events.destroy();
	};

	/**
	 * EventManager is used to manager DOM events creationg and destruction in a single function call.
	 *
	 * It is used by objects to make it easier to add, manager and remove events from DOM elements.
	 *
	 * @constructor
	 * @class EventManager
	 * @module Utils
	 */
	function EventManager()
	{
		/**
		 * Stores all events in the manager, their target and callback.
		 * 
		 * Format [target, event, callback, active]
		 * 
		 * @attribute events
		 * @type {Array}
		 */
		this.events = [];
	}

	/**
	 * Add and create and event to the event manager.
	 *
	 * Creates the event and attaches it to the DOM element immediatly.
	 *
	 * @method addCreate
	 * @param {Element} target Event target element.
	 * @param {string} event Event name.
	 * @param {Function} callback Callback function.
	 */
	EventManager.prototype.addAndCreate = function(target, event, callback)
	{
		var data = [target, event, callback, true];
		data[0].addEventListener(data[1], data[2]);
		data[3] = true;
		this.events.push(data);
	};


	/**
	 * Remove and destroy event(s) from a DOM element and from the manager.
	 *
	 * @method remove
	 * @param {Element} target Event target element to remove elements from.
	 * @param {string} event Event name to be removed.
	 */
	EventManager.prototype.remove = function(target, event)
	{
		for(var i = this.events.length - 1; i >= 0; i--)
		{
			// Check if the target and event matches
			if(this.events[i][0] === target && this.events[i][1] === event)
			{
				// Destroy event if it is active
				if(this.events[i][3])
				{
					this.events[i][0].removeEventListener(this.events[i][1], this.events[i][2]);
					this.events[i][3] = false;
				}

				this.events.splice(i, 1);
			}
		}
	};


	/**
	 * Add new event to the manager, the event is not created immediatly the create() method had to be called to create the event.
	 *
	 * @method add
	 * @param {Element} target Event target element.
	 * @param {string} event Event name.
	 * @param {Function} callback Callback function.
	 */
	EventManager.prototype.add = function(target, event, callback)
	{
		this.events.push([target, event, callback, false]);
	};

	/**
	 * Destroys this manager by stopping all event handlers and remove them from the manager.
	 *
	 * @method clear
	 */
	EventManager.prototype.clear = function()
	{
		this.destroy();
		this.events = [];
	};

	/**
	 * Creates the events in this manager by attaching them to the DOM elements.
	 *
	 * Uses the element.addEventListener() method to attach the event handlers.
	 * 
	 * @method create
	 */
	EventManager.prototype.create = function()
	{
		for(var i = 0; i < this.events.length; i++)
		{
			var event = this.events[i];
			event[0].addEventListener(event[1], event[2]);
			event[3] = true;
		}
	};

	/**
	 * Destroy all events in this manager, stop the events.
	 *
	 * Uses the element.removeEventListener() method to destroy the event handlers.
	 *
	 * Does not remove the events from the manager.
	 * 
	 * @method destroy
	 */
	EventManager.prototype.destroy = function()
	{
		for(var i = 0; i < this.events.length; i++)
		{
			var event = this.events[i];
			event[0].removeEventListener(event[1], event[2]);
			event[3] = false;
		}
	};

	/**
	 * Add a scroll event to a target element.
	 *
	 * @method addScrollEvent
	 * @param {Element} target Event target element.
	 * @param {Function} callback Callback function.
	 */
	EventManager.prototype.addScrollEvent = function(target, callback)
	{
		if(window.onmousewheel !== undefined)
		{
			this.add(target, "mousewheel", callback);
		}
		else if(window.addEventListener !== undefined)
		{
			this.add(target, "DOMMouseScroll", function(event)
			{
				event.deltaY = event.detail * 30;
				callback(event);
			});
		}
		else
		{
			this.add(target, "wheel", callback);
		}
	};

	/**
	 * Base64Utils contains methods to convert from and to Base64 binary format.
	 *
	 * @class Base64Utils
	 * @module BinaryUtils
	 * @static
	 */
	function Base64Utils(){}

	/**
	 * Charset used to encode binary data.
	 *
	 * @attribute encoding
	 * @type {string}
	 */
	Base64Utils.encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	/**
	 * Check if some data is encoded as base64.
	 *
	 * This is a fast test that picks some random position in the string to check if they are valid base64 characters.
	 *
	 * @method isBase64
	 * @param {Object} data Data to be tested.
	 * @return {boolean} True if data is base64 encoded, false otherwise.
	 */
	Base64Utils.isBase64 = function(data)
	{
		if(typeof data !== "string")
		{
			return false;
		}

		// Check if it has a base64 header
		if(data.startsWith("data:"))
		{
			return true;
		}

		// Check string data
		for(var i = 0; i < data.length; i++)
		{
			if(!Base64Utils.encoding.includes(data.charAt(i)))
			{
				return false;
			}
		}

		return true;
	};

	/**
	 * Remove base64 header from data.
	 * 
	 * Usefull for removing the heander from image, audio, video, etc.
	 *
	 * @method removeHeader
	 * @param {string} base64
	 * @return {string} base64
	 */
	Base64Utils.removeHeader = function(data)
	{
		return data.slice(data.search(";base64,") + 8);
	};

	/**
	 * Get the file format present in the base64 string.
	 *
	 * @method getFileFormat
	 * @param  {string} data Base64 data.
	 * @return {string} File format present in the JSON data.
	 */
	Base64Utils.getFileFormat = function(data)
	{
		var start = data.indexOf("/") + 1;
		var end = data.indexOf(";");
		
		return data.substr(start, end - start);
	};

	/**
	 * Create base64 string from arraybuffer.
	 *
	 * @method fromArraybuffer
	 * @param {Arraybuffer} arraybuffer
	 * @return {string} base64
	 */
	Base64Utils.fromArraybuffer = function(arraybuffer)
	{
		var base64 = "";

		var view = new Uint8Array(arraybuffer);
		var remainder = view.byteLength % 3;
		var length = view.byteLength - remainder;

		var a, b, c, d;
		var chunk;

		// Chunks of 3 bytes for cycle
		for(var i = 0; i < length; i += 3)
		{
			chunk = (view[i] << 16) | (view[i + 1] << 8) | view[i + 2];

			a = (chunk & 16515072) >> 18;
			b = (chunk & 258048) >> 12;
			c = (chunk & 4032) >> 6;
			d = chunk & 63;

			base64 += Base64Utils.encoding[a] + Base64Utils.encoding[b] + Base64Utils.encoding[c] + Base64Utils.encoding[d];
		}

		// Remaining bytes
		if(remainder === 1)
		{
			chunk = view[length];

			a = (chunk & 252) >> 2;
			b = (chunk & 3) << 4;

			base64 += Base64Utils.encoding[a] + Base64Utils.encoding[b] + "==";
		}
		else if(remainder === 2)
		{
			chunk = (view[length] << 8) | view[length + 1];

			a = (chunk & 64512) >> 10;
			b = (chunk & 1008) >> 4;
			c = (chunk & 15) << 2;

			base64 += Base64Utils.encoding[a] + Base64Utils.encoding[b] + Base64Utils.encoding[c] + "=";
		}

		return base64;
	};

	/**
	 * Create base64 string from binary string.
	 *
	 * @method fromBinaryString
	 * @param {string} str
	 * @return {string} base64
	 */
	Base64Utils.fromBinaryString = function(str)
	{
		var base64 = "";
		var remainder = str.length % 3;
		var length = str.length - remainder;

		var a, b, c;

		for(var i = 0; i < length; i += 3)
		{
			a = str.charCodeAt(i) & 0xff;
			b = str.charCodeAt(i + 1);
			c = str.charCodeAt(i + 2);

			base64 += Base64Utils.encoding.charAt(a >> 2);
			base64 += Base64Utils.encoding.charAt(((a & 0x3) << 4) | ((b & 0xF0) >> 4));
			base64 += Base64Utils.encoding.charAt(((b & 0xF) << 2) | ((c & 0xC0) >> 6));
			base64 += Base64Utils.encoding.charAt(c & 0x3F);
		}
		
		if(remainder === 1)
		{
			a = str.charCodeAt(i) & 0xff;

			base64 += Base64Utils.encoding.charAt(a >> 2);
			base64 += Base64Utils.encoding.charAt((a & 0x3) << 4);
			base64 += "==";
		}
		else if(remainder === 2)
		{
			a = str.charCodeAt(i) & 0xff;
			b = str.charCodeAt(i + 1);

			base64 += Base64Utils.encoding.charAt(a >> 2);
			base64 += Base64Utils.encoding.charAt(((a & 0x3) << 4) | ((b & 0xF0) >> 4));
			base64 += Base64Utils.encoding.charAt((b & 0xF) << 2);
			base64 += "=";
		}

		return base64;
	};

	/**
	 * ArraybufferUtils contains methods to convert from and to ArrayBuffer binary format
	 * 
	 * @class ArraybufferUtils
	 * @module BinaryUtils
	 * @static
	 */
	function ArraybufferUtils(){}

	/**
	 * Create arraybuffer from binary string
	 *
	 * @method fromBinaryString
	 * @param {string} str
	 * @return {Arraybuffer} data
	 */
	ArraybufferUtils.fromBinaryString = function(str)
	{
		var length = str.length;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		for(var i = 0; i < length; i++)
		{
			view[i] = str.charCodeAt(i);
		}

		return arraybuffer;
	};

	/**
	 * Create arraybuffer from base64 string
	 *
	 * @method fromBase64
	 * @param {string} base64
	 * @return {Arraybuffer} data
	 */
	ArraybufferUtils.fromBase64 = function(str)
	{
		var encoding = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		var length = str.length / 4 * 3;
		var arraybuffer = new ArrayBuffer(length);
		var view = new Uint8Array(arraybuffer);

		var a, b, c, d;

		for(var i = 0, j = 0; i < length; i += 3)
		{
			a = encoding.indexOf(str.charAt(j++));
			b = encoding.indexOf(str.charAt(j++));
			c = encoding.indexOf(str.charAt(j++));
			d = encoding.indexOf(str.charAt(j++));

			view[i] = (a << 2) | (b >> 4);
			if(c !== 64)
			{
				view[i+1] = ((b & 15) << 4) | (c >> 2);
			}
			if(d !== 64)
			{
				view[i+2] = ((c & 3) << 6) | d;
			}
		}

		return arraybuffer;
	};

	/**
	 * Create arraybuffer from Nodejs buffer
	 *
	 * @method fromBuffer
	 * @param {Buffer} buffer
	 * @return {Arraybuffer} data
	 */
	ArraybufferUtils.fromBuffer = function(buffer)
	{
		var array = new ArrayBuffer(buffer.length);
		var view = new Uint8Array(array);

		for(var i = 0; i < buffer.length; i++)
		{
			view[i] = buffer[i];
		}

		return array;

		// Faster but the results is failing the "instanceof ArrayBuffer" test
		// return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
	};

	/**
	 * BufferUtils contains methods to convert from and to Node.js Buffer binary format
	 * 
	 * @class BufferUtils
	 * @module BinaryUtils
	 * @static
	 */
	function BufferUtils(){}

	/**
	 * Create nodejs buffer from arraybuffer
	 *
	 * @method fromArrayBuffer
	 * @param {Arraybuffer} array
	 * @return {Buffer} buffer
	 */
	BufferUtils.fromArrayBuffer = function(array)
	{
		var buffer = new Buffer(array.byteLength);
		var view = new Uint8Array(array);
		
		for(var i = 0; i < buffer.length; i++)
		{
			buffer[i] = view[i];
		}

		return buffer;
	};

	/**
	 * Audio class is used to store audio data as a arraybuffer to be later used by objects with the WebAudio API.
	 * 
	 * @class Audio
	 * @extends {Resource}
	 * @module Resources
	 * @param {ArrayBuffer, String} url URL to Audio file or ArrayBuffer data.
	 * @param {string} encoding Audio encoding (mp3, wav, etc).
	 */
	function Audio(url, encoding)
	{
		Resource.call(this, "audio", "Audio");
		
		if(url !== undefined)
		{
			// Arraybuffer
			if(url instanceof ArrayBuffer)
			{
				this.data = url;
				this.encoding = (encoding !== undefined) ? encoding : "";
				this.format = "arraybuffer";
			}
			// Base64
			else if(Base64Utils.isBase64(url))
			{
				this.encoding = (encoding !== undefined) ? encoding : "";
				this.data = ArraybufferUtils.fromBase64(url);
				this.format = "arraybuffer";
			}
			// URL
			else
			{
				this.data = FileSystem.readFileArrayBuffer(url);
				this.encoding = FileSystem.getFileExtension(url);
				this.format = "arraybuffer";
			}
		}
	}

	Audio.prototype = Object.create(Resource.prototype);

	/**
	 * Check if a file name refers to a supported audio file.
	 *
	 * @method fileIsAudio
	 * @static
	 * @param {File} file
	 * @return {boolean} True if the file refers to a supported audio format.
	 */
	Audio.fileIsAudio = function(file)
	{
		if(file !== undefined)
		{
			if(file.type.startsWith("audio"))
			{
				return true;
			}
		}

		return false;
	};

	/**
	 * Get an WebAudio buffer to play the audio stored in this resources.
	 *
	 * This method is asyncronous and the value is returned using a callback function.
	 * 
	 * @method getAudioBuffer
	 * @param {AudioContext} context WebAudio context used to decode the audio data.
	 * @param {Function} callback Callback funtion that receives an audio buffer as argument.
	 */
	Audio.prototype.getAudioBuffer = function(context, callback)
	{
		context.decodeAudioData(this.data.slice(0), callback, function(error)
		{
			console.error("nunuStudio: Cannot decode audio buffer (" + error + ")");
		});
	};


	/**
	 * Serialize audio data as json.
	 * 
	 * Audio data is serialized in Base64.
	 *
	 * @method toJSON
	 * @param {meta} meta
	 * @return {Object} data
	 */
	Audio.prototype.toJSON = function(meta)
	{
		if(meta.audio[this.uuid] !== undefined)
		{
			return meta.audio[this.uuid];
		}

		var data = Resource.prototype.toJSON.call(this, meta);
		
		data.encoding = this.encoding;
		data.data = this.data;
		data.format = this.format;

		meta.audio[this.uuid] = data;

		return data;
	};

	/**
	 * Containers are used to group objects together.
	 *
	 * They are not drawn in the scene are just used as logic containers.
	 * 
	 * @class Container
	 * @extends {Group}
	 * @module Misc
	 */
	function Container()
	{
		three.Group.call(this);

		this.name = "container";
		this.type = "Group";
	}

	Container.prototype = Object.create(three.Group.prototype);

	/**
	 * MathUtils contains auxiliar values and function to help with mathematical operations.
	 *
	 * @static
	 * @class MathUtils
	 * @module Utils
	 */
	function MathUtils(){}

	/**
	 * Value of PI*2. 360 degrees.
	 *
	 * @attribute pi2
	 * @type {number}
	 */
	MathUtils.PI2 = 2 * Math.PI;

	/**
	 * Value of PI/3. 60 degrees.
	 *
	 * @attribute pid3
	 * @type {number}
	 */
	MathUtils.PID3 = Math.PI / 3;

	/**
	 * Value of PI/2. 45 degrees.
	 *
	 * @attribute pid2
	 * @type {number}
	 */
	MathUtils.PID2 = Math.PI / 2;

	/**
	 * Generates a random color code.
	 *
	 * Uses the #RRGGBB format.
	 *
	 * @method randomColor
	 * @return {string} Generated color code.
	 */
	MathUtils.randomColor = function()
	{
		var letters = "0123456789ABCDEF";
		var color = "#";

		for(var i = 0; i < 6; i++)
		{
			color += letters[Math.floor(Math.random() * 16)];
		}

		return color;
	};

	/**
	 * Image class is used to store image data that is used to create Textures.
	 * 
	 * Images can be stored in mutiple formats.
	 *
	 * Some formats (tga, tiff, etc) are converted to png or jpeg in order to work with the rest of the code.
	 * 
	 * @class Image
	 * @extends {Resource}
	 * @module Resources
	 * @param {ArrayBuffer, Base64, String} data Can be URL to image, ArrayBuffer data or base64 encoded data.
	 * @param {string} encoding Image encoding, required for ArrayBuffer data.
	 */
	function Image(url, encoding)
	{
		Resource.call(this, "image", "Image");

		/**
		 * Image width (in pixels), if not available should be set -1.
		 *
		 * Stores the real size of the image not the used to represent it, its obtained from the naturalWidth attribute of the image element.
		 *
		 * @attribute width
		 * @type {number}
		 */
		this.width = -1;

		/**
		 * Image height (in pixels), if not available should be set -1.
		 *
		 * Stores the real size of the image not the used to represent it, its obtained from the naturalHeight attribute of the image element.
		 *
		 * @attribute height
		 * @type {number}
		 */
		this.height = -1;

		if(url !== undefined)
		{
			// ArrayBuffer
			if(url instanceof ArrayBuffer)
			{
				this.loadArrayBufferData(url, encoding);
			}
			// Base64
			else if(Base64Utils.isBase64(url))
			{
				this.encoding = Base64Utils.getFileFormat(url);
				this.format = "base64";
				this.data = url;
			}
			// Blob (Need to be read immediatly might be revoked to clean space).
			else if(url.startsWith("blob"))
			{
				var arraybuffer = FileSystem.readFileArrayBuffer(url, true);
				this.loadArrayBufferData(arraybuffer);
			}
			// URL
			else
			{
				this.encoding = FileSystem.getFileExtension(url);
				this.format = "url";
				this.data = url;
			}
		}
		else
		{
			this.createSolidColor();
		}
	}

	Image.prototype = Object.create(Resource.prototype);

	/**
	 * Check if a file name refers to a supported binary image file.
	 *
	 * @static
	 * @method fileIsImage
	 * @param {File} file File to check format of.
	 * @return {boolean} True if the file refers to a supported image format.
	 */
	Image.fileIsImage = function(file)
	{
		if(file !== undefined)
		{
			if(file.type.startsWith("image"))
			{
				return true;
			}

			file = file.name.toLocaleLowerCase();

			return file.endsWith("tga") || file.endsWith("dds") || file.endsWith("pvr") || file.endsWith("ktx") || file.endsWith("basis");
		}

		return false;
	};

	/**
	 * Get the image size if its available, if the image size its not available it has to be loaded first.
	 *
	 * @method getImageSize
	 * @param {Function} onLoad Callack method to get the image size, receives (width, height) as parameters.
	 */
	Image.prototype.getImageSize = function(onLoad)
	{
		if(this.width > -1 && this.height > -1)
		{
			onLoad(this.width, this.height);
		}
		else
		{
			var self = this;

			var image = document.createElement("img");
			image.src = this.data;
			image.onload = function()
			{
				self.width = image.naturalWidth;
				self.height = image.naturalHeight;

				onLoad(self.width, self.height);
			};
		}

	};

	/**
	 * Read the image data and return the raw pixel data of the image as a ImageData object.
	 *
	 * @method getImageData
	 * @param {Function} onLoad Callback method to retrieve the image data, receives (data, width, height) as parameters.
	 * @return {ImageData} Image data object with the content of the image object.
	 */
	Image.prototype.getImageData = function(onLoad)
	{
		var self = this;

		var image = document.createElement("img");
		image.src = this.data;
		image.onload = function()
		{	
			self.width = image.naturalWidth;
			self.height = image.naturalHeight;

			var canvas = document.createElement("canvas");
			canvas.width = image.naturalWidth;
			canvas.height = image.naturalWidth;

			var context = canvas.getContext("2d");
			context.drawImage(image, 0, 0, image.width, image.height);

			onLoad(context.getImageData(0, 0, image.width, image.height),self.width, self.height);
		};

	};

	/**
	 * Create a new image with 1x1 resolution with solid color.
	 *
	 * Can be called externally on data load error to load dummy data.
	 *
	 * @method createSolidColor
	 * @param {string} color CSS Color string.
	 */
	Image.prototype.createSolidColor = function(color)
	{
		var canvas = document.createElement("canvas");
		canvas.width = 1;
		canvas.height = 1;

		var context = canvas.getContext("2d");
		context.fillStyle = (color !== undefined) ? color : MathUtils.randomColor();
		context.fillRect(0, 0, 1, 1);

		this.data = canvas.toDataURL("image/png");
		this.format = "base64";
		this.encoding = "png";
	};

	/**
	 * Load arraybuffer data to this image.
	 *
	 * Creates a blob with data to be stored on data atribute and used by external objects.
	 *
	 * @method loadArrayBufferData
	 * @param {ArrayBuffer} data Data to be loaded.
	 * @param {string} encoding Image enconding (jpeg, png, etc).
	 */
	Image.prototype.loadArrayBufferData = function(data, encoding)
	{
		var view = new Uint8Array(data);
		var blob = new Blob([view], {type: "image/" + encoding});

		this.data = URL.createObjectURL(blob);
		this.arraybuffer = data;
		this.encoding = encoding !== undefined ? encoding : "";
		this.format = "arraybuffer";
	};

	/**
	 * Check if this image has alpha channel.
	 *
	 * This checks the file encoding if the file a GIF or a PNG is assumed that the file has alpha channel.
	 *
	 * @method hasTransparency
	 * @param {boolean} perPixel Check every individual pixel to see if the image actually has tranparency data, default is false.
	 * @return {boolean} True if the image is encoded as PNG or GIF
	 */
	Image.prototype.hasTransparency = function(perPixel)
	{
		if(perPixel === true && this.width > -1 && this.height > -1)
		{
			var image = document.createElement("img");

			var canvas = document.createElement("canvas");
			canvas.width = image.width;
			canvas.height = image.height;

			var context = canvas.getContext("2d");
			context.drawImage(image, 0, 0, image.width, image.height);

			var data = context.getImageData(0, 0, image.width, image.height).data;

			for(var i = 3; i < data.length; i += 4)
			{
				if(data[i] !== 255)
				{
					return true;
				}
			}

			return false;
		}
		else
		{
			return this.encoding === "png" || this.encoding === "gif";
		}
	};

	/**
	 * Compresses image data to JPEG.
	 *
	 * Can be used to compress data and save some space.
	 * 
	 * @method compressJPEG
	 * @param {number} quality JPEG compression quality level by default 0.7 is used (1.0  means max quality).
	 */
	Image.prototype.compressJPEG = function(quality)
	{
		var image = document.createElement("img");
		image.src = this.data;

		var canvas = document.createElement("canvas");
		canvas.width = image.width;
		canvas.height = image.height;

		var context = canvas.getContext("2d");
		context.drawImage(image, 0, 0, image.width, image.height);

		var self = this;

		canvas.toBlob(function(blob)
		{
			var reader = new FileReader();
			
			reader.onload = function()
			{
				self.encoding = "jpeg";
				self.format = "arraybuffer";
				self.data = reader.result;
			};

			reader.readAsArrayBuffer(blob);

		}, "image/jpeg", quality !== undefined ? quality : 0.7);
	};

	Image.prototype.dispose = function()
	{
		if(this.format === "arraybuffer")
		{
			URL.revokeObjectURL(this.data);
		}
	};

	/**
	 * Serialize Image resource to json.
	 *
	 * If image is stored as URL it is converter to PNG or JPEG.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	Image.prototype.toJSON = function(meta)
	{
		if(meta.images[this.uuid] !== undefined)
		{
			return meta.images[this.uuid];
		}

		var data = Resource.prototype.toJSON.call(this, meta);

		if(this.format === "url")
		{
			this.loadArrayBufferData(FileSystem.readFileArrayBuffer(this.data), this.encoding);
		}

		data.width = this.width;
		data.height = this.height;
		data.encoding = this.encoding;

		if(this.format === "arraybuffer")
		{
			data.format = this.format;
			data.data = this.arraybuffer;
		}
		else if(this.format === "base64")
		{
			data.format = "arraybuffer";
			data.data = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(this.data));
		}
		else
		{
			data.format = this.format;
			data.data = this.data;
		}
		
		meta.images[this.uuid] = data;

		return data;
	};

	/**
	 * Basic image texture object wraps a texture from a img DOM element
	 *
	 * Support for GIF animations without playback controls.
	 * 
	 * @class Texture
	 * @extends {Texture}
	 * @module Textures
	 * @param {Image | String} source
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} magFilter
	 * @param {number} minFilter
	 * @param {number} format
	 * @param {number} type
	 * @param {number} anisotropy
	 * @param {number} encoding
	 */
	function Texture(source, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)
	{
		/**
		 * Source image of the texture.
		 * 
		 * @property source
		 * @type {Image}
		 */
		if(typeof source === "string")
		{
			this.source = new Image(source);
		}
		else if(source === undefined)
		{
			this.source = new Image();
		}
		else
		{
			this.source = source;
		}

		three.Texture.call(this, document.createElement("img"), mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
		
		var self = this;

		/**
		 * Name of the texture (doesn't need to be unique).
		 * @property name
		 * @type {string}
		 */
		this.name = "texture";
		this.category = "Image";

		/**
		 * Flag used to know is the texture has been disposed.
		 * 
		 * Is used to control animation when using a gif as a texture.
		 * 
		 * @property disposed
		 * @type {boolean}
		 * @default false
		 */
		this.disposed = false;

		this.format = this.source.hasTransparency() ? three.RGBAFormat : three.RGBFormat;

		this.updateSource();

		// Check if image is animated format and start an update cycle
		if(this.source.encoding === "gif")
		{
			this.generateMipmaps = false;
			this.magFilter = three.LinearFilter;
			this.minFilter = three.LinearFilter;

			function update()
			{
				if(!self.disposed)
				{
					self.needsUpdate = true;
					requestAnimationFrame(update);
				}
			}
			update();
		}
	}

	Texture.prototype = Object.create(three.Texture.prototype);
	Texture.isTexture = true;

	/**
	 * Should be called after updating the source of the texture.
	 *
	 * Will copy the source data to the texture for upload to the GPU.
	 *
	 * @method updateSource
	 */
	Texture.prototype.updateSource = function()
	{
		if(this.source !== null)
		{
			var self = this;

			this.image.crossOrigin = "anonymous";
			this.image.src = this.source.data;
			this.image.onload = function()
			{
				self.needsUpdate = true;
			};
			this.image.onerror = function()
			{
				console.log("nunuStudio: Failed to load image " + self.source.uuid + " data.");
				self.source.createSolidColor();
				self.image.src = self.source.data;
				self.needsUpdate = true;
			};
		}
		else
		{
			console.warn("nunuStudio: Texture source is null.");

			this.source.createSolidColor();
			this.image.src = self.source.data;
			this.needsUpdate = true;
		}
	};

	/**
	 * Dispose texture.
	 * 
	 * @method dispose
	 */
	Texture.prototype.dispose = function()
	{	
		three.Texture.prototype.dispose.call(this);

		this.disposed = true;
	};

	/**
	 * Create JSON description for texture, serializes image used in the texture
	 * Texture serialization is different inside nunuStudio, the Texture class does not serialize any image data.
	 *
	 * @param {Object} meta
	 * @method toJSON
	 */
	Texture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);
		var image = this.source.toJSON(meta);

		data.image = image.uuid;

		return data;
	};

	/**
	 * A Mesh combines a geometry and a material forming a complete rederizable object.
	 * 
	 * Based on Mesh documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Objects/Mesh.
	 * 
	 * @class Mesh
	 * @module Meshes
	 * @param {Geometry} geometry Geometry used by this mesh
	 * @param {Material} material Material used to shade the superficie of the geometry
	 * @extends {Mesh}
	 */
	function Mesh(geometry, material)
	{
		three.Mesh.call(this, geometry, material);

		this.name = "model";

		this.receiveShadow = true;
		this.castShadow = true;
	}

	Mesh.prototype = Object.create(three.Mesh.prototype);

	/**
	 * Dispose mesh along with its material and geometry.
	 * 
	 * @method dispose
	 */
	Mesh.prototype.dispose = function()
	{
		if(this.material !== null && this.material.dispose !== undefined)
		{
			this.material.dispose();
		}
		if(this.geometry !== null && this.geometry.dispose !== undefined)
		{
			this.geometry.dispose();
		}

		three.Object3D.prototype.dispose.call(this);
	};

	/**
	 * Special mesh type used to draw 3D text.
	 * 
	 * It receives a Font resource that is used to triangulate and extrude font data into a 3D mesh.
	 * 
	 * @class TextMesh
	 * @module Meshes
	 * @param {string} text Text to be draw
	 * @param {Material} material Material used to shade the superficie of the geometry
	 * @param {Font} font Font
	 * @param {number} height Text height
	 * @param {boolean} bevel
	 * @param {number} bevelThickness
	 * @param {number} size
	 * @param {number} curveSegments
	 * @extends {Mesh}
	 */
	function TextMesh(text, material, font, height, bevel, bevelThickness, bevelSize, size, curveSegments, extruded)
	{
		Mesh.call(this, TextMesh.EMPTY_GEOMETRY, material);
		
		this.name = "text";
		this.type = "TextMesh";

		/**
		 * Font used to draw text.
		 *
		 * @property font
		 * @type {Font}
		 */
		this.font = font !== undefined ? font : null;

		/**
		 * Indicates if the text mesh has volume or not.
		 *
		 * @property extruded
		 * @type {boolean}
		 */
		this.extruded = extruded !== undefined ? extruded : true;

		/**
		 * Size of the text (depth).
		 *
		 * @property size
		 * @type {number}
		 */
		this.size = size !== undefined ? size : 1;

		/**
		 * Height of the text.
		 *
		 * @property height
		 * @type {number}
		 */
		this.height = height !== undefined ? height : 0.5;

		/**
		 * Number of segments that compose a curve in the font.
		 *
		 * @property curveSegments
		 * @type {number}
		 */
		this.curveSegments = curveSegments !== undefined ? curveSegments : 15;

		/**
		 * If true a bevel is added to the text.
		 *
		 * @property bevel
		 * @type {boolean}
		 */
		this.bevel = bevel !== undefined ? bevel : false;

		/**
		 * Bevel thickness.
		 *
		 * @property bevelThickness
		 * @type {number}
		 */
		this.bevelThickness = bevelThickness !== undefined ? bevelThickness : 0.1;

		/**
		 * Bevel size.
		 *
		 * @property bevelSize
		 * @type {number}
		 */
		this.bevelSize = bevelSize !== undefined ? bevelSize : 0.05;

		/**
		 * Text to be diplayed in the mesh.
		 *
		 * @property text
		 * @type {string}
		 */
		var text = text !== undefined ? text : "text";
		Object.defineProperties(this,
		{
			text:
			{
				get: function(){return text;},
				set: function(value)
				{
					if(text !== value)
					{
						text = value;
						this.updateGeometry();
					}}
				}
		});
		
		this.updateGeometry();
	}

	TextMesh.prototype = Object.create(Mesh.prototype);

	TextMesh.EMPTY_GEOMETRY = new three.Geometry();

	/**
	 * Set font used by this text 3D instance.
	 * 
	 * @param {Font} font Font
	 * @method setFont
	 */
	TextMesh.prototype.setFont = function(font)
	{
		if(this.font !== font)
		{
			this.font = font;
			this.updateGeometry();
		}
	};

	/**
	 * Change text.
	 * 
	 * @param {string} text
	 * @method setText
	 */
	TextMesh.prototype.setText = function(text)
	{
		this.text = text;
	};

	/**
	 * Update the text geometry.
	 * 
	 * Should be called after chaging any attribute to generate a new geometry.
	 * 
	 * @method updateGeometry
	 */
	TextMesh.prototype.updateGeometry = function()
	{
		if(this.font !== null)
		{
			if(this.geometry !== undefined)
			{
				this.geometry.dispose();
			}

			if(this.font.isFont !== true)
			{
				console.warn("nunuStudio: Font parameter is not an instance of Font.");
				this.geometry = TextMesh.EMPTY_GEOMETRY;
				return;
			}

			var shapes = this.font.generateShapes(this.text, this.size);

			if(this.extruded)
			{		
				this.geometry = new three.ExtrudeBufferGeometry(shapes,
				{
					curveSegments: this.curveSegments,
					depth: this.height,
					bevelEnabled: this.bevel,
					bevelSize: this.bevelSize,
					bevelThickness: this.bevelThickness
				});
				this.geometry.computeVertexNormals();
			}
			else
			{
				this.geometry = new three.ShapeBufferGeometry(shapes, this.curveSegments);
			}
		}
	};

	/**
	 * Clone this object instance into a new object.
	 * 
	 * @method clone
	 * @return {TextMesh} Clone of this object.
	 */
	TextMesh.prototype.clone = function()
	{
		return new TextMesh(this.text, this.material, this.font, this.height, this.bevel, this.bevelThickness, this.bevelSize, this.size, this.curveSegments);
	};

	/**
	 * Create JSON for object.
	 * 
	 * Need to backup geometry and set to undefined to avoid it being stored.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	TextMesh.prototype.toJSON = function(meta)
	{
		var geometry = this.geometry;
		this.geometry = undefined;

		var font = this.font;
		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{
			font = font.toJSON(meta);
		});

		data.object.text = this.text;
		data.object.font = font.uuid;
		data.object.size = this.size;
		data.object.curveSegments = this.curveSegments;
		data.object.height = this.height;
		data.object.bevel = this.bevel;
		data.object.bevelThickness = this.bevelThickness;
		data.object.bevelSize = this.bevelSize;
		data.object.extruded = this.extruded;

		this.geometry = geometry;

		return data;
	};

	/**
	 * Font class stores font data, font data can be stored as an opentype json or as a TTF file (stored in Base64).
	 * 
	 * Font objects are used to draw text using the TextMesh object and/or generate text bitmap.
	 * 
	 * @class Font
	 * @extends {Resource}
	 * @module Resources
	 * @param {string} url URL to font file
	 */
	function Font(url)
	{
		Resource.call(this, "font", "Font");

		/**
		 * If true the font glyphs are reversed.
		 *
		 * @property reversed
		 * @type {boolean}
		 * @default false
		 */
		this.reversed = false;

		/**
		 * Font data, can be an ArrayBuffer or JSON.
		 *
		 * @property font
		 * @type {Object}
		 * @default null
		 */
		this.font = null;

		if(url !== undefined)
		{	
			// Arraybuffer
			if(url instanceof ArrayBuffer)
			{
				this.data = url;
				this.format = "arraybuffer";
				this.loadTTF();
			}
			// Opentype JSON
			else if(typeof url === "object")
			{
				this.data = url;
				this.font = url;
				this.format = "json";
				this.encoding = "json";
			}
			// URL
			else
			{
				this.encoding = FileSystem.getFileExtension(url);
				this.name = FileSystem.getFileName(url);

				if(this.encoding === "json")
				{
					this.data = JSON.parse(FileSystem.readFile(url));
					this.format = "json";
					this.font = this.data;
				}
				else if(this.encoding === "ttf" || this.encoding === "otf" || this.encoding === "ttc" || this.encoding === "otc")
				{
					this.data = FileSystem.readFileArrayBuffer(url);
					this.format = "arraybuffer";
					this.loadTTF();
				}
			}
		}
	}

	Font.prototype = Object.create(Resource.prototype);

	/**
	 * Check if a file name refers to a font file.
	 *
	 * @method fileIsFont
	 * @static
	 * @param {string} fname
	 * @return {boolean} True if the fname refers to a supported font format.
	 */
	Font.fileIsFont = function(file)
	{
		if(file !== undefined)
		{
			file = file.name.toLocaleLowerCase();

			return file.endsWith("ttf") || file.endsWith("otf") || file.endsWith("ttc") || file.endsWith("otc") || file.endsWith("json");
		}

		return false;
	};

	Font.prototype.isFont = true;

	/**
	 * Reverse the font glyphs.
	 *
	 * Can be used to fix fonts that have paths defined CW.
	 *
	 * @method reverseGlyphs
	 */
	Font.prototype.reverseGlyphs = function()
	{
		this.reversed = !this.reversed;

		this.loadTTF();
	};

	/**
	 * Load font from data using the TTF loader.
	 * 
	 * @method loadTTF
	 */
	Font.prototype.loadTTF = function()
	{
		var loader = new three.TTFLoader();
		loader.reversed = this.reversed;
		this.font = loader.parse(this.data);
	};

	/**
	 * Serialize font resource to json.
	 *
	 * Font data is stored as Base64 is present in a binary format, or JSON otherwise.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	Font.prototype.toJSON = function(meta)
	{
		if(meta.fonts[this.uuid] !== undefined)
		{
			return meta.fonts[this.uuid];
		}

		var data = Resource.prototype.toJSON.call(this, meta);
		
		data.encoding = this.encoding;
		data.reversed = this.reversed;
		
		if(this.format === "arraybuffer")
		{
			data.data = this.data;
			data.format = this.format;
		}
		else if(this.format === "base64")
		{
			data.data = ArraybufferUtils.fromBase64(this.data);
			data.format = "arraybuffer";
		}
		else
		{
			data.data = this.data;
			data.format = this.format;
		}

		meta.fonts[this.uuid] = data;
		
		return data;
	};

	/**
	 * Generate shapes from font data.
	 * 
	 * The shapes generated can be extruded to create 3D geometry.
	 *
	 * @method generateShapes
	 * @param {string} text
	 * @param {number} size
	 * @param {number} divisions
	 * @return {Array} paths
	 */
	Font.prototype.generateShapes = function(text, size, divisions)
	{
		if(size === undefined)
		{
			size = 100;
		}

		if(divisions === undefined)
		{
			divisions = 10;
		}

		var data = this.font;
		var paths = createPaths(text);
		var shapes = [];

		for(var p = 0; p < paths.length; p++)
		{
			Array.prototype.push.apply(shapes, paths[p].toShapes());
		}

		return shapes;

		// Create paths for text
		function createPaths(text)
		{
			var chars = String(text).split("");
			var scale = size / data.resolution;
			var lineHeight = (data.boundingBox.yMax - data.boundingBox.yMin) * scale;
			
			var offsetX = 0, offsetY = 0;
			var paths = [];

			for(var i = 0; i < chars.length; i++)
			{
				var char = chars[i];

				if(char === "\n")
				{
					offsetY -= lineHeight;
					offsetX = 0;
				}
				else
				{
					var ret = createPath(char, scale, offsetX, offsetY);
					offsetX += ret.width;

					paths.push(ret.path);
				}
			}

			return paths;
		}

		// Create path for a character
		function createPath(c, scale, offsetX, offsetY)
		{
			var glyph = data.glyphs[c] || data.glyphs["?"];
			
			if(!glyph)
			{
				return;
			}

			var path = new three.ShapePath();

			// Temporary variables
			var pts = [], b2 = three.ShapeUtils.b2, b3 = three.ShapeUtils.b3;
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

			if(glyph.o)
			{
				var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));

				for(var i = 0, l = outline.length; i < l;)
				{
					var action = outline[i++];

					// Move to
					if(action === "m")
					{
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.moveTo(x, y);
					}
					// Line to
					if(action === "l")
					{
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.lineTo(x, y);
					}
					// Quadratic curve to
					else if(action === "q")
					{
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;

						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
						laste = pts[pts.length - 1];

						if(laste)
						{
							cpx0 = laste.x;
							cpy0 = laste.y;

							for(var i2 = 1; i2 <= divisions; i2++)
							{
								var t = i2 / divisions;
								b2(t, cpx0, cpx1, cpx);
								b2(t, cpy0, cpy1, cpy);
							}
						}
					}
					// Bezier curve to
					else if(action === "b")
					{
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						cpx2 = outline[i++] * scale + offsetX;
						cpy2 = outline[i++] * scale + offsetY;

						path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
						laste = pts[pts.length - 1];

						if(laste)
						{
							cpx0 = laste.x;
							cpy0 = laste.y;

							for(var i2 = 1; i2 <= divisions; i2++)
							{
								var t = i2 / divisions;
								b3(t, cpx0, cpx1, cpx2, cpx);
								b3(t, cpy0, cpy1, cpy2, cpy);
							}
						}
					}
				}
			}

			return {width: glyph.ha * scale, path: path};
		}
	};

	/**
	 * Resource container contains resource of multiple types.
	 *
	 * @method ResourceContainer
	 */
	function ResourceContainer()
	{
		/**
		 * Image resources.
		 * 
		 * @property images
		 * @type {Array}
		 */
		this.images = [];

		/**
		 * Video resources.
		 * 
		 * @property videos
		 * @type {Array}
		 */
		this.videos = [];

		/**
		 * Audio resources.
		 * 
		 * @property audio
		 * @type {Array}
		 */
		this.audio = [];

		/**
		 * Fonts resources.
		 * 
		 * @property fonts
		 * @type {Array}
		 */
		this.fonts = [];

		/**
		 * Materials resources.
		 * 
		 * @property materials
		 * @type {Array}
		 */
		this.materials = [];

		/**
		 * Textures resources.
		 * 
		 * @property textures
		 * @type {Array}
		 */
		this.textures = [];

		/**
		 * Geometries resources.
		 * 
		 * @property geometries
		 * @type {Array}
		 */
		this.geometries = [];

		/**
		 * Generic resources, can be program data, code files etc.
		 * 
		 * @property resources
		 * @type {Array}
		 */
		this.resources = [];

		/**
		 * Shapes resources, may be used to generate geometry data.
		 * 
		 * @property shapes
		 * @type {Array}
		 */
		this.shapes = [];

		/**
		 * Skeletons resources, use for the meshes to store their skeleton data.
		 *
		 * Skeletons can be shared between meshes.
		 * 
		 * @property skeletons
		 * @type {Array}
		 */
		this.skeletons = [];
	}
	ResourceContainer.libraries = ["images", "videos", "audio", "fonts", "materials", "textures", "geometries", "resources", "shapes", "skeletons"];

	/**
	 * Copy resources from another resource container into this one.
	 *
	 * @method copyResources
	 */
	ResourceContainer.prototype.copyResources = function(container)
	{
		this.materials = container.materials;
		this.textures = container.textures;
		this.resources = container.resources;
		this.fonts = container.fonts;
		this.audio = container.audio;
		this.geometries = container.geometries;
		this.images = container.images;
		this.videos = container.videos;
		this.shapes = container.shapes;
		this.skeletons = container.skeletons;
	};

	ResourceContainer.prototype.getTexture = function(uuid)
	{
		if(this.textures[uuid] === undefined)
		{
			console.warn("ResourceContainer: Undefined texture", uuid);
		}

		return this.textures[uuid];
	};

	ResourceContainer.prototype.getGeometry = function(uuid)
	{
		if(this.geometries[uuid] === undefined)
		{
			console.warn("ResourceContainer: Undefined geometry", uuid);
		}
		
		return this.geometries[uuid];
	};

	ResourceContainer.prototype.getMaterial = function(uuid)
	{
		if(uuid instanceof Array)
		{
			var array = [];
			for(var i = 0; i < uuid.length; i++)
			{
				if(this.materials[uuid[i]] === undefined)
				{
					console.warn("ResourceContainer: Undefined material", uuid);
				}

				array.push(this.materials[uuid[i]]);
			}
			
			return array;
		}

		if(this.materials[uuid] === undefined)
		{
			console.warn("ResourceContainer: Undefined material", uuid);
		}

		return this.materials[uuid];
	};

	ResourceContainer.prototype.getFont = function(uuid)
	{
		if(this.fonts[uuid] === undefined)
		{
			console.warn("ResourceContainer: Undefined font", uuid);
		}
		return this.fonts[uuid];
	};

	ResourceContainer.prototype.getAudio = function(uuid)
	{
		if(this.audio[uuid] === undefined)
		{
			console.warn("ResourceContainer: Undefined audio", uuid);
		}
		return this.audio[uuid];
	};

	/**
	 * Scenes allow you to set up what and where is to be rendered by the engine.
	 *
	 * This is where you place objects, lights and cameras.
	 *
	 * A program may contain multiple scenes, its possible to change between scene using scripts.
	 *  
	 * Scene three.js documentation available here https:// threejs.org/docs/index.html#Reference/Scenes/Scene.
	 * 
	 * @class Scene
	 * @module Core
	 * @extends {Scene}
	 */
	function Scene()
	{
		three.Scene.call(this);

		this.name = "scene";
		this.matrixAutoUpdate = false;

		this.usePhysics = true;

		/**
		 * Cannon.js world used for physics simulation.
		 *
		 * The world is configured by default with a NaiveBroadphase and a SplitSolver.
		 *
		 * Documentation for cannon.js physics World object can be found here http:// schteppe.github.io/cannon.js/docs/classes/World.html.
		 *
		 * @property world
		 * @type {World}
		 */
		this.world = new cannon.World();
		this.world.defaultContactMaterial.contactEquationStiffness = 1e9;
		this.world.defaultContactMaterial.contactEquationRelaxation = 4;
		this.world.quatNormalizeSkip = 0;
		this.world.quatNormalizeFast = false;
		this.world.gravity.set(0, -9.8, 0);
		this.world.broadphase = new cannon.NaiveBroadphase();
		this.world.solver = new cannon.SplitSolver(new cannon.GSSolver());
		this.world.solver.tolerance = 0.05;
		this.world.solver.iterations = 7;

		/**
		 * Background of the scene.
		 *
		 * The background of the scene is drawn after the renderer clears the buffers.
		 *
		 * It can be a color, a texture or a cubemap.
		 *
		 * @property background
		 * @type {Color|Texture}
		 */
		this.background = new three.Color(0x000000);

		/** 
		 * List of active cameras currently being displayed.
		 *
		 * The cameras are rendered by their render order.
		 *
		 * @property cameras
		 * @type {Array}
		 */
		this.cameras = [];

		/**
		 * Default camera of the scene used where there is no active camera.
		 *
		 * While using the editor the scene default camera gets set as the last camera configuration used.
		 * 
		 * @property defaultCamera
		 * @type {Camera}
		 */
		this.defaultCamera = null;

		/**
		 * Stores the time since the last frame.
		 *
		 * @property delta
		 * @type {number}
		 */
		this.delta = 0;

		/**
		 * Raycaster used for mouse interaction with 3D objects.
		 *
		 * This raycaster is automatically updated using the first camera being drawn.
		 *
		 * @property raycaster
		 * @type {Raycaster}
		 */
		this.raycaster = new three.Raycaster();

		// TODO <OCTREE CODE>
		/**
		 * Indicates if the scene is using octree indexation for raycasting.
		 *
		 * @property useOctree
		 * @type {boolean}
		 */
	 	this.useOctree = false;

		/**
		 * Octree used to index all the unoObject in the scene being visualized.
		 *
		 * It is used to filter the visiblity of objects and raycast them.
		 *
		 * @attribute octree
		 * @type {SPARSEOCTREE.PointOctree}
		 */
		this.octree = null;

		/**
		 * Flag indicating if the is a octree update scheduled.
		 *
		 * Avoids scheduling multiple octree updates from different objects.
		 *
		 * @attribute octreeUpdateScheduled
		 * @type {Boolean}
		 */
		this.octreeUpdateScheduled = false;
		
		/** 
		 * Stores the octree object matches, that are the objects currently visible.
		 *
		 * @attribute octreeMatches
		 * @type {Array}
		 */
		this.octreeMatches = [];

		/**
		 * Program that contains this scene.
		 *
		 * @property program
		 * @type {Program}
		 */
		this.program = null;

		/**
		 * Canvas used to draw this scene.
		 *
		 * @property canvas
		 * @type {Element}
		 */
		this.canvas = null;

		/**
		 * Normalized mouse coordinates used by the scene internal raycaster.
		 *
		 * @property mouse
		 * @type {Vector2}
		 */
		this.mouse = new three.Vector2(0, 0);
	}

	Scene.prototype = Object.create(three.Scene.prototype);

	Scene.prototype.initialize = function()
	{
		this.program = this.parent;
		this.canvas = this.parent.canvas;

		three.Object3D.prototype.initialize.call(this);

		for(var i = 0; i < this.children.length; i++)
		{
			this.children[i].traverse(function(children)
			{
				children.initialize();
			});
		}
	};

	/**
	 * Update scene objects and the physics world.
	 * 
	 * Also updates the global raycaster object used for object culling.
	 *
	 * @method update
	 * @param {number} delta The time since the last frame.
	 */
	Scene.prototype.update = function(delta)
	{
		// TODO <USE THE VIEWPORT OBJECT>

		this.mouse.set(this.program.mouse.position.x / this.canvas.width * 2 - 1, -2 * this.program.mouse.position.y / this.canvas.height + 1);
		
		if(this.cameras.length > 0)
		{
			this.raycaster.setFromCamera(this.mouse, this.cameras[0]);
		}
		
		if(this.usePhysics)
		{
			this.world.step(delta < 0.05 ? delta : 0.05);
		}

		for(var i = 0; i < this.children.length; i++)
		{
			this.children[i].traverse(function(children)
			{
				children.update(delta);
			});
		}
	};

	Scene.prototype.resize = function(x, y)
	{
		if(this.defaultCamera !== null)
		{
			this.defaultCamera.resize(x, y);
		}

		for(var i = 0; i < this.cameras.length; i++)
		{

			this.cameras[i].resize(x, y);
		}

		for(var i = 0; i < this.children.length; i++)
		{
			this.children[i].traverse(function(children)
			{
				children.resize(x, y);
			});
		}
	};

	Scene.prototype.dispose = function()
	{
		for(var i = 0; i < this.children.length; i++)
		{
			this.children[i].traverse(function(children)
			{
				children.dispose();
			});
		}
	};

	/**
	 * Render scene using all active cameras.
	 * 
	 * @method render
	 * @param {Renderer} renderer
	 */
	Scene.prototype.render = function(renderer)
	{
		renderer.setClearColor(this.background);

		if(this.cameras.length > 0)
		{
			renderer.setScissorTest(true);
			
			for(var i = 0; i < this.cameras.length; i++)
			{
				this.cameras[i].setupRenderer(renderer);
				this.cameras[i].render(renderer, this);
			}

			renderer.setScissorTest(false);
		}
		else if(this.defaultCamera !== null)
		{
			this.defaultCamera.render(renderer, this);
		}
	};

	/**
	 * Get camera from scene using cameras uuid.
	 * 
	 * @method getCamera
	 * @param {string} uuid UUID of the camera
	 * @return {Camera} Camera if found, else null
	 */
	Scene.prototype.getCamera = function(uuid, object)
	{
		if(object === undefined)
		{
			object = this;
		}

		if(uuid === object.uuid)
		{
			return object;
		}

		var children = object.children;
		for(var i = 0; i < children.length; i++)
		{
			var camera = this.getCamera(uuid, children[i]);
			if(camera !== null)
			{
				return camera;
			}
		}

		return null;
	};

	/**
	 * Add camera to active cameras list.
	 * 
	 * @method addCamera
	 * @param {Camera} camera
	 */
	Scene.prototype.addCamera = function(camera)
	{
		if(this.cameras.indexOf(camera) === -1)
		{
			this.cameras.push(camera);
			this.updateCameraOrder();
		}
	};

	/**
	 * Update active camera lister order.
	 *
	 * This method should be called after changing order value for an active camera.
	 *  
	 * @method updateCameraOrder
	 */
	Scene.prototype.updateCameraOrder = function()
	{
		this.cameras.sort(function(a, b)
		{
			return a.order > b.order;
		});
	};

	/**
	 * Remove camera from active camera list.
	 * 
	 * @param {Camera} camera Camera to be removed
	 * @method removeCamera
	 */
	Scene.prototype.removeCamera = function(camera)
	{
		var index = this.cameras.indexOf(camera);
		if(index > -1)
		{
			this.cameras.splice(index, 1);
		}
	};

	/**
	 * Check is camera is active.
	 * 
	 * @param {Camera} camera Camera to be removed
	 * @method isCameraActive
	 */
	Scene.prototype.isCameraActive = function(camera)
	{
		return this.cameras.indexOf(camera) > -1;
	};


	/**
	 * Set scene fog mode.
	 * 
	 * It recreates the fog object attached to the scene and set the same color.
	 *
	 * @method setFogMode
	 * @param {number} mode
	 */
	Scene.prototype.setFogMode = function(mode)
	{	
		var color = (this.fog !== null) ? this.fog.color.getHex() : "#FFFFFF";

		if(mode === three.Fog.LINEAR)
		{	
			this.fog = new three.Fog(color, 5, 20);
		}
		else if(mode === three.Fog.EXPONENTIAL)
		{
			this.fog = new three.FogExp2(color, 0.01);
		}
		else if(mode === three.Fog.NONE)
		{
			this.fog = null;
		}
	};

	Scene.prototype.toJSON = function(meta)
	{
		if(this.parent == null || this.parent.type !== "Program")
		{
			console.warn("nunuStudio: Scene is not on top level serializing as Group.");

			this.type = "Group";
			return three.Object3D.prototype.toJSON.call(this, meta);
		}

		var self = this;

		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{
			// Background
			if(self.background instanceof three.Color)
			{
				object.background = self.background.toJSON(meta);
			}
			else if(self.background instanceof three.Texture)
			{
				object.background = self.background.toJSON(meta).uuid;
			}

			// Environment
			if(self.environment instanceof three.Texture)
			{
				object.environment = self.environment.toJSON(meta).uuid;
			}
		});

		if(this.defaultCamera !== null)
		{
			var position = new three.Vector3();
			var quaternion = new three.Quaternion();
			var scale = new three.Vector3();

			this.defaultCamera.matrixWorld.decompose(position, quaternion, scale);

			var defaultCamera = this.defaultCamera.toJSON(meta);
			defaultCamera.object.position = position.toArray();
			defaultCamera.object.quaternion = quaternion.toArray();
			defaultCamera.object.scale = scale.toArray();
			data.object.defaultCamera = defaultCamera;
		}

		if(this.fog !== null)
		{
			data.object.fog = this.fog.toJSON();
		}

		data.object.usePhysics = this.usePhysics;
		
		data.object.cameras = [];
		for(var i = 0; i < this.cameras.length; i++)
		{
			data.object.cameras.push(this.cameras[i].uuid);
		}

		data.object.world = {};
		data.object.world.gravity = this.world.gravity;
		data.object.world.quatNormalizeSkip = this.world.quatNormalizeSkip;
		data.object.world.quatNormalizeFast = this.world.quatNormalizeFast;
		data.object.world.solver = {};
		data.object.world.solver.tolerance = this.world.solver.tolerance;
		data.object.world.solver.iterations = this.world.solver.iterations;

		return data;
	};

	/**
	 * Script objects are used to control other objects present in the scene.
	 *
	 * These scripts can access everything inside of the program where they are running they should be used to control logic aspect of the application.
	 *
	 * Its possible to extend these scripts by using libraries that can be imported using the include() function provided. Libraries can be stored locally on the project or loaded from remote sources.
	 * 
	 * @class Script
	 * @extends {Object}
	 * @param {string} code Javascript code to be used by this script
	 * @module Script
	 */
	function Script(code, mode)
	{
		three.Group.call(this);
		
		this.type = "Script";
		this.name = "script";

		/**
		 * Javascript code attached to the script.
		 *
		 * It can access and change every object in the program and supports some events
		 *  - initialize
		 *    - Called on app initialization, its called after all children elements are initialized, its safe to apply operations on other objects inside this method.
		 *  - update(delta)
		 *    - Called on every frame after rendering
		 *  - dispose
		 *    - Called when disposing the program
		 *  - onMouseOver(intersections)
		 *    - Called on every frame if mouse is on top of one of the script children
		 *    - Receives an intersections array as argument.
		 *  - onResize(x, y)
		 *    - Called every time the window is resized
		 *    - Receives width and height as parameters
		 *  - onAppData(data)
		 *    - Called when receiving data sent by the host website
		 * 
		 * Code written inside scripts have access to the following attributes:
		 *  - scene
		 *  - program
		 *  - self
		 *    - Same as this reference but global in the script scope
		 *  - Keyboard
		 *  - Mouse
		 *
		 * There is also access to the following functions
		 *  - include
		 *    - Include a javascript file from resources, when including files the user needs to be carefull and clear manually global declarations. The access to this method may be restricted depeding on the include mode 
		 * 
		 * @property code
		 * @type {string}
		 */
		this.code = (code !== undefined) ? code : Script.DEFAULT;

		/**
		 * Mode indicates how to include external javascripts files into the script.
		 *
		 * Can be APPEND, EVALUATE or INCLUDE.
		 *
		 * APPEND mode with append the library code to the script code, when running in this mode the include method cannot be used during runtime
		 *
		 * EVALUATE node with evaluate the library code during runtime, include method may still be used.
		 *
		 * INCLUDE mode will include the file as a global script, these libraries are not unloaded after the script or application is terminated.
		 *
		 * @property mode
		 * @type {number}
		 */
		this.mode = (mode !== undefined) ? mode : Script.APPEND;

		/**
		 * Compiled function used during runtime.
		 *
		 * This varible gets created using the compileCode() function called automatically on initalization.
		 *
		 * @attribute script
		 * @type {Function}
		 */
		this.script = {};

		/**
		 * Reference to the program object.
		 *
		 * Can be used to access other scenes, get resources and objects.
		 *
		 * @property program
		 * @type {Program}
		 */
		this.program = null;

		/**
		 * Reference to the scene where the script is placed.
		 *
		 * Can be used to interact with other objects.
		 *
		 * @property scene
		 * @type {Scene}
		 */
		this.scene = null;
	}

	Script.prototype = Object.create(three.Group.prototype);

	/**
	 * Regular expression to obtain all the include calls placed inside of scripts.
	 *
	 * @attribute includeRegex
	 * @type {RegExp}
	 */
	Script.includeRegex = /include[ ]*\([ \n]*["'].+?["'][ \n]*\);*/gi;
	Script.includeRegexStart = /include[ ]*\([ \n]*["']/gi;
	Script.includeRegexEnd = /["'][ \n]*\);*/gi;

	/**
	 * Default script code used when creating a new Script.
	 *
	 * @attribute DEFAULT
	 * @type {string}
	 */
	Script.DEFAULT = "function initialize()\n{\n	// TODO <INITIALIZATION CODE>\n}\n\nfunction update(delta)\n{\n	// TODO <UPDATE CODE>\n}\n";

	/**
	 * List of default methods that can be implemented by scripts.
	 *
	 * @attribute METHODS
	 * @type {Array}
	 */
	Script.METHODS = ["initialize", "update", "dispose", "onMouseOver", "onResize", "onAppData"];

	/**
	 * Append libraries on initialization.
	 *
	 * Libraries are appended to the script code on initialization.
	 *
	 * @attribute APPEND
	 * @type {number}
	 */
	Script.APPEND = 100;

	/**
	 * Evaluate libs during runtime.
	 *
	 * This allows to load new libs during runtime, but its not possible to access private statements.
	 *
	 * @attribute EVALUATE
	 * @type {number}
	 */
	Script.EVALUATE = 101;

	/**
	 * Include file into the document.body.
	 *
	 * This imports the JS file as any other file included into a <script> tag.
	 *
	 * @attribute INCLUDE
	 * @type {number}
	 */
	Script.INCLUDE = 102;

	/**
	 * Auxiliar function to include javascript source file from resource into the script.
	 *
	 * The imported source is evaluated and loaded in the context of the script.
	 *
	 * Global declarations need to be cleaned using the dipose method.
	 *
	 * @method include
	 * @param {string} name Javascript resource name.
	 */

	/**
	 * Get includes from the code.
	 *
	 * Used to extract includes from code when loading libraries in APPEND mode.
	 *
	 * @static
	 * @method getIncludes
	 * @param {string} code Script code.
	 */
	Script.getIncludes = function(code)
	{
		var results = [];

		// Regex object is statefull and iterates on each exec() call
		var includeRegex = new RegExp(Script.includeRegex, 'gi');

		while(true)
		{
			var match = includeRegex.exec(code);
			if(match === null)
			{
				break;
			}

			// Filter only the resource/library name
			var include = match[0];
			include = include.replace(Script.includeRegexStart, '');
			include = include.replace(Script.includeRegexEnd, '');
			results.push(include);
		}

		return results;
	};

	/**
	 * Remove includes from code.
	 *
	 * Used to remove include statements when initializing code in APPEND mode.
	 *
	 * @static
	 * @method removeIncludes
	 * @param {string} code Script code.
	 */
	Script.removeIncludes = function(code)
	{
		return code.replace(Script.includeRegex, "");
	};

	/**
	 * Initialize script. Automatically called by the runtime.
	 *
	 * Compiles the script code and calls the script initialize method if it exists after the code is compiled.
	 *
	 * @method initialize
	 */
	Script.prototype.initialize = function()
	{
		var node = this;
		while(node.parent !== null)
		{
			node = node.parent;
			if(node instanceof Scene)
			{
				this.scene = node;
			}
			else if(node instanceof Program)
			{
				this.program = node;
			}
		}

		three.Object3D.prototype.initialize.call(this);

		var self = this;

		this.compileCode(this.code, function()
		{
			if(self.script.initialize !== undefined)
			{
				self.script.initialize.call(self);
			}
		});
	};

	/**
	 * Update script state.
	 * 
	 * Calls the script update method if it exists.
	 * 
	 * @method update
	 */
	Script.prototype.update = function(delta)
	{
		if(this.script.onMouseOver !== undefined)
		{
			var intersections = this.scene.raycaster.intersectObjects(this.children, true);
			if(intersections.length > 0)
			{
				this.script.onMouseOver.call(this, intersections);
			}
		}

		if(this.script.update !== undefined)
		{
			this.script.update.call(this, delta);
		}

		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Disposes the script, can be used to clear resources when the program exits.
	 * 
	 * Calls the script dispose method if it exists.
	 * 
	 * @method dispose
	 */
	Script.prototype.dispose = function()
	{
		if(this.script.dispose !== undefined)
		{
			this.script.dispose.call(this);
		}

		three.Object3D.prototype.dispose.call(this);
	};

	/**
	 * Call resize method if available.
	 *
	 * The resize method receives width and height as arguments.
	 * 
	 * @method resize
	 */
	Script.prototype.resize = function(x, y)
	{
		if(this.script.onResize !== undefined)
		{
			this.script.onResize.call(this, x, y);
		}
	};

	/**
	 * Call onAppData if available.
	 *
	 * Called automatically every time external data is passed to the runtime.
	 * 
	 * @method appData
	 * @param {Object} data
	 */
	Script.prototype.appData = function(data)
	{
		if(this.script.onAppData !== undefined)
		{
			this.script.onAppData.call(this, data);
		}
	};

	/**
	 * Prepare the script code to be run. The script can be prepared using different methods depending on the include mode defined.
	 * 
	 * Can be used to dinamically change the script code. However it is not recommended can lead to undefined behavior.
	 *
	 * @method compileCode
	 * @param {string} code
	 * @param {Function} onReady Funtion called when the code is ready.
	 */
	Script.prototype.compileCode = function(code, onReady)
	{
		if(code !== undefined)
		{
			this.code = code;
		}

		try
		{
			// Public method declaration
			var code = this.code;
			for(var i = 0; i < Script.METHODS.length; i++)
			{
				var method = Script.METHODS[i];
				code += "\nif(this." + method + " == undefined && typeof " + method + " !== 'undefined'){this." + method + " = " + method + ";}";
			}

			// Append libraries to code
			if(this.mode === Script.APPEND)
			{
				var libs = Script.getIncludes(code);	
				code = Script.removeIncludes(code);

				for(var i = 0; i < libs.length; i++)
				{
					var libCode = this.program.getResourceByName(libs[i]);
					if(libCode === null)
					{
						libCode = FileSystem.readFile(libs[i], true);
						if(libCode !== null)
						{
							code = libCode + "\n" + code;
						}
						else
						{
							throw new Error("Script include() library " + libs[i] + " not found.");
						}
					}
					else
					{
						code = libCode.data + "\n" + code;
					}
				}

				code += "\nfunction include(name)\
			{\
				console.warn(\"nunuStudio: Script running in append mode, \" + name + \" cannot be included in runtime.\");\
			}";
			}
			// Declare include method
			else if(this.mode === Script.EVALUATE)
			{
				code += "\nfunction include(name)\
			{\
				var text = program.getResourceByName(name);\
				if(text === null)\
				{\
					text = FileSystem.readFile(name, true);\
					if(text !== null)\
					{\
						new Function(text).call(this);\
					}\
					else\
					{\
						console.warn(\"nunuStudio: Javascript file \" + name + \" not found.\");\
					}\
				}\
				else\
				{\
					new Function(text.data).call(this);\
				}\
			}";
			}
			// Include
			else if(this.mode === Script.INCLUDE)
			{
				var libs = Script.getIncludes(code);	
				code = Script.removeIncludes(code);

				var libsLoaded = 0;
				var urls = [];

				for(var i = 0; i < libs.length; i++)
				{
					var resource = this.program.getResourceByName(libs[i]);
					if(resource !== null)
					{
						var blob = new Blob([resource.data], {type:"text/plain"});
						urls.push(URL.createObjectURL(blob));
					}
					else
					{
						// Read file content and loade locally to overcome CORS JS script issues.
						var text = FileSystem.readFile(libs[i], true);
						if(text !== null)
						{
							var blob = new Blob([text], {type:"text/plain"});
							urls.push(URL.createObjectURL(blob));
						}
						else
						{
							throw new Error("Script include() library " + libs[i] + " not found.");
						}
					}
				}

				if(urls.length > 0)
				{
					for(var i = 0; i < urls.length; i++)
					{
						var js = document.createElement("script");
						js.type = "text/javascript";
						js.async = true;
						js.src = url;
						js.onload = function()
						{
							libsLoaded++;

							if(libsLoaded === urls.length)
							{
								onReady();
							}
						};
						js.onerror = js.onload;
						document.body.appendChild(js);
					}
				}
				else
				{
					onReady();
				}
			}

			// Evaluate code and create constructor
			var Constructor = new Function("Keyboard, Mouse, self, program, scene", code);

			// Create script object
			try
			{
				this.script = new Constructor(this.program.keyboard, this.program.mouse, this, this.program, this.scene);
			}
			catch(e)
			{
				console.warn("nunuStudio: Error initializing script code", e);
				throw "Error initializing script code";
				this.script = {};
			}

			if(this.mode !== Script.INCLUDE)
			{
				onReady();
			}
		}
		catch(e)
		{
			console.warn("nunuStudio: Error compiling script code", e);
			throw "Error compiling script code";
		}
	};

	Script.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.code = this.code;
		data.object.mode = this.mode;

		return data;
	};

	/**
	 * Sprites allways face the screen are used for 2D elements.
	 * 
	 * Based on Sprite documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Objects/Sprite.
	 * 
	 * @class Sprite
	 * @module Sprite
	 * @param {Material} material Material used to draw sprites
	 * @extends {Script}
	 */

	/**
	 * Material used to render the sprite.
	 * @property material
	 * @type {Material}
	*/
	function Sprite(material)
	{
		three.Sprite.call(this, material);

		this.name = "sprite";
	}

	Sprite.prototype = Object.create(three.Sprite.prototype);

	Sprite.prototype.dispose = function()
	{
		if(this.material !== null && this.material.dispose !== undefined)
		{
			this.material.dispose();
		}
		
		three.Object3D.prototype.dispose.call(this);
	};

	var ParticleShaderChunks =
	{
		// Register color-packing define statements.
		defines:
		[
			"#define PACKED_COLOR_SIZE 256.0",
			"#define PACKED_COLOR_DIVISOR 255.0"
		].join("\n"),

		// All uniforms used by vertex / fragment shaders
		uniforms:
		[
			"uniform float deltaTime;",
			"uniform float runTime;",
			"uniform sampler2D textureSampler;",
			"uniform vec4 textureAnimation;",
			"uniform float scale;",
		].join("\n"),

		// All attributes used by the vertex shader.
		//
		// Note that some attributes are squashed into other ones:
		//
		//* Drag is acceleration.w
		attributes:
		[
			"attribute vec4 acceleration;",
			"attribute vec3 velocity;",
			"attribute vec4 rotation;",
			"attribute vec3 rotationCenter;",
			"attribute vec4 params;",
			"attribute vec4 size;",
			"attribute vec4 angle;",
			"attribute vec4 color;",
			"attribute vec4 opacity;"
		].join("\n"),

		//
		varyings:
		[
			"varying vec4 vColor;",
			"#ifdef SHOULD_ROTATE_TEXTURE",
			"    varying float vAngle;",
			"#endif",

			"#ifdef SHOULD_CALCULATE_SPRITE",
			"    varying vec4 vSpriteSheet;",
			"#endif"
		].join("\n"),


		// Branch-avoiding comparison fns
		//- http:// theorangeduck.com/page/avoiding-shader-conditionals
		branchAvoidanceFunctions:
		[
			"float when_gt(float x, float y) {",
			"    return max(sign(x - y), 0.0);",
			"}",

			"float when_lt(float x, float y) {",
			"    return min(max(1.0 - sign(x - y), 0.0), 1.0);",
			"}",

			"float when_eq(float x, float y) {",
			"    return 1.0 - abs(sign(x - y));",
			"}",

			"float when_ge(float x, float y) {",
			"  return 1.0 - when_lt(x, y);",
			"}",

			"float when_le(float x, float y) {",
			"  return 1.0 - when_gt(x, y);",
			"}",

			// Branch-avoiding logical operators (to be used with above comparison fns)
			"float and(float a, float b) {",
			"    return a * b;",
			"}",

			"float or(float a, float b) {",
			"    return min(a + b, 1.0);",
			"}",
		].join("\n"),


		// From:
		//- http:// stackoverflow.com/a/12553149
		//- https:// stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader
		unpackColor:
		[
			"vec3 unpackColor(in float hex) {",
			"   vec3 c = vec3(0.0);",

			"   float r = mod((hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);",
			"   float g = mod((hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);",
			"   float b = mod(hex, PACKED_COLOR_SIZE);",

			"   c.r = r / PACKED_COLOR_DIVISOR;",
			"   c.g = g / PACKED_COLOR_DIVISOR;",
			"   c.b = b / PACKED_COLOR_DIVISOR;",

			"   return c;",
			"}",
		].join("\n"),

		unpackRotationAxis:
		[
			"vec3 unpackRotationAxis(in float hex) {",
			"   vec3 c = vec3(0.0);",

			"   float r = mod((hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);",
			"   float g = mod((hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE);",
			"   float b = mod(hex, PACKED_COLOR_SIZE);",

			"   c.r = r / PACKED_COLOR_DIVISOR;",
			"   c.g = g / PACKED_COLOR_DIVISOR;",
			"   c.b = b / PACKED_COLOR_DIVISOR;",

			"   c *= vec3(2.0);",
			"   c -= vec3(1.0);",

			"   return c;",
			"}",
		].join("\n"),

		floatOverLifetime:
		[
			"float getFloatOverLifetime(in float positionInTime, in vec4 attr) {",
			"    highp float value = 0.0;",
			"    float deltaAge = positionInTime * float(VALUE_OVER_LIFETIME_LENGTH - 1);",
			"    float fIndex = 0.0;",
			"    float shouldApplyValue = 0.0;",

			// This might look a little odd, but it's faster in the testing I"ve done than using branches. Uses basic maths to avoid branching.
			//
			// Take a look at the branch-avoidance functions defined above, and be sure to check out The Orange Duck site where I got this from (link above).
			//
			// Fix for static emitters (age is always zero).
			"    value += attr[0] * when_eq(deltaAge, 0.0);",
			"",
			"    for(int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i) {",
			"       fIndex = float(i);",
			"       shouldApplyValue = and(when_gt(deltaAge, fIndex), when_le(deltaAge, fIndex + 1.0));",
			"       value += shouldApplyValue * mix(attr[i], attr[i + 1], deltaAge - fIndex);",
			"    }",
			"",
			"    return value;",
			"}",
		].join("\n"),

		colorOverLifetime:
		[
			"vec3 getColorOverLifetime(in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4) {",
			"    vec3 value = vec3(0.0);",
			"    value.x = getFloatOverLifetime(positionInTime, vec4(color1.x, color2.x, color3.x, color4.x));",
			"    value.y = getFloatOverLifetime(positionInTime, vec4(color1.y, color2.y, color3.y, color4.y));",
			"    value.z = getFloatOverLifetime(positionInTime, vec4(color1.z, color2.z, color3.z, color4.z));",
			"    return value;",
			"}",
		].join("\n"),

		paramFetchingFunctions:
		[
			"float getAlive() {",
			"   return params.x;",
			"}",

			"float getAge() {",
			"   return params.y;",
			"}",

			"float getMaxAge() {",
			"   return params.z;",
			"}",

			"float getWiggle() {",
			"   return params.w;",
			"}",
		].join("\n"),

		forceFetchingFunctions:
		[
			"vec4 getPosition(in float age) {",
			"   return modelViewMatrix * vec4(position, 1.0);",
			"}",

			"vec3 getVelocity(in float age) {",
			"   return velocity * age;",
			"}",

			"vec3 getAcceleration(in float age) {",
			"   return acceleration.xyz * age;",
			"}",
		].join("\n"),


		rotationFunctions:
		[
			// Huge thanks to:
			//- http:// www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/
			"#ifdef SHOULD_ROTATE_PARTICLES",
			"   mat4 getRotationMatrix(in vec3 axis, in float angle) {",
			"       axis = normalize(axis);",
			"       float s = sin(angle);",
			"       float c = cos(angle);",
			"       float oc = 1.0 - c;",
			"",
			"       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,",
			"                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,",
			"                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,",
			"                   0.0,                                0.0,                                0.0,                                1.0);",
			"   }",
			"",
			"   vec3 getRotation(in vec3 pos, in float positionInTime) {",
			"      if(rotation.y == 0.0) {",
			"           return pos;",
			"      }",
			"",
			"      vec3 axis = unpackRotationAxis(rotation.x);",
			"      vec3 center = rotationCenter;",
			"      vec3 translated;",
			"      mat4 rotationMatrix;",

			"      float angle = 0.0;",
			"      angle += when_eq(rotation.z, 0.0) * rotation.y;",
			"      angle += when_gt(rotation.z, 0.0) * mix(0.0, rotation.y, positionInTime);",
			"      translated = rotationCenter - pos;",
			"      rotationMatrix = getRotationMatrix(axis, angle);",
			"      return center - vec3(rotationMatrix * vec4(translated, 0.0));",
			"   }",
			"#endif"
		].join("\n"),


		// Fragment chunks
		rotateTexture:
		[
			"    vec2 vUv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);",
			"",
			"    #ifdef SHOULD_ROTATE_TEXTURE",
			"       float x = gl_PointCoord.x - 0.5;",
			"       float y = 1.0 - gl_PointCoord.y - 0.5;",
			"       float c = cos(-vAngle);",
			"       float s = sin(-vAngle);",

			"       vUv = vec2(c * x + s * y + 0.5, c * y - s * x + 0.5);",
			"    #endif",
			"",

			// Spritesheets overwrite angle calculations.
			"    #ifdef SHOULD_CALCULATE_SPRITE",
			"        float framesX = vSpriteSheet.x;",
			"        float framesY = vSpriteSheet.y;",
			"        float columnNorm = vSpriteSheet.z;",
			"        float rowNorm = vSpriteSheet.w;",

			"        vUv.x = gl_PointCoord.x * framesX + columnNorm;",
			"        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);",
			"    #endif",

			"",
			"    vec4 rotatedTexture = texture2D(textureSampler, vUv);",
		].join("\n")
	};

	var ParticleShaders =
	{
		vertex:
		[
			ParticleShaderChunks.defines,
			ParticleShaderChunks.uniforms,
			ParticleShaderChunks.attributes,
			ParticleShaderChunks.varyings,

			three.ShaderChunk.common,
			three.ShaderChunk.logdepthbuf_pars_vertex,
			three.ShaderChunk.fog_pars_vertex,

			ParticleShaderChunks.branchAvoidanceFunctions,
			ParticleShaderChunks.unpackColor,
			ParticleShaderChunks.unpackRotationAxis,
			ParticleShaderChunks.floatOverLifetime,
			ParticleShaderChunks.colorOverLifetime,
			ParticleShaderChunks.paramFetchingFunctions,
			ParticleShaderChunks.forceFetchingFunctions,
			ParticleShaderChunks.rotationFunctions,

			"void main() {",

			// Setup
			"    highp float age = getAge();",
			"    highp float alive = getAlive();",
			"    highp float maxAge = getMaxAge();",
			"    highp float positionInTime = (age / maxAge);",
			"    highp float isAlive = when_gt(alive, 0.0);",
			"    #ifdef SHOULD_WIGGLE_PARTICLES",
			"        float wiggleAmount = positionInTime * getWiggle();",
			"        float wiggleSin = isAlive * sin(wiggleAmount);",
			"        float wiggleCos = isAlive * cos(wiggleAmount);",
			"    #endif",

			// Forces

			// Get forces & position
			"    vec3 vel = getVelocity(age);",
			"    vec3 accel = getAcceleration(age);",
			"    vec3 force = vec3(0.0);",
			"    vec3 pos = vec3(position);",

			// Calculate the required drag to apply to the forces.
			"    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;",

			// Integrate forces...
			"    force += vel;",
			"    force *= drag;",
			"    force += accel * age;",
			"    pos += force;",


			// Wiggly wiggly wiggle!
			"    #ifdef SHOULD_WIGGLE_PARTICLES",
			"        pos.x += wiggleSin;",
			"        pos.y += wiggleCos;",
			"        pos.z += wiggleSin;",
			"    #endif",


			// Rotate the emitter around it's central point
			"    #ifdef SHOULD_ROTATE_PARTICLES",
			"        pos = getRotation(pos, positionInTime);",
			"    #endif",

			// Convert pos to a world-space value
			"    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);",

			// Determine point size.
			"    highp float pointSize = getFloatOverLifetime(positionInTime, size) * isAlive;",

			// Determine perspective
			"    #ifdef HAS_PERSPECTIVE",
			"        float perspective = scale / length(mvPosition.xyz);",
			"    #else",
			"        float perspective = 1.0;",
			"    #endif",

			// Apply perpective to pointSize value
			"    float pointSizePerspective = pointSize * perspective;",

			// Determine color and opacity for this particle
			"    #ifdef COLORIZE",
			"       vec3 c = isAlive * getColorOverLifetime(",
			"           positionInTime,",
			"           unpackColor(color.x),",
			"           unpackColor(color.y),",
			"           unpackColor(color.z),",
			"           unpackColor(color.w)",
			"      );",
			"    #else",
			"       vec3 c = vec3(1.0);",
			"    #endif",

			"    float o = isAlive * getFloatOverLifetime(positionInTime, opacity);",

			// Assign color to vColor varying.
			"    vColor = vec4(c, o);",

			// Determine angle
			"    #ifdef SHOULD_ROTATE_TEXTURE",
			"        vAngle = isAlive * getFloatOverLifetime(positionInTime, angle);",
			"    #endif",

			// If this particle is using a sprite-sheet as a texture, we"ll have to figure out what frame of the texture the particle is using at it's current position in time.
			"    #ifdef SHOULD_CALCULATE_SPRITE",
			"        float framesX = textureAnimation.x;",
			"        float framesY = textureAnimation.y;",
			"        float loopCount = textureAnimation.w;",
			"        float totalFrames = textureAnimation.z;",
			"        float frameNumber = mod((positionInTime * loopCount) * totalFrames, totalFrames);",

			"        float column = floor(mod(frameNumber, framesX));",
			"        float row = floor((frameNumber - column) / framesX);",

			"        float columnNorm = column / framesX;",
			"        float rowNorm = row / framesY;",

			"        vSpriteSheet.x = 1.0 / framesX;",
			"        vSpriteSheet.y = 1.0 / framesY;",
			"        vSpriteSheet.z = columnNorm;",
			"        vSpriteSheet.w = rowNorm;",
			"    #endif",

			// Write values
			// Set PointSize according to size at current point in time.
			"    gl_PointSize = pointSizePerspective;",
			"    gl_Position = projectionMatrix * mvPosition;",

			three.ShaderChunk.logdepthbuf_vertex,
			three.ShaderChunk.fog_vertex,

			"}"
		].join("\n"),

		fragment:
		[
			ParticleShaderChunks.uniforms,

			three.ShaderChunk.common,
			three.ShaderChunk.fog_pars_fragment,
			three.ShaderChunk.logdepthbuf_pars_fragment,

			ParticleShaderChunks.varyings,

			ParticleShaderChunks.branchAvoidanceFunctions,

			"void main() {",
			"    vec3 outgoingLight = vColor.xyz;",
			"    ",
			"    #ifdef ALPHATEST",
			"       if(vColor.w < float(ALPHATEST)) discard;",
			"    #endif",

			ParticleShaderChunks.rotateTexture,

			three.ShaderChunk.logdepthbuf_fragment,

			"    outgoingLight = vColor.xyz * rotatedTexture.xyz;",
			"    gl_FragColor = vec4(outgoingLight.xyz, rotatedTexture.w * vColor.w);",

			three.ShaderChunk.fog_fragment,

			"}"
		].join("\n")
	};

	/**
	 * A helper class for TypedArrays.
	 *
	 * Allows for easy resizing, assignment of various component-based types (e.g. Vector2, Vector3, Mat3, Color, ...) Numbers, and setting from other TypedArrays.
	 *
	 * @constructor
	 * @author Luke Moody
	 * @class TypedArrayHelper
	 * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)
	 * @param {number} size The size of the array to create
	 * @param {number} componentSize The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)
	 * @param {number} indexOffset The index in the array from which to start assigning values. Default 0 if none provided
	 */
	function TypedArrayHelper(TypedArrayConstructor, size, componentSize, indexOffset)
	{
		this.componentSize = componentSize || 1;
		this.size = size || 1;
		this.TypedArrayConstructor = TypedArrayConstructor || Float32Array;
		this.array = new TypedArrayConstructor(size * this.componentSize);
		this.indexOffset = indexOffset || 0;
	}

	TypedArrayHelper.constructor = TypedArrayHelper;

	/**
	 * Sets the size of the internal array.
	 *
	 * Delegates to this.shrink or this.grow depending on size argument's relation to the current size of the internal array.
	 *
	 * Note that if the array is to be shrunk, data will be lost.
	 *
	 * @method setSize
	 * @param {number} size The new size of the array.
	 */
	TypedArrayHelper.prototype.setSize = function(size, noComponentMultiply)
	{
		var currentArraySize = this.array.length;

		if(!noComponentMultiply)
		{
			size = size * this.componentSize;
		}

		if(size < currentArraySize)
		{
			return this.shrink(size);
		}
		else if(size > currentArraySize)
		{
			return this.grow(size);
		}
	};

	/**
	 * Shrinks the internal array.
	 *
	 * @method shrink
	 * @param {number} size The new size of the typed array. Must be smaller than this.array.length.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.shrink = function(size)
	{
		this.array = this.array.subarray(0, size);
		this.size = size;
		return this;
	};

	/**
	 * Grows the internal array.
	 *
	 * @method grow
	 * @param {number} size The new size of the typed array. Must be larger than this.array.length.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.grow = function(size)
	{
		var existingArray = this.array,
			newArray = new this.TypedArrayConstructor(size);

		newArray.set(existingArray);
		this.array = newArray;
		this.size = size;

		return this;
	};


	/**
	 * Perform a splice operation on this arrays buffer.
	 *
	 * @method splice
	 * @param {number} start The start index of the splice. Will be multiplied by the number of components for this attribute.
	 * @param {number} end The end index of the splice. Will be multiplied by the number of components for this attribute.
	 * @return {Object} The TypedArrayHelper instance.
	 */
	TypedArrayHelper.prototype.splice = function(start, end)
	{
		start *= this.componentSize;
		end *= this.componentSize;

		var data = [],
			array = this.array,
			size = array.length;

		for(var i = 0; i < size; ++i)
		{
			if(i < start || i >= end)
			{
				data.push(array[i]);
			}
		}

		this.setFromArray(0, data);

		return this;
	};


	/**
	 * Copies from the given TypedArray into this one, using the index argument as the start position.
	 *
	 * Alias for TypedArray.set. Will automatically resize if the given source array is of a larger size than the internal array.
	 *
	 * @method setFromArray
	 * @param {number} index The start position from which to copy into this array.
	 * @param {TypedArray} array The array from which to copy; the source array.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setFromArray = function(index, array)
	{
		var sourceArraySize = array.length,
			newSize = index + sourceArraySize;

		if(newSize > this.array.length)
		{
			this.grow(newSize);
		}
		else if(newSize < this.array.length)
		{
			this.shrink(newSize);
		}

		this.array.set(array, this.indexOffset + index);

		return this;
	};

	/**
	 * Set a Vector2 value at index.
	 *
	 * @method setVec2
	 * @param {number} index The index at which to set the vec2 values from.
	 * @param {Vector2} vec2  Any object that has x and y properties.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setVec2 = function(index, vec2)
	{
		return this.setVec2Components(index, vec2.x, vec2.y);
	};

	/**
	 * Set a Vector2 value using raw components.
	 *
	 * @method setVec2Components
	 * @param {number} index The index at which to set the vec2 values from.
	 * @param {number} x The Vec2"s x component.
	 * @param {number} y The Vec2"s y component.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setVec2Components = function(index, x, y)
	{
		var array = this.array,
			i = this.indexOffset + (index * this.componentSize);

		array[i] = x;
		array[i + 1] = y;
		return this;
	};

	/**
	 * Set a Vector3 value at index.
	 *
	 * @method setVec3
	 * @param {number} index The index at which to set the vec3 values from.
	 * @param {Vector3} vec2  Any object that has x, y, and z properties.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setVec3 = function(index, vec3)
	{
		return this.setVec3Components(index, vec3.x, vec3.y, vec3.z);
	};

	/**
	 * Set a Vector3 value using raw components.
	 *
	 * @method setVec3Components
	 * @param {number} index The index at which to set the vec3 values from.
	 * @param {number} x The Vec3"s x component.
	 * @param {number} y The Vec3"s y component.
	 * @param {number} z The Vec3"s z component.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setVec3Components = function(index, x, y, z)
	{
		var array = this.array,
			i = this.indexOffset + (index * this.componentSize);

		array[i] = x;
		array[i + 1] = y;
		array[i + 2] = z;
		return this;
	};

	/**
	 * Set a Vector4 value at index.
	 *
	 * @method setVec4
	 * @param {number} index The index at which to set the vec4 values from.
	 * @param {Vector4} vec2  Any object that has x, y, z, and w properties.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setVec4 = function(index, vec4)
	{
		return this.setVec4Components(index, vec4.x, vec4.y, vec4.z, vec4.w);
	};

	/**
	 * Set a Vector4 value using raw components.
	 *
	 * @method setVec4Components
	 * @param {number} index The index at which to set the vec4 values from.
	 * @param {number} x The Vec4"s x component.
	 * @param {number} y The Vec4"s y component.
	 * @param {number} z The Vec4"s z component.
	 * @param {number} w The Vec4"s w component.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setVec4Components = function(index, x, y, z, w)
	{
		var array = this.array,
			i = this.indexOffset + (index * this.componentSize);

		array[i] = x;
		array[i + 1] = y;
		array[i + 2] = z;
		array[i + 3] = w;
		return this;
	};

	/**
	 * Set a Matrix3 value at index.
	 *
	 * @method setMat3
	 * @param {number} index The index at which to set the matrix values from.
	 * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named elements to copy from.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setMat3 = function(index, mat3)
	{
		return this.setFromArray(this.indexOffset + (index * this.componentSize), mat3.elements);
	};

	/**
	 * Set a Matrix4 value at index.
	 *
	 * @method setMat4
	 * @param {number} index The index at which to set the matrix values from.
	 * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named elements to copy from.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setMat4 = function(index, mat4)
	{
		return this.setFromArray(this.indexOffset + (index * this.componentSize), mat4.elements);
	};

	/**
	 * Set a Color value at index.
	 *
	 * @method setColor
	 * @param {number} index The index at which to set the vec3 values from.
	 * @param {Color} color  Any object that has r, g, and b properties.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setColor = function(index, color)
	{
		return this.setVec3Components(index, color.r, color.g, color.b);
	};

	/**
	 * Set a Number value at index.
	 *
	 * @method setNumber
	 * @param {number} index The index at which to set the vec3 values from.
	 * @param {number} numericValue  The number to assign to this index in the array.
	 * @return {TypedArrayHelper} Instance of this class.
	 */
	TypedArrayHelper.prototype.setNumber = function(index, numericValue)
	{
		this.array[this.indexOffset + (index * this.componentSize)] = numericValue;
		return this;
	};

	/**
	 * Returns the value of the array at the given index, taking into account the indexOffset property of this class.
	 *
	 * Note that this function ignores the component size and will just return a single value.
	 *
	 * @method getValueAtIndex
	 * @param {number} index The index in the array to fetch.
	 * @return {number} The value at the given index.
	 */
	TypedArrayHelper.prototype.getValueAtIndex = function(index)
	{
		return this.array[this.indexOffset + index];
	};

	/**
	 * Returns the component value of the array at the given index, taking into account the indexOffset property of this class.
	 *
	 * If the componentSize is set to 3, then it will return a new TypedArray of length 3.
	 *
	 * @method getComponentValueAtIndex
	 * @param {number} index The index in the array to fetch.
	 * @return {TypedArray} The component value at the given index.
	 */
	TypedArrayHelper.prototype.getComponentValueAtIndex = function(index)
	{
		return this.array.subarray(this.indexOffset + (index * this.componentSize));
	};

	/**
	 * A helper to handle creating and updating a BufferAttribute instance.
	 *
	 * @constructor
	 * @class ShaderAttribute
	 * @author Luke Moody
	 * @param {string} type The buffer attribute type. See ShaderAttribute.typeSizeMap for valid values.
	 * @param {boolean} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.
	 * @param {Function} arrayType A reference to a TypedArray constructor. Defaults to Float32Array if none provided.
	 */
	function ShaderAttribute(type, dynamicBuffer, arrayType)
	{
		this.type = typeof type === "string" && ShaderAttribute.typeSizeMap.hasOwnProperty(type) ? type : "f";
		this.componentSize = ShaderAttribute.typeSizeMap[this.type];
		this.arrayType = arrayType || Float32Array;
		this.typedArray = null;
		this.bufferAttribute = null;
		this.dynamicBuffer = !!dynamicBuffer;

		this.updateMin = 0;
		this.updateMax = 0;
	}

	ShaderAttribute.constructor = ShaderAttribute;

	/**
	 * A map of uniform types to their component size.
	 *
	 * @static
	 * @attribute typeSizeMap
	 */
	ShaderAttribute.typeSizeMap =
	{
		f: 1,
		v2: 2,
		v3: 3,
		v4: 4,
		c: 3,
		m3: 9,
		m4: 16
	};

	/**
	 * Calculate the minimum and maximum update range for this buffer attribute using component size independant min and max values.
	 *
	 * @method setUpdateRange
	 * @param {number} min The start of the range to mark as needing an update.
	 * @param {number} max The end of the range to mark as needing an update.
	 */
	ShaderAttribute.prototype.setUpdateRange = function(min, max)
	{
		this.updateMin = Math.min(min * this.componentSize, this.updateMin * this.componentSize);
		this.updateMax = Math.max(max * this.componentSize, this.updateMax * this.componentSize);
	};

	/**
	 * Calculate the number of indices that this attribute should mark as needing updating. Also marks the attribute as needing an update.
	 *
	 * @method flagUpdate
	 */
	ShaderAttribute.prototype.flagUpdate = function()
	{
		var range = this.bufferAttribute.updateRange;
		range.offset = this.updateMin;
		range.count = Math.min((this.updateMax - this.updateMin) + this.componentSize, this.typedArray.array.length);

		this.bufferAttribute.needsUpdate = true;
	};

	/**
	 * Reset the index update counts for this attribute
	 *
	 * @method resetUpdateRange
	 */
	ShaderAttribute.prototype.resetUpdateRange = function()
	{
		this.updateMin = 0;
		this.updateMax = 0;
	};

	ShaderAttribute.prototype.resetDynamic = function()
	{
		this.bufferAttribute.usage = this.dynamicBuffer ? three.DynamicDrawUsage : three.StaticDrawUsage;
	};

	/**
	 * Perform a splice operation on this attribute"s buffer.
	 *
	 * @method splice
	 * @param {number} start The start index of the splice. Will be multiplied by the number of components for this attribute.
	 * @param {number} end The end index of the splice. Will be multiplied by the number of components for this attribute.
	 */
	ShaderAttribute.prototype.splice = function(start, end)
	{
		this.typedArray.splice(start, end);

		// Reset the reference to the attribute"s typed array since it has probably changed.
		this.forceUpdateAll();
	};

	ShaderAttribute.prototype.forceUpdateAll = function()
	{
		this.bufferAttribute.array = this.typedArray.array;
		this.bufferAttribute.updateRange.offset = 0;
		this.bufferAttribute.updateRange.count = -1;
		this.bufferAttribute.usage = three.StaticDrawUsage;
		this.bufferAttribute.needsUpdate = true;
	};

	/**
	 * Make sure this attribute has a typed array associated with it.
	 *
	 * If it does, then it will ensure the typed array is of the correct size.
	 *
	 * If not, a new TypedArrayHelper instance will be created.
	 *
	 * @method _ensureTypedArray
	 * @param {number} size The size of the typed array to create or update to.
	 */
	ShaderAttribute.prototype._ensureTypedArray = function(size)
	{
		// Condition that's most likely to be true at the top: no change.
		if(this.typedArray !== null && this.typedArray.size === size * this.componentSize)
		{
			return;
		}

		// Resize the array if we need to, telling the TypedArrayHelper to ignore it's component size when evaluating size.
		else if(this.typedArray !== null && this.typedArray.size !== size)
		{
			this.typedArray.setSize(size);
		}

		// This condition should only occur once in an attribute"s lifecycle.
		else if(this.typedArray === null)
		{
			this.typedArray = new TypedArrayHelper(this.arrayType, size, this.componentSize);
		}
	};


	/**
	 * Creates a BufferAttribute instance if one doesn't exist already.
	 *
	 * Ensures a typed array is present by calling _ensureTypedArray() first.
	 *
	 * If a buffer attribute exists already, then it will be marked as needing an update.
	 *
	 * @method _createBufferAttribute
	 * @param {number} size The size of the typed array to create if one doesn't exist, or resize existing array to.
	 */
	ShaderAttribute.prototype._createBufferAttribute = function(size)
	{
		// Make sure the typedArray is present and correct.
		this._ensureTypedArray(size);

		// Don't create it if it already exists, but do flag that it needs updating on the next render cycle.
		if(this.bufferAttribute !== null)
		{
			this.bufferAttribute.array = this.typedArray.array;
			this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize;
			this.bufferAttribute.needsUpdate = true;
			return;
		}

		this.bufferAttribute = new three.BufferAttribute(this.typedArray.array, this.componentSize);
		this.bufferAttribute.usage = this.dynamicBuffer ? three.DynamicDrawUsage : three.StaticDrawUsage;
	};

	/**
	 * Returns the length of the typed array associated with this attribute.
	 *
	 * @method getLength
	 * @return {number} The length of the typed array. Will be 0 if no typed array has been created yet.
	 */
	ShaderAttribute.prototype.getLength = function()
	{
		if(this.typedArray === null)
		{
			return 0;
		}

		return this.typedArray.array.length;
	};

	/**
	 * A map of options to configure an ParticleEmitterControl instance.
	 *
	 * @class ParticleEmitterControlOptions
	 * @property {distribution} [type=BOX] The default distribution this emitter should use to control its particle"s spawn position and force behaviour. Must be an ParticleDistributions.* value.
	 * @property {number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number of particles emitted in a second, or anything like that. The number of particles   emitted per-second is calculated by particleCount / maxAge (approximately!)
	 * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter will emit particles indefinitely. NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from    it's group, but rather is just marked as dead, allowing it to be reanimated at a later time    using ParticleEmitterControl.prototype.enable().
	 * @property {boolean} [isStatic=false] Whether this emitter should be not be simulated (true).
	 * @property {boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter"s particlesPerSecond should be emitted, where 0 is 0%, and 1 is 100%.     For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond     value of 50. Setting activeMultiplier to 0.5, then, will only emit 25 particles per second (0.5 = 50%).     Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles     before it's next activation cycle.
	 * @property {boolean} [direction=1] The direction of the emitter. If value is 1, emitter will start at beginning of particle"s lifecycle. If value is -1, emitter will start at end of particle"s lifecycle and work it's way backwards.
	 * @property {Object} [maxAge={}] An object describing the particle"s maximum age in seconds.
	 * @property {number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.
	 * @property {number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.
	 * @property {Object} [position={}] An object describing this emitter"s position.
	 * @property {Object} [position.value=new Vector3()] A Vector3 instance describing this emitter"s base position.
	 * @property {Object} [position.spread=new Vector3()] A Vector3 instance describing this emitter"s position variance on a per-particle basis. Note that when using a SPHERE or DISC distribution, only the x-component                of this vector is used.
	 * @property {Object} [position.spreadClamp=new Vector3()] A Vector3 instance describing the numeric multiples the particle"s should be spread out over. Note that when using a SPHERE or DISC distribution, only the x-component                   of this vector is used.
	 * @property {number} [position.radius=10] This emitter"s base radius.
	 * @property {Object} [position.radiusScale=new Vector3()] A Vector3 instance describing the radius"s scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.
	 * @property {distribution} [position.distribution=value of the type option.] A specific distribution to use when radiusing particles. Overrides the type option.
	 * @property {boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [velocity={}] An object describing this particle velocity.
	 * @property {Object} [velocity.value=new Vector3()] A Vector3 instance describing this emitter"s base velocity.
	 * @property {Object} [velocity.spread=new Vector3()] A Vector3 instance describing this emitter"s velocity variance on a per-particle basis. Note that when using a SPHERE or DISC distribution, only the x-component                of this vector is used.
	 * @property {distribution} [velocity.distribution=value of the type option.] A specific distribution to use when calculating a particle"s velocity. Overrides the type option.
	 * @property {boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [acceleration={}] An object describing this particle"s acceleration.
	 * @property {Object} [acceleration.value=new Vector3()] A Vector3 instance describing this emitter"s base acceleration.
	 * @property {Object} [acceleration.spread=new Vector3()] A Vector3 instance describing this emitter"s acceleration variance on a per-particle basis.               Note that when using a SPHERE or DISC distribution, only the x-component               of this vector is used.
	 * @property {distribution} [acceleration.distribution=value of the type option.] A specific distribution to use when calculating a particle"s acceleration. Overrides the type option.
	 * @property {boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.
	 * @property {number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.
	 * @property {number} [drag.spread=0] A number describing the drag variance on a per-particle basis.
	 * @property {boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,  or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will  start off with no wiggle, and end up wiggling about with the distance of the value specified by the time it dies.  It's quite handy to simulate fire embers, or similar effects where the particle"s position should slightly change over  time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.
	 * @property {number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.
	 * @property {number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.
	 * @property {Object} [rotation={}] An object describing this emitter"s rotation. It can either be static, or set to rotate from 0radians to the value of rotation.value   over a particle"s lifetime. Rotation values affect both a particle"s position and the forces applied to it.
	 * @property {Object} [rotation.axis=new Vector3(0, 1, 0)] A Vector3 instance describing this emitter"s axis of rotation.
	 * @property {Object} [rotation.axisSpread=new Vector3()] A Vector3 instance describing the amount of variance to apply to the axis of rotation on                  a per-particle basis.
	 * @property {number} [rotation.angle=0] The angle of rotation, given in radians. If rotation.static is true, the emitter will start off rotated at this angle, and stay as such.   Otherwise, the particles will rotate from 0radians to this value over their lifetimes.
	 * @property {number} [rotation.angleSpread=0] The amount of variance in each particle"s rotation angle.
	 * @property {boolean} [rotation.static=false] Whether the rotation should be static or not.
	 * @property {Object} [rotation.center=The value of position.value] A Vector3 instance describing the center point of rotation.
	 * @property {boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [color={}] An object describing a particle"s color. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be given to describe specific value changes over a particle"s lifetime. Depending on the value of valueOverLifetimeLength, if arrays of Color instances are given, then the array will be interpolated to have a length matching the value of valueOverLifetimeLength.
	 * @property {Object} [color.value=new Color()] Either a single Color instance, or an array of Color instances to describe the color of a particle over it's lifetime.
	 * @property {Object} [color.spread=new Vector3()] Either a single Vector3 instance, or an array of Vector3 instances to describe the color variance of a particle over it's lifetime.
	 * @property {boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [opacity={}] An object describing a particle"s opacity. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be given to describe specific value changes over a particle"s lifetime. Depending on the value of valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to have a length matching the value of valueOverLifetimeLength.
	 * @property {number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.
	 * @property {number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.
	 * @property {boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [size={}] An object describing a particle"s size. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be given to describe specific value changes over a particle"s lifetime. Depending on the value of valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to have a length matching the value of valueOverLifetimeLength.
	 * @property {number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.
	 * @property {number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.
	 * @property {boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.
	 * @property {Object} [angle={}] An object describing a particle"s angle. The angle is a 2d-rotation, measured in radians, applied to the particle"s texture. NOTE: if a particle"s texture is a sprite-sheet, this value IS IGNORED. This property is a "value-over-lifetime" property, meaning an array of values and spreads can be given to describe specific value changes over a particle"s lifetime. Depending on the value of valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to have a length matching the value of valueOverLifetimeLength.
	 * @property {number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.
	 * @property {number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.
	 * @property {boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.
	 */

	/**
	 * The ParticleEmitterControl class.
	 *
	 * @constructor
	 * @author Luke Moody
	 * @class ParticleEmitterControl
	 * @param {ParticleEmitterControlOptions} options A map of options to configure the emitter.
	 */
	function ParticleEmitterControl(options)
	{
		// Ensure we have a map of options to play with, and that each option is in the correct format.
		options = ShaderUtils.ensureTypedArg(options, ShaderUtils.types.OBJECT, {});
		options.position = ShaderUtils.ensureTypedArg(options.position, ShaderUtils.types.OBJECT, {});
		options.velocity = ShaderUtils.ensureTypedArg(options.velocity, ShaderUtils.types.OBJECT, {});
		options.acceleration = ShaderUtils.ensureTypedArg(options.acceleration, ShaderUtils.types.OBJECT, {});
		options.radius = ShaderUtils.ensureTypedArg(options.radius, ShaderUtils.types.OBJECT, {});
		options.drag = ShaderUtils.ensureTypedArg(options.drag, ShaderUtils.types.OBJECT, {});
		options.rotation = ShaderUtils.ensureTypedArg(options.rotation, ShaderUtils.types.OBJECT, {});
		options.color = ShaderUtils.ensureTypedArg(options.color, ShaderUtils.types.OBJECT, {});
		options.opacity = ShaderUtils.ensureTypedArg(options.opacity, ShaderUtils.types.OBJECT, {});
		options.size = ShaderUtils.ensureTypedArg(options.size, ShaderUtils.types.OBJECT, {});
		options.angle = ShaderUtils.ensureTypedArg(options.angle, ShaderUtils.types.OBJECT, {});
		options.wiggle = ShaderUtils.ensureTypedArg(options.wiggle, ShaderUtils.types.OBJECT, {});
		options.maxAge = ShaderUtils.ensureTypedArg(options.maxAge, ShaderUtils.types.OBJECT, {});

		if(options.onParticleSpawn)
		{
			console.warn("nunuStudio: onParticleSpawn has been removed. Please set properties directly to alter values at runtime.");
		}

		this.uuid = three.Math.generateUUID();

		this.type = ShaderUtils.ensureTypedArg(options.type, ShaderUtils.types.NUMBER, ParticleDistributions.BOX);

		this.position =
		{
			_value: ShaderUtils.ensureInstanceOf(options.position.value, three.Vector3, new three.Vector3()),
			_spread: ShaderUtils.ensureInstanceOf(options.position.spread, three.Vector3, new three.Vector3()),
			_spreadClamp: ShaderUtils.ensureInstanceOf(options.position.spreadClamp, three.Vector3, new three.Vector3()),
			_distribution: ShaderUtils.ensureTypedArg(options.position.distribution, ShaderUtils.types.NUMBER, this.type),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false),
			_radius: ShaderUtils.ensureTypedArg(options.position.radius, ShaderUtils.types.NUMBER, 10),
			_radiusScale: ShaderUtils.ensureInstanceOf(options.position.radiusScale, three.Vector3, new three.Vector3(1, 1, 1)),
			_distributionClamp: ShaderUtils.ensureTypedArg(options.position.distributionClamp, ShaderUtils.types.NUMBER, 0),
		};

		this.velocity =
		{
			_value: ShaderUtils.ensureInstanceOf(options.velocity.value, three.Vector3, new three.Vector3()),
			_spread: ShaderUtils.ensureInstanceOf(options.velocity.spread, three.Vector3, new three.Vector3()),
			_distribution: ShaderUtils.ensureTypedArg(options.velocity.distribution, ShaderUtils.types.NUMBER, this.type),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.acceleration =
		{
			_value: ShaderUtils.ensureInstanceOf(options.acceleration.value, three.Vector3, new three.Vector3()),
			_spread: ShaderUtils.ensureInstanceOf(options.acceleration.spread, three.Vector3, new three.Vector3()),
			_distribution: ShaderUtils.ensureTypedArg(options.acceleration.distribution, ShaderUtils.types.NUMBER, this.type),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.drag =
		{
			_value: ShaderUtils.ensureTypedArg(options.drag.value, ShaderUtils.types.NUMBER, 0),
			_spread: ShaderUtils.ensureTypedArg(options.drag.spread, ShaderUtils.types.NUMBER, 0),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.wiggle =
		{
			_value: ShaderUtils.ensureTypedArg(options.wiggle.value, ShaderUtils.types.NUMBER, 0),
			_spread: ShaderUtils.ensureTypedArg(options.wiggle.spread, ShaderUtils.types.NUMBER, 0)
		};

		this.rotation =
		{
			_axis: ShaderUtils.ensureInstanceOf(options.rotation.axis, three.Vector3, new three.Vector3(0.0, 1.0, 0.0)),
			_axisSpread: ShaderUtils.ensureInstanceOf(options.rotation.axisSpread, three.Vector3, new three.Vector3()),
			_angle: ShaderUtils.ensureTypedArg(options.rotation.angle, ShaderUtils.types.NUMBER, 0),
			_angleSpread: ShaderUtils.ensureTypedArg(options.rotation.angleSpread, ShaderUtils.types.NUMBER, 0),
			_static: ShaderUtils.ensureTypedArg(options.rotation.static, ShaderUtils.types.BOOLEAN, false),
			_center: ShaderUtils.ensureInstanceOf(options.rotation.center, three.Vector3, this.position._value.clone()),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.maxAge =
		{
			_value: ShaderUtils.ensureTypedArg(options.maxAge.value, ShaderUtils.types.NUMBER, 2),
			_spread: ShaderUtils.ensureTypedArg(options.maxAge.spread, ShaderUtils.types.NUMBER, 0)
		};

		// The following properties can support either single values, or an array of values that change the property over a particle"s lifetime (value over lifetime).
		this.color =
		{
			_value: ShaderUtils.ensureArrayInstanceOf(options.color.value, three.Color, new three.Color()),
			_spread: ShaderUtils.ensureArrayInstanceOf(options.color.spread, three.Vector3, new three.Vector3()),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.opacity =
		{
			_value: ShaderUtils.ensureArrayTypedArg(options.opacity.value, ShaderUtils.types.NUMBER, 1),
			_spread: ShaderUtils.ensureArrayTypedArg(options.opacity.spread, ShaderUtils.types.NUMBER, 0),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.size =
		{
			_value: ShaderUtils.ensureArrayTypedArg(options.size.value, ShaderUtils.types.NUMBER, 1),
			_spread: ShaderUtils.ensureArrayTypedArg(options.size.spread, ShaderUtils.types.NUMBER, 0),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.angle =
		{
			_value: ShaderUtils.ensureArrayTypedArg(options.angle.value, ShaderUtils.types.NUMBER, 0),
			_spread: ShaderUtils.ensureArrayTypedArg(options.angle.spread, ShaderUtils.types.NUMBER, 0),
			_randomise: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		// Assign renaining option values.
		this.particleCount = ShaderUtils.ensureTypedArg(options.particleCount, ShaderUtils.types.NUMBER, 100);
		this.duration = ShaderUtils.ensureTypedArg(options.duration, ShaderUtils.types.NUMBER, null);
		this.isStatic = ShaderUtils.ensureTypedArg(options.isStatic, ShaderUtils.types.BOOLEAN, false);
		this.activeMultiplier = ShaderUtils.ensureTypedArg(options.activeMultiplier, ShaderUtils.types.NUMBER, 1);
		this.direction = ShaderUtils.ensureTypedArg(options.direction, ShaderUtils.types.NUMBER, 1);

		// Whether this emitter is alive or not.
		this.alive = ShaderUtils.ensureTypedArg(options.alive, ShaderUtils.types.BOOLEAN, true);

		// The following properties are set internally and are not user-controllable.
		this.particlesPerSecond = 0;

		// The current particle index for which particles should be marked as active on the next update cycle.
		this.activationIndex = 0;

		// The offset in the typed arrays this emitter"s particle"s values will start at
		this.attributeOffset = 0;

		// The end of the range in the attribute buffers
		this.attributeEnd = 0;

		// Holds the time the emitter has been alive for.
		this.age = 0.0;

		// Holds the number of currently-alive particles
		this.activeParticleCount = 0.0;

		// Holds a reference to this emitter"s group once
		// it's added to one.
		this.group = null;

		// Holds a reference to this emitter"s group"s attributes object
		// for easier access.
		this.attributes = null;

		// Holds a reference to the params attribute"s typed array
		// for quicker access.
		this.paramsArray = null;

		// A set of flags to determine whether particular properties should be re-randomised when a particle is reset.
		//
		// If a randomise property is given, this is preferred. Otherwise, it looks at whether a spread value has been given.
		//
		// It allows randomization to be turned off as desired. If all randomization is turned off, then I'd expect a performance boost as no attribute buffers (excluding the params) would have to be re-passed to the GPU each frame (since nothing except the params attribute would have changed).
		this.resetFlags =
		{
			position: ShaderUtils.ensureTypedArg(options.position.randomise, ShaderUtils.types.BOOLEAN, false) || ShaderUtils.ensureTypedArg(options.radius.randomise, ShaderUtils.types.BOOLEAN, false),
			velocity: ShaderUtils.ensureTypedArg(options.velocity.randomise, ShaderUtils.types.BOOLEAN, false),
			acceleration: ShaderUtils.ensureTypedArg(options.acceleration.randomise, ShaderUtils.types.BOOLEAN, false) || ShaderUtils.ensureTypedArg(options.drag.randomise, ShaderUtils.types.BOOLEAN, false),
			rotation: ShaderUtils.ensureTypedArg(options.rotation.randomise, ShaderUtils.types.BOOLEAN, false),
			rotationCenter: ShaderUtils.ensureTypedArg(options.rotation.randomise, ShaderUtils.types.BOOLEAN, false),
			size: ShaderUtils.ensureTypedArg(options.size.randomise, ShaderUtils.types.BOOLEAN, false),
			color: ShaderUtils.ensureTypedArg(options.color.randomise, ShaderUtils.types.BOOLEAN, false),
			opacity: ShaderUtils.ensureTypedArg(options.opacity.randomise, ShaderUtils.types.BOOLEAN, false),
			angle: ShaderUtils.ensureTypedArg(options.angle.randomise, ShaderUtils.types.BOOLEAN, false)
		};

		this.updateFlags = {};
		this.updateCounts = {};

		// A map to indicate which emitter parameters should update which attribute.
		this.updateMap =
		{
			maxAge: "params",
			position: "position",
			velocity: "velocity",
			acceleration: "acceleration",
			drag: "acceleration",
			wiggle: "params",
			rotation: "rotation",
			size: "size",
			color: "color",
			opacity: "opacity",
			angle: "angle"
		};

		for(var i in this.updateMap)
		{
			if(this.updateMap.hasOwnProperty(i))
			{
			  this.updateCounts[this.updateMap[i]] = 0.0;
			  this.updateFlags[this.updateMap[i]] = false;
			  this._createGetterSetters(this[i], i);
			}
		}

		this.bufferUpdateRanges = {};
		this.attributeKeys = null;
		this.attributeCount = 0;


		// Ensure that the value-over-lifetime property objects above have value and spread properties that are of the same length.
		//
		// Also, for now, make sure they have a length of 3 (min/max arguments here).
		ShaderUtils.ensureValueOverLifetimeCompliance(this.color, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
		ShaderUtils.ensureValueOverLifetimeCompliance(this.opacity, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
		ShaderUtils.ensureValueOverLifetimeCompliance(this.size, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
		ShaderUtils.ensureValueOverLifetimeCompliance(this.angle, ParticleEmitter.valueOverLifetimeLength, ParticleEmitter.valueOverLifetimeLength);
	}

	ParticleEmitterControl.constructor = ParticleEmitterControl;

	ParticleEmitterControl.prototype._createGetterSetters = function(propObj, propName)
	{
		var self = this;

		for(var i in propObj)
		{
			if(propObj.hasOwnProperty(i))
			{
			  var name = i.replace("_", "");

			  Object.defineProperty(propObj, name,
			  {
				  get: (function(prop)
				  {
					return function()
					{
						return this[prop];
					};
				  }(i)),

				  set: (function(prop)
				  {
					  return function(value)
					  {
						 var mapName = self.updateMap[propName],
							 prevValue = this[prop],
							 length = ParticleEmitter.valueOverLifetimeLength;

						 if(prop === "_rotationCenter")
						 {
							self.updateFlags.rotationCenter = true;
							self.updateCounts.rotationCenter = 0.0;
						 }
						 else if(prop === "_randomise")
						 {
							self.resetFlags[mapName] = value;
						 }
						 else
						 {
							self.updateFlags[mapName] = true;
							self.updateCounts[mapName] = 0.0;
						 }

						 self.group._updateDefines();

						 this[prop] = value;

						 // If the previous value was an array, then make sure the provided value is interpolated correctly.
						 if(Array.isArray(prevValue))
						 {
							 ShaderUtils.ensureValueOverLifetimeCompliance(self[propName], length, length);
						 }
					  };
				  }(i))
			  });
			}
		}
	};

	ParticleEmitterControl.prototype._setBufferUpdateRanges = function(keys)
	{
		this.attributeKeys = keys;
		this.attributeCount = keys.length;

		for(var i = this.attributeCount - 1; i >= 0; --i)
		{
			this.bufferUpdateRanges[keys[i]] =
			{
			  min: Number.POSITIVE_INFINITY,
			  max: Number.NEGATIVE_INFINITY
			};
		}
	};

	ParticleEmitterControl.prototype._calculatePPSValue = function(groupMaxAge)
	{
		var particleCount = this.particleCount;

		// Calculate the particlesPerSecond value for this emitter.
		// It's used when determining which particles should die and which should live.
		if(this.duration)
		{
			this.particlesPerSecond = particleCount / (groupMaxAge < this.duration ? groupMaxAge : this.duration);
		}
		else
		{
			this.particlesPerSecond = particleCount / groupMaxAge;
		}
	};

	ParticleEmitterControl.prototype._setAttributeOffset = function(startIndex)
	{
		this.attributeOffset = startIndex;
		this.activationIndex = startIndex;
		this.activationEnd = startIndex + this.particleCount;
	};


	ParticleEmitterControl.prototype._assignValue = function(prop, index)
	{
		switch (prop)
		{
			case "position":
				this._assignPositionValue(index);
				break;

			case "velocity":
			case "acceleration":
				this._assignForceValue(index, prop);
				break;

			case "size":
			case "opacity":
				this._assignAbsLifetimeValue(index, prop);
				break;

			case "angle":
				this._assignAngleValue(index);
				break;

			case "params":
				this._assignParamsValue(index);
				break;

			case "rotation":
				this._assignRotationValue(index);
				break;

			case "color":
				this._assignColorValue(index);
				break;
		}
	};

	ParticleEmitterControl.prototype._assignPositionValue = function(index)
	{
		var prop = this.position;
		var attr = this.attributes.position;
		var value = prop._value;
		var spread = prop._spread;
		var distribution = prop._distribution;

		switch (distribution)
		{
			case ParticleDistributions.BOX:
				ShaderUtils.randomVector3(attr, index, value, spread, prop._spreadClamp);
				break;
			case ParticleDistributions.SPHERE:
				ShaderUtils.randomVector3OnSphere(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount);
				break;
			case ParticleDistributions.DISC:
				ShaderUtils.randomVector3OnDisc(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x);
				break;
		}
	};

	ParticleEmitterControl.prototype._assignForceValue = function(index, attrName)
	{
		var prop = this[attrName];
		var value = prop._value;
		var spread = prop._spread;
		var distribution = prop._distribution;
		var pos;
		var positionX;
		var positionY;
		var positionZ;
		var i;

		switch (distribution)
		{
			case ParticleDistributions.BOX:
				ShaderUtils.randomVector3(this.attributes[attrName], index, value, spread);
				break;

			case ParticleDistributions.SPHERE:
				pos = this.attributes.position.typedArray.array;
				i = index * 3;

				// Ensure position values aren't zero, otherwise no force will be applied.
				positionX = pos[i];
				positionY = pos[i + 1];
				positionZ = pos[i + 2];

				ShaderUtils.randomDirectionVector3OnSphere(
					this.attributes[attrName], index,
					positionX, positionY, positionZ,
					this.position._value,
					prop._value.x,
					prop._spread.x
				);
				break;

			case ParticleDistributions.DISC:
				pos = this.attributes.position.typedArray.array;
				i = index * 3;

				// Ensure position values aren't zero, otherwise no force will be applied.
				positionX = pos[i];
				positionY = pos[i + 1];
				positionZ = pos[i + 2];

				ShaderUtils.randomDirectionVector3OnDisc(
					this.attributes[attrName], index,
					positionX, positionY, positionZ,
					this.position._value,
					prop._value.x,
					prop._spread.x
				);
				break;
		}

		if(attrName === "acceleration")
		{
			var drag = ShaderUtils.clamp(ShaderUtils.randomFloat(this.drag._value, this.drag._spread), 0, 1);
			this.attributes.acceleration.typedArray.array[index * 4 + 3] = drag;
		}
	};

	ParticleEmitterControl.prototype._assignAbsLifetimeValue = function(index, propName)
	{
		var array = this.attributes[propName].typedArray;
		var prop = this[propName];
		var value;

		if(ShaderUtils.arrayValuesAreEqual(prop._value) && ShaderUtils.arrayValuesAreEqual(prop._spread))
		{
			value = three.Math.abs(ShaderUtils.randomFloat(prop._value[0], prop._spread[0]));
			array.setVec4Components(index, value, value, value, value);
		}
		else
		{
			array.setVec4Components(index,
			  three.Math.abs(ShaderUtils.randomFloat(prop._value[0], prop._spread[0])),
			  three.Math.abs(ShaderUtils.randomFloat(prop._value[1], prop._spread[1])),
			  three.Math.abs(ShaderUtils.randomFloat(prop._value[2], prop._spread[2])),
			  three.Math.abs(ShaderUtils.randomFloat(prop._value[3], prop._spread[3]))
		  );
		}
	};

	ParticleEmitterControl.prototype._assignAngleValue = function(index)
	{
		var array = this.attributes.angle.typedArray;
		var prop = this.angle;
		var value;

		if(ShaderUtils.arrayValuesAreEqual(prop._value) && ShaderUtils.arrayValuesAreEqual(prop._spread))
		{
			value = ShaderUtils.randomFloat(prop._value[0], prop._spread[0]);
			array.setVec4Components(index, value, value, value, value);
		}
		else
		{
			array.setVec4Components(index,
			  ShaderUtils.randomFloat(prop._value[0], prop._spread[0]),
			  ShaderUtils.randomFloat(prop._value[1], prop._spread[1]),
			  ShaderUtils.randomFloat(prop._value[2], prop._spread[2]),
			  ShaderUtils.randomFloat(prop._value[3], prop._spread[3])
		  );
		}
	};

	ParticleEmitterControl.prototype._assignParamsValue = function(index)
	{
		this.attributes.params.typedArray.setVec4Components(index,
			this.isStatic ? 1 : 0,
			0.0,
			three.Math.abs(ShaderUtils.randomFloat(this.maxAge._value, this.maxAge._spread)),
			ShaderUtils.randomFloat(this.wiggle._value, this.wiggle._spread)
		);
	};

	ParticleEmitterControl.prototype._assignRotationValue = function(index)
	{
		this.attributes.rotation.typedArray.setVec3Components(index,
			ShaderUtils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread),
			ShaderUtils.randomFloat(this.rotation._angle, this.rotation._angleSpread),
			this.rotation._static ? 0 : 1
		);

		this.attributes.rotationCenter.typedArray.setVec3(index, this.rotation._center);
	};

	ParticleEmitterControl.prototype._assignColorValue = function(index)
	{
		ShaderUtils.randomColorAsHex(this.attributes.color, index, this.color._value, this.color._spread);
	};

	ParticleEmitterControl.prototype._resetParticle = function(index)
	{
		var resetFlags = this.resetFlags;
		var updateFlags = this.updateFlags;
		var updateCounts = this.updateCounts;
		var keys = this.attributeKeys;
		var key;
		var updateFlag;

		for(var i = this.attributeCount - 1; i >= 0; --i)
		{
			key = keys[i];
			updateFlag = updateFlags[key];

			if(resetFlags[key] === true || updateFlag === true)
			{
			  this._assignValue(key, index);
			  this._updateAttributeUpdateRange(key, index);

			  if(updateFlag === true && updateCounts[key] === this.particleCount)
			  {
				  updateFlags[key] = false;
				  updateCounts[key] = 0.0;
			  }
			  else if(updateFlag == true)
			  {
				  ++updateCounts[key];
			  }
			}
		}
	};

	ParticleEmitterControl.prototype._updateAttributeUpdateRange = function(attr, i) {
		var ranges = this.bufferUpdateRanges[attr];

		ranges.min = three.Math.min(i, ranges.min);
		ranges.max = three.Math.max(i, ranges.max);
	};

	ParticleEmitterControl.prototype._resetBufferRanges = function()
	{
		var ranges = this.bufferUpdateRanges;
		var keys = this.bufferUpdateKeys;

		for(var i = this.bufferUpdateCount - 1; i >= 0; --i)
		{
			var key = keys[i];
			ranges[key].min = Number.POSITIVE_INFINITY;
			ranges[key].max = Number.NEGATIVE_INFINITY;
		}
	};

	ParticleEmitterControl.prototype._onRemove = function()
	{
		// Reset any properties of the emitter that were set by a group when it was added.
		this.particlesPerSecond = 0;
		this.attributeOffset = 0;
		this.activationIndex = 0;
		this.activeParticleCount = 0;
		this.group = null;
		this.attributes = null;
		this.paramsArray = null;
		this.age = 0.0;
	};

	ParticleEmitterControl.prototype._decrementParticleCount = function()
	{
		--this.activeParticleCount;
	};

	ParticleEmitterControl.prototype._incrementParticleCount = function()
	{
		++this.activeParticleCount;
	};

	ParticleEmitterControl.prototype._checkParticleAges = function(start, end, params, dt)
	{
		for(var i = end - 1, index, maxAge, age, alive; i >= start; --i)
		{
			index = i * 4;
			alive = params[index];

			if(alive === 0.0)
			{
			  continue;
			}

			// Increment age
			age = params[index + 1];
			maxAge = params[index + 2];

			if(this.direction === 1)
			{
				age += dt;

				if(age >= maxAge)
				{
					age = 0.0;
					alive = 0.0;
					this._decrementParticleCount();
				}
			}
			else
			{
				age -= dt;

				if(age <= 0.0)
				{
					age = maxAge;
					alive = 0.0;
					this._decrementParticleCount();
				}
			}

			params[index] = alive;
			params[index + 1] = age;

			this._updateAttributeUpdateRange("params", i);
		}
	};

	ParticleEmitterControl.prototype._activateParticles = function(activationStart, activationEnd, params, dtPerParticle)
	{
		var direction = this.direction;

		for(var i = activationStart, index, dtValue; i < activationEnd; ++i) {
			index = i * 4;

			// Don't re-activate particles that aren't dead yet.
			if(params[index] != 0.0 && this.particleCount !== 1) {
			  continue;
			}

			// Increment the active particle count.
			this._incrementParticleCount();

			// Mark the particle as alive.
			params[index] = 1.0;

			// Reset the particle
			this._resetParticle(i);

			// Move each particle being activated to its actual position in time.
			//
			// This stops particles being "clumped" together when frame rates are on the lower side of 60fps or not constant (a very real possibility!)
			dtValue = dtPerParticle * (i - activationStart);
			params[index + 1] = direction === -1 ? params[index + 2] - dtValue : dtValue;

			this._updateAttributeUpdateRange("params", i);
		}
	};

	/**
	 * Simulates one frame worth of particles, updating particles that are already alive, and marking ones that are currently dead but should be alive as alive.
	 *
	 * If the emitter is marked as static, then this function will do nothing.
	 *
	 * @method tick
	 * @param {number} dt The number of seconds to simulate (deltaTime)
	 */
	ParticleEmitterControl.prototype.tick = function(dt)
	{
		if(this.isStatic)
		{
			return;
		}

		if(this.paramsArray === null)
		{
			this.paramsArray = this.attributes.params.typedArray.array;
		}

		var start = this.attributeOffset,
			end = start + this.particleCount,
			params = this.paramsArray, // vec3(alive, age, maxAge, wiggle)
			ppsDt = this.particlesPerSecond * this.activeMultiplier * dt,
			activationIndex = this.activationIndex;

		// Reset the buffer update indices.
		this._resetBufferRanges();

		// Increment age for those particles that are alive, and kill off any particles whose age is over the limit.
		this._checkParticleAges(start, end, params, dt);

		// If the emitter is dead, reset the age of the emitter to zero, ready to go again if required
		if(this.alive === false)
		{
			this.age = 0.0;
			return;
		}

		// If the emitter has a specified lifetime and we"ve exceeded it, mark the emitter as dead.
		if(this.duration !== null && this.age > this.duration)
		{
			this.alive = false;
			this.age = 0.0;
			return;
		}


		var activationStart = this.particleCount === 1 ? activationIndex : (activationIndex | 0),
			activationEnd = three.Math.min(activationStart + ppsDt, this.activationEnd),
			activationCount = activationEnd - this.activationIndex | 0,
			dtPerParticle = activationCount > 0 ? dt / activationCount : 0;

		this._activateParticles(activationStart, activationEnd, params, dtPerParticle);

		// Move the activation window forward, soldier.
		this.activationIndex += ppsDt;

		if(this.activationIndex > end)
		{
			this.activationIndex = start;
		}

		// Increment the age of the emitter.
		this.age += dt;
	};

	/**
	 * Resets all the emitter"s particles to their start positions and marks the particles as dead if the force argument is true.
	 *
	 * @method reset
	 * @param {boolean} [force=undefined] If true, all particles will be marked as dead instantly.
	 * @return {ParticleEmitterControl} This emitter instance.
	 */
	ParticleEmitterControl.prototype.reset = function(force)
	{
		this.age = 0.0;
		this.alive = false;

		if(force === true)
		{
			var start = this.attributeOffset,
			  end = start + this.particleCount,
			  array = this.paramsArray,
			  attr = this.attributes.params.bufferAttribute;

			for(var i = end - 1, index; i >= start; --i)
			{
			  index = i * 4;

			  array[index] = 0.0;
			  array[index + 1] = 0.0;
			}

			attr.updateRange.offset = 0;
			attr.updateRange.count = -1;
			attr.needsUpdate = true;
		}

		return this;
	};

	/**
	 * Enables the emitter. If not already enabled, the emitter will start emitting particles.
	 *
	 * @method enable
	 * @return {ParticleEmitterControl} This emitter instance.
	 */
	ParticleEmitterControl.prototype.enable = function()
	{
		this.alive = true;
		return this;
	};

	/**
	 * Disables th emitter, but does not instantly remove it's particles fromt the scene. When called, the emitter will be "switched off" and just stop emitting.
	 *
	 * Any particle"s alive will be allowed to finish their lifecycle.
	 *
	 * @method disable
	 * @return {ParticleEmitterControl} This emitter instance.
	 */
	ParticleEmitterControl.prototype.disable = function()
	{
		this.alive = false;
		return this;
	};

	/**
	 * Remove this emitter from it's parent group (if it has been added to one).
	 *
	 * Delgates to group.prototype.removeEmitter().
	 *
	 * When called, all particle"s belonging to this emitter will be instantly removed from the scene.
	 *
	 * @method remove
	 * @return {ParticleEmitterControl} This emitter instance.
	 */
	ParticleEmitterControl.prototype.remove = function()
	{
		if(this.group !== null)
		{
			this.group.removeEmitter(this);
		}
		else
		{
			console.error("nunuStudio: ParticleEmitterControl does not belong to a group, cannot remove.");
		}

		return this;
	};

	ParticleEmitterControl.prototype.toJSON = function(meta)
	{
		var data = {};

		data.uuid = this.uuid;
		data.type = this.type;
		data.direction = this.direction;
		data.particleCount = this.particleCount;
		data.duration = this.duration;
		data.isStatic = this.isStatic;

		// Max age
		data.maxAge = {};
		data.maxAge.value = this.maxAge.value;
		data.maxAge.spread = this.maxAge.spread;

		// Position
		data.position = {};
		data.position.value = this.position.value.toArray();
		data.position.spread = this.position.spread.toArray();
		data.position.radius = this.position.radius;
		data.position.radiusScale = this.position.radiusScale.toArray();

		// Velocity
		data.velocity = {};
		data.velocity.value = this.velocity.value.toArray();
		data.velocity.spread = this.velocity.spread.toArray();

		// Acceleration
		data.acceleration = {};
		data.acceleration.value = this.acceleration.value.toArray();
		data.acceleration.spread = this.acceleration.spread.toArray();

		// Wiggle
		data.wiggle = {};
		data.wiggle.value = this.wiggle.value;
		data.wiggle.spread = this.wiggle.spread;

		// Opacity
		data.opacity = {};
		data.opacity.value = this.opacity.value.slice(0);
		data.opacity.spread = this.opacity.spread;

		// Size
		data.size = {};
		data.size.value = this.size.value.slice(0);
		data.size.spread = this.size.spread;

		// Angle
		data.angle = {};
		data.angle.value = this.angle.value.slice(0);
		data.angle.spread = this.angle.spread;

		// Color
		data.color = {};
		data.color.value = [];
		for(var i = 0; i < this.color.value.length; i++)
		{
			data.color.value.push(this.color.value[i].getHex());
		}

		data.color.spread = [];
		for(var i = 0; i < this.color.spread.length; i++)
		{
			data.color.spread.push(this.color.spread[i].toArray());
		}

		return data;
	};

	/**
	 * A bunch of utility functions used throughout the library.
	 *
	 * @static
	 * @class ShaderUtils
	 * @author Luke Moody
	 */
	var ShaderUtils =
	{
		/**
		 * A map of types used by ShaderUtils.ensureTypedArg and ShaderUtils.ensureArrayTypedArg to compare types against.
		 *
		 * @static
		 * @attribute types
		 * @type {Object}
		 */
		types:
		{
			BOOLEAN: "boolean",
			STRING: "string",
			NUMBER: "number",
			OBJECT: "object"
		},

		/**
		 * Given a value, a type, and a default value to fallback to, ensure the given argument adheres to the type requesting, returning the default value if type check is false.
		 *
		 * @method ensureTypedArg
		 * @param {(boolean|string|number|object)} arg The value to perform a type-check on.
		 * @param {string} type The type the arg argument should adhere to.
		 * @param {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.
		 * @return {(boolean|string|number|object)} The given value if type check passes, or the default value if it fails.
		 */
		ensureTypedArg: function(arg, type, defaultValue)
		{
			if(typeof arg === type)
			{
				return arg;
			}
			else
			{
				return defaultValue;
			}
		},

		/**
		 * Given an array of values, a type, and a default value, ensure the given array"s contents ALL adhere to the provided type, returning the default value if type check fails.
		 *
		 * If the given value to check isn't an Array, delegates to ShaderUtils.ensureTypedArg.
		 *
		 * @static
		 * @attribute ensureArrayTypedArg
		 * @param {Array|boolean|string|number|object} arg The array of values to check type of.
		 * @param {string} type The type that should be adhered to.
		 * @param {(boolean|string|number|object)} defaultValue A default fallback value.
		 * @return {(boolean|string|number|object)} The given value if type check passes, or the default value if it fails.
		 */
		ensureArrayTypedArg: function(arg, type, defaultValue)
		{
			// If the argument being checked is an array, loop through it and ensure all the values are of the correct type, falling back to the defaultValue if any aren"t.
			if(Array.isArray(arg))
			{
				for(var i = arg.length - 1; i >= 0; --i)
				{
					if(typeof arg[i] !== type)
					{
						return defaultValue;
					}
				}

				return arg;
			}

			// If the arg isn't an array then just fallback to checking the type.
			return this.ensureTypedArg(arg, type, defaultValue);
		},

		/**
		 * Ensures the given value is an instance of a constructor function.
		 *
		 * @static
		 * @attribute ensureInstanceOf
		 * @param Object} arg The value to check instance of.
		 * @param {Function} instance The constructor of the instance to check against.
		 * @param {Object} defaultValue A default fallback value if instance check fails
		 * @return {Object} The given value if type check passes, or the default value if it fails.
		 */
		ensureInstanceOf: function(arg, instance, defaultValue)
		{
			if(instance !== undefined && arg instanceof instance) {
				return arg;
			}
			else
			{
				return defaultValue;
			}
		},

		/**
		 * Given an array of values, ensure the instances of all items in the array matches the given instance constructor falling back to a default value if the check fails.
		 *
		 * If given value isn't an Array, delegates to ShaderUtils.ensureInstanceOf.
		 *
		 * @static
		 * @attribute ensureArrayInstanceOf
		 * @param {Array|Object} arg The value to perform the instanceof check on.
		 * @param {Function} instance The constructor of the instance to check against.
		 * @param {Object} defaultValue A default fallback value if instance check fails
		 * @return {Object} The given value if type check passes, or the default value if it fails.
		 */
		ensureArrayInstanceOf: function(arg, instance, defaultValue)
		{
			// If the argument being checked is an array, loop through it and ensure all the values are of the correct type, falling back to the defaultValue if any aren"t.
			if(Array.isArray(arg))
			{
				for(var i = arg.length - 1; i >= 0; --i)
				{
					if(instance !== undefined && arg[i] instanceof instance === false)
					{
						return defaultValue;
					}
				}

				return arg;
			}

			return this.ensureInstanceOf(arg, instance, defaultValue);
		},

		/**
		 * Ensures that any "value-over-lifetime" properties of an emitter are of the correct length (as dictated by valueOverLifetimeLength).
		 *
		 * Delegates to ShaderUtils.interpolateArray for array resizing.
		 *
		 * If properties aren't arrays, then property values are put into one.
		 *
		 * @static
		 * @attribute ensureValueOverLifetimeCompliance
		 * @param {Object} property  The property of an ParticleEmitterControl instance to check compliance of.
		 * @param {number} minLength The minimum length of the array to create.
		 * @param {number} maxLength The maximum length of the array to create.
		 */
		ensureValueOverLifetimeCompliance: function(property, minLength, maxLength)
		{
			minLength = minLength || 3;
			maxLength = maxLength || 3;

			// First, ensure both properties are arrays.
			if(Array.isArray(property._value) === false)
			{
				property._value = [property._value];
			}

			if(Array.isArray(property._spread) === false)
			{
				property._spread = [property._spread];
			}

			var valueLength = this.clamp(property._value.length, minLength, maxLength),
				spreadLength = this.clamp(property._spread.length, minLength, maxLength),
				desiredLength = Math.max(valueLength, spreadLength);

			if(property._value.length !== desiredLength)
			{
				property._value = this.interpolateArray(property._value, desiredLength);
			}

			if(property._spread.length !== desiredLength)
			{
				property._spread = this.interpolateArray(property._spread, desiredLength);
			}
		},

		/**
		 * Performs linear interpolation (lerp) on an array.
		 *
		 * For example, lerping [1, 10], with a newLength of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].
		 *
		 * Delegates to ShaderUtils.lerpTypeAgnostic to perform the actual interpolation.
		 *
		 * @static
		 * @attribute interpolateArray
		 * @param {Array} srcArray  The array to lerp.
		 * @param {number} newLength The length the array should be interpolated to.
		 * @return {Array} The interpolated array.
		 */
		interpolateArray: function(srcArray, newLength)
		{
			var sourceLength = srcArray.length,
				newArray = [typeof srcArray[0].clone === "function" ? srcArray[0].clone() : srcArray[0]],
				factor = (sourceLength - 1) / (newLength - 1);


			for(var i = 1; i < newLength - 1; ++i)
			{
				var f = i * factor,
					before = Math.floor(f),
					after = Math.ceil(f),
					delta = f - before;

				newArray[i] = this.lerpTypeAgnostic(srcArray[before], srcArray[after], delta);
			}

			newArray.push(
				typeof srcArray[sourceLength - 1].clone === "function" ?
				srcArray[sourceLength - 1].clone() :
				srcArray[sourceLength - 1]
		   );

			return newArray;
		},

		/**
		 * Clamp a number to between the given min and max values.
		 *
		 * @static
		 * @attribute clamp
		 * @param {number} value The number to clamp.
		 * @param {number} min The minimum value.
		 * @param {number} max The maximum value.
		 * @return {number} The clamped number.
		 */
		clamp: function(value, min, max)
		{
			return Math.max(min, Math.min(value, max));
		},

		/**
		 * If the given value is less than the epsilon value, then return a randomised epsilon value if specified, or just the epsilon value if not.
		 *
		 * Works for negative numbers as well as positive.
		 *
		 * @static
		 * @attribute zeroToEpsilon
		 * @param {number} value     The value to perform the operation on.
		 * @param {boolean} randomise Whether the value should be randomised.
		 * @return {number}           The result of the operation.
		 */
		zeroToEpsilon: function(value, randomise)
		{
			var epsilon = 0.00001;
			var result = value;

			result = randomise ? Math.random() * epsilon * 10 : epsilon;

			if(value < 0 && value > -epsilon)
			{
				result = -result;
			}

			return result;
		},

		/**
		 * Linearly interpolates two values of various types. The given values must be of the same type for the interpolation to work.
		 *
		 * @static
		 * @attribute lerpTypeAgnostic
		 * @param {(number|Object)} start The start value of the lerp.
		 * @param {(number|object)} end The end value of the lerp.
		 * @param {number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).
		 * @return {(number|object|undefined)} The result of the operation. Result will be undefined if the start and end arguments aren't a supported type, or if their types do not match.
		 */
		lerpTypeAgnostic: function(start, end, delta)
		{
			var types = this.types,
				out;

			if(typeof start === types.NUMBER && typeof end === types.NUMBER)
			{
				return start + ((end - start) * delta);
			}
			else if(start instanceof three.Vector2 && end instanceof three.Vector2)
			{
				out = start.clone();
				out.x = this.lerp(start.x, end.x, delta);
				out.y = this.lerp(start.y, end.y, delta);
				return out;
			}
			else if(start instanceof three.Vector3 && end instanceof three.Vector3)
			{
				out = start.clone();
				out.x = this.lerp(start.x, end.x, delta);
				out.y = this.lerp(start.y, end.y, delta);
				out.z = this.lerp(start.z, end.z, delta);
				return out;
			}
			else if(start instanceof three.Vector4 && end instanceof three.Vector4)
			{
				out = start.clone();
				out.x = this.lerp(start.x, end.x, delta);
				out.y = this.lerp(start.y, end.y, delta);
				out.z = this.lerp(start.z, end.z, delta);
				out.w = this.lerp(start.w, end.w, delta);
				return out;
			}
			else if(start instanceof three.Color && end instanceof three.Color)
			{
				out = start.clone();
				out.r = this.lerp(start.r, end.r, delta);
				out.g = this.lerp(start.g, end.g, delta);
				out.b = this.lerp(start.b, end.b, delta);
				return out;
			}
			else
			{
				console.warn("nunuStudio: Invalid argument types, or argument types do not match.", start, end);
			}
		},

		/**
		 * Perform a linear interpolation operation on two numbers.
		 *
		 * @static
		 * @attribute lerp
		 * @param {number} start The start value.
		 * @param {number} end The end value.
		 * @param {number} delta The position to interpolate to.
		 * @return {number} The result of the lerp operation.
		 */
		lerp: function(start, end, delta)
		{
			return start + ((end - start) * delta);
		},

		/**
		 * Rounds a number to a nearest multiple.
		 *
		 * @static
		 * @attribute roundToNearestMultiple
		 * @param {number} n The number to round.
		 * @param {number} multiple The multiple to round to.
		 * @return {number} The result of the round operation.
		 */
		roundToNearestMultiple: function(n, multiple)
		{
			var remainder = 0;

			if(multiple === 0)
			{
				return n;
			}

			remainder = Math.abs(n) % multiple;

			if(remainder === 0)
			{
				return n;
			}

			if(n < 0)
			{
				return -(Math.abs(n) - remainder);
			}

			return n + multiple - remainder;
		},

		/**
		 * Check if all items in an array are equal. Uses strict equality.
		 *
		 * @static
		 * @attribute arrayValuesAreEqual
		 * @param {Array} array The array of values to check equality of.
		 * @return {boolean}       Whether the array"s values are all equal or not.
		 */
		arrayValuesAreEqual: function(array)
		{
			for(var i = 0; i < array.length - 1; ++i)
			{
				if(array[i] !== array[i + 1])
				{
					return false;
				}
			}

			return true;
		},

		/**
		 * Given a start value and a spread value, create and return a random number.
		 *
		 * @static
		 * @attribute randomFloat
		 * @param {number} base   The start value.
		 * @param {number} spread The size of the random variance to apply.
		 * @return {number}        A randomised number.
		 */
		randomFloat: function(base, spread)
		{
			return base + spread * (Math.random() - 0.5);
		},

		/**
		 * Given an ShaderAttribute instance, and various other settings, assign values to the attribute"s array in a vec3 format.
		 *
		 * @static
		 * @attribute randomVector3
		 * @param {Object} attribute The instance of ShaderAttribute to save the result to.
		 * @param {number} index The offset in the attribute"s TypedArray to save the result from.
		 * @param {Object} base Vector3 instance describing the start value.
		 * @param {Object} spread Vector3 instance describing the random variance to apply to the start value.
		 * @param {Object} spreadClamp Vector3 instance describing the multiples to clamp the randomness to.
		 */
		randomVector3: function(attribute, index, base, spread, spreadClamp)
		{
			var x = base.x + (Math.random() * spread.x - (spread.x * 0.5)),
				y = base.y + (Math.random() * spread.y - (spread.y * 0.5)),
				z = base.z + (Math.random() * spread.z - (spread.z * 0.5));

			if(spreadClamp)
			{
				x = -spreadClamp.x * 0.5 + this.roundToNearestMultiple(x, spreadClamp.x);
				y = -spreadClamp.y * 0.5 + this.roundToNearestMultiple(y, spreadClamp.y);
				z = -spreadClamp.z * 0.5 + this.roundToNearestMultiple(z, spreadClamp.z);
			}

			attribute.typedArray.setVec3Components(index, x, y, z);
		},

		/**
		 * Given an Shader attribute instance, and various other settings, assign Color values to the attribute.
		 *
		 * @static
		 * @attribute randomColor
		 * @param {Object} attribute The instance of ShaderAttribute to save the result to.
		 * @param {number} index The offset in the attribute"s TypedArray to save the result from.
		 * @param {Object} base Color instance describing the start color.
		 * @param {Object} spread Vector3 instance describing the random variance to apply to the start color.
		 */
		randomColor: function(attribute, index, base, spread)
		{
			var r = base.r + (Math.random() * spread.x),
				g = base.g + (Math.random() * spread.y),
				b = base.b + (Math.random() * spread.z);

			r = this.clamp(r, 0, 1);
			g = this.clamp(g, 0, 1);
			b = this.clamp(b, 0, 1);


			attribute.typedArray.setVec3Components(index, r, g, b);
		},


		/**
		 * Assigns a random color value, encoded as a hex value in decimal format, to a ShaderAttribute instance.
		 *
		 * @static
		 * @attribute randomColorAsHex
		 * @param {Object} attribute The instance of ShaderAttribute to save the result to.
		 * @param {number} index The offset in the attribute"s TypedArray to save the result from.
		 * @param {Object} base Color instance describing the start color.
		 * @param {Object} spread Vector3 instance describing the random variance to apply to the start color.
		 */
		randomColorAsHex: (function()
		{
			var workingColor = new three.Color();

			return function(attribute, index, base, spread)
			{
				var numItems = base.length,
					colors = [];

				for(var i = 0; i < numItems; ++i) {
					var spreadVector = spread[i];

					workingColor.copy(base[i]);

					workingColor.r += (Math.random() * spreadVector.x) - (spreadVector.x * 0.5);
					workingColor.g += (Math.random() * spreadVector.y) - (spreadVector.y * 0.5);
					workingColor.b += (Math.random() * spreadVector.z) - (spreadVector.z * 0.5);

					workingColor.r = this.clamp(workingColor.r, 0, 1);
					workingColor.g = this.clamp(workingColor.g, 0, 1);
					workingColor.b = this.clamp(workingColor.b, 0, 1);

					colors.push(workingColor.getHex());
				}

				attribute.typedArray.setVec4Components(index, colors[0], colors[1], colors[2], colors[3]);
			};
		}()),

		/**
		 * Assigns a random vector 3 value to an ShaderAttribute instance, projecting the given values onto a sphere.
		 *
		 * @static
		 * @attribute randomVector3OnSphere
		 * @param {Object} attribute The instance of ShaderAttribute to save the result to.
		 * @param {number} index     The offset in the attribute"s TypedArray to save the result from.
		 * @param {Object} base              Vector3 instance describing the origin of the transform.
		 * @param {number} radius            The radius of the sphere to project onto.
		 * @param {number} radiusSpread      The amount of randomness to apply to the projection result
		 * @param {Object} radiusScale       Vector3 instance describing the scale of each axis of the sphere.
		 * @param {number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.
		 */
		randomVector3OnSphere: function(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp)
		{
			var depth = 2 * Math.random() - 1,
				t = 6.2832 * Math.random(),
				r = Math.sqrt(1 - depth * depth),
				rand = this.randomFloat(radius, radiusSpread),
				x = 0,
				y = 0,
				z = 0;


			if(radiusSpreadClamp)
			{
				rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;
			}

			// Set position on sphere
			x = r * Math.cos(t) * rand;
			y = r * Math.sin(t) * rand;
			z = depth * rand;

			// Apply radius scale to this position
			x *= radiusScale.x;
			y *= radiusScale.y;
			z *= radiusScale.z;

			// Translate to the base position.
			x += base.x;
			y += base.y;
			z += base.z;

			// Set the values in the typed array.
			attribute.typedArray.setVec3Components(index, x, y, z);
		},

		seededRandom: function(seed)
		{
			var x = Math.sin(seed) * 10000;
			return x - (x | 0);
		},

		/**
		 * Assigns a random vector 3 value to an ShaderAttribute instance, projecting the given values onto a 2d-disc.
		 *
		 * @static
		 * @attribute randomVector3OnDisc
		 * @param {Object} attribute The instance of ShaderAttribute to save the result to.
		 * @param {number} index The offset in the attribute"s TypedArray to save the result from.
		 * @param {Object} base Vector3 instance describing the origin of the transform.
		 * @param {number} radius The radius of the sphere to project onto.
		 * @param {number} radiusSpread The amount of randomness to apply to the projection result
		 * @param {Object} radiusScale Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.
		 * @param {number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.
		 */
		randomVector3OnDisc: function(attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp)
		{
			var t = 6.2832 * Math.random(),
				rand = Math.abs(this.randomFloat(radius, radiusSpread)),
				x = 0,
				y = 0,
				z = 0;

			if(radiusSpreadClamp)
			{
				rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;
			}

			// Set position on sphere
			x = Math.cos(t) * rand;
			y = Math.sin(t) * rand;

			// Apply radius scale to this position
			x *= radiusScale.x;
			y *= radiusScale.y;

			// Translate to the base position.
			x += base.x;
			y += base.y;
			z += base.z;

			// Set the values in the typed array.
			attribute.typedArray.setVec3Components(index, x, y, z);
		},

		/**
		 * Given an ShaderAttribute instance, create a direction vector from the given
		 * position, using speed as the magnitude. Values are saved to the attribute.
		 *
		 * @static
		 * @attribute randomDirectionVector3OnSphere
		 * @param {Object} attribute       The instance of ShaderAttribute to save the result to.
		 * @param {number} index           The offset in the attribute"s TypedArray to save the result from.
		 * @param {number} posX            The particle"s x coordinate.
		 * @param {number} posY            The particle"s y coordinate.
		 * @param {number} posZ            The particle"s z coordinate.
		 * @param {Object} emitterPosition Vector3 instance describing the emitter"s base position.
		 * @param {number} speed           The magnitude to apply to the vector.
		 * @param {number} speedSpread     The amount of randomness to apply to the magnitude.
		 */
		randomDirectionVector3OnSphere: (function()
		{
			var v = new three.Vector3();

			return function(attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread)
			{
				v.copy(emitterPosition);

				v.x -= posX;
				v.y -= posY;
				v.z -= posZ;

				v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));

				attribute.typedArray.setVec3Components(index, v.x, v.y, v.z);
			};
		}()),


		/**
		 * Given an ShaderAttribute instance, create a direction vector from the given position, using speed as the magnitude. Values are saved to the attribute.
		 *
		 * @static
		 * @attribute randomDirectionVector3OnDisc
		 * @param {Object} attribute The instance of ShaderAttribute to save the result to.
		 * @param {number} index The offset in the attribute"s TypedArray to save the result from.
		 * @param {number} posX The particle"s x coordinate.
		 * @param {number} posY The particle"s y coordinate.
		 * @param {number} posZ The particle"s z coordinate.
		 * @param {Object} emitterPosition Vector3 instance describing the emitter"s base position.
		 * @param {number} speed The magnitude to apply to the vector.
		 * @param {number} speedSpread The amount of randomness to apply to the magnitude.
		 */
		randomDirectionVector3OnDisc: (function()
		{
			var v = new three.Vector3();

			return function(attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread)
			{
				v.copy(emitterPosition);

				v.x -= posX;
				v.y -= posY;
				v.z -= posZ;

				v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));

				attribute.typedArray.setVec3Components(index, v.x, v.y, 0);
			};
		}()),

		/**
		 * Given a rotation axis, and a rotation axis spread vector, calculate a randomised rotation axis, and pack it into a hexadecimal value represented in decimal form.
		 *
		 * @static
		 * @attribute getPackedRotationAxis
		 * @param {Object} axis Vector3 instance describing the rotation axis.
		 * @param {Object} axisSpread Vector3 instance describing the amount of randomness to apply to the rotation axis.
		 * @return {number} The packed rotation axis, with randomness.
		 */
		getPackedRotationAxis: (function()
		{
			var v = new three.Vector3(),
				vSpread = new three.Vector3(),
				c = new three.Color(),
				addOne = new three.Vector3(1, 1, 1);

			return function(axis, axisSpread)
			{
				v.copy(axis).normalize();
				vSpread.copy(axisSpread).normalize();

				v.x += (-axisSpread.x * 0.5) + (Math.random() * axisSpread.x);
				v.y += (-axisSpread.y * 0.5) + (Math.random() * axisSpread.y);
				v.z += (-axisSpread.z * 0.5) + (Math.random() * axisSpread.z);

				v.normalize().add(addOne).multiplyScalar(0.5);

				c.setRGB(v.x, v.y, v.z);

				return c.getHex();
			};
		}())
	};

	/**
	 * A map of options to configure an ParticleGroup instance.
	 *
	 * @class {Object} ParticleGroupOptions
	 * @property {Object} texture An object describing the texture used by the group.
	 * @property {Object} texture.value An instance of Texture.
	 * @property {Object=} texture.frames A Vector2 instance describing the number of frames on the x- and y-axis of the given texture. If not provided, the texture will NOT be treated as a sprite-sheet and as such will NOT be animated.
	 * @property {number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.                                Allows for sprite-sheets that don't fill the entire                                texture.
	 * @property {number} texture.loop The number of loops through the sprite-sheet that should   be performed over the course of a single particle"s lifetime.
	 * @property {number} fixedTimeStep If no dt (or deltaTime) value is passed to this group"s    tick() function, this number will be used to move the particle    simulation forward. Value in SECONDS.
	 * @property {boolean} hasPerspective Whether the distance a particle is from the camera should affect the particle"s size.
	 * @property {boolean} colorize Whether the particles in this group should be rendered with color, or whether the only color of particles will come from the provided texture.
	 * @property {number} blending One of Three.js"s blending modes to apply to this group"s ShaderMaterial.
	 * @property {boolean} transparent Whether these particle"s should be rendered with transparency.
	 * @property {number} alphaTest Sets the alpha value to be used when running an alpha test on the texture.value property. Value between 0 and 1.
	 * @property {boolean} depthWrite Whether rendering the group has any effect on the depth buffer.
	 * @property {boolean} depthTest Whether to have depth test enabled when rendering this group.
	 * @property {boolean} fog Whether this group"s particles should be affected by their scene"s fog.
	 * @property {number} scale The scale factor to apply to this group"s particle sizes. Useful for setting particle sizes to be relative to renderer size.
	 */


	/**
	 * The ParticleGroup class. Creates a new group, containing a material, geometry, and mesh.
	 *
	 * @constructor
	 * @author Luke Moody
	 * @class ParticleGroup
	 * @param {ParticleGroupOptions} options A map of options to configure the group instance.
	 */
	function ParticleGroup(options)
	{
		// Ensure we have a map of options to play with
		options = ShaderUtils.ensureTypedArg(options, ShaderUtils.types.OBJECT, {});
		options.texture = ShaderUtils.ensureTypedArg(options.texture, ShaderUtils.types.OBJECT, {});

		// Assign a UUID to this instance
		this.uuid = three.Math.generateUUID();

		// If no deltaTime value is passed to the ParticleGroup.tick function, the value of this property will be used to advance the simulation.
		this.fixedTimeStep = ShaderUtils.ensureTypedArg(options.fixedTimeStep, ShaderUtils.types.NUMBER, 0.016);

		// Set properties used in the uniforms map, starting with the texture stuff.
		this.texture = ShaderUtils.ensureInstanceOf(options.texture.value, three.Texture, null);
		this.textureFrames = ShaderUtils.ensureInstanceOf(options.texture.frames, three.Vector2, new three.Vector2(1, 1));
		this.textureFrameCount = ShaderUtils.ensureTypedArg(options.texture.frameCount, ShaderUtils.types.NUMBER, this.textureFrames.x * this.textureFrames.y);
		this.textureLoop = ShaderUtils.ensureTypedArg(options.texture.loop, ShaderUtils.types.NUMBER, 1);
		this.textureFrames.max(new three.Vector2(1, 1));

		this.hasPerspective = ShaderUtils.ensureTypedArg(options.hasPerspective, ShaderUtils.types.BOOLEAN, true);
		this.colorize = ShaderUtils.ensureTypedArg(options.colorize, ShaderUtils.types.BOOLEAN, true);
		this.maxParticleCount = ShaderUtils.ensureTypedArg(options.maxParticleCount, ShaderUtils.types.NUMBER, null);

		// Set properties used to define the ShaderMaterial"s appearance.
		this.blending = ShaderUtils.ensureTypedArg(options.blending, ShaderUtils.types.NUMBER, three.AdditiveBlending);
		this.transparent = ShaderUtils.ensureTypedArg(options.transparent, ShaderUtils.types.BOOLEAN, true);
		this.alphaTest = parseFloat(ShaderUtils.ensureTypedArg(options.alphaTest, ShaderUtils.types.NUMBER, 0.0));
		this.depthWrite = ShaderUtils.ensureTypedArg(options.depthWrite, ShaderUtils.types.BOOLEAN, false);
		this.depthTest = ShaderUtils.ensureTypedArg(options.depthTest, ShaderUtils.types.BOOLEAN, true);
		this.fog = ShaderUtils.ensureTypedArg(options.fog, ShaderUtils.types.BOOLEAN, true);
		this.scale = ShaderUtils.ensureTypedArg(options.scale, ShaderUtils.types.NUMBER, 300);

		this.emitters = [];
		this.emitterIDs = [];

		// Create properties for use by the emitter pooling functions.
		this.pool = [];
		this.poolCreationSettings = null;
		this._createNewWhenPoolEmpty = 0;

		// Whether all attributes should be forced to updated their entire buffer contents on the next tick.
		//
		// Used when an emitter is removed.
		this._attributesNeedRefresh = false;
		this._attributesNeedDynamicReset = false;

		this.particleCount = 0;

		/**
		 * Map of uniforms to be applied to the ShaderMaterial instance.
		 *
		 * @attribute uniforms
		 * @type {Object}
		 */
		this.uniforms =
		{
			textureSampler: {
				type: "t",
				value: this.texture
			},
			textureAnimation: {
				type: "v4",
				value: new three.Vector4(
					this.textureFrames.x,
					this.textureFrames.y,
					this.textureFrameCount,
					three.Math.max(three.Math.abs(this.textureLoop), 1.0)
			   )
			},
			fogColor: {
				type: "c",
				value: null
			},
			fogNear: {
				type: "f",
				value: 10
			},
			fogFar: {
				type: "f",
				value: 200
			},
			fogDensity: {
				type: "f",
				value: 0.5
			},
			deltaTime: {
				type: "f",
				value: 0
			},
			runTime: {
				type: "f",
				value: 0
			},
			scale: {
				type: "f",
				value: this.scale
			}
		};

		this.defines =
		{
			HAS_PERSPECTIVE: this.hasPerspective,
			COLORIZE: this.colorize,
			VALUE_OVER_LIFETIME_LENGTH: ParticleEmitter.valueOverLifetimeLength,
			SHOULD_ROTATE_TEXTURE: false,
			SHOULD_ROTATE_PARTICLES: false,
			SHOULD_WIGGLE_PARTICLES: false,
			SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1
		};

		/**
		 * Map of all attributes to be applied to the particles.
		 *
		 * See ShaderAttribute for a bit more info on this bit.
		 *
		 * @attribute attributes
		 * @type {Object}
		 */
		this.attributes =
		{
			position: new ShaderAttribute("v3", true),
			acceleration: new ShaderAttribute("v4", true), // w component is drag
			velocity: new ShaderAttribute("v3", true),
			rotation: new ShaderAttribute("v4", true),
			rotationCenter: new ShaderAttribute("v3", true),
			params: new ShaderAttribute("v4", true), // Holds (alive, age, delay, wiggle)
			size: new ShaderAttribute("v4", true),
			angle: new ShaderAttribute("v4", true),
			color: new ShaderAttribute("v4", true),
			opacity: new ShaderAttribute("v4", true)
		};

		this.attributeKeys = Object.keys(this.attributes);
		this.attributeCount = this.attributeKeys.length;

		this.material = new three.ShaderMaterial(
		{
			uniforms: this.uniforms,
			vertexShader: ParticleShaders.vertex,
			fragmentShader: ParticleShaders.fragment,
			blending: this.blending,
			transparent: this.transparent,
			alphaTest: this.alphaTest,
			depthWrite: this.depthWrite,
			depthTest: this.depthTest,
			defines: this.defines,
			fog: this.fog
		});

		this.geometry = new three.BufferGeometry();
		this.mesh = new three.Points(this.geometry, this.material);

		if(this.maxParticleCount === null)
		{
			console.warn("nunuStudio: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
		}
	}

	ParticleGroup.constructor = ParticleGroup;

	ParticleGroup.prototype._updateDefines = function()
	{
		var emitters = this.emitters;
		var emitter;
		var defines = this.defines;

		for(var i = emitters.length - 1; i >= 0; --i) {
			emitter = emitters[i];

			// Only do angle calculation if there"s no spritesheet defined.
			//
			// Saves calculations being done and then overwritten in the shaders.
			if(!defines.SHOULD_CALCULATE_SPRITE) {
				defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!three.Math.max(
					three.Math.max.apply(null, emitter.angle.value),
					three.Math.max.apply(null, emitter.angle.spread)
			   );
			}

			defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!three.Math.max(
				emitter.rotation.angle,
				emitter.rotation.angleSpread
		   );

			defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!three.Math.max(
				emitter.wiggle.value,
				emitter.wiggle.spread
		   );
		}

		this.material.needsUpdate = true;
	};

	ParticleGroup.prototype._applyAttributesToGeometry = function()
	{
		var attributes = this.attributes;
		var geometry = this.geometry;
		var geometryAttributes = geometry.attributes;
		var attribute;
		var geometryAttribute;

		// Loop through all the shader attributes and assign (or re-assign) typed array buffers to each one.
		for(var attr in attributes)
		{
			if(attributes.hasOwnProperty(attr))
			{
				attribute = attributes[attr];
				geometryAttribute = geometryAttributes[attr];

				// Update the array if this attribute exists on the geometry.
				//
				// This needs to be done because the attribute"s typed array might have been resized and reinstantiated, and might now be looking at a different ArrayBuffer, so reference needs updating.
				if(geometryAttribute)
				{
					geometryAttribute.array = attribute.typedArray.array;
				}

				// Add the attribute to the geometry if it doesn't already exist.
				else
				{
					geometry.setAttribute(attr, attribute.bufferAttribute);
				}

				// Mark the attribute as needing an update the next time a frame is rendered.
				attribute.bufferAttribute.needsUpdate = true;
			}
		}

		// Mark the draw range on the geometry. This will ensure only the values in the attribute buffers that are associated with a particle will be used in render cycle.
		this.geometry.setDrawRange(0, this.particleCount);
	};

	/**
	 * Adds an ParticleEmitterControl instance to this group, creating particle values and assigning them to this group"s shader attributes.
	 *
	 * @method addEmitter
	 * @param {ParticleEmitterControl} emitter The emitter to add to this group.
	 */
	ParticleGroup.prototype.addEmitter = function(emitter)
	{
		// Ensure an actual emitter instance is passed here.
		if(emitter instanceof ParticleEmitterControl === false)
		{
			console.error("nunuStudio: emitter argument must be instance of ParticleEmitterControl.", emitter);
			return;
		}
		// If the emitter already exists as a member of this group, then stop here, we don't want to add it again.
		else if(this.emitterIDs.indexOf(emitter.uuid) > -1)
		{
			console.error("nunuStudio: ParticleEmitterControl already exists in this group.");
			return;
		}
		// And finally, if the emitter is a member of another group, don't add it to this group.
		else if(emitter.group !== null)
		{
			console.error("nunuStudio: ParticleEmitterControl already belongs to another group.");
			return;
		}

		var attributes = this.attributes;
		var start = this.particleCount;
		var end = start + emitter.particleCount;

		// Update this group"s particle count.
		this.particleCount = end;

		// Emit a warning if the emitter being added will exceed the buffer sizes specified.
		if(this.maxParticleCount !== null && this.particleCount > this.maxParticleCount)
		{
			console.warn("nunuStudio: ParticleGroup maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount);
		}

		// Set the particlesPerSecond value (PPS) on the emitter. It's used to determine how many particles to release on a per-frame basis.
		emitter._calculatePPSValue(emitter.maxAge._value + emitter.maxAge._spread);
		emitter._setBufferUpdateRanges(this.attributeKeys);

		// Store the offset value in the TypedArray attributes for this emitter.
		emitter._setAttributeOffset(start);

		// Save a reference to this group on the emitter so it knows where it belongs.
		emitter.group = this;

		// Store reference to the attributes on the emitter for easier access during the emitter"s tick function.
		emitter.attributes = this.attributes;

		// Ensure the attributes and their BufferAttributes exist, and their TypedArrays are of the correct size.
		for(var attr in attributes)
		{
			if(attributes.hasOwnProperty(attr))
			{
				// When creating a buffer, pass through the maxParticle count if one is specified.
				attributes[attr]._createBufferAttribute(
					this.maxParticleCount !== null ?
					this.maxParticleCount :
					this.particleCount
			   );
			}
		}

		// Loop through each particle this emitter wants to have, and create the attributes values, storing them in the TypedArrays that each attribute holds.
		for(var i = start; i < end; ++i)
		{
			emitter._assignPositionValue(i);
			emitter._assignForceValue(i, "velocity");
			emitter._assignForceValue(i, "acceleration");
			emitter._assignAbsLifetimeValue(i, "opacity");
			emitter._assignAbsLifetimeValue(i, "size");
			emitter._assignAngleValue(i);
			emitter._assignRotationValue(i);
			emitter._assignParamsValue(i);
			emitter._assignColorValue(i);
		}

		// Update the geometry and make sure the attributes are referencing the typed arrays properly.
		this._applyAttributesToGeometry();

		// Store this emitter in this group"s emitter"s store.
		this.emitters.push(emitter);
		this.emitterIDs.push(emitter.uuid);

		// Update certain flags to enable shader calculations only if they"re necessary.
		this._updateDefines(emitter);

		// Update the material since defines might have changed
		this.material.needsUpdate = true;
		this.geometry.needsUpdate = true;
		this._attributesNeedRefresh = true;

		// Return the group to enable chaining.
		return this;
	};

	/**
	 * Removes an ParticleEmitterControl instance from this group.
	 *
	 * When called, all particle"s belonging to the given emitter will be instantly removed from the scene.
	 *
	 * @method removeEmitter
	 * @param {ParticleEmitterControl} emitter The emitter to add to this group.
	 */
	ParticleGroup.prototype.removeEmitter = function(emitter)
	{
		var emitterIndex = this.emitterIDs.indexOf(emitter.uuid);

		// Ensure an actual emitter instance is passed here.
		if(emitter instanceof ParticleEmitterControl === false)
		{
			console.error("nunuStudio: emitter argument must be instance of ParticleEmitterControl. Was provided with:", emitter);
			return;
		}

		// Issue an error if the emitter isn't a member of this group.
		else if(emitterIndex === -1)
		{
			console.error("nunuStudio: ParticleEmitterControl does not exist in this group. Will not remove.");
			return;
		}

		// Kill all particles by marking them as dead and their age as 0.
		var start = emitter.attributeOffset;
		var end = start + emitter.particleCount;
		var params = this.attributes.params.typedArray;

		// Set alive and age to zero.
		for(var i = start; i < end; ++i)
		{
			params.array[i * 4] = 0.0;
			params.array[i * 4 + 1] = 0.0;
		}

		// Remove the emitter from this group"s "store".
		this.emitters.splice(emitterIndex, 1);
		this.emitterIDs.splice(emitterIndex, 1);

		// Remove this emitter"s attribute values from all shader attributes.
		// The .splice() call here also marks each attribute"s buffer as needing to update it's entire contents.
		for(var attr in this.attributes)
		{
			if(this.attributes.hasOwnProperty(attr))
			{
				this.attributes[attr].splice(start, end);
			}
		}

		// Ensure this group"s particle count is correct.
		this.particleCount -= emitter.particleCount;

		// Call the emitter"s remove method.
		emitter._onRemove();

		// Set a flag to indicate that the attribute buffers should be updated in their entirety on the next frame.
		this._attributesNeedRefresh = true;
	};

	/**
	 * Fetch a single emitter instance from the pool.
	 *
	 * If there are no objects in the pool, a new emitter will becreated if specified.
	 *
	 * @method getFromPool
	 * @return {ParticleEmitterControl|null}
	 */
	ParticleGroup.prototype.getFromPool = function()
	{
		var pool = this.pool;
		var createNew = this._createNewWhenPoolEmpty;

		if(pool.length)
		{
			return pool.pop();
		}
		else if(createNew)
		{
			var emitter = new ParticleEmitterControl(this.poolCreationSettings);
			
			this.addEmitter(emitter);
			
			return emitter;
		}

		return null;
	};

	/**
	 * Release an emitter into the pool.
	 *
	 * @method releaseIntoPool
	 * @param {ShaderParticleParticleEmitterControl} emitter
	 * @return {ParticleGroup} This group instance.
	 */
	ParticleGroup.prototype.releaseIntoPool = function(emitter)
	{
		if(emitter instanceof ParticleEmitterControl === false)
		{
			console.error("nunuStudio: Argument is not instanceof ParticleEmitterControl:", emitter);
			return;
		}

		emitter.reset();
		this.pool.unshift(emitter);

		return this;
	};

	/**
	 * Get the pool array
	 *
	 * @method getPool
	 * @return {Array}
	 */
	ParticleGroup.prototype.getPool = function()
	{
		return this.pool;
	};

	/**
	 * Add a pool of emitters to this particle group
	 *
	 * @method addPool
	 * @param {number} numEmitters The number of emitters to add to the pool.
	 * @param {ParticleEmitterControlOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.
	 * @param {boolean} createNew Should a new emitter be created if the pool runs out?
	 * @return {ParticleGroup} This group instance.
	 */
	ParticleGroup.prototype.addPool = function(numEmitters, emitterOptions, createNew)
	{
		var emitter;

		// Save relevant settings and flags.
		this.poolCreationSettings = emitterOptions;
		this._createNewWhenPoolEmpty = !!createNew;

		// Create the emitters, add them to this group and the pool.
		for(var i = 0; i < numEmitters; ++i)
		{
			if(Array.isArray(emitterOptions))
			{
				emitter = new ParticleEmitterControl(emitterOptions[i]);
			}
			else
			{
				emitter = new ParticleEmitterControl(emitterOptions);
			}
			this.addEmitter(emitter);
			this.releaseIntoPool(emitter);
		}

		return this;
	};

	ParticleGroup.prototype._triggerSingleEmitter = function(pos)
	{
		var emitter = this.getFromPool();
		var self = this;

		if(emitter === null)
		{
			console.log("nunuStudio: ParticleGroup pool ran out.");
			return;
		}

		if(pos instanceof three.Vector3)
		{
			emitter.position.value.copy(pos);
			emitter.position.value = emitter.position.value;
		}

		emitter.enable();

		setTimeout(function()
		{
			emitter.disable();
			self.releaseIntoPool(emitter);
		}, (three.Math.max(emitter.duration, (emitter.maxAge.value + emitter.maxAge.spread))) * 1000);

		return this;
	};

	/**
	 * Set a given number of emitters as alive, with an optional position vector3 to move them to.
	 *
	 * @method triggerEmitter
	 * @param {number} numEmitters The number of emitters to activate
	 * @param {Object} [position=undefined] A Vector3 instance describing the position to activate the emitter(s) at.
	 * @return {ParticleGroup} This group instance.
	 */
	ParticleGroup.prototype.triggerEmitter = function(numEmitters, position)
	{
		if(typeof numEmitters === "number" && numEmitters > 1)
		{
			for(var i = 0; i < numEmitters; ++i)
			{
				this._triggerSingleEmitter(position);
			}
		}
		else
		{
			this._triggerSingleEmitter(position);
		}

		return this;
	};

	ParticleGroup.prototype._updateUniforms = function(dt)
	{
		this.uniforms.runTime.value += dt;
		this.uniforms.deltaTime.value = dt;
	};

	ParticleGroup.prototype._resetBufferRanges = function()
	{
		var keys = this.attributeKeys;

		for(var i = this.attributeCount - 1; i >= 0; --i)
		{
			this.attributes[keys[i]].resetUpdateRange();
		}
	};


	ParticleGroup.prototype._updateBuffers = function(emitter)
	{
		var keys = this.attributeKeys;
		var attrs = this.attributes;
		var emitterRanges = emitter.bufferUpdateRanges;
		var key;
		var emitterAttr;
		var attr;

		for(var i = this.attributeCount - 1; i >= 0; --i)
		{
			key = keys[i];
			emitterAttr = emitterRanges[key];
			attr = attrs[key];
			attr.setUpdateRange(emitterAttr.min, emitterAttr.max);
			attr.flagUpdate();
		}
	};


	/**
	 * Simulate all the emitter"s belonging to this group, updating attribute values along the way.
	 *
	 * @method tick
	 * @param {number} [dt=ParticleGroup"s fixedTimeStep value] The number of seconds to simulate the group"s emitters for(deltaTime)
	 */
	ParticleGroup.prototype.tick = function(dt)
	{
		var emitters = this.emitters;
		var numEmitters = emitters.length;
		var deltaTime = dt || this.fixedTimeStep;
		var keys = this.attributeKeys;
		var i;
		var attrs = this.attributes;

		// Update uniform values.
		this._updateUniforms(deltaTime);

		// Reset buffer update ranges on the shader attributes.
		this._resetBufferRanges();

		// If nothing needs updating, then stop here.
		if(numEmitters === 0 && this._attributesNeedRefresh === false && this._attributesNeedDynamicReset === false)
		{
			return;
		}

		// Loop through each emitter in this group and simulate it, then update the shader attribute buffers.
		for(var i = 0, emitter; i < numEmitters; ++i)
		{
			emitter = emitters[i];
			emitter.tick(deltaTime);
			this._updateBuffers(emitter);
		}

		// If the shader attributes have been refreshed, then the dynamic properties of each buffer attribute will need to be reset.
		if(this._attributesNeedDynamicReset === true)
		{
			i = this.attributeCount - 1;

			for(i; i >= 0; --i)
			{
				attrs[keys[i]].resetDynamic();
			}

			this._attributesNeedDynamicReset = false;
		}

		if(this._attributesNeedRefresh === true)
		{
			i = this.attributeCount - 1;

			for(i; i >= 0; --i)
			{
				attrs[keys[i]].forceUpdateAll();
			}

			this._attributesNeedRefresh = false;
			this._attributesNeedDynamicReset = true;
		}
	};


	/**
	 * Dipose the geometry and material for the group.
	 *
	 * @method dispose
	 * @return {ParticleGroup} ParticleGroup instance.
	 */
	ParticleGroup.prototype.dispose = function()
	{
		this.geometry.dispose();
		this.material.dispose();
		return this;
	};

	ParticleGroup.prototype.toJSON = function(meta)
	{
		var data = {};

		data.texture = {};
		data.texture.value = this.texture.uuid;
		data.texture.frames = this.textureFrames.toArray();
		data.texture.frameCount = this.textureFrameCount;
		data.texture.loop = this.textureLoop;
		data.fixedTimeStep = this.fixedTimeStep;
		data.hasPerspective = this.hasPerspective;
		data.colorize = this.colorize;
		data.maxParticleCount = this.maxParticleCount;
		data.transparent = this.transparent;
		data.blending = this.blending;
		data.alphaTest = this.alphaTest;
		data.depthWrite = this.depthWrite;
		data.depthTest = this.depthTest;
		data.fog = this.fog;
		data.scale = this.scale;

		return data;
	};

	/**
	 * The viewport object is used to handle virtual visualization windows for the WebGL renderer.
	 * 
	 * It uses normalized coordinates [0 to 1] when using RELATIVE mode or pixel based coordinated for ABSOLUTE mode.
	 * 
	 * @class Viewport
	 * @param {number} mode
	 */
	function Viewport(mode)
	{
		/**
		 * Camera viewport offset.
		 * 
		 * Values range from 0.0 to 1.0 in screen space when in RELATIVE mode.
		 * 
		 * @property offset
		 * @type {Vector2}
		*/
		this.offset = new three.Vector2(0.0, 0.0);

		/**
		 * Camera viewport size.
		 * 
		 * Values range from 0.0 to 1.0 in screen space when in RELATIVE mode.
		 * 
		 * @property size
		 * @type {Vector2}
		 */
		this.size = new three.Vector2(1.0, 1.0);

		/** 
		 * Viewport sizing mode.
		 * 
		 * Can be RELATIVE or ABSOLUTE.
		 *
		 * @property mode
		 * @type {number}
		 */
		this.mode = mode !== undefined ? mode : Viewport.RELATIVE;

		/** 
		 * Positioning anchor of the viewport.
		 *
		 * @property anchor
		 * @type {number}
		 */
		this.anchor = Viewport.TOP_LEFT;

		/**
		 * Width of the final output canvas.
		 *
		 * This width should match the canvas size / rendering resolution.
		 *
		 * @property width
		 * @type {number}
		 */
		this.width = 1;

		/**
		 * Height of the final output canvas.
		 *
		 * This height should match the canvas size / rendering resolution.
		 *
		 * @property height
		 * @type {number}
		 */
		this.height = 1;

		/**
		 * Calculated absolute viewport values (x, y, width, height) stored in a vector.
		 *
		 * It is calculated using the update() method that should be called after applying changes.
		 *
		 * @property viewport
		 * @type {Vector4}
		 */
		this.viewport = new three.Vector4(0, 0, 1, 1);
	}

	/** 
	 * Viewport calculated relatively to the screen viewport.
	 * 
	 * @static
	 * @attribute RELATIVE
	 */
	Viewport.RELATIVE = 200;

	/** 
	 * Viewport defined absolutely in pixels.
	 * 
	 * @static
	 * @attribute ABSOLUTE
	 */
	Viewport.ABSOLUTE = 201;

	Viewport.TOP_LEFT = 301;
	Viewport.TOP_RIGHT = 302;
	Viewport.BOTTOM_LEFT = 303;
	Viewport.BOTTOM_RIGHT = 304;

	/** 
	 * Update the viewport box from the values.
	 *
	 * Has to be called after applying changes to the viewport, the viewport is resized of the 
	 *
	 * @method update
	 * @param {Viewport} container Viewport that contains this viewport (optional).
	 */
	Viewport.prototype.update = function(container)
	{
		var width, height;
		var x, y;

		if(container === undefined)
		{
			x = 0;
			y = 0;
			width = this.width;
			height = this.height;
		}
		else
		{
			x = container.viewport.x;
			y = container.viewport.y;
			width = container.viewport.z;
			height = container.viewport.w;
		}

		var offset, viewport;

		if(this.mode === Viewport.RELATIVE)
		{
			offset = new three.Vector2(this.offset.x * width, this.offset.y * height);
			viewport = new three.Vector2(this.size.x * width, this.size.y * height);
		}
		else if(this.mode === Viewport.ABSOLUTE)
		{
			offset = this.offset;
			viewport = this.size;
		}

		if(this.anchor === Viewport.BOTTOM_LEFT)
		{
			this.viewport.set(offset.x + x, offset.y + y, viewport.x, viewport.y);
		}
		else if(this.anchor === Viewport.BOTTOM_RIGHT)
		{
			this.viewport.set(width - viewport.x - offset.x + x, offset.y + y, viewport.x, viewport.y);
		}
		else if(this.anchor === Viewport.TOP_LEFT)
		{
			this.viewport.set(offset.x + x, height - viewport.y - offset.y + y, viewport.x, viewport.y);
		}
		else if(this.anchor === Viewport.TOP_RIGHT)
		{
			this.viewport.set(width - viewport.x - offset.x + x, height - viewport.y - offset.y + y, viewport.x, viewport.y);
		}
	};

	/**
	 * Get the aspect ratio of this viewport in x / y.
	 * 
	 * @method getAspectRatio
	 * @return {number} The aspect ratio of the viewport.
	 */
	Viewport.prototype.getAspectRatio = function()
	{
		return this.viewport.z / this.viewport.w;
	};

	/**
	 * Check if the mouse is inside this viewport.
	 * 
	 * @method isInside
	 * @param {Component} canvas Canvas for offset calculation.
	 * @param {Mouse} mouse Mouse object with coordinates inside of the canvas.
	 */
	Viewport.prototype.isInside = function(canvas, mouse)
	{
		return mouse.position.x > this.viewport.x &&
		mouse.position.x < this.viewport.x + this.viewport.z &&
		mouse.position.y < this.height - this.viewport.y &&
		mouse.position.y > this.height - this.viewport.y - this.viewport.w;
	};

	/** 
	 * Get normalized coordinates between [-1, 1] for a canvas size and mouse position.
	 *
	 * Usefull to use raycasting for object picking in a viewport.
	 *
	 * @method getNormalized
	 * @param {Component} canvas Canvas for offset calculation.
	 * @param {Mouse} mouse Mouse object with coordinates inside of the canvas.
	 * @return {Vector2} Normalized coordinated of the mouse.
	 */
	Viewport.prototype.getNormalized = function()
	{
		var normalized = new three.Vector2();

		return function(canvas, mouse)
		{
			var x = mouse.position.x - this.viewport.z - this.viewport.x;
			var y = mouse.position.y - (this.height - (this.viewport.y + this.viewport.w));

			normalized.set((x / this.viewport.z) * 2 + 1, (-y / this.viewport.w) * 2 + 1);

			return normalized;
		};
	}();

	/**
	 * Enable this viewport for rendering using a WebGLRenderer
	 *
	 * After rendering the WebGL renderer has to manually reset to the original values.
	 *
	 * @method enable
	 * @param {WebGLRenderer} renderer
	 */
	Viewport.prototype.enable = function(renderer)
	{
		renderer.setViewport(this.viewport);
		renderer.setScissor(this.viewport);
	};

	/**
	 * Serializer viewport data to JSON.
	 *
	 * @method toJSON
	 * @return {Object} Serialized viewport object.
	 */
	Viewport.prototype.toJSON = function()
	{
		return {
			offset: this.offset.toArray(),
			size: this.size.toArray(),
			mode: this.mode,
			anchor: this.anchor
		};
	};

	/**
	 * Fill viewport data from serialized JSON data.
	 *
	 * @method toJSON
	 * @param {Object} data Serialized viewport object.
	 */
	Viewport.prototype.fromJSON = function(data)
	{
		this.offset.fromArray(data.offset);
		this.size.fromArray(data.size);
		this.mode = data.mode;
		this.anchor = data.anchor;
	};

	/**
	 * Text file resource can be used to store data or code.
	 *
	 * Text file data can be used to store information to be consumend by the application or runtime code that can be imported by scripts.
	 *
	 * @class TextFile
	 * @extends {Resource}
	 * @module Resources
	 */
	function TextFile(data, encoding)
	{
		Resource.call(this, "text", "TextFile");

		this.format = "string";
		this.encoding = (encoding !== undefined) ? encoding : "txt";
		this.data = (data !== undefined) ? data : "";
	}

	TextFile.prototype = Object.create(Resource.prototype);

	TextFile.extensions = [".js", ".txt", ".glsl", ".json", ".xml", ".yaml", ".csv", ".css", ".html"];

	/**
	 * Check if a file name refers to a text file.
	 *
	 * @method fileIsText
	 * @static
	 * @param {File} file
	 * @return {boolean} True if the file is text.
	 */
	TextFile.fileIsText = function(file)
	{
		file = file.name.toLocaleLowerCase();

		for(var i = 0; i < TextFile.extensions.length; i++)
		{
			if(file.endsWith(TextFile.extensions[i]))
			{
				return true;
			}
		}

		return false;
	};

	/**
	 * Serialize File resource data to json.
	 *
	 * @method toJSON
	 * @param {meta} meta
	 * @return {Object} data
	 */
	TextFile.prototype.toJSON = function(meta)
	{
		if(meta.resources[this.uuid] !== undefined)
		{
			return meta.resources[this.uuid];
		}

		var data = Resource.prototype.toJSON.call(this, meta);
		
		data.encoding = this.encoding;
		data.data = this.data;
		data.format = this.format;

		meta.resources[this.uuid] = data;

		return data;
	};

	/**
	 * Model is used to load and check file type for external 3D models, animations, scenes etc.
	 *
	 * It wraps other threejs loaders and loads files using them depending on file format.
	 * 
	 * @class Model
	 * @extends {Resource}
	 * @module Resources
	 */
	function Model()
	{
		Resource.call(this, "model", "Model");
	}

	Model.prototype = Object.create(Resource.prototype);

	/**
	 * List of file types supported for 3D models.
	 *
	 * @property {Array} extensions List of extensions.
	 * @type {Array}
	 */
	Model.extensions = ["gcode", "drc", "assimp", "assimp.json", "blend", "amf", "babylon", "prwm", "svg", "obj", "3ds", "dae", "gltf", "glb", "3mf", "awd", "ply", "vtk", "vtp", "wrl", "vrml", "fbx", "pcd", "stl", "json", "x"];

	/**
	 * Check if a file name refers to a 3D geometry file.
	 *
	 * @method fileIsFont
	 * @static
	 * @param {File} file
	 * @return {boolean} True if the fname refers to a supported format.
	 */
	Model.fileIsModel = function(file)
	{
		if(file !== undefined)
		{
			file = file.name.toLocaleLowerCase();

			for(var i = 0; i < Model.extensions.length; i++)
			{
				if(file.endsWith(Model.extensions[i]))
				{
					return true;
				}
			}
		}

		return false;
	};

	/**
	 * Renderer state can be used to store and restore a renderer state between postprocessing passes.
	 *
	 * It stores the clean configurations of the renderer.
	 *
	 * @class RendererState
	 */
	function RendererState()
	{
		this.autoClear = false;
		this.autoClearColor = false;
		this.autoClearStencil = false;
		this.autoClearDepth = false;
		
		this.sortObjects = true;

		this.clearColor = new three.Color();
		this.clearAlpha = 1;
	}

	/**
	 * Store the renderer state.
	 *
	 * @method backup
	 * @param {WebGlRenderer} renderer
	 */ 
	RendererState.prototype.backup = function(renderer)
	{
		this.autoClear = renderer.autoClear;
		this.autoClearColor = renderer.autoClearColor;
		this.autoClearStencil = renderer.autoClearStencil;
		this.autoClearDepth = renderer.autoClearDepth;

		this.sortObjects = renderer.sortObjects;

		this.clearColor.copy(renderer.getClearColor());
		this.clearAlpha = renderer.getClearAlpha();
	};

	/**
	 * Restore the renderer state.
	 *
	 * @method restore
	 * @param {WebGlRenderer} renderer
	 */ 
	RendererState.prototype.restore = function(renderer)
	{
		renderer.autoClear = this.autoClear;
		renderer.autoClearColor = this.autoClearColor;
		renderer.autoClearStencil = this.autoClearStencil;
		renderer.autoClearDepth = this.autoClearDepth;

		renderer.sortObjects = this.sortObjects;

		renderer.setClearColor(this.clearColor);
		renderer.setClearAlpha(this.clearAlpha);
	};

	/**
	 * A render Pass is used to render something in the graphics pipeline.
	 *
	 * Can be used to render a scene, apply post processing effects, merge buffers,  etc.
	 *
	 * @class Pass
	 * @module Postprocessing
	 */
	function Pass()
	{
		this.uuid = three.Math.generateUUID();
		this.type = "Pass";

		/**
		 * If set to true, the pass is processed by the composer.
		 *
		 * @property enabled
		 * @type {boolean}
		 */
		this.enabled = true;

		/**
		 * If set to true, the pass indicates to swap read and write buffer after rendering.
		 *
		 * @property needsSwap
		 * @type {boolean}
		 */
		this.needsSwap = true;

		/**
		 * If set to true, the pass clears its target buffer before rendering.
		 *
		 * @property clear
		 * @type {boolean}
		 */
		this.clear = false;

		/**
		 * If set to true, the result of the pass is rendered to screen.
		 *
		 * @property renderToScreen
		 * @type {boolean}
		 */
		this.renderToScreen = false;

		/**
		 * If set to true, the result of the pass needs to be copied to the ouput by the effect renderer if renderToScren is enabled.
		 *
		 * @property copyToScreen
		 * @type {boolean}
		 */
		this.copyToScreen = false;
	}

	/** 
	 * Parameters used for a RGBA linear filtered render target.
	 *
	 * @static
	 * @attribute RGBALinear
	 * @type {Object}
	 */
	Pass.RGBALinear =
	{
		minFilter: three.LinearFilter,
		magFilter: three.LinearFilter,
		format: three.RGBAFormat
	};

	/** 
	 * Parameters used for a RGB linear filtered render target.
	 *
	 * @static
	 * @attribute RGBLinear
	 * @type {Object}
	 */
	Pass.RGBLinear =
	{
		minFilter: three.LinearFilter,
		magFilter: three.LinearFilter,
		format: three.RGBFormat
	};

	/** 
	 * Parameters used for a RGBA unfiltered render target.
	 *
	 * @static
	 * @attribute RGBANearest
	 * @type {Object}
	 */
	Pass.RGBANearest =
	{
		minFilter: three.NearestFilter,
		magFilter: three.NearestFilter,
		format: three.RGBAFormat
	};

	/**
	 * Create a quad scene to render post-processing effects.
	 *
	 * It creates multiple attributes in the object to support that scene.
	 *
	 * @method createQuadScene
	 */
	Pass.prototype.createQuadScene = function()
	{
		/**
		 * Quad rendering camera.
		 *
		 * @attribute camera
		 * @type {OthographicCamera}
		 */
		this.camera = new three.OrthographicCamera(-1, 1, 1, -1, 0, 1);

		/**
		 * Quad scene, that contains a single quad children.
		 *
		 * @attribute scene
		 * @type {Scene}
		 */
		this.scene = new three.Scene();

		/**
		 * Quad mesh, composed of a 2 by 2 plane geometry.
		 *
		 * @attribute quad
		 * @type {Mesh}
		 */
		this.quad = new three.Mesh(new three.PlaneBufferGeometry(2, 2), null);
		this.quad.frustumCulled = false;
		this.scene.add(this.quad);
	};

	/**
	 * Set resolution of this render pass.
	 * 
	 * @method setSize
	 * @param {number} width
	 * @param {number} height
	 */
	Pass.prototype.setSize = function(width, height){};

	/**
	 * Render the scene using this render pass.
	 *
	 * @method render
	 * @param {WebGLRenderer} renderer
	 * @param {WebGLRenderTarget} writeBuffer Buffer to write output.
	 * @param {WebGLRenderTarget} readBuffer Input buffer.
	 * @param {number} delta Delta time in milliseconds.
	 * @param {boolean} maskActive Not used in this pass.
	 * @param {Scene} scene Scene to render.
	 */
	Pass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera){};

	/**
	 * Dispose this render pass.
	 *
	 * @method dispose
	 */
	Pass.prototype.dispose = function(){};

	/**
	 * Serialize pass to json.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata object.
	 */
	Pass.prototype.toJSON = function(meta)
	{
		var data = {};

		data.uuid = this.uuid;
		data.type = this.type;

		data.clear = this.clear;
		data.enabled = this.enabled;
		data.needsSwap = this.needsSwap;
		data.renderToScreen = this.renderToScreen;
		data.copyToScreen = this.copyToScreen;

		return data;
	};

	/**
	 * Shader pass is used to apply a post processing effect over an already rendered scene.
	 * 
	 * @author alteredq / http:// alteredqualia.com/
	 * @class ShaderPass
	 * @module Postprocessing
	 */
	function ShaderPass(shader, textureID)
	{
		Pass.call(this);

		this.type = "Shader";
		this.textureID = (textureID !== undefined ) ? textureID : "tDiffuse";

		if(shader instanceof three.ShaderMaterial)
		{
			this.uniforms = shader.uniforms;
			this.material = shader;
		}
		else if(shader)
		{
			this.uniforms = three.UniformsUtils.clone(shader.uniforms);
			this.material = new three.ShaderMaterial(
			{
				defines: Object.assign({}, shader.defines),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			});
		}

		this.createQuadScene();
	}
	ShaderPass.prototype = Object.create(Pass.prototype);

	ShaderPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		if(this.uniforms[this.textureID])
		{
			this.uniforms[this.textureID].value = readBuffer.texture;
		}

		this.quad.material = this.material;

		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);

		if(this.clear)
		{
			renderer.clear();
		}

		renderer.render(this.scene, this.camera);
	};

	/**
	 * Render pass is used to render the scene the same way as if were using the renderer directly.
	 * 
	 * @class RenderPass
	 * @extends {Pass}
	 * @module Postprocessing
	 */
	function RenderPass()
	{
		Pass.call(this);

		this.type = "Render";
		
		this.clear = true;
	}

	RenderPass.prototype = Object.create(Pass.prototype);

	RenderPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		if(this.clear)
		{
			renderer.autoClear = true;
			renderer.autoClearColor = true;
			renderer.autoClearDepth = true;
			renderer.autoClearStencil = true;
		}
		else
		{
			renderer.autoClear = false;
		}

		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
		renderer.render(scene, camera);
	};

	/**
	 * Simple bloom effect pass.
	 *
	 * @class BloomPass
	 * @author alteredq / http:// alteredqualia.com/
	 * @module Postprocessing
	 * @param {number} strength  Bloom effect strength.
	 * @param {number} kernelSize Bloom kernel size.
	 * @param {number} sigma Sigma.
	 * @param {number} resolution Bloom buffer resolution.
	 */
	function BloomPass(strength, kernelSize, sigma, resolution)
	{
		Pass.call(this);

		if(three.ConvolutionShader === undefined)
		{
			console.error("BloomPass relies on ConvolutionShader");
		}
		if(three.CopyShader === undefined)
		{
			console.error("BloomPass relies on CopyShader");
		}

		this.type = "Bloom";
		this.copyToScreen = true;

		this.createQuadScene();

		strength = (strength !== undefined) ? strength : 1;
		kernelSize = (kernelSize !== undefined) ? kernelSize : 25;
		sigma = (sigma !== undefined) ? sigma : 4.0;
		resolution = (resolution !== undefined) ? resolution : 256;

		// Render targets
		this.renderTargetX = new three.WebGLRenderTarget(resolution, resolution, Pass.RGBALinear);

		// Render targets
		this.renderTargetY = new three.WebGLRenderTarget(resolution, resolution, Pass.RGBALinear);

		// Copy material
		this.copyUniforms = three.UniformsUtils.clone(three.CopyShader.uniforms);
		this.copyUniforms["opacity"].value = strength;

		// Copy material
		this.materialCopy = new three.ShaderMaterial(
		{
			uniforms: this.copyUniforms,
			vertexShader: three.CopyShader.vertexShader,
			fragmentShader: three.CopyShader.fragmentShader,
			blending: three.AdditiveBlending,
			transparent: true
		});

		// Convolution material
		this.convolutionUniforms = three.UniformsUtils.clone(three.ConvolutionShader.uniforms);
		this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
		this.convolutionUniforms["cKernel"].value = three.ConvolutionShader.buildKernel(sigma);
		this.materialConvolution = new three.ShaderMaterial(
		{
			uniforms: this.convolutionUniforms,
			vertexShader:  three.ConvolutionShader.vertexShader,
			fragmentShader: three.ConvolutionShader.fragmentShader,
			defines:
			{
				"KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
				"KERNEL_SIZE_INT": kernelSize.toFixed(0)
			}
		});
		
	}

	BloomPass.blurX = new three.Vector2(0.001953125, 0.0);
	BloomPass.blurY = new three.Vector2(0.0, 0.001953125);

	BloomPass.prototype = Object.create(Pass.prototype);

	BloomPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		if(maskActive)
		{
			renderer.context.disable(renderer.context.STENCIL_TEST);
		}

		// Render quad with blured scene into texture (convolution pass 1)
		this.quad.material = this.materialConvolution;
		this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
		this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurX;
		renderer.setRenderTarget(this.renderTargetX);
		renderer.clear(true, true, true);
		renderer.render(this.scene, this.camera);

		// Render quad with blured scene into texture (convolution pass 2)
		this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
		this.convolutionUniforms["uImageIncrement"].value = BloomPass.blurY;
		renderer.setRenderTarget(this.renderTargetY);
		renderer.clear(true, true, true);
		renderer.render(this.scene, this.camera);

		// Render original scene with superimposed blur to texture
		this.quad.material = this.materialCopy;
		this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;

		if(maskActive)
		{
			renderer.context.enable(renderer.context.STENCIL_TEST);
		}

		renderer.setRenderTarget(writeBuffer);
		renderer.render(this.scene, this.camera);
	};

	BloomPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.strength = this.strength;
		data.kernelSize = this.kernelSize;
		data.sigma = this.sigma;
		data.resolution = this.resolution;

		return data;
	};

	/**
	 * Unreal engine like bloom effect pass.
	 *
	 * More information available here
	 *  - https:// docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/
	 *
	 * @author spidersharma / http:// eduperiment.com/
	 * @class UnrealBloomPass
	 * @module Postprocessing
	 * @param {number} strength  Bloom effect strength.
	 * @param {number} radius Bloom effect radius.
	 * @param {number} threshold White point threshold.
	 */
	function UnrealBloomPass(strength, radius, threshold)
	{
		if(three.LuminosityHighPassShader === undefined)
		{
			console.error("UnrealBloomPass relies on LuminosityHighPassShader");
		}
		if(three.CopyShader === undefined)
		{
			console.error("UnrealBloomPass relies on CopyShader");
		}

		Pass.call(this);
		
		this.type = "UnrealBloom";
		
		// Render targets for passes
		this.renderTargetsHorizontal = [];
		this.renderTargetsVertical = [];
		this.nMips = 5;

		for(var i = 0; i < this.nMips; i++)
		{
			var renderTarget = new three.WebGLRenderTarget(0, 0, Pass.RGBALinear);
			renderTarget.texture.generateMipmaps = false;
			this.renderTargetsHorizontal.push(renderTarget);

			var renderTarget = new three.WebGLRenderTarget(0, 0, Pass.RGBALinear);
			renderTarget.texture.generateMipmaps = false;
			this.renderTargetsVertical.push(renderTarget);
		}

		// Render target for final pass
		this.renderTargetBright = new three.WebGLRenderTarget(0, 0, Pass.RGBALinear);
		this.renderTargetBright.texture.generateMipmaps = false;

		// Luminosity high pass material
		var highPassShader = three.LuminosityHighPassShader;
		this.highPassUniforms = three.UniformsUtils.clone(highPassShader.uniforms);
		this.materialHighPassFilter = new three.ShaderMaterial(
		{
			uniforms: this.highPassUniforms,
			vertexShader: highPassShader.vertexShader,
			fragmentShader: highPassShader.fragmentShader,
			defines: {}
		});

		// Gaussian Blur material
		this.separableBlurMaterials = [];
		var kernelSizeArray = [3, 5, 7, 9, 11];
		for(var i = 0; i < this.nMips; i++)
		{
			this.separableBlurMaterials.push(UnrealBloomPass.getSeperableBlurMaterial(kernelSizeArray[i]));
			this.separableBlurMaterials[i].uniforms["texSize"].value = new three.Vector2(0, 0);
		}

		// Composite material
		this.compositeMaterial = UnrealBloomPass.getCompositeMaterial(this.nMips);
		this.compositeMaterial.uniforms["blurTexture1"].value = this.renderTargetsVertical[0].texture;
		this.compositeMaterial.uniforms["blurTexture2"].value = this.renderTargetsVertical[1].texture;
		this.compositeMaterial.uniforms["blurTexture3"].value = this.renderTargetsVertical[2].texture;
		this.compositeMaterial.uniforms["blurTexture4"].value = this.renderTargetsVertical[3].texture;
		this.compositeMaterial.uniforms["blurTexture5"].value = this.renderTargetsVertical[4].texture;

		// Configuration parameters
		this.highPassUniforms["luminosityThreshold"].value = (threshold !== undefined) ? threshold : 0.7;
		this.highPassUniforms["smoothWidth"].value = 0.01;
		this.compositeMaterial.uniforms["bloomStrength"].value = (strength !== undefined) ? strength : 0.8;
		this.compositeMaterial.uniforms["bloomRadius"].value = (radius !== undefined) ? radius : 0.3;
		this.compositeMaterial.uniforms["bloomFactors"].value = [1.0, 0.8, 0.6, 0.4, 0.2];
		this.compositeMaterial.uniforms["bloomTintColors"].value = [new three.Vector3(1, 1, 1), new three.Vector3(1, 1, 1), new three.Vector3(1, 1, 1), new three.Vector3(1, 1, 1), new three.Vector3(1, 1, 1)];
		this.compositeMaterial.needsUpdate = true;

		// Copy material
		this.copyUniforms = three.UniformsUtils.clone(three.CopyShader.uniforms);
		this.copyUniforms["opacity"].value = 1.0;
		this.materialCopy = new three.ShaderMaterial(
		{
			uniforms: this.copyUniforms,
			vertexShader: three.CopyShader.vertexShader,
			fragmentShader: three.CopyShader.fragmentShader,
			blending: three.AdditiveBlending,
			depthTest: false,
			depthWrite: false,
			transparent: true
		});

		// Quad scene
		this.createQuadScene();
		this.basic = new three.MeshBasicMaterial();
		Object.defineProperties(this,
		{
			/**
			 * Scales the color of the whole bloom effect.
			 *
			 * @property strength
			 * @type {number}
			 */
			strength:
			{
				get: function() {return this.compositeMaterial.uniforms["bloomStrength"].value;},
				set: function(value) {this.compositeMaterial.uniforms["bloomStrength"].value = value;}
			},

			/**
			 * Bloom effect radius.
			 *
			 * @property radius
			 * @type {number}
			 */
			radius:
			{
				get: function() {return this.compositeMaterial.uniforms["bloomRadius"].value;},
				set: function(value) {this.compositeMaterial.uniforms["bloomRadius"].value = value;}
			},

			/**
			 * Defines how many luminance units a color needs to have to affect bloom. In addition to the threshold, there is a linear part (one unit wide) where the color only partly affects the bloom.
			 * 
			 * To have all scene colors contributing to the bloom, a volume of -1 needs to be used.
			 *
			 * @property threshold
			 * @type {number}
			 */
			threshold:
			{
				get: function() {return this.highPassUniforms["luminosityThreshold"].value;},
				set: function(value) {this.highPassUniforms["luminosityThreshold"].value;}
			},

			/**
			 * Smooth factor.
			 *
			 * @property smooth
			 * @type {number}
			 */
			smooth:
			{
				get: function() {return this.highPassUniforms["smoothWidth"].value;},
				set: function(value) {this.highPassUniforms["smoothWidth"].value;}
			},

			/**
			 * The size in percent of the screen width. Is clamped by some number. If you need a larger number, use the next lower resolution blur instead (higher number).
			 *
			 * @property bloomFactors
			 * @type {Array}
			 */
			bloomFactors:
			{
				get: function() {return this.compositeMaterial.uniforms["bloomFactors"].value;},
				set: function(value) {this.compositeMaterial.uniforms["bloomFactors"].value;}
			},

			/**
			 * Modifies the brightness and color of each bloom. Using a black color will not make this pass faster but that can be done.
			 *
			 * @property bloomTintColors
			 * @type {Array}
			 */
			bloomTintColors:
			{
				get: function() {return this.compositeMaterial.uniforms["bloomTintColors"].value;},
				set: function(value) {this.compositeMaterial.uniforms["bloomTintColors"].value = value;}
			}
		});
	}

	UnrealBloomPass.prototype = Object.create(Pass.prototype);

	UnrealBloomPass.BlurDirectionX = new three.Vector2(1.0, 0.0);
	UnrealBloomPass.BlurDirectionY = new three.Vector2(0.0, 1.0);

	UnrealBloomPass.prototype.dispose = function()
	{
		for(var i = 0; i < this.renderTargetsHorizontal.length; i++)
		{
			this.renderTargetsHorizontal[i].dispose();
		}
		for(var i = 0; i < this.renderTargetsVertical.length; i++)
		{
			this.renderTargetsVertical[i].dispose();
		}
		this.renderTargetBright.dispose();
	};

	UnrealBloomPass.prototype.setSize = function(width, height)
	{
		var resx = Math.round(width / 2);
		var resy = Math.round(height / 2);

		this.renderTargetBright.setSize(resx, resy);
		
		for(var i = 0; i < this.nMips; i++)
		{
			this.renderTargetsHorizontal[i].setSize(resx, resy);
			this.renderTargetsVertical[i].setSize(resx, resy);
			this.separableBlurMaterials[i].uniforms["texSize"].value.set(resx, resy);

			resx = Math.round(resx / 2);
			resy = Math.round(resy / 2);
		}
	};

	UnrealBloomPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		renderer.autoClear = false;
		renderer.setClearColor(new three.Color(0, 0, 0), 0);
		
		if(maskActive)
		{
			renderer.context.disable(renderer.context.STENCIL_TEST);
		}

		// Clear screen
		if(this.renderToScreen)
		{
			this.quad.material = this.basic;
			this.basic.map = readBuffer.texture;

			renderer.setRenderTarget(null);
			renderer.clear();
			renderer.render(this.scene, this.camera);
		}

		// Extract Bright Areas
		this.highPassUniforms["tDiffuse"].value = readBuffer.texture;
		this.quad.material = this.materialHighPassFilter;
		renderer.setRenderTarget(this.renderTargetBright);
		renderer.clear();
		renderer.render(this.scene, this.camera);

		// Blur All the mips progressively
		var inputRenderTarget = this.renderTargetBright;
		for(var i = 0; i < this.nMips; i++)
		{
			this.quad.material = this.separableBlurMaterials[i];

			this.separableBlurMaterials[i].uniforms["colorTexture"].value = inputRenderTarget.texture;
			this.separableBlurMaterials[i].uniforms["direction"].value = UnrealBloomPass.BlurDirectionX;

			renderer.setRenderTarget(this.renderTargetsHorizontal[i]);
			renderer.clear();
			renderer.render(this.scene, this.camera);

			this.separableBlurMaterials[i].uniforms["colorTexture"].value = this.renderTargetsHorizontal[i].texture;
			this.separableBlurMaterials[i].uniforms["direction"].value = UnrealBloomPass.BlurDirectionY;

			renderer.setRenderTarget(this.renderTargetsVertical[i]);
			renderer.clear();
			renderer.render(this.scene, this.camera);

			inputRenderTarget = this.renderTargetsVertical[i];
		}

		// Composite All the mips
		this.quad.material = this.compositeMaterial;
		renderer.setRenderTarget(this.renderTargetsHorizontal[0]);
		renderer.render(this.scene, this.camera);

		// Blend it additively over the input texture
		this.quad.material = this.materialCopy;
		this.copyUniforms["tDiffuse"].value = this.renderTargetsHorizontal[0].texture;
		
		if(maskActive)
		{
			renderer.context.enable(renderer.context.STENCIL_TEST);
		}

		renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
		renderer.render(this.scene, this.camera);
	};

	/**
	 * Serialize this effect composer to JSON.
	 *
	 * @method toJSON
	 */
	UnrealBloomPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);
		
		data.strength = this.strength;
		data.radius = this.radius;
		data.threshold = this.threshold;
		data.bloomFactors = this.bloomFactors;

		data.bloomTintColors = [];
		for(var i = 0; i < this.bloomTintColors.length; i++)
		{
			data.bloomTintColors.push(this.bloomTintColors[i].toArray());
		}

		return data;
	};

	UnrealBloomPass.getSeperableBlurMaterial = function(kernelRadius)
	{
		return new three.ShaderMaterial(
		{
			defines:
			{
				KERNEL_RADIUS: kernelRadius,
				SIGMA: kernelRadius
			},
			uniforms:
			{
				colorTexture: {value: null},
				texSize: {value: new three.Vector2(0.5, 0.5)},
				direction: {value: new three.Vector2(0.5, 0.5)}
			},
			vertexShader: "\n\
			varying vec2 vUv;\n\
			void main()\n\
			{\n\
				vUv = uv;\n\
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
			}",
			fragmentShader: "\n\
			#include <common>\n\
			varying vec2 vUv;\n\
			uniform sampler2D colorTexture;\n\
			uniform vec2 texSize;\n\
			uniform vec2 direction;\n\
			\n\
			float gaussianPdf(in float x, in float sigma)\n\
			{\n\
				return 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\
			}\n\
			\n\
			void main()\n\
			{\n\
				vec2 invSize = 1.0 / texSize;\n\
				float fSigma = float(SIGMA);\n\
				float weightSum = gaussianPdf(0.0, fSigma);\n\
				vec3 diffuseSum = texture2D(colorTexture, vUv).rgb * weightSum;\n\
				for(int i = 1; i < KERNEL_RADIUS; i++)\n\
				{\n\
					float x = float(i);\n\
					float w = gaussianPdf(x, fSigma);\n\
					vec2 uvOffset = direction * invSize * x;\n\
					vec3 sample1 = texture2D(colorTexture, vUv + uvOffset).rgb;\n\
					vec3 sample2 = texture2D(colorTexture, vUv - uvOffset).rgb;\n\
					diffuseSum += (sample1 + sample2) * w;\n\
					weightSum += 2.0 * w;\n\
				}\n\
				gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\
			}"
		});
	};

	UnrealBloomPass.getCompositeMaterial = function(nMips)
	{
		return new three.ShaderMaterial(
		{
			defines:
			{
				NUM_MIPS: nMips
			},
			uniforms:
			{
				blurTexture1: {value: null},
				blurTexture2: {value: null},
				blurTexture3: {value: null},
				blurTexture4: {value: null},
				blurTexture5: {value: null},
				dirtTexture: {value: null},
				bloomStrength: {value: 1.0},
				bloomFactors: {value: null},
				bloomTintColors: {value: null},
				bloomRadius: {value: 0.0}
			},
			vertexShader: "\n\
			varying vec2 vUv;\n\
			void main()\n\
			{\n\
				vUv = uv;\n\
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
			}",
			fragmentShader: "\n\
			varying vec2 vUv;\n\
			uniform sampler2D blurTexture1;\n\
			uniform sampler2D blurTexture2;\n\
			uniform sampler2D blurTexture3;\n\
			uniform sampler2D blurTexture4;\n\
			uniform sampler2D blurTexture5;\n\
			uniform sampler2D dirtTexture;\n\
			uniform float bloomStrength;\n\
			uniform float bloomRadius;\n\
			uniform float bloomFactors[NUM_MIPS];\n\
			uniform vec3 bloomTintColors[NUM_MIPS];\n\
			\n\
			float lerpBloomFactor(const in float factor)\n\
			{\n\
				float mirrorFactor = 1.2 - factor;\n\
				return mix(factor, mirrorFactor, bloomRadius);\n\
			}\n\
			\n\
			void main()\n\
			{\n\
				gl_FragColor = bloomStrength * (lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \n\
												 lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \n\
												 lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \n\
												 lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \n\
												 lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv));\n\
			}"
		});
	};

	/**
	 * Simulate technicolor television colors.
	 * 
	 * @class TechnicolorPass
	 * @module Postprocessing
	 */
	function TechnicolorPass()
	{
		ShaderPass.call(this, three.TechnicolorShader);

		this.type = "Technicolor";
	}

	TechnicolorPass.prototype = Object.create(ShaderPass.prototype);

	/**
	 * Screen-space ambient occlusion shader
	 *    - http:// devlog-martinsh.blogspot.com (assembled by Martins Upitis)
	 *    - http:// www.gamedev.net/topic/550699-ssao-no-halo-artifacts/ (original technique is made by ArKano22)
	 *
	 * Modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
	 *
	 * @static
	 * @class SSAOShader
	 * @author alteredq / http:// alteredqualia.com/
	 */
	var SSAOShader =
	{
		uniforms:
		{
			tDiffuse: {value: null},
			tDepth: {value: null},
			size: {value: new three.Vector2(512, 512)},
			cameraNear: {value: 1},
			cameraFar: {value: 100},
			radius: {value: 32},
			onlyAO: {value: 0},
			aoClamp: {value: 0.25},
			lumInfluence: {value: 0.7}
		},

		vertexShader: "\n\
	varying vec2 vUv;\n\
	void main()\n\
	{\n\
		vUv = uv;\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
	}",

		fragmentShader: "\n\
	uniform float cameraNear;\n\
	uniform float cameraFar;\n\
\n\
	#ifdef USE_LOGDEPTHBUF\n\
		uniform float logDepthBufFC;\n\
	#endif\n\
\n\
	uniform float radius; // ao radius \n\
	uniform bool onlyAO; // use only ambient occlusion pass?\n\
\n\
	uniform vec2 size; // texture width, height\n\
	uniform float aoClamp; // depth clamp - reduces haloing at screen edges\n\
\n\
	uniform float lumInfluence; // how much luminance affects occlusion\n\
\n\
	uniform sampler2D tDiffuse;\n\
	uniform sampler2D tDepth;\n\
\n\
	varying vec2 vUv;\n\
\n\
	#define DL 2.399963229728653 // PI *(3.0 - sqrt(5.0))\n\
	#define EULER 2.718281828459045\n\
\n\
	// user variables\n\
	const int samples = 64; // ao sample count\n\
	const bool useNoise = true; // use noise instead of pattern for sample dithering\n\
	const float noiseAmount = 0.0004; // dithering amount\n\
	const float diffArea = 0.4; // self-shadowing reduction\n\
	const float gDisplace = 0.4; // gauss bell center\n\
\n\
	// RGBA depth\n\
	#include <packing>\n\
\n\
	// generating noise / pattern texture for dithering\n\
	vec2 rand(const vec2 coord)\n\
	{\n\
		vec2 noise;\n\
\n\
		if(useNoise)\n\
		{\n\
			float nx = dot(coord, vec2(12.9898, 78.233));\n\
			float ny = dot(coord, vec2(12.9898, 78.233) * 2.0);\n\
			noise = clamp(fract(43758.5453 * sin(vec2(nx, ny))), 0.0, 1.0);\n\
		}\n\
		else\n\
		{\n\
			float ff = fract(1.0 - coord.s *(size.x / 2.0));\n\
			float gg = fract(coord.t *(size.y / 2.0));\n\
			noise = vec2(0.25, 0.75) * vec2(ff) + vec2(0.75, 0.25) * gg;\n\
		}\n\
\n\
		return(noise * 2.0  - 1.0) * noiseAmount;\n\
	}\n\
\n\
	float readDepth(const in vec2 coord) {\n\
\n\
		float cameraFarPlusNear = cameraFar + cameraNear;\n\
		float cameraFarMinusNear = cameraFar - cameraNear;\n\
		float cameraCoef = 2.0 * cameraNear;\n\
\n\
		#ifdef USE_LOGDEPTHBUF\n\
			float logz = unpackRGBAToDepth(texture2D(tDepth, coord));\n\
			float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\n\
			float z = (logz / w) + 1.0;\n\
		#else\n\
			float z = unpackRGBAToDepth(texture2D(tDepth, coord));\n\
		#endif\n\
\n\
		return cameraCoef /(cameraFarPlusNear - z * cameraFarMinusNear);\n\
	}\n\
\n\
	float compareDepths(const in float depth1, const in float depth2, inout int far)\n\
	{\n\
		float garea = 8.0; // gauss bell width\n\
		float diff =(depth1 - depth2) * 100.0; // depth difference (0-100)\n\
\n\
		// reduce left bell width to avoid self-shadowing\n\
		if(diff < gDisplace)\n\
		{\n\
			garea = diffArea;\n\
\n\
		}\n\
		else\n\
		{\n\
			far = 1;\n\
		}\n\
\n\
		float dd = diff - gDisplace;\n\
		float gauss = pow(EULER, -2.0 *(dd * dd) /(garea * garea));\n\
		return gauss;\n\
	}\n\
\n\
	float calcAO(float depth, float dw, float dh)\n\
	{\n\
		vec2 vv = vec2(dw, dh);\n\
		vec2 coord1 = vUv + radius * vv;\n\
		vec2 coord2 = vUv - radius * vv;\n\
\n\
		float temp1 = 0.0;\n\
		float temp2 = 0.0;\n\
\n\
		int far = 0;\n\
		temp1 = compareDepths(depth, readDepth(coord1), far);\n\
\n\
		// DEPTH EXTRAPOLATION\n\
		if(far > 0)\n\
		{\n\
			temp2 = compareDepths(readDepth(coord2), depth, far);\n\
			temp1 +=(1.0 - temp1) * temp2;\n\
		}\n\
\n\
		return temp1;\n\
	}\n\
\n\
	void main()\n\
	{\n\
		vec2 noise = rand(vUv);\n\
		float depth = readDepth(vUv);\n\
\n\
		float tt = clamp(depth, aoClamp, 1.0);\n\
\n\
		float w =(1.0 / size.x) / tt +(noise.x *(1.0 - noise.x));\n\
		float h =(1.0 / size.y) / tt +(noise.y *(1.0 - noise.y));\n\
\n\
		float ao = 0.0;\n\
\n\
		float dz = 1.0 / float(samples);\n\
		float l = 0.0;\n\
		float z = 1.0 - dz / 2.0;\n\
\n\
		for(int i = 0; i <= samples; i ++)\n\
		{\n\
			float r = sqrt(1.0 - z);\n\
\n\
			float pw = cos(l) * r;\n\
			float ph = sin(l) * r;\n\
			ao += calcAO(depth, pw * w, ph * h);\n\
			z = z - dz;\n\
			l = l + DL;\n\
		}\n\
\n\
		ao /= float(samples);\n\
		ao = 1.0 - ao;\n\
\n\
		vec3 color = texture2D(tDiffuse, vUv).rgb;\n\
\n\
		vec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\
		float lum = dot(color.rgb, lumcoeff);\n\
		vec3 luminance = vec3(lum);\n\
\n\
		vec3 final = vec3(color * mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); // mix(color * ao, white, luminance)\n\
\n\
		if(onlyAO)\n\
		{\n\
			final = vec3(mix(vec3(ao), vec3(1.0), luminance * lumInfluence)); // ambient occlusion only\n\
		}\n\
\n\
		gl_FragColor = vec4(final, 1.0);\n\
	}"
	};

	/**
	 * Screen space ambient occlusion (SSAO) pass is used to simulate ambient occlusion shadowing effect.
	 *
	 * This variant of SSAO produces a halo like effect to simulate the effect.
	 * 
	 * More information about SSAO here
	 *  - http:// developer.download.nvidia.com/SDK/10.5/direct3d/Source/ScreenSpaceAO/doc/ScreenSpaceAO.pdf
	 *
	 * @author alteredq / http:// alteredqualia.com/
	 * @class SSAOPass
	 * @module Postprocessing
	 */
	function SSAOPass()
	{
		ShaderPass.call(this, SSAOShader);

		this.type = "SSAO";

		// Depth material
		this.depthMaterial = new three.MeshDepthMaterial();
		this.depthMaterial.depthPacking = three.RGBADepthPacking;
		this.depthMaterial.blending = three.NoBlending;

		// Depth render target
		this.depthRenderTarget = new three.WebGLRenderTarget(2, 2, {minFilter: three.LinearFilter, magFilter: three.LinearFilter});

		// Shader uniforms
		this.uniforms["tDepth"].value = this.depthRenderTarget.texture;
		this.uniforms["size"].value.set(2, 2);
		Object.defineProperties(this,
		{
			/**
			 * Ambient occlusion shadow radius.
			 *
			 * @property radius
			 * @type {number}
			 */
			radius:
			{
				get: function() {return this.uniforms["radius"].value;},
				set: function(value) {this.uniforms["radius"].value = value;}
			},

			/**
			 * Display only ambient occlusion result.
			 *
			 * @property onlyAO
			 * @type {boolean}
			 */
			onlyAO:
			{
				get: function() {return this.uniforms["onlyAO"].value;},
				set: function(value) {this.uniforms["onlyAO"].value = value;}
			},

			/**
			 * Ambient occlusion clamp.
			 *
			 * @property aoClamp
			 * @type {number}
			 */
			aoClamp:
			{
				get: function() {return this.uniforms["aoClamp"].value;},
				set: function(value) {this.uniforms["aoClamp"].value = value;}
			},

			/**
			 * Pixel luminosity influence in AO calculation.
			 *
			 * @property lumInfluence
			 * @type {number}
			 */
			lumInfluence:
			{
				get: function() {return this.uniforms["lumInfluence"].value;},
				set: function(value) {this.uniforms["lumInfluence"].value = value;}
			},
		});

		this.radius = 4;
		this.onlyAO = false;
		this.aoClamp = 0.25;
		this.lumInfluence = 0.7;
	}

	SSAOPass.prototype = Object.create(ShaderPass.prototype);

	/**
	 * Render using this pass.
	 * 
	 * @method render
	 * @param {WebGLRenderer} renderer
	 * @param {WebGLRenderTarget} writeBuffer Buffer to write output.
	 * @param {WebGLRenderTarget} readBuffer Input buffer.
	 * @param {number} delta Delta time in milliseconds.
	 * @param {boolean} maskActive Not used in this pass.
	 */
	SSAOPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		this.uniforms["cameraNear"].value = camera.near;
		this.uniforms["cameraFar"].value = camera.far;

		// Render depth
		scene.overrideMaterial = this.depthMaterial;
		
		renderer.setRenderTarget(this.depthRenderTarget);
		renderer.clear(true, true, true);
		renderer.render(scene, camera);

		// Render shader
		scene.overrideMaterial = null;

		ShaderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta, maskActive);
	};


	/**
	 * Set resolution of this render pass.
	 * 
	 * @method setSize
	 * @param {number} width
	 * @param {number} height
	 */
	SSAOPass.prototype.setSize = function(width, height)
	{
		this.uniforms["size"].value.set(width, height);
		this.depthRenderTarget.setSize(width, height);
	};

	/**
	 * Serialize pass to json.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata object.
	 */
	SSAOPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);
		
		data.onlyAO = this.onlyAO;
		data.radius = this.radius;
		data.aoClamp = this.aoClamp;
		data.lumInfluence = this.lumInfluence;

		return data;
	};

	/**
	 * Screen space ambient occlusion (SSAO) pass is used to simulate ambient occlusion shadowing effect.
	 *
	 * Uses the normal-oriented hemisphere method produces a more realistic-looking than the basic Crysis method.
	 *
	 * Based on the article from http:// john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html
	 *
	 * More information about SSAO here
	 *  - http:// developer.download.nvidia.com/SDK/10.5/direct3d/Source/ScreenSpaceAO/doc/ScreenSpaceAO.pdf
	 *
	 * @class SSAONOHPass
	 * @module Postprocessing
	 */
	function SSAONOHPass()
	{
		if(three.SSAOShader === undefined)
		{
			console.warn("SSAONOHPass depends on SSAOShader");
		}

		Pass.call(this);

		this.type = "SSAONOH";
		
		this.kernel = [];
		this.noiseTexture = null;
		this.createQuadScene();

		/**
		 * Depth texture attached to the normal material
		 *
		 * @attribute depthTexture
		 * @type {DepthTexture}
		 */
		this.depthTexture = new three.DepthTexture();
		this.depthTexture.type = three.UnsignedShortType;
		this.depthTexture.minFilter = three.NearestFilter;
		this.depthTexture.maxFilter = three.NearestFilter;

		/**
		 * Normal rendering material.
		 *
		 * @attribute normalMaterial
		 * @type {MeshNormalMaterial}
		 */
		this.normalMaterial = new three.MeshNormalMaterial();
		this.normalMaterial.blending = three.NoBlending;

		// Normal render target
		this.normalRenderTarget = new three.WebGLRenderTarget(1, 1,
		{
			minFilter: three.LinearFilter,
			magFilter: three.LinearFilter,
			format: three.RGBAFormat,
			depthTexture: this.depthTexture,
			depthBuffer: true
		});

		// SSAO render target
		this.ssaoRenderTarget = new three.WebGLRenderTarget(1, 1, Pass.RGBALinear);

		// Blur render target
		this.blurRenderTarget = new three.WebGLRenderTarget(1, 1, Pass.RGBALinear);

		/**
		 * Blur pass render material.
		 *
		 * @attribute blurMaterial
		 * @type {ShaderMaterial}
		 */
		this.blurMaterial = new three.ShaderMaterial(
		{
			defines: Object.assign({}, three.SSAOBlurShader.defines),
			uniforms: three.UniformsUtils.clone(three.SSAOBlurShader.uniforms),
			vertexShader: three.SSAOBlurShader.vertexShader,
			fragmentShader: three.SSAOBlurShader.fragmentShader
		});
		this.blurMaterial.uniforms["tDiffuse"].value = this.ssaoRenderTarget.texture;

		/**
		 * Shader material for the SSAO render pass.
		 *
		 * @attribute ssaoMaterial
		 * @type {ShaderMaterial}
		 */
		this.ssaoMaterial = new three.ShaderMaterial(
		{
			defines: Object.assign({}, three.SSAOShader.defines),
			uniforms: three.UniformsUtils.clone(three.SSAOShader.uniforms),
			vertexShader: three.SSAOShader.vertexShader,
			fragmentShader: three.SSAOShader.fragmentShader,
			blending: three.NoBlending
		});
		this.ssaoMaterial.uniforms["tNormal"].value = this.normalRenderTarget.texture;
		
		/**
		 * Material used to copy data between buffers.
		 *
		 * @attribute copyMaterial
		 * @type {ShaderMaterial}
		 */
		this.copyMaterial = new three.ShaderMaterial(
		{
			uniforms: three.UniformsUtils.clone(three.CopyShader.uniforms),
			vertexShader: three.CopyShader.vertexShader,
			fragmentShader: three.CopyShader.fragmentShader,
			transparent: true,
			depthTest: false,
			depthWrite: false,
			blendSrc: three.DstColorFactor,
			blendDst: three.ZeroFactor,
			blendEquation: three.AddEquation,
			blendSrcAlpha: three.DstAlphaFactor,
			blendDstAlpha: three.ZeroFactor,
			blendEquationAlpha: three.AddEquation
		});

		this._kernelSize = 0;
		
		var self = this;

		Object.defineProperties(this,
		{
			/**
			 * Kernel radius used for the SSAO effect.
			 *
			 * @property kernelRadius
			 * @type {boolean}
			 */
			kernelRadius:
			{
				get: function(){return self.ssaoMaterial.uniforms["kernelRadius"].value;},
				set: function(value){self.ssaoMaterial.uniforms["kernelRadius"].value = value;}
			},

			/**
			 * Minimum camera distance considered for the SSAO effect.
			 *
			 * @property minDistance
			 * @type {number}
			 */
			minDistance:
			{
				get: function(){return self.ssaoMaterial.uniforms["minDistance"].value;},
				set: function(value){self.ssaoMaterial.uniforms["minDistance"].value = value;}
			},

			/**
			 * Maximum camera distance considered for the SSAO effect.
			 *
			 * @property maxDistance
			 * @type {number}
			 */
			maxDistance:
			{
				get: function() {return self.ssaoMaterial.uniforms["maxDistance"].value;},
				set: function(value) {self.ssaoMaterial.uniforms["maxDistance"].value = value;}
			},

			/**
			 * SSAO effect kernel size.
			 *
			 * @property kernelSize
			 * @type {number}
			 */
			kernelSize:
			{
				get: function(){return self._kernelSize;},
				set: function(value)
				{
					self._kernelSize = value;
					self.generateSampleKernel();
					self.generateRandomKernelRotations();
					self.ssaoMaterial.uniforms["tNoise"].value = self.noiseTexture;
					self.ssaoMaterial.uniforms["kernel"].value = self.kernel;
				}
			}
		});

		this.kernelSize = 64;
		this.kernelRadius = 8;
		this.minDistance = 0.1;
		this.maxDistance = 1000;
	}

	SSAONOHPass.prototype = Object.create(Pass.prototype);

	/** 
	 * Generate a sample kernel based on the kernelSize value.
	 * 
	 * @method generateSampleKernel
	 */
	SSAONOHPass.prototype.generateSampleKernel = function()
	{
		for(var i = 0; i < this._kernelSize; i++)
		{
			var sample = new three.Vector3();
			sample.x = (three.Math.random() * 2) - 1;
			sample.y = (three.Math.random() * 2) - 1;
			sample.z = three.Math.random();
			sample.normalize();

			var scale = i / this._kernelSize;
			scale = three.Math.lerp(0.1, 1, scale * scale);
			sample.multiplyScalar(scale);
			this.kernel.push(sample);
		}
	};

	/**
	 * Use noise to generate multiple pseudo random kernel rotations.
	 *
	 * @method generateRandomKernelRotations
	 */
	SSAONOHPass.prototype.generateRandomKernelRotations = function()
	{
		var width = 4, height = 4;

		if(SimplexNoise === undefined)
		{
			console.error("SSAONOHPass: The pass relies on SimplexNoise.");
		}

		var simplex = new SimplexNoise();
		var size = width * height;
		var data = new Float32Array(size);

		for(var i = 0; i < size; i++)
		{
			var x = (three.Math.random() * 2) - 1;
			var y = (three.Math.random() * 2) - 1;
			var z = 0;
			data[i] = simplex.noise3d(x, y, z);
		}

		this.noiseTexture = new three.DataTexture(data, width, height, three.LuminanceFormat, three.FloatType);
		this.noiseTexture.wrapS = three.RepeatWrapping;
		this.noiseTexture.wrapT = three.RepeatWrapping;
		this.noiseTexture.needsUpdate = true;
	};

	/**
	 * Render using this pass.
	 * 
	 * @method render
	 * @param {WebGLRenderer} renderer
	 * @param {WebGLRenderTarget} writeBuffer Buffer to write output.
	 * @param {WebGLRenderTarget} readBuffer Input buffer.
	 * @param {number} delta Delta time in milliseconds.
	 * @param {boolean} maskActive Not used in this pass.
	 */
	SSAONOHPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		// Render configuration
		renderer.autoClear = false;
		renderer.setClearColor(0x7777ff);
		renderer.setClearAlpha(1.0);

		// Render normals
		scene.overrideMaterial = this.normalMaterial;
		renderer.setRenderTarget(this.normalRenderTarget);
		renderer.clear(true, true, true);
		renderer.render(scene, camera);

		scene.overrideMaterial = null;

		// Render SSAO
		this.ssaoMaterial.uniforms["tDepth"].value = this.depthTexture;
		this.ssaoMaterial.uniforms["tDiffuse"].value = readBuffer.texture;
		this.ssaoMaterial.uniforms["cameraNear"].value = camera.near;
		this.ssaoMaterial.uniforms["cameraFar"].value = camera.far;
		this.ssaoMaterial.uniforms["cameraProjectionMatrix"].value.copy(camera.projectionMatrix);
		this.ssaoMaterial.uniforms["cameraInverseProjectionMatrix"].value.getInverse(camera.projectionMatrix); 
		this.renderPass(renderer, this.ssaoMaterial, this.ssaoRenderTarget);

		// Render blur
		this.renderPass(renderer, this.blurMaterial, this.blurRenderTarget);

		// Output to screen
		if(this.renderToScreen)
		{
			// Copy SSAO result
			this.copyMaterial.uniforms["tDiffuse"].value = readBuffer.texture;
			this.copyMaterial.blending = three.NoBlending;
			this.renderPass(renderer, this.copyMaterial, null , this.clear);

			// Copy blur and blend it to output
			this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
			this.copyMaterial.blending = three.CustomBlending;
			this.renderPass(renderer, this.copyMaterial, null, false);
		}
		// Output to writeBuffer
		else
		{
			// Copy SSAO result
			this.copyMaterial.uniforms["tDiffuse"].value = readBuffer.texture;
			this.copyMaterial.blending = three.NoBlending;
			this.renderPass(renderer, this.copyMaterial, writeBuffer, this.clear);

			// Copy blur and blend it to output
			this.copyMaterial.uniforms["tDiffuse"].value = this.blurRenderTarget.texture;
			this.copyMaterial.blending = three.CustomBlending;
			this.renderPass(renderer, this.copyMaterial, writeBuffer, false);
		}	
	};

	/**
	 * Render a quad scene using a pass material.
	 *
	 * @method renderPass
	 */
	SSAONOHPass.prototype.renderPass = function(renderer, passMaterial, renderTarget, clear)
	{
		this.quad.material = passMaterial;

		renderer.autoClear = false;
		renderer.setRenderTarget(renderTarget);

		if(clear)
		{
			renderer.clear(true, true, true);
		}

		renderer.render(this.scene, this.camera);
	};

	SSAONOHPass.prototype.dispose = function()
	{
		// Render targets
		this.normalRenderTarget.dispose();
		this.ssaoRenderTarget.dispose();
		this.blurRenderTarget.dispose();

		// Geometry
		this.quad.geometry.dispose();

		// Materials
		this.normalMaterial.dispose();
		this.blurMaterial.dispose();
		this.copyMaterial.dispose();
	};

	/**
	 * Set resolution of this render pass.
	 * 
	 * @method setSize
	 * @param {number} width
	 * @param {number} height
	 */
	SSAONOHPass.prototype.setSize = function(width, height)
	{
		this.ssaoMaterial.uniforms["resolution"].value.set(width, height);
		this.blurMaterial.uniforms["resolution"].value.set(width, height);

		this.normalRenderTarget.setSize(width, height);
		this.ssaoRenderTarget.setSize(width, height);
		this.blurRenderTarget.setSize(width, height);
	};

	/**
	 * Serialize pass to json.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata object.
	 */
	SSAONOHPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);
		
		data.kernelSize = this.kernelSize;
		data.kernelRadius = this.kernelRadius;
		data.minDistance = this.minDistance;
		data.maxDistance = this.maxDistance;

		return data;
	};

	/**
	 * Sobel pass is used to create a edge highlight effect with a sobel operator.
	 *  
	 * @class SobelPass
	 * @module Postprocessing
	 */
	function SobelPass(center, angle, scale)
	{
		if(three.SobelOperatorShader === undefined)
		{
			console.error("SobelPass relies on SobelOperatorShader");
		}
		if(three.LuminosityShader === undefined)
		{
			console.error("SobelPass relies on LuminosityShader");
		}

		ShaderPass.call(this, three.SobelOperatorShader);

		this.type = "Sobel";
	}
	SobelPass.prototype = Object.create(ShaderPass.prototype);

	SobelPass.prototype.setSize = function(width, height)
	{
		this.uniforms.resolution.value.set(width, height);
	};

	/**
	 * Hue and saturation pass.
	 * 
	 * @class HueSaturationPass
	 * @module Postprocessing
	 * @param {number} hue Hue rotation from -1 to 1
	 * @param {number} saturation Color saturation from -1  to 1
	 */
	function HueSaturationPass(hue, saturation)
	{
		ShaderPass.call(this, three.HueSaturationShader);

		this.type = "HueSaturation";
		Object.defineProperties(this,
		{
			hue:
			{
				get: function(){return this.uniforms["hue"].value;},
				set: function(value){this.uniforms["hue"].value = value;}
			},

			saturation:
			{
				get: function(){return this.uniforms["saturation"].value;},
				set: function(value){this.uniforms["saturation"].value = value;}
			}
		});

		this.hue = hue !== undefined ? hue : 0;
		this.saturation = saturation !== undefined ? saturation : 0;
	}

	HueSaturationPass.prototype = Object.create(ShaderPass.prototype);

	/**
	 * Serialize pass to json.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata object.
	 */
	HueSaturationPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.hue = this.hue;
		data.saturation = this.saturation;
		
		return data;
	};

	/**
	 * Film pass is used to simulate a film/TV like effect.
	 *
	 * @class FilmPass
	 * @module Postprocessing
	 * @author alteredq / http:// alteredqualia.com/
	 */
	function FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale)
	{
		if(three.FilmShader === undefined)
		{
			console.error("FilmPass relies on FilmShader");
		}

		Pass.call(this);

		this.type = "Film";
		this.createQuadScene();

		this.uniforms = three.UniformsUtils.clone(three.FilmShader.uniforms);
		this.material = new three.ShaderMaterial(
		{
			uniforms: this.uniforms,
			vertexShader: three.FilmShader.vertexShader,
			fragmentShader: three.FilmShader.fragmentShader
		});

		var self = this;

		Object.defineProperties(this,
		{
			/**
			 * If set true a grascale effect will be applied.
			 *
			 * @property grayscale
			 * @type {boolean}
			 */
			grayscale:
			{
				get: function(){return self.uniforms["grayscale"].value;},
				set: function(value){self.uniforms["grayscale"].value = value;}
			},

			/**
			 * Ammout of noise to be applied to the image.
			 *
			 * @property noiseIntensity
			 * @type {number}
			 */
			noiseIntensity:
			{
				get: function(){return self.uniforms["nIntensity"].value;},
				set: function(value){self.uniforms["nIntensity"].value = value;}
			},

			/**
			 * Scanline intensity.
			 *
			 * @property scanlinesIntensity
			 * @type {number}
			 */
			scanlinesIntensity:
			{
				get: function() {return self.uniforms["sIntensity"].value;},
				set: function(value) {self.uniforms["sIntensity"].value = value;}
			},

			/**
			 * Number of scanline to be displayed.
			 *
			 * @property scanlinesCount
			 * @type {number}
			 */
			scanlinesCount:
			{
				get: function(){return self.uniforms["sCount"].value;},
				set: function(value){self.uniforms["sCount"].value = value;}
			}
		});

		this.grayscale = (grayscale !== undefined) ? grayscale : false;
		this.noiseIntensity = (noiseIntensity !== undefined) ? noiseIntensity : 0.35;
		this.scanlinesIntensity = (scanlinesIntensity !== undefined) ? scanlinesIntensity : 0.5;
		this.scanlinesCount = (scanlinesCount !== undefined) ? scanlinesCount : 512;
	}
	FilmPass.prototype = Object.create(Pass.prototype);

	FilmPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		this.uniforms["time"].value += delta;
		this.uniforms["tDiffuse"].value = readBuffer.texture;

		this.quad.material = this.material;

		if(this.clear)
		{
			renderer.autoClear = true;
			renderer.autoClearColor = true;
			renderer.autoClearDepth = true;
			renderer.autoClearStencil = true;
		}
		else
		{
			renderer.autoClear = false;
		}

		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
		renderer.render(this.scene, this.camera);
	};

	FilmPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.grayscale = this.grayscale;
		data.noiseIntensity = this.noiseIntensity;
		data.scanlinesIntensity = this.scanlinesIntensity;
		data.scanlinesCount = this.scanlinesCount;

		return data;
	};

	/**
	 * DotScreen pass generates a poster like effect on top of the scene.
	 *  
	 * @class DotScreenPass
	 * @module Postprocessing
	 * @author alteredq / http:// alteredqualia.com/
	 * @param {number} center Dot rotation center.
	 * @param {number} angle Dot rotation angle.
	 * @param {number} scale Dot scale.
	 */
	function DotScreenPass(center, angle, scale)
	{
		if(three.DotScreenShader === undefined)
		{
			console.error("DotScreenPass relies on DotScreenShader");
		}

		Pass.call(this);

		this.type = "DotScreen";
		this.createQuadScene();

		this.uniforms = three.UniformsUtils.clone(three.DotScreenShader.uniforms);

		this.material = new three.ShaderMaterial(
		{
			uniforms: this.uniforms,
			vertexShader: three.DotScreenShader.vertexShader,
			fragmentShader: three.DotScreenShader.fragmentShader
		});
		Object.defineProperties(this,
		{
			/**
			 * Center of rotation of the dot grid in normalized coordinates.
			 *
			 * @property center
			 * @type {Vector2}
			 */
			center:
			{
				get: function() {return this.uniforms["center"].value;},
				set: function(value) {this.uniforms["center"].value = value;}
			},

			/**
			 * Rotation of the dot grid.
			 *
			 * @property angle
			 * @type {number}
			 */
			angle:
			{
				get: function() {return this.uniforms["angle"].value;},
				set: function(value) {this.uniforms["angle"].value = value;}
			},

			/**
			 * Scale of the dots used in the effect.
			 *
			 * @property scale
			 * @type {number}
			 */
			scale:
			{
				get: function() {return this.uniforms["scale"].value;},
				set: function(value) {this.uniforms["scale"].value = value;}
			}
		});

		if(center !== undefined)
		{
			this.center.copy(center);
		}
		
		this.angle = angle !== undefined ? angle : 0.5;
		this.scale = scale !== undefined ? scale : 0.8;
	}
	DotScreenPass.prototype = Object.create(Pass.prototype);

	DotScreenPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		this.uniforms["tDiffuse"].value = readBuffer.texture;
		this.uniforms["tSize"].value.set(readBuffer.width, readBuffer.height);

		this.quad.material = this.material;

		if(this.clear)
		{
			renderer.autoClear = true;
			renderer.autoClearColor = true;
			renderer.autoClearDepth = true;
			renderer.autoClearStencil = true;
		}
		else
		{
			renderer.autoClear = false;
		}

		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
		renderer.render(this.scene, this.camera);
	};

	DotScreenPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.center = this.center.toArray();
		data.angle = this.angle;
		data.scale = this.scale;

		return data;
	};

	/**
	 * Copy pass can be used to copy the actual content on the composer to the screen.
	 *
	 * @class CopyPass
	 * @module Postprocessing
	 */
	function CopyPass()
	{
		ShaderPass.call(this, three.CopyShader);

		this.type = "Copy";
	}

	CopyPass.prototype = Object.create(ShaderPass.prototype);

	/**
	 * Colorify pass can be used to colorify the scene.
	 * 
	 * @class ColorifyPass
	 * @module Postprocessing
	 */
	function ColorifyPass()
	{
		ShaderPass.call(this, three.ColorifyShader);

		this.type = "Colorify";
		Object.defineProperties(this,
		{
			color:
			{
				get: function() {return this.uniforms["color"].value;},
				set: function(value) {this.uniforms["color"].value = value;}
			}
		});
	}

	ColorifyPass.prototype = Object.create(ShaderPass.prototype);

	/**
	 * Serialize pass to json.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata object.
	 */
	ColorifyPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.color = this.color.getHex();
		
		return data;
	};

	/**
	 * Depth-of-field post-process with bokeh shader.
	 * 
	 * @class BokehPass
	 * @module Postprocessing
	 * @param {number} focus Focus distance.
	 * @param {number} aperture Camera aperture.
	 * @param {number} maxblur Maximum level of blur.
	 */

	function BokehPass(focus, aperture, maxblur)
	{
		if(three.BokehShader === undefined)
		{
			console.error("BokehPass relies on BokehShader");
		}

		Pass.call(this);

		this.type = "Bokeh";

		// Render targets
		this.renderTargetColor = new three.WebGLRenderTarget(0, 0, Pass.RGBLinear);
		this.renderTargetDepth = this.renderTargetColor.clone();

		// Depth material
		this.materialDepth = new three.MeshDepthMaterial();
		this.materialDepth.depthPacking = three.RGBADepthPacking;
		this.materialDepth.blending = three.NoBlending;

		// Bokeh material
		this.uniforms = three.UniformsUtils.clone(three.BokehShader.uniforms);
		this.uniforms["tDepth"].value = this.renderTargetDepth.texture;

		this.materialBokeh = new three.ShaderMaterial(
		{
			defines: three.BokehShader.defines,
			uniforms: this.uniforms,
			vertexShader: three.BokehShader.vertexShader,
			fragmentShader: three.BokehShader.fragmentShader
		});

		// Scene
		this.createQuadScene();
		this.quad.material = this.materialBokeh;

		// Setters and getters for uniforms
		var self = this;
		Object.defineProperties(this,
		{
			/**
			 * Camera aperture.
			 *
			 * @property aperture
			 * @type {number}
			 */
			aperture:
			{
				get: function() {return self.uniforms["aperture"].value;},
				set: function(value) {self.uniforms["aperture"].value = value;}
			},

			/**
			 * Focus point distance.
			 *
			 * @property focus
			 * @type {number}
			 */
			focus:
			{
				get: function() {return self.uniforms["focus"].value;},
				set: function(value) {self.uniforms["focus"].value = value;}
			},
			
			/**
			 * Maximum level of blur that can be applied to more distant objects.
			 *
			 * @property enabled
			 * @type {maxblur}
			 */
			maxblur:
			{
				get: function() {return self.uniforms["maxblur"].value;},
				set: function(value) {self.uniforms["maxblur"].value = value;}
			},
		});

		this.focus = (focus !== undefined) ? focus : 1.0;
		this.aperture = (aperture !== undefined) ? aperture : 1.0;
		this.maxblur = (maxblur !== undefined) ? maxblur : 0.2;
	}
	BokehPass.prototype = Object.create(Pass.prototype);

	BokehPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		// Render depth into texture
		scene.overrideMaterial = this.materialDepth;

		renderer.autoClear = false;
		renderer.setClearColor(0xFFFFFF);
		renderer.setClearAlpha(1.0);
		renderer.setRenderTarget(this.renderTargetDepth);
		renderer.clear(true, true, true);
		renderer.render(scene, camera);

		// Update camera uniforms
		this.uniforms["tColor"].value = readBuffer.texture;
		this.uniforms["nearClip"].value = camera.near;
		this.uniforms["farClip"].value = camera.far;
		this.uniforms["aspect"].value = camera.aspect;

		if(this.clear)
		{
			renderer.autoClear = true;
			renderer.autoClearColor = true;
			renderer.autoClearDepth = true;
			renderer.autoClearStencil = true;
		}
		else
		{
			renderer.autoClear = false;
		}

		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
		renderer.render(this.scene, this.camera);

		// Restore scene
		scene.overrideMaterial = null;
	};

	BokehPass.prototype.setSize = function(width, height)
	{
		this.renderTargetColor.setSize(width, height);
		this.renderTargetDepth.setSize(width, height);
	};

	/**
	 * Serialize pass to json.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata object.
	 */
	BokehPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.aperture = this.aperture;
		data.focus = this.focus;
		data.maxblur = this.maxblur;
		
		return data;
	};

	/**
	 * Fast approximate anti-aliasing (FXAA) is an anti-aliasing algorithm to smooth jagged edges on post procesing effects.
	 * 
	 * More information about FXAA available here:
	 *  - https:// developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
	 * 
	 * @class FXAAPass
	 * @module Postprocessing
	 */
	function FXAAPass()
	{
		ShaderPass.call(this, three.FXAAShader);

		this.type = "FXAA";
	}

	FXAAPass.prototype = Object.create(ShaderPass.prototype);

	FXAAPass.prototype.setSize = function(width, height)
	{
		this.uniforms["resolution"].value.set(1.0 / width, 1.0 / height);
	};

	/**
	 * After image render pass blends the current frame with the previous frame.
	 *
	 * A dampening value is applied in the blend, that is performed additively.
	 *  
	 * @class AfterimagePass
	 * @module Postprocessing
	 */
	function AfterimagePass(damp)
	{
		if(three.AfterimageShader === undefined)
		{
			console.error("AfterimagePass relies on AfterimageShader");
		}

		Pass.call(this);

		this.type = "Afterimage";

		this.uniforms = three.UniformsUtils.clone(three.AfterimageShader.uniforms);

		this.textureComp = new three.WebGLRenderTarget(1, 1,
		{
			minFilter: three.LinearFilter,
			magFilter: three.NearestFilter,
			format: three.RGBAFormat
		});

		this.textureOld = new three.WebGLRenderTarget(1, 1,
		{
			minFilter: three.LinearFilter,
			magFilter: three.NearestFilter,
			format: three.RGBAFormat
		});

		this.shaderMaterial = new three.ShaderMaterial(
		{
			uniforms: this.uniforms,
			vertexShader: three.AfterimageShader.vertexShader,
			fragmentShader: three.AfterimageShader.fragmentShader
		});

		this.basicMaterial = new three.MeshBasicMaterial();

		this.createQuadScene();
		Object.defineProperties(this,
		{
			/**
			 * Dampening applied to the previous frame.
			 *
			 * @property damp
			 * @type {number}
			 */
			damp:
			{
				get: function() {return this.uniforms["damp"].value;},
				set: function(value) {this.uniforms["damp"].value = value;}
			}
		});

		this.damp = damp !== undefined ? damp : 0.96;
	}
	AfterimagePass.prototype = Object.create(Pass.prototype);

	AfterimagePass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive, scene, camera)
	{
		// Swap texture
		var temp = this.textureOld;
		this.textureOld = this.textureComp;
		this.textureComp = temp;

		// Setup uniforms
		this.uniforms["tNew"].value = readBuffer.texture;
		this.uniforms["tOld"].value = this.textureOld.texture;

		// Render textureComp
		this.quad.material = this.shaderMaterial;
		renderer.autoClear = false;
		renderer.setRenderTarget(this.textureComp);
		renderer.render(this.scene, this.camera);

		// Set copy from texture
		this.basicMaterial.map = this.textureComp.texture;

		// Clear configuration
		if(this.clear)
		{
			renderer.autoClear = true;
			renderer.autoClearColor = true;
			renderer.autoClearDepth = true;
			renderer.autoClearStencil = true;
		}
		else
		{
			renderer.autoClear = false;
		}

		this.quad.material = this.basicMaterial;
		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
		renderer.render(this.scene, this.camera);
	};


	AfterimagePass.prototype.setSize = function(width, height)
	{
		this.textureComp.setSize(width, height);
		this.textureOld.setSize(width, height);
	};

	AfterimagePass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.damp = this.damp;

		return data;
	};

	/**
	 * Generate a texture that represents the luminosity of the current scene, adapted over time to simulate the optic nerve responding to the amount of light it is receiving.
	 *
	 * Based on a GDC2007 presentation by Wolfgang Engel titled "Post-Processing Pipeline"
	 *
	 * Full-screen tone-mapping shader based on http:// www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
	 *
	 * class AdaptiveToneMappingPass
	 * @module Postprocessing
	 * @author miibond
	 */
	function AdaptiveToneMappingPass(adaptive, resolution)
	{
		Pass.call(this);
		var self = this;
		
		this.type = "AdaptiveToneMapping";
		this.needsInit = true;

		this.resolution = resolution !== undefined ? resolution : 256;
		this._adaptive = adaptive !== undefined ? adaptive : true;

		this.luminanceRT = null;
		this.previousLuminanceRT = null;
		this.currentLuminanceRT = null;

		this.copyUniforms = three.UniformsUtils.clone(three.CopyShader.uniforms);
		this.materialCopy = new three.ShaderMaterial(
		{
			uniforms: this.copyUniforms,
			vertexShader: three.CopyShader.vertexShader,
			fragmentShader: three.CopyShader.fragmentShader,
			blending: three.NoBlending,
			depthTest: false
		});

		this.materialLuminance = new three.ShaderMaterial(
		{
			uniforms: three.UniformsUtils.clone(three.LuminosityShader.uniforms),
			vertexShader: three.LuminosityShader.vertexShader,
			fragmentShader: three.LuminosityShader.fragmentShader,
			blending: three.NoBlending
		});

		this.createShader();

		if(three.ToneMapShader === undefined)
		{
			console.error("nunuStudio: AdaptiveToneMappingPass relies on ToneMapShader");
		}

		this.materialToneMap = new three.ShaderMaterial(
		{
			uniforms: three.UniformsUtils.clone(three.ToneMapShader.uniforms),
			vertexShader: three.ToneMapShader.vertexShader,
			fragmentShader: three.ToneMapShader.fragmentShader,
			blending: three.NoBlending
		});

		this.createQuadScene();

		Object.defineProperties(this,
		{
			/**
			 * Minimum luminance.
			 *
			 * @property minLuminance
			 * @type {number}
			 */
			minLuminance:
			{
				get: function(){return self.adaptLuminanceShader.uniforms["minLuminance"].value;},
				set: function(value){self.adaptLuminanceShader.uniforms["minLuminance"].value = value;}
			},

			/**
			 * Rate of luminance variation (adaptation rate).
			 *
			 * @property tau
			 * @type {number}
			 */
			tau:
			{
				get: function(){return self.adaptLuminanceShader.uniforms["tau"].value;},
				set: function(value){self.adaptLuminanceShader.uniforms["tau"].value = value;}
			},

			/**
			 * Rate of luminance variation (adaptation rate).
			 *
			 * @property tau
			 * @type {number}
			 */
			adaptive:
			{
				get: function(){return self._adaptive;},
				set: function(adaptive)
				{
					if(adaptive)
					{
						this._adaptive = true;
						this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
						this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
					}
					else
					{
						this._adaptive = false;
						delete this.materialToneMap.defines["ADAPTED_LUMINANCE"];
						this.materialToneMap.uniforms.luminanceMap.value = null;
					}

					this.materialToneMap.needsUpdate = true;
				}
			}
		});
	}
	AdaptiveToneMappingPass.prototype = Object.create(Pass.prototype);

	AdaptiveToneMappingPass.prototype.constructor = AdaptiveToneMappingPass;

	AdaptiveToneMappingPass.prototype.render = function(renderer, writeBuffer, readBuffer, delta, maskActive)
	{
		if(this.needsInit)
		{
			this.reset();

			this.luminanceRT.texture.type = readBuffer.texture.type;
			this.previousLuminanceRT.texture.type = readBuffer.texture.type;
			this.currentLuminanceRT.texture.type = readBuffer.texture.type;
			this.needsInit = false;
		}

		if(this._adaptive)
		{
			// Render the luminance of the current scene into a render target with mipmapping enabled
			this.quad.material = this.materialLuminance;
			this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;
			renderer.setRenderTarget(this.currentLuminanceRT);
			renderer.render(this.scene, this.camera);

			// Use the new luminance values, the previous luminance and the frame delta to adapt the luminance over time.
			this.quad.material = this.materialAdaptiveLum;
			this.materialAdaptiveLum.uniforms.delta.value = delta;
			this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;
			this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;
			renderer.setRenderTarget(this.luminanceRT);
			renderer.render(this.scene, this.camera);

			// Copy the new adapted luminance value so that it can be used by the next frame.
			this.quad.material = this.materialCopy;
			this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;
			renderer.setRenderTarget(this.previousLuminanceRT);
			renderer.render(this.scene, this.camera);
		}

		this.quad.material = this.materialToneMap;
		this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;

		if(this.clear)
		{
			renderer.autoClear = true;
			renderer.autoClearColor = true;
			renderer.autoClearDepth = true;
			renderer.autoClearStencil = true;
		}
		else
		{
			renderer.autoClear = false;
		}

		renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);
		renderer.render(this.scene, this.camera);
	};

	AdaptiveToneMappingPass.prototype.createShader = function()
	{
		this.adaptLuminanceShader =
		{
			defines:
			{
				MIP_LEVEL_1X1 : (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)
			},
			uniforms:
			{
				lastLum: {value: null},
				currentLum: {value: null},
				minLuminance: {value: 0.01},
				delta: {value: 0.016},
				tau: {value: 1.0}
			},
			vertexShader:
			"varying vec2 vUv;\n\
		void main(){\n\
		\n\
			vUv = uv;\n\
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
		\n\
		}",
			fragmentShader:
			"varying vec2 vUv;\n\
		\n\
		uniform sampler2D lastLum;\n\
		uniform sampler2D currentLum;\n\
		uniform float minLuminance;\n\
		uniform float delta;\n\
		uniform float tau;\n\
		\n\
		void main()\n\
		{\n\
			vec4 lastLum = texture2D(lastLum, vUv, MIP_LEVEL_1X1);\n\
			vec4 currentLum = texture2D(currentLum, vUv, MIP_LEVEL_1X1);\n\
			\n\
			float fLastLum = max(minLuminance, lastLum.r);\n\
			float fCurrentLum = max(minLuminance, currentLum.r);\n\
			\n\
			// The adaption seems to work better in extreme lighting differences if the input luminance is squared.\
			fCurrentLum *= fCurrentLum;\n\
			\n\
			// Adapt the luminance using Pattanaik's technique\
			float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\n\
			gl_FragColor.r = fAdaptedLum;\n\
		}",
		};

		this.materialAdaptiveLum = new three.ShaderMaterial(
		{
			uniforms: three.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),
			vertexShader: this.adaptLuminanceShader.vertexShader,
			fragmentShader: this.adaptLuminanceShader.fragmentShader,
			defines: this.adaptLuminanceShader.defines,
			blending: three.NoBlending
		});
	};

	AdaptiveToneMappingPass.prototype.reset = function()
	{
		// Render targets
		if(this.luminanceRT)
		{
			this.luminanceRT.dispose();
		}
		if(this.currentLuminanceRT)
		{
			this.currentLuminanceRT.dispose();
		}
		if(this.previousLuminanceRT)
		{
			this.previousLuminanceRT.dispose();
		}

		this.luminanceRT = new three.WebGLRenderTarget(this.resolution, this.resolution, Pass.RGBALinear);
		this.luminanceRT.texture.generateMipmaps = false;

		this.previousLuminanceRT = new three.WebGLRenderTarget(this.resolution, this.resolution, Pass.RGBALinear);
		this.previousLuminanceRT.texture.generateMipmaps = false;

		// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader
		this.currentLuminanceRT = new three.WebGLRenderTarget(this.resolution, this.resolution,
		{
			minFilter: three.LinearMipMapLinearFilter,
			magFilter: three.LinearFilter,
			format: three.RGBAFormat
		});

		if(this._adaptive)
		{
			this.materialToneMap.defines["ADAPTED_LUMINANCE"] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;
		}

		// Put something in the adaptive luminance texture so that the scene can render initially
		this.quad.material = new three.MeshBasicMaterial({color: 0x777777});
		this.materialLuminance.needsUpdate = true;
		this.materialAdaptiveLum.needsUpdate = true;
		this.materialToneMap.needsUpdate = true;
	};

	AdaptiveToneMappingPass.prototype.dispose = function()
	{
		if(this.luminanceRT)
		{
			this.luminanceRT.dispose();
		}
		if(this.previousLuminanceRT)
		{
			this.previousLuminanceRT.dispose();
		}
		if(this.currentLuminanceRT)
		{
			this.currentLuminanceRT.dispose();
		}
		if(this.materialLuminance)
		{
			this.materialLuminance.dispose();
		}
		if(this.materialAdaptiveLum)
		{
			this.materialAdaptiveLum.dispose();
		}
		if(this.materialCopy)
		{
			this.materialCopy.dispose();
		}
		if(this.materialToneMap)
		{
			this.materialToneMap.dispose();
		}
	};

	AdaptiveToneMappingPass.prototype.toJSON = function(meta)
	{
		var data = Pass.prototype.toJSON.call(this, meta);

		data.minLuminance = this.minLuminance;
		data.tau = this.tau;
		data.adaptive = this._adaptive;

		return data;
	};

	/**
	 * The effect composer is used to organize multiple post-processing passes.
	 *
	 * It is used by camera objects to organize the rendering pipeline.
	 * 
	 * @class EffectComposer
	 * @module Postprocessing
	 */
	function EffectComposer()
	{
		if(three.CopyShader === undefined)
		{
			console.error("EffectComposer relies on CopyShader");
		}

		this.uuid = three.Math.generateUUID();
		this.width = 1;
		this.height = 1;

		/**
		 * Passes attached to this effect composer.
		 *
		 * The passes are rendered in order.
		 *
		 * @property passes
		 * @type {Array}
		 */
		this.passes = [];

		/**
		 * Input buffer passed to the render pass.
		 *
		 * @property writeBuffer
		 * @type {WebGLRenderTarget}
		 */
		this.writeBuffer = new three.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);

		/**
		 * Input buffer passed to the render pass.
		 *
		 * @property readBuffer
		 * @type {WebGLRenderTarget}
		 */
		this.readBuffer = new three.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);

		/**
		 * Copy shader used to copy data between the read and write buffer or to copy the writeBuffer to screen when necessary.
		 *
		 * @property copyPass
		 * @type {ShaderPass}
		 */
		this.copyPass = new ShaderPass(three.CopyShader);

		/**
		 * Renderer state configuration, stored the clear configuration of the renderer.
		 *
		 * Used to store and restore states.
		 *
		 * @property rendererState
		 * @type {RendererState}
		 */
		this.rendererState = new RendererState();
	}

	EffectComposer.bufferParameters =
	{
		minFilter: three.LinearFilter,
		magFilter: three.LinearFilter,
		format: three.RGBAFormat,
		stencilBuffer: false
	};

	/**
	 * Swap rendering buffers.
	 *
	 * Used to make the output buffer of a render pass the input of the next one.
	 * 
	 * @method swapBuffers
	 */
	EffectComposer.prototype.swapBuffers = function()
	{
		var temp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = temp;
	};

	/**
	 * Add new pass to the composer.
	 * 
	 * @method addPass
	 * @param {Pass} pass Rendering pass to be added.
	 */
	EffectComposer.prototype.addPass = function(pass)
	{
		this.passes.push(pass);
	};

	/**
	 * Move pass back in the list of render passes.
	 *
	 * Moving back means that the pass is rendered earlier in the pipeline.
	 * 
	 * @method moveBack
	 * @param {Pass} pass Pass to be moved.
	 * @return {boolean} Returns true on success, false otherwise.
	 */
	EffectComposer.prototype.moveBack = function(pass)
	{
		var index = this.passes.indexOf(pass);

		if(index > 0)
		{
			for(var k = index; k !== index - 1 ; k -= 1)
			{
				this.passes[k] = this.passes[k - 1];
			}
			this.passes[index - 1] = pass;

			return true;
		}

		return false;
	};

	/**
	 * Move pass forward in the list of render passes.
	 *
	 * Moving forward in the list means being renderer later down the pipeline.
	 * 
	 * @method moveForward
	 * @param {Pass} pass Pass to be moved.
	 * @return {boolean} Returns true on success, false otherwise.
	 */
	EffectComposer.prototype.moveForward = function(pass)
	{
		var index = this.passes.indexOf(pass);

		if(index !== -1 && index < this.passes.length - 1)
		{
			for(var k = index; k !== index + 1 ; k += 1)
			{
				this.passes[k] = this.passes[k + 1];
			}
			this.passes[index + 1] = pass;

			return true;
		}

		return false;
	};

	/**
	 * Remove pass from this composer, if pass is not found nothing happens.
	 *
	 * @method removePass
	 * @param {Pass} pass Pass to be removed from the composer.
	 */
	EffectComposer.prototype.removePass = function(pass)
	{
		var index = this.passes.indexOf(pass);
		if(index !== -1)
		{
			this.passes.splice(index, 1);
		}
	};

	/**
	 * Insert new pass into the composer in a specific position.
	 *
	 * @method insertPass
	 * @param {Pass} pass Rendering pass to be added.
	 * @param {number} index Index to be inserted on.
	 */
	EffectComposer.prototype.insertPass = function(pass, index)
	{
		this.passes.splice(index, 0, pass);
	};

	/**
	 * Render a scene using this effect composer and a renderer.
	 *
	 * @method render
	 * @param {WebGLRenderer} renderer Render to be used to render the scene.
	 * @param {Scene} scene Scene to render.
	 * @param {[type]} delta Delta time. 
	 */
	EffectComposer.prototype.render = function(renderer, scene, camera, delta)
	{
		var maskActive = false;

		this.rendererState.backup(renderer);

		for(var i = 0; i < this.passes.length; i++)
		{
			var pass = this.passes[i];

			// Render pass if its enabled
			if(pass.enabled)
			{
				pass.render(renderer, this.writeBuffer, this.readBuffer, delta, maskActive, scene, camera);

				// If rendered to screen stop here
				if(pass.renderToScreen)
				{
					// Copy writeBuffer to screen
					if(pass.copyToScreen)
					{
						this.copyPass.renderToScreen = true;
						this.copyPass.render(renderer, this.readBuffer, this.writeBuffer, delta);
					}

					break;
				}

				// Swap read and write buffers
				if(pass.needsSwap)
				{
					if(maskActive)
					{
						renderer.context.stencilFunc(renderer.context.NOTEQUAL, 1, 0xFFFFFFff);
						this.copyPass.renderToScreen = false;
						this.copyPass.render(renderer, this.writeBuffer, this.readBuffer, delta);
						renderer.context.stencilFunc(renderer.context.EQUAL, 1, 0xFFFFFFff);
					}

					this.swapBuffers();
				}

				// Check mask passes
				if(three.MaskPass !== undefined)
				{
					if(pass instanceof three.MaskPass)
					{
						maskActive = true;
					}
					else if(pass instanceof three.ClearMaskPass)
					{
						maskActive = false;
					}
				}
			}
		}

		this.rendererState.restore(renderer);
	};

	/**
	 * Set rendering size for the composer.
	 *
	 * Also updates the size for all passes attached to the composer.
	 *
	 * @method setSize
	 * @param {number} width Width.
	 * @param {number} height Height.
	 */
	EffectComposer.prototype.setSize = function(width, height)
	{
		width = three.Math.floor(width);
		height = three.Math.floor(height);

		this.width = width;
		this.height = height;

		this.writeBuffer.setSize(width, height);
		this.readBuffer.setSize(width, height);

		for(var i = 0; i < this.passes.length; i++)
		{
			this.passes[i].setSize(width, height);
		}
	};

	/**
	 * Reset this effect composer.
	 *
	 * @method reset
	 */
	EffectComposer.prototype.reset = function()
	{
		this.dispose();

		this.writeBuffer = new three.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);

		this.readBuffer = new three.WebGLRenderTarget(this.width, this.height, EffectComposer.bufferParameters);
	};

	/**
	 * Dispose this effect composer.
	 * 
	 * @method dispose
	 */
	EffectComposer.prototype.dispose = function()
	{
		this.writeBuffer.dispose();
		this.readBuffer.dispose();

		this.writeBuffer = null;
		this.readBuffer = null;
	};

	/**
	 * Serialize this effect composer to JSON.
	 *
	 * @method toJSON
	 */
	EffectComposer.prototype.toJSON = function()
	{
		var data = {};

		data.uuid = this.uuid;
		data.passes = [];
		
		for(var i = 0; i < this.passes.length; i++)
		{
			data.passes.push(this.passes[i].toJSON());
		}

		return data;
	};

	/**
	 * Create a new effect composer loaded from json data.
	 * 
	 * @static
	 * @method fromJSON
	 * @param {Object} json JSON data to load.
	 * @return {EffectComposer} Composer loaded from data.
	 */
	EffectComposer.fromJSON = function(json)
	{
		var composer = new EffectComposer();
		composer.uuid = json.uuid;

		for(var i = 0; i < json.passes.length; i++)
		{	
			var data = json.passes[i];
			var pass = null;

			if(data.type === "Render")
			{
				pass = new RenderPass();
			}
			else if(data.type === "UnrealBloom")
			{
				pass = new UnrealBloomPass();
				pass.strength = data.strength;
				pass.radius = data.radius;
				pass.threshold = data.threshold;
				pass.bloomFactors = data.bloomFactors;

				for(var i = 0; i < pass.bloomTintColors.length; i++)
				{
					pass.bloomTintColors[i].fromArray(data.bloomTintColors[i]);
				}
			}
			else if(data.type === "Bloom")
			{
				pass = new BloomPass(data.strength, data.kernelSize, data.sigma, data.resolution);
			}
			else if(data.type === "SSAONOH")
			{
				pass = new SSAONOHPass();
				pass.kernelRadius = data.kernelRadius;
				pass.minDistance = data.minDistance;
				pass.maxDistance = data.maxDistance;
				pass.kernelSize = data.kernelSize;
			}
			else if(data.type === "SSAO")
			{
				pass = new SSAOPass();
				pass.onlyAO = data.onlyAO;
				pass.radius = data.radius;
				pass.aoClamp = data.aoClamp;
				pass.lumInfluence = data.lumInfluence;
			}
			else if(data.type === "Bokeh")
			{
				pass = new BokehPass(data.focus, data.aperture, data.maxblur);
			}
			else if(data.type === "FXAA")
			{
				pass = new FXAAPass();
			}
			else if(data.type === "Copy")
			{
				pass = new CopyPass();
			}
			else if(data.type === "Film")
			{
				pass = new FilmPass();
				pass.grayscale = data.grayscale;
				pass.noiseIntensity = data.noiseIntensity;
				pass.scanlinesIntensity = data.scanlinesIntensity;
				pass.scanlinesCount = data.scanlinesCount;
			}
			else if(data.type === "DotScreen")
			{
				pass = new DotScreenPass();
				pass.center.fromArray(data.center);
				pass.angle = data.angle;
				pass.scale = data.scale;
			}
			else if(data.type === "Colorify")
			{
				pass = new ColorifyPass();
				pass.color.setHex(data.color);
			}
			else if(data.type === "Sobel")
			{
				pass = new SobelPass();
			}
			else if(data.type === "Technicolor")
			{
				pass = new TechnicolorPass();
			}
			else if(data.type === "HueSaturation")
			{
				pass = new HueSaturationPass();
				pass.hue = data.hue;
				pass.saturation = data.saturation;
			}
			else if(data.type === "AdaptiveToneMapping")
			{
				pass = new AdaptiveToneMappingPass(data.adaptive);
				pass.tau = data.tau;
				pass.minLuminance = data.minLuminance;
			}
			else if(data.type === "Afterimage")
			{
				pass = new AfterimagePass();
				pass.damp = data.damp;
			}
			else
			{
				pass = new RenderPass();
			}

			pass.uuid = data.uuid;
			pass.enabled = data.enabled;
			pass.needsSwap = data.needsSwap;
			pass.renderToScreen = data.renderToScreen;
			pass.clear = data.clear;
			pass.copyToScreen = data.copyToScreen === true;

			composer.addPass(pass);
		}
		
		return composer;
	};

	/**
	 * Canvas textures can be used to draw content to the texture during runtime, using the context property.
	 * 
	 * Canvas textures always start with black background and a red text "Canvas Texture".
	 * 
	 * @class CanvasTexture
	 * @extends {Texture}
	 * @module Textures
	 * @param {number} width Canvas width
	 * @param {number} height Canvas height
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} magFilter
	 * @param {number} minFilter
	 * @param {number} format
	 * @param {number} type
	 * @param {number} anisotropy
	 * @param {number} encoding
	 */
	function CanvasTexture(width, height, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)
	{
		/**
		 * Image is used to store a DOM canvas element.
		 * 
		 * @property image
		 * @type {Element}
		 */
		three.Texture.call(this, document.createElement("canvas"), mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.name = "canvas";
		this.category = "Canvas";
		this.format = three.RGBAFormat;

		Object.defineProperties(this,
		{
			/**
			 * Canvas width, internal resolution of the canvas texture.
			 * 
			 * @property width
			 * @type {number}
			 */
			width:
			{
				get: function(){return this.image.width;},
				set: function(value){this.image.width = value;}
			},

			/**
			 * Canvas height, internal resolution of the canvas texture.
			 * 
			 * @property height
			 * @type {number}
			 */
			height:
			{
				get: function(){return this.image.height;},
				set: function(value){this.image.height = value;}
			}
		});

		this.width = (width !== undefined) ? width : 1;
		this.height = (height !== undefined) ? height : 1;

		/**
		 * Canvas context 2D, can be used to draw content do the canvas texture.
		 * 
		 * @property context
		 * @type {Context2D}
		 */
		this.context = this.image.getContext("2d");
	}

	CanvasTexture.prototype = Object.create(three.Texture.prototype);
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * Draw a placeholder figure into the canvas texture.
	 * 
	 * @method placeholder
	 */
	CanvasTexture.prototype.placeholder = function()
	{	
		this.context.fillStyle = "#000000";
		this.context.fillRect(0, 0, this.width, this.height);
		this.context.font = "Normal " + Math.round(this.width / 12) +  "px Arial";
		this.context.textAlign = "center";
		this.context.fillStyle = "#FF0000";
		this.context.fillText("Canvas Texture", this.width/2, this.height/2);
		this.needsUpdate = true;
	};

	/**
	 * Clear canvas texture with a background color.
	 *
	 * Uses the internal context to draw a rect to fill the canvas.
	 *
	 * @method clear
	 * @param {string} color
	 */
	CanvasTexture.prototype.clear = function(color)
	{
		if(color === undefined)
		{
			this.context.clearRect(0, 0, width, height);
		}
		else
		{
			this.context.fillStyle = color;
			this.context.fillRect(0, 0, this.width, this.height);
		}
	};

	/**
	 * Create JSON description for canvas texture, canvas image is not serialized.
	 * 
	 * @param {Object} meta
	 * @method toJSON
	 */
	CanvasTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);

		data.width = this.width;
		data.height = this.height;

		return data;
	};

	/**
	 * Canvas sprite is used to render canvas based elements in a 2D canvas.
	 *
	 * The sprite can be configured to keep a relative size to the screen of an absolute size.
	 * 
	 * @class CanvasSprite
	 * @extends {Sprite}
	 */
	function CanvasSprite()
	{
		/**
		 * Texture where the text is drawn to.
		 * 
		 * @attribute texture
		 * @type {CanvasTexture}
		 */
		this.texture = new CanvasTexture();

		/**
		 * DOM canvas to draw.
		 * 
		 * @attribute canvas
		 * @type {Element}
		 */
		this.canvas = this.texture.image;

		var material = new three.SpriteMaterial(
		{
			map: this.texture,
			color: 0xFFFFFF,
			transparent: true,
			alphaTest: 0.4,
			depthTest: true,
			depthWrite: true,
			sizeAttenuation: true
		});

		three.Sprite.call(this, material);

		this.name = "sprite";
		this.type = "CanvasSprite";

		Object.defineProperties(this,
		{
			/**
			 * Size attenuation indicates how the sprite should be scaled relative to the camera.
			 *
			 * @attribute sizeAttenuation
			 * @type {number}
			 */
			sizeAttenuation:
			{
				get: function(){return this.material.sizeAttenuation;},
				set: function(value)
				{
					this.material.sizeAttenuation = value;
					this.material.needsUpdate = true;
				}
			}
		});
	}	

	CanvasSprite.prototype = Object.create(three.Sprite.prototype);

	/**
	 * Text sprite is used to represent text as a sprite.
	 * 
	 * This approach is memory expensive since it needs to write a new texture for each text. But allows the used to access any font available in the browser.
	 *
	 * The text is rendered to canvas and then copied to a texture. It automatically ajusts the object scale to match the text aspect.
	 * 
	 * @class TextSprite
	 * @extends {CanvasSprite}
	 */
	function TextSprite()
	{
		CanvasSprite.call(this);
		
		this.name = "text";
		this.type = "TextSprite";
		
		var text = "";
		var color = "#FFFFFF";
		var outline = true;
		var outlineColor = "#000000";
		var outlineWidth = 1;
		var resolution = 32;
		var align = TextSprite.CENTER;
		var font = "arial";

		Object.defineProperties(this,
		{
			/**
			 * CSS Font style to be used.
			 * 
			 * @attribute font
			 * @type {string}
			 */
			font:
			{
				get: function(){return font;},
				set: function(value){font = value; this.drawText();}
			},

			/**
			 * Horizontal text alignment can be
			 *    - TextSprite.LEFT
			 *    - TextSprite.RIGHT
			 *    - TextSprite.CENTER
			 *
			 * @attribute align
			 * @type {string}
			 */
			align:
			{
				get: function(){return align;},
				set: function(value){align = value; this.drawText();}
			},

			/**
			 * CSS color of the text.
			 * 
			 * @attribute color
			 * @type {string}
			 */
			color:
			{
				get: function(){return color;},
				set: function(value){color = value; this.drawText();}
			},

			/**
			 * Text of this object.
			 * 
			 * @attribute text
			 * @type {string}
			 */
			text:
			{
				get: function(){return text;},
				set: function(value)
				{
					if(value !== text)
					{
						text = value;
						this.drawText();
					}
				}
			},

			/**
			 * Indicates if the text has an outline border.
			 * 
			 * @attribute outline
			 * @type {boolean}
			 */
			outline:
			{
				get: function(){return outline;},
				set: function(value){outline = value; this.drawText();}
			},

			/**
			 * CSS color of the outline.
			 * 
			 * @attribute outlineColor
			 * @type {string}
			 */
			outlineColor:
			{
				get: function(){return outlineColor;},
				set: function(value){outlineColor = value; this.drawText();}
			},

			/**
			 * Width of the text outline.
			 * 
			 * @attribute outlineWidth
			 * @type {number}
			 */
			outlineWidth:
			{
				get: function(){return outlineWidth;},
				set: function(value){outlineWidth = value; this.drawText();}
			},

			/**
			 * Vertical resolution of the texture created from canvas used.
			 * 
			 * Should always be a npot of 2.
			 *
			 * @attribute resolution
			 * @type {number}
			 */
			resolution:
			{
				get: function(){return resolution;},
				set: function(value){resolution = value; this.drawText();}
			}
		});

		this.text = "text";
	}

	TextSprite.prototype = Object.create(CanvasSprite.prototype);

	/**
	 * Align text to the left side.
	 *
	 * @static
	 * @attribute LEFT
	 * @type {string}
	 */
	TextSprite.LEFT = "left";

	/**
	 * Align text to the center.
	 *
	 * @static
	 * @attribute CENTER
	 * @type {string}
	 */
	TextSprite.CENTER = "center";

	/**
	 * Align text to the right side.
	 *
	 * @static
	 * @attribute RIGHT
	 * @type {string}
	 */
	TextSprite.RIGHT = "right";

	/**
	 * Update the canvas texture, redrawText text into the canvas.
	 *
	 * @method drawText
	 */
	TextSprite.prototype.drawText = function()
	{
		var height = this.resolution;
		var fontSize = height * 0.8;

		var context = this.texture.context;
		context.font = fontSize + "px " + this.font;

		var size = context.measureText(this.text).width;
		var width = three.Math.ceilPowerOfTwo(size);
		var ratio = width / height;

		this.texture.width = width;
		this.texture.height = height;

		context.clearRect(0, 0, width, height);
		
		if(this.text.length === 0)
		{
			return;
		}

		context.font = fontSize + "px " + this.font;
		context.textAlign = this.align;
		context.textBaseline = "middle";
		context.fillStyle = this.color;
		context.fillText(this.text, width / 2, height / 2);
		
		if(this.outline === true)
		{
			context.lineWidth = this.outlineWidth;
			context.strokeStyle = this.outlineColor;
			context.strokeText(this.text, width / 2, height / 2);
		}

		this.scale.x = ratio * this.scale.y;
		this.texture.needsUpdate = true;
	};

	TextSprite.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.text = this.text;
		data.object.color = this.color;
		data.object.outline = this.outline;
		data.object.outlineColor = this.outlineColor;
		data.object.outlineWidth = this.outlineWidth;
		data.object.resolution = this.resolution;
		data.object.align = this.align;
		data.object.font = this.font;

		return data;
	};


	TextSprite.fromJSON = function(data)
	{
		var object = new TextSprite();
		object.text = data.text;
		object.color = data.color;
		object.outline = data.outline;
		object.outlineColor = data.outlineColor;
		object.outlineWidth = data.outlineWidth;
		object.resolution = data.resolution;
		object.align = data.align;
		object.font = data.font;
		
		return object;
	};

	/**
	 * Text bitmap atlas with support for signed distance field data.
	 *
	 * Input data should be composed of a BMFont file (can be a .fnt, .json. etc) file and a character atlas texture from an image.
	 *
	 * Font atlas can be generate using the tool http:// www.angelcode.com/products/bmfont/
	 *
	 * Based on the three-bmfont-text library.
	 *  - https:// github.com/Jam3/three-bmfont-text
	 *  - https:// github.com/Jam3/load-bmfont
	 *
	 * @class TextBitmap
	 * @extends {Mesh}
	 * @param {Object} config Configuration object with all parameters for bmfont.
	 * @param {Texture} texture Texture with the image character atlas to be used.
	 * @param {number} shader The text rendering shader to be used (Bitmap, SDF, MSDF).
	 * @param {number} color Color of the text.
	 */
	function TextBitmap(config, texture, shader, color)
	{
		if(config.font === undefined)
		{
			throw new Error("TextBitmap configuration font is required.");
		}

		if(config.width === undefined){config.width = 500;}
		if(config.align === undefined){config.align = TextBitmap.CENTER;}
		if(config.lineHeight === undefined){config.lineHeight = config.font.common.lineHeight;}
		if(config.letterSpacing === undefined){config.letterSpacing = 5;}
		if(config.text === undefined){config.text = "";}

		/**
		 * BMFont text configuration object.
		 *
		 * Passed to the BMFont text geometry generator. It is a object with the format.
		 *
		 * {
		 *    font: (Object) Font data should be parsed from (.json, .fnt, etc) file,
		 *    text: (String),
		 *    width: (Number) Width of the text area,
		 *    align: (String) Side to align the text,
		 *    lineHeight: (Number) Line height/font size,
		 *    letterSpacing: (Number) Spacing between characters,
		 *    mode: (String) a mode for word-wrapper; can be 'pre' (maintain spacing), or 'nowrap' (collapse whitespace but only break on newline characters), otherwise assumes normal word-wrap behaviour (collapse whitespace, break at width or newlines)
		 *    tabSize: (Number) the number of spaces to use in a single tab (default 4)
		 *    start: (Number) the starting index into the text to layout (default 0)
		 *    end: (Number) the ending index (exclusive) into the text to layout (default text.length)
		 * }
		 *
		 * @attribute config
		 * @type {Object}
		 */
		this.config = config;

		/**
		 * Uniforms passed to the text rendering shaders.
		 *
		 * @attribute uniforms
		 * @type {Object}
		 */
		this.uniforms =
		{
			map: {type: "t", value: texture},
			color: {type: "v3", value: new three.Color(color !== undefined ? color : 0xFFFFFF)},
			smoothing: {type: "f", value: 0.0},
			threshold: {type: "f", value: 0.4}
		};

		three.Mesh.call(this, createGeometry(this.config), null);

		this.name = "text";
		this.type = "TextBitmap";

		var shader = shader !== undefined ? shader : TextBitmap.BITMAP;
		var fontScale = 0.01;

		Object.defineProperties(this,
		{
			/**
			 * Scale applied to the generated text geometry.
			 *
			 * @attribute fontScale
			 * @type {number}
			 */
			fontScale:
			{
				get: function(){return fontScale;},
				set: function(value){fontScale = value; this.updateGeometry();}
			},

			/**
			 * Text bitmap rendering shader, can be:
			 *    - TextBitmap.BITMAP 
			 *    - TextBitmap.SDF 
			 *    - TextBitmap.MSDF 
			 *
			 * @attribute shader
			 * @type {number}
			 */
			shader:
			{
				get: function(){return shader;},
				set: function(value){shader = value; this.updateShader();}
			},

			/**
			 * Texture containing the bitmap characters.
			 *
			 * Data specifiyng the position of each character in the texture should be placed in the font.
			 *
			 * @attribute texture
			 * @type {Texture}
			 */
			texture:
			{
				get: function(){return this.uniforms.map.value;},
				set: function(value){this.uniforms.map.value = value; this.material.needsUpdate = true;}
			},

			/**
			 * BMFont text font data, contains the data about all characters available, and their position in the atlas.
			 *
			 * Font data should be parsed from (.json, .fnt, etc) file.
			 *
			 * Passed to the BMFont text geometry generator.
			 *
			 * @attribute font
			 * @type {Object}
			 */
			font: 
			{
				get: function(){return this.config.font;},
				set: function(value){this.config.font = value; this.updateGeometry();}
			},

			/** 
			 * Text displayed on the object.
			 *
			 * @attribute text
			 * @type {string}
			 */
			text:
			{
				get: function(){return this.config.text;},
				set: function(value)
				{
					if(this.config.text !== value)
					{					
						this.config.text = value;
						this.updateGeometry();
					}
				}
			},

			/**
			 * Space between each text line.
			 *
			 * @attribute lineHeight
			 * @type {number}
			 */
			lineHeight:
			{
				get: function(){return this.config.lineHeight;},
				set: function(value){this.config.lineHeight = value; this.updateGeometry();}
			},
			
			/**
			 * Spacing between each letter.
			 *
			 * @attribute letterSpacing
			 * @type {number}
			 */
			letterSpacing:
			{
				get: function(){return this.config.letterSpacing;},
				set: function(value){this.config.letterSpacing = value; this.updateGeometry();}
			},

			/**
			 * Horizontal text alignment can be
			 *    - TextBitmap.LEFT
			 *    - TextBitmap.RIGHT
			 *    - TextBitmap.CENTER
			 *
			 * @attribute align
			 * @type {string}
			 */
			align:
			{
				get: function(){return this.config.align;},
				set: function(value){this.config.align = value; this.updateGeometry();}
			},

			/** 
			 * Width of the text box.
			 *
			 * @attribute width
			 * @type {number}
			 */
			width:
			{
				get: function(){return this.config.width;},
				set: function(value){this.config.width = value; this.updateGeometry();}
			},

			/** 
			 * Color of the text, only applied for SDF and MSDF modes.
			 *
			 * @attribute color
			 * @type {Color}
			 */
			color:
			{
				get: function(){return this.uniforms.color.value;},
				set: function(value){this.uniforms.color.value = value;}
			},

			/** 
			 * SDF distance alpha threshold.
			 *
			 * @attribute threshold
			 * @type {number}
			 */
			threshold: 
			{
				get: function(){return this.uniforms.threshold.value;},
				set: function(value){this.uniforms.threshold.value = value;}
			},

			/** 
			 * Smoothing of the text borders.
			 *
			 * @attribute smoothing
			 * @type {number}
			 */
			smoothing:
			{
				get: function(){return this.uniforms.smoothing.value;},
				set: function(value){this.uniforms.smoothing.value = value;}
			}
		});

		this.updateGeometry();
		this.updateShader(texture);
	}

	TextBitmap.prototype = Object.create(three.Mesh.prototype);
	TextBitmap.prototype.constructor = TextBitmap;

	/**
	 * Simple bitmap font atlas.
	 *
	 * @static
	 * @attribute BITMAP
	 * @type {number}
	 */
	TextBitmap.BITMAP = 100;

	/**
	 * Single channel signed distance field font atlas.
	 *
	 * @static
	 * @attribute SDF
	 * @type {number}
	 */
	TextBitmap.SDF = 101;

	/**
	 * Multi channel signed distance field font atlas.
	 *
	 * @static
	 * @attribute MSDF
	 * @type {number}
	 */
	TextBitmap.MSDF = 102;

	/**
	 * Align text to the left side.
	 *
	 * @static
	 * @attribute LEFT
	 * @type {string}
	 */
	TextBitmap.LEFT = "left";

	/**
	 * Align text to the center.
	 *
	 * @static
	 * @attribute CENTER
	 * @type {string}
	 */
	TextBitmap.CENTER = "center";

	/**
	 * Align text to the right side.
	 *
	 * @static
	 * @attribute RIGHT
	 * @type {string}
	 */
	TextBitmap.RIGHT = "right";

	/**
	 * Vertex shader used to draw the text, is responsible for applying the billboard effect by removing the rotation from the transformation matrix.
	 *
	 * @static
	 * @attribute VERTEX_SHADER
	 * @type {string}
	 */
	TextBitmap.VERTEX_SHADER = "\n\
#define BILLBOARD 0 \n\
\n\
varying vec2 vUv;\n\
\n\
void main()\n\
{\n\
	vUv = uv;\n\
	\n\
	#if BILLBOARD\n\
		mat4 model = modelViewMatrix; \n\
		model[0][0] = 1.0;\n\
		model[0][1] = 0.0;\n\
		model[0][2] = 0.0;\n\
		\n\
		model[1][0] = 0.0;\n\
		model[1][1] = 1.0;\n\
		model[1][2] = 0.0;\n\
		\n\
		model[2][0] = 0.0;\n\
		model[2][1] = 0.0;\n\
		model[2][2] = 1.0;\n\
		\n\
		gl_Position = projectionMatrix * model * vec4(position, 1.0);\n\
	#else\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
	#endif\n\
	\n\
}";


	/**
	 * Shader object used to render the bitmap directly without any processing.
	 *
	 * Contains only the fragment shader code, the vertex is the same for every render mode.
	 *
	 * @static
	 * @attribute BITMAP_SHADER
	 * @type {string}
	 */
	TextBitmap.BITMAP_SHADER = "\n\
varying vec2 vUv;\n\
uniform sampler2D map;\n\
\n\
void main()\n\
{\n\
	gl_FragColor = texture2D(map, vUv);\n\
}";

	/**
	 * Shader object used to render single channel SDF data.
	 *
	 * Contains only the fragment shader code, the vertex is the same for every render mode.
	 * 
	 * Details about signed distance fields for vetorial shapes rendering.
	 *    - https:// steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf
	 *
	 * @static
	 * @attribute SDF_SHADER
	 * @type {string}
	 */
	TextBitmap.SDF_SHADER = "\n\
varying vec2 vUv;\n\
uniform sampler2D map;\n\
uniform vec3 color;\n\
uniform float smoothing;\n\
uniform float threshold;\n\
\n\
void main()\n\
{\n\
	float distance = texture2D(map, vUv).a;\n\
	float alpha = smoothstep(threshold - smoothing, threshold + smoothing, distance);\n\
	gl_FragColor = vec4(color, alpha);\n\
}";

	/**
	 * Shader object used to render single channel MSDF data.
	 *
	 * Contains only the fragment shader code, the vertex is the same for every render mode.
	 * 
	 * Details about MultiChannel Signed Distance Fields for vetorial shapes rendering.
	 *    - https:// onlinelibrary.wiley.com/doi/full/10.1111/cgf.13265
	 *
	 * @static
	 * @attribute SDF_SHADER
	 * @type {string}
	 */
	TextBitmap.MSDF_SHADER = "\n\
#extension GL_OES_standard_derivatives : enable\n\
\n\
varying vec2 vUv;\n\
uniform sampler2D map;\n\
uniform vec3 color;\n\
uniform float smoothing;\n\
uniform float threshold;\n\
\n\
float median(float r, float g, float b)\n\
{\n\
	return max(min(r, g), min(max(r, g), b));\n\
}\n\
\n\
void main()\n\
{\n\
	vec3 sample = texture2D(map, vUv).rgb;\n\
	float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n\
	float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);\n\
	gl_FragColor = vec4(color, 1.0 - alpha);\n\
}";

	/**
	 * Set the text to be displayed.
	 *
	 * @method setText
	 * @param {string} text
	 */
	TextBitmap.prototype.setText = function(text)
	{
		this.text = text;
	};

	/**
	 * Update the shader used to draw the bitmap information in the screen.
	 *
	 * @method updateShader
	 */
	TextBitmap.prototype.updateShader = function()
	{
		var fragmentShader;

		if(this.shader === TextBitmap.SDF)
		{
			fragmentShader = TextBitmap.SDF_SHADER;
		}
		else if(this.shader === TextBitmap.MSDF)
		{
			fragmentShader = TextBitmap.MSDF_SHADER;
		}
		else
		{
			fragmentShader = TextBitmap.BITMAP_SHADER;
		}

		this.material = new three.ShaderMaterial(
		{
			uniforms: this.uniforms,
			fragmentShader: fragmentShader,
			vertexShader: TextBitmap.VERTEX_SHADER,
			side: three.DoubleSide,
			transparent: true,
			depthTest: true
		});
	};


	/**
	 * Update the text bitmap geometry to match config.
	 *
	 * Should be called every time after changes to configuration are made.
	 *
	 * @method updateGeometry
	 */
	TextBitmap.prototype.updateGeometry = function()
	{
		this.geometry.update(this.config);

		if(this.fontScale !== 1.0)
		{
			var position = this.geometry.attributes.position.array;
			for(var i = 0; i < position.length; i++)
			{
				position[i] *= this.fontScale;
			}
		}
	};

	TextBitmap.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.texture = this.texture.toJSON(meta).uuid;
		data.object.fontScale = this.fontScale;
		data.object.shader = this.shader;
		data.object.text = this.text;
		data.object.font = this.font;
		data.object.lineHeight = this.lineHeight;
		data.object.letterSpacing = this.letterSpacing;
		data.object.align = this.align;
		data.object.width = this.width;
		data.object.color = this.color;
		data.object.threshold = this.threshold;
		data.object.smoothing = this.smoothing;

		return data;
	};

	TextBitmap.fromJSON = function(data, texture)
	{
		var object = new TextBitmap(data, texture, data.shader);
		object.color = data.color;
		object.threshold = data.threshold;
		object.smoothing = data.smoothing;
		object.fontScale = data.fontScale;
		
		return object;
	};

	/**
	 * Spine animation textures adapted to work with nunuStudio textures.
	 * 
	 * Based on SpineTexture from original spine runtime for three.js
	 * 
	 * @class SpineTexture
	 * @module Textures
	 * @param {Texture} texture
	 */
	function SpineTexture(texture)
	{
		spine.threejs.ThreeJsTexture.call(this, texture.image);
		
		this.texture = texture;
		this.texture.flipY = false;	
	}
	SpineTexture.prototype = Object.create(spine.threejs.ThreeJsTexture.prototype);

	/**
	 * Spine animation object, to used with animation produced inside Esoteric spine. These animations are created using the Spine animation studio software.
	 * 
	 * Based on the official three.js runtime code available at https:// github.com/EsotericSoftware/spine-runtimes.
	 * 
	 * More information about spine available at www.esotericsoftware.com.
	 * 
	 * @class SpineAnimation
	 * @extends {spine.threejs.SkeletonMesh}
	 * @param {Object} json
	 * @param {string} atlas
	 * @param {string} path
	 * @param {Array} textures
	 * @module Animations
	 */
	function SpineAnimation(json, atlas, path, textures)
	{
		if(textures === undefined)
		{
			textures = [];
		}
		
		var textureAtlas = new spine.TextureAtlas(atlas, function(file)
		{
			for(var i = 0; i < textures.length; i++)
			{
				if(textures[i].name === file)
				{
					var texture = new SpineTexture(textures[i].texture);
					break;
				}
			}

			if(i === textures.length)
			{
				var texture = new SpineTexture(new Texture(new Image(path + "/" + file)));
				textures.push({name: file, texture: texture.texture});
			}

			var element = texture.texture.image;
			var image = texture.texture.source;

			if(image.width > 0 && image.height > 0)
			{
				element.width = image.width;
				element.height = image.height;
			}
			else if(element.naturalWidth !== 0 && element.naturalHeight !== 0)
			{
				element.width = element.naturalWidth;
				element.height = element.naturalHeight;
				image.width = element.width;
				image.height = element.height;
			}
			else
			{
				var beginning = atlas.search("size: ");
				var end = atlas.search("\nformat");
				var size = atlas.substring(beginning + 6, end);
				size = size.split(",");
				element.width = parseInt(size[0]);
				element.height = parseInt(size[1]);
			}
			
			return texture;
		});

		var loader = new spine.AtlasAttachmentLoader(textureAtlas);
		var skeleton = new spine.SkeletonJson(loader).readSkeletonData(json);

		spine.threejs.SkeletonMesh.call(this, skeleton);

		this.name = "spine";
		this.type = "SpineAnimation";

		this.scale.set(0.01, 0.01, 0.01);

		/**
		 * Spine animation data.
		 *
		 * @property json
		 * @type {Object}
		 */
		this.json = json;
		
		/**
		 * Texture atlas information.
		 *
		 * @property atlas
		 * @type {Object}
		 */
		this.atlas = atlas;
		
		/**
		 * Array of SpineTextures used by the animation.
		 *
		 * @property textures
		 * @type {Array}
		 */
		this.textures = textures;

		/**
		 * The animation can have multiple skins that define diferent sets of textures for the same animation.
		 *
		 * @attribute skin
		 * @type {Object}
		 */
		this.skin = (this.getSkins().length > 0) ? this.getSkins()[0].name : null;
		
		/**
		 * Animation currently playing, animations are split into tracks.
		 *
		 * An animation (e.g. walk) can be composed of multiple tracks.
		 *
		 * @attribute animation
		 * @type {Object}
		 */
		this.animation = (this.getAnimations().length > 0) ? this.getAnimations()[0].name : null;
			
		/** 
		 * Index of the animation track playing.
		 *
		 * @attribute track
		 * @type {number}
		 */
		this.track = 0;

		/** 
		 * Indicates the loop mode of the animation if set true the animation starts again after it ends.
		 *
		 * @attribute loop
		 * @type {boolean}
		 */
		this.loop = true;

		this.clock = new three.Clock();
		
		this.play();
	}

	SpineAnimation.prototype = Object.create(spine.threejs.SkeletonMesh.prototype);

	SpineAnimation.prototype.update = function(delta)
	{
		spine.threejs.SkeletonMesh.prototype.update.call(this, delta);
		three.Object3D.prototype.update.call(this);
	};

	/**
	 * Update mesh geometry from animation state before rendering.
	 * 
	 * @method onBeforeRender
	 */
	SpineAnimation.prototype.onBeforeRender = function()
	{
		this.state.update(this.clock.getDelta());
		this.state.apply(this.skeleton);
		this.skeleton.updateWorldTransform();
		this.updateGeometry();
	};

	/**
	 * Play animation.
	 * 
	 * @method play
	 */
	SpineAnimation.prototype.play = function()
	{
		if(this.animation !== null)
		{
			this.setAnimation(this.track, this.animation, this.loop);
		}

		if(this.skin !== null)
		{
			this.setSkin(this.skin);
		}
	};

	/**
	 * Get all available animations.
	 * 
	 * @method getAnimations
	 * @return {Array} Animations
	 */
	SpineAnimation.prototype.getAnimations = function()
	{
		return this.state.data.skeletonData.animations;
	};

	/**
	 * Set animation from track number and name.
	 * 
	 * @method setAnimation
	 * @param {number} track Track number.
	 * @param {string} animation Animation name.
	 * @param {boolean} loop If true the animation plays in loop.
	 */
	SpineAnimation.prototype.setAnimation = function(track, animation, loop)
	{
		try
		{
			if(track !== undefined){this.track = track;}
			if(animation !== undefined){this.animation = animation;}
			if(loop !== undefined){this.loop = loop;}

			this.state.setAnimation(this.track, this.animation, this.loop);
		}
		catch(e)
		{
			this.animation = null;

			console.warn("nunuStudio: Error setting spine animation " + name + " on track " + track);
		}
	};

	/**
	 * Get skins available for this animation.
	 *
	 * @method getSkins
	 * @return {Array} List of skins available for this animation.
	 */
	SpineAnimation.prototype.getSkins = function()
	{
		return this.state.data.skeletonData.skins;
	};

	/**
	 * Set skin to be used by this animation
	 *
	 * @method setSkin
	 * @param {string} name Skin name.
	 */
	SpineAnimation.prototype.setSkin = function(name)
	{
		try
		{
			this.skeleton.setSkinByName(name);
			this.skin = name;
		}
		catch(e)
		{
			this.skin = null;
			console.warn("nunuStudio: Error setting spine skin " + name);
		}
	};

	SpineAnimation.prototype.toJSON = function(meta)
	{
		// Store textures
		var textures = [];
		var self = this;
		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{
			for(var i = 0; i < self.textures.length; i++)
			{
				var texture = self.textures[i].texture.toJSON(meta);
				textures.push({name: self.textures[i].name, texture: texture.uuid});
			}
		});

		// Animation data
		data.object.json = this.json;
		data.object.atlas = this.atlas;
		data.object.textures = textures;

		// Default animation and skin
		if(this.animation !== null)
		{
			data.object.animation = this.animation;
			data.object.track = this.track;
			data.object.loop = this.loop;
		}
		if(this.skin !== null)
		{
			data.object.skin = this.skin;	
		}

		return data;
	};

	/**
	 * Wrapper for cannon.js physics objects.
	 *
	 * The editor includes tools to create cannon shapes from three.js geometry objects.
	 * 
	 * Documentation for cannon.js physics available here http:// schteppe.github.io/cannon.js/docs/
	 * 
	 * @class PhysicsObject
	 * @extends {Group}
	 * @module Physics
	 */
	function PhysicsObject()
	{
		three.Group.call(this);

		this.name = "physics";
		this.type = "Physics";

		/**
		 * Physics body contains the following attributes:
		 *  - position Vec3
		 *  - velocity Vec3
		 *  - torque Vec3
		 *  - angularVelocity Vec3
		 *  - quaternion Quaternion
		 *  - mass Number
		 *  - material Material
		 *  - type Number
		 *  - linearDamping Number
		 *  - angularDamping Number
		 *  - allowSleep Boolean
		 *  - sleepSpeedLimit Number
		 *  - sleepTimeLimit Number
		 *  - collisionFilterGroup Number
		 *  - collisionFilterMask Number
		 *  - fixedRotation Boolean
		 *  - shape Array
		 *  
		 * @attribute body
		 * @type {Body}
		 */
		this.body = new cannon.Body();
		this.body.type = cannon.Body.DYNAMIC;
		this.body.mass = 1.0;

		/**
		 * Physics object position mode, indicates how coordinates from the physics engine are transformed into object coordinates.
		 *
		 * @attribute mode
		 * @type {number}
		 */
		this.mode = PhysicsObject.LOCAL;

		/**
		 * Refenrece to the physics world.
		 * 
		 * @attribute world
		 * @type {World}
		 */
		this.world = null;
	}

	PhysicsObject.prototype = Object.create(three.Group.prototype);

	/**
	 * The position of the object is copied directly from the body.
	 *
	 * Ignores the world tranforms inherited from parent objects.
	 * 
	 * Faster but the physics object should not carry any world transformations.
	 *
	 * @static
	 * @attribute LOCAL
	 * @type {number}
	 */
	PhysicsObject.LOCAL = 100;

	/**
	 * The position of the object is adjusted to follow the parent object transformation.
	 *
	 * This mode should be used for objects placed inside others.
	 *
	 * @static
	 * @attribute WORLD
	 * @type {number}
	 */
	PhysicsObject.WORLD = 101;

	/**
	 * Intialize physics object and add it to the scene physics world.
	 * 
	 * @method initialize
	 */
	PhysicsObject.prototype.initialize = function()
	{
		if(this.mode === PhysicsObject.LOCAL)
		{
			this.body.position.copy(this.position);
			this.body.quaternion.copy(this.quaternion);	
		}
		else if(this.mode === PhysicsObject.WORLD)
		{
			var position = new three.Vector3();
			this.getWorldPosition(position);
			this.body.position.copy(position);

			var quaternion = new three.Quaternion();
			this.getWorldQuaternion(quaternion);
			this.body.quaternion.copy(quaternion);
		}

		// Physics world
		var node = this;
		while(node.parent !== null)
		{
			node = node.parent;
			if(node instanceof Scene)
			{
				this.world = node.world;
				this.world.addBody(this.body);
			}
		}

		three.Object3D.prototype.initialize.call(this);
	};

	/**
	 * Update object position and rotation based on cannon.js body.
	 * 
	 * @method update
	 */
	PhysicsObject.prototype.update = function(delta)
	{
		if(this.mode === PhysicsObject.LOCAL)
		{
			this.position.copy(this.body.position);
			if(!this.body.fixedRotation)
			{
				this.quaternion.copy(this.body.quaternion);
			}
		}
		else if(this.mode === PhysicsObject.WORLD)
		{

			// Physics transform matrix
			var transform = new three.Matrix4();
			if(this.body.fixedRotation)
			{
				transform.setPosition(this.body.position.x, this.body.position.y, this.body.position.z);
			}
			else
			{
				var quaternion = new three.Quaternion();
				quaternion.copy(this.body.quaternion);
				transform.makeRotationFromQuaternion(quaternion);
				transform.setPosition(this.body.position.x, this.body.position.y, this.body.position.z);
			}


			// Get inverse of the world matrix
			var inverse = new three.Matrix4();
			inverse.getInverse(this.parent.matrixWorld);

			// Get position, scale and quaternion
			var scale = new three.Vector3();
			inverse.multiply(transform);
			inverse.decompose(this.position, this.quaternion, scale);
		}
	 
		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Add shape to physics object body.
	 * 
	 * @param {Shape} shape
	 * @method addShape
	 */
	PhysicsObject.prototype.addShape = function(shape)
	{
		if(shape instanceof cannon.Shape)
		{
			this.body.addShape(shape);
		}
	};

	PhysicsObject.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.mode = this.mode;

		// Body
		data.object.body = {};
		data.object.body.type = this.body.type;
		data.object.body.mass = this.body.mass;
		data.object.body.linearDamping = this.body.linearDamping;
		data.object.body.angularDamping = this.body.angularDamping;
		data.object.body.allowSleep = this.body.allowSleep;
		data.object.body.sleepSpeedLimit = this.body.sleepSpeedLimit;
		data.object.body.sleepTimeLimit = this.body.sleepTimeLimit;
		data.object.body.collisionFilterGroup = this.body.collisionFilterGroup;
		data.object.body.collisionFilterMask = this.body.collisionFilterMask;
		data.object.body.fixedRotation = this.body.fixedRotation;
		data.object.body.shapes = [];

		// Shapes array
		var shapes = this.body.shapes;
		for(var i = 0; i < shapes.length; i++)
		{
			var shape = shapes[i];
			var values = {};

			// Shape type
			values.type = shape.type;

			if(shape.type === cannon.Shape.types.SPHERE)
			{
				values.radius = shape.radius;
			}
			else if(shape.type === cannon.Shape.types.BOX)
			{
				values.halfExtents = {};
				values.halfExtents.x = shape.halfExtents.x;
				values.halfExtents.y = shape.halfExtents.y;
				values.halfExtents.z = shape.halfExtents.z;
			}
			else if(shape.type === cannon.Shape.types.CONVEXPOLYHEDRON)
			{
				values.vertices = shape.vertices;
				values.faces = shape.faces;
			}
			else if(shape.type === cannon.Shape.types.HEIGHTFIELD)
			{
				values.data = shape.data;
				values.maxValue = shape.maxValue;
				values.minValue = shape.minValue;
				values.elementSize = shape.elementSize;
			}
			else if(shape.type === cannon.Shape.types.TRIMESH)
			{
				values.vertices = shape.vertices;
				values.normals = shape.normals;
				values.edges = shape.edges;
				values.indices = shape.indices;
			}

			// Add shape
			data.object.body.shapes[i] = values;
		}

		return data;
	};


	PhysicsObject.fromJSON = function(data)
	{
		var object = new PhysicsObject();
		
		if(data.mode !== undefined)
		{
			object.mode = data.mode;
		}

		// Body
		object.body.type = data.body.type;
		object.body.mass = data.body.mass;
		object.body.linearDamping = data.body.linearDamping;
		object.body.angularDamping = data.body.angularDamping;
		object.body.allowSleep = data.body.allowSleep;
		object.body.sleepSpeedLimit = data.body.sleepSpeedLimit;
		object.body.sleepTimeLimit = data.body.sleepTimeLimit;
		object.body.collisionFilterGroup = data.body.collisionFilterGroup;
		object.body.collisionFilterMask = data.body.collisionFilterMask;
		object.body.fixedRotation = data.body.fixedRotation;

		// Shapes
		var shapes = data.body.shapes;
		for(var i = 0; i < shapes.length; i++)
		{
			var shape = shapes[i];

			if(shape.type === cannon.Shape.types.SPHERE)
			{
				object.body.addShape(new cannon.Sphere(shape.radius));
			}
			else if(shape.type === cannon.Shape.types.BOX)
			{
				object.body.addShape(new cannon.Box(new cannon.Vec3(shape.halfExtents.x, shape.halfExtents.y, shape.halfExtents.z)));
			}
			else if(shape.type === cannon.Shape.types.PARTICLE)
			{
				object.body.addShape(new cannon.Particle());
			}
			else if(shape.type === cannon.Shape.types.PLANE)
			{
				object.body.addShape(new cannon.Plane());
			}
			else if(shape.type === cannon.Shape.types.HEIGHTFIELD)
			{
				object.body.addShape(new cannon.Heightfield(shape.data,
				{
					maxValue : shape.maxValue,
					minValue : shape.minValue,
					elementSize : shape.elementSize
				}));
			}
			else if(shape.type === cannon.Shape.types.CONVEXPOLYHEDRON)
			{
				for(var k = 0; k < shape.vertices.length; k++)
				{
					shape.vertices[k] = new cannon.Vec3(shape.vertices[k].x, shape.vertices[k].y, shape.vertices[k].z);
				}
				
				object.body.addShape(new cannon.ConvexPolyhedron(shape.vertices, shape.faces));
			}
		}

		return object;
	};

	/**
	 * A light that gets emitted in a specific direction.
	 * 
	 * This light will behave as though it is infinitely far away and the rays produced from it are all parallel.
	 * 
	 * Based on DirectionalLight documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Lights/DirectionalLight
	 * 
	 * @param {number} hex Light color in hex RGB
	 * @param {number} intensity Light intensity
	 * @class DirectionalLight
	 * @extends {DirectionalLight}
	 * @module Lights
	 */
	function DirectionalLight(hex, intensity)
	{
		three.DirectionalLight.call(this, hex, intensity);

		this.name = "directional";
		
		this.castShadow = true;
		
		this.shadow.camera.near = 0.5;
		this.shadow.camera.far = 10000;
	}

	DirectionalLight.prototype = Object.create(three.DirectionalLight.prototype);

	/**
	 * Update light shadow map atributtes at runtime
	 * @method updateShadowMap
	 */
	DirectionalLight.prototype.updateShadowMap = function()
	{
		this.shadow.map.dispose();
		this.shadow.map = null;
		this.shadow.camera.updateProjectionMatrix();
	};

	/**
	 * Sky class if composed of a HemisphereLight, DirectionalLight and a dynamic generated Sky sphere geometry.
	 * 
	 * This object is composed by 3 internal objects
	 * 	- Hemisphere light
	 * 	- Directional Light
	 * 	- Mesh
	 * 
	 * @param {boolean} autoUpdate If true sky auto updated its state 
	 * @param {number} dayTime Day duration in seconds
	 * @param {number} sunDistance Distance of the sun
	 * @param {number} time Starting time
	 * @class Sky
	 * @extends {Object3D}
	 * @module Lights
	 */
	function Sky(autoUpdate, dayTime, sunDistance, time)
	{	
		three.Group.call(this);

		this.name = "sky";
		this.type = "Sky";
		
		/**
		 * Array with top sky colors.
		 *
		 * @property colorTop
		 * @type {Array}
		 */
		this.colorTop = [new three.Color(0x77b3fb), new three.Color(0x0076ff), new three.Color(0x035bb6), new three.Color(0x002439)];

		/**
		 * Array with bottom sky colors.
		 *
		 * @property colorBottom
		 * @type {Array}
		 */
		this.colorBottom = [new three.Color(0xebece6), new three.Color(0xFFFFFF), new three.Color(0xfee7d7), new three.Color(0x0065a7)];

		/**
		 * Sun color in hex RGB.
		 *
		 * @property sunColor
		 * @type {number}
		 * @default 0xFFFFAA
		 */
		this.sunColor = 0xFFFFAA;

		/**
		 * Sun color intensity.
		 *
		 * @property intensity
		 * @type {number}
		 */
		this.intensity = 0.3;

		/**
		 * Moon color in hex RGB.
		 *
		 * @property moonColor
		 * @type {number}
		 * @default 0x5555BB
		 */
		this.moonColor = 0x5555BB;

		/**
		 * Hemisphere light used to match ambient ligth with sky color.
		 *
		 * @property hemisphere
		 * @type {HemisphereLight}
		 */
		this.hemisphere = new three.HemisphereLight(0x3284ff, 0xffcc7f, 0.5);
		this.hemisphere.locked = true;
		this.hemisphere.matrixAutoUpdate = false;
		this.add(this.hemisphere);

		/**
		 * Directional light to simulate sun light and cast shadows.
		 *
		 * @property sun
		 * @type {DirectionalLight}
		 */
		this.sun = new DirectionalLight(this.sunColor, this.intensity);
		this.sun.castShadow = true;
		this.sun.locked = true;
		this.add(this.sun);

		// Uniforms
		var uniforms =
		{
			topColor: {type: "c", value: new three.Color(0.0, 0.46, 1.0)},
			bottomColor: {type: "c", value: new three.Color(1.0, 1.0, 1.0)},
			offset:	{type: "f", value: 20},
			exponent: {type: "f", value: 0.2}
		};
		
		uniforms.topColor.value.copy(this.hemisphere.color);

		// Sky
		var geometry = new three.SphereBufferGeometry(1500, 16, 16);
		var material = new three.ShaderMaterial(
		{
			vertexShader: Sky.VERTEX,
			fragmentShader: Sky.FRAGMENT,
			uniforms: uniforms,
			side: three.BackSide
		});

		/**
		 * Sky mesh with material shader to calculate dinamically sky color.
		 *
		 * @property sky
		 * @type {Mesh}
		 */
		this.sky = new three.Mesh(geometry, material);
		this.sky.locked = true;
		this.sky.matrixAutoUpdate = false;
		this.add(this.sky);

		// Override sky raycast function
		this.sky.raycast = function()
		{
			return null;
		};

		/**
		 * If set to true the sky auto updates its time.
		 *
		 * @property autoUpdate
		 * @default true
		 * @type {boolean}
		 */
		this.autoUpdate = autoUpdate !== undefined ? autoUpdate : true;

		/**
		 * Sun distance.
		 *
		 * @property sunDistance
		 * @type {number}
		 */
		this.sunDistance = sunDistance !== undefined ? sunDistance : 100;

		/**
		 * Day time in seconds.
		 *
		 * @property dayTime
		 * @type {number}
		 */
		this.dayTime = dayTime !== undefined ? dayTime : 120;

		/**
		 * Current day time in seconds.
		 *
		 * @property time
		 * @type {number}
		 */
		this.time = time !== undefined ? time : 75;
		
		this.updateSky();
	}

	Sky.prototype = Object.create(three.Group.prototype);

	Sky.VERTEX = "varying vec3 vWorldPosition;\n\
void main()\n\
{\n\
	vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n\
	vWorldPosition = worldPosition.xyz;\n\
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
}";

	Sky.FRAGMENT = "uniform vec3 topColor;\n\
uniform vec3 bottomColor;\n\
uniform float offset;\n\
uniform float exponent;\n\
varying vec3 vWorldPosition;\n\
void main()\n\
{\n\
	float h = normalize(vWorldPosition + offset).y;\n\
	gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h , 0.0), exponent), 0.0)), 1.0);\n\
}";

	Sky.prototype.initialize = function()
	{
		this.updateSky();
		
		three.Object3D.prototype.initialize.call(this);
	};

	/**
	 * Update sky state, updates the time value and the gradient uniform values.
	 *
	 * @method update
	 */
	Sky.prototype.update = function(delta)
	{
		if(this.autoUpdate)
		{
			this.time += delta;

			if(this.time > this.dayTime)
			{
				this.time -= this.dayTime;
			}

			this.updateSky();
		}

		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Update sky color and sun position.
	 * 
	 * If autoUpdate set to true is automatically called by the update method.
	 * 
	 * @method updateSky
	 */
	Sky.prototype.updateSky = function()
	{
		// Time in % of day
		var time = (this.time / this.dayTime);

		//0H - 6H (night)
		if(time < 0.25)
		{
			this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, this.colorBottom[3].g, this.colorBottom[3].b);
		}
		//6H - 7H (night to morning)
		else if(time < 0.292)
		{
			var t = (time-0.25) * 23.81;
			var f = 1 - t;

			this.sky.material.uniforms.topColor.value.setRGB(f*this.colorTop[3].r + t*this.colorTop[0].r, f*this.colorTop[3].g + t*this.colorTop[0].g, f*this.colorTop[3].b + t*this.colorTop[0].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(f*this.colorBottom[3].r + t*this.colorBottom[0].r, f*this.colorBottom[3].g + t*this.colorBottom[0].g, f*this.colorBottom[3].b + t*this.colorBottom[0].b);
		}
		//7H - 10H (morning)
		else if(time < 0.4167)
		{
			this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[0].r, this.colorTop[0].g, this.colorTop[0].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[0].r, this.colorBottom[0].g, this.colorBottom[0].b);
		}
		//10H - 12H (morning to noon)
		else if(time < 0.5)
		{
			var t = (time-0.4167) * 12;
			var f = 1 - t;

			this.sky.material.uniforms.topColor.value.setRGB(f*this.colorTop[0].r + t*this.colorTop[1].r, f*this.colorTop[0].g + t*this.colorTop[1].g, f*this.colorTop[0].b + t*this.colorTop[1].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(f*this.colorBottom[0].r + t*this.colorBottom[1].r, f*this.colorBottom[0].g + t*this.colorBottom[1].g, f*this.colorBottom[0].b + t*this.colorBottom[1].b);
		}
		//12H - 17H (noon)
		else if(time < 0.708)
		{
			this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[1].r, this.colorTop[1].g, this.colorTop[1].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[1].r, this.colorBottom[1].g, this.colorBottom[1].b);
		}
		//17H -> 18h (noon to afternoon)
		else if(time < 0.75)
		{
			var t = (time-0.708) * 23.81;
			var f = 1 - t;

			this.sky.material.uniforms.topColor.value.setRGB(f*this.colorTop[1].r + t*this.colorTop[2].r, f*this.colorTop[1].g + t*this.colorTop[2].g, f*this.colorTop[1].b + t*this.colorTop[2].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(f*this.colorBottom[1].r + t*this.colorBottom[2].r, f*this.colorBottom[1].g + t*this.colorBottom[2].g, f*this.colorBottom[1].b + t*this.colorBottom[2].b);
		}
		//18H -> 20H (afternoon to night)
		else if(time < 0.8333)
		{
			var t = (time-0.75) * 12.048;
			var f = 1 - t;

			this.sky.material.uniforms.topColor.value.setRGB(f*this.colorTop[2].r + t*this.colorTop[3].r, f*this.colorTop[2].g + t*this.colorTop[3].g, f*this.colorTop[2].b + t*this.colorTop[3].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(f*this.colorBottom[2].r + t*this.colorBottom[3].r, f*this.colorBottom[2].g + t*this.colorBottom[3].g, f*this.colorBottom[2].b + t*this.colorBottom[3].b);
		}
		//20H -> 24H (night)
		else
		{
			this.sky.material.uniforms.topColor.value.setRGB(this.colorTop[3].r, this.colorTop[3].g, this.colorTop[3].b);
			this.sky.material.uniforms.bottomColor.value.setRGB(this.colorBottom[3].r, this.colorBottom[3].g, this.colorBottom[3].b);
		}

		// Sun / moon color
		if(time < 0.20)
		{
			this.sun.intensity = this.intensity;
			this.sun.color.setHex(this.moonColor);
		}
		else if(time < 0.30)
		{
			var t = (time-0.20) * 10;
			var f = 1 - t;

			if(t < 0.5)
			{
				var f = 2 - t*2;
				this.sun.intensity = f * this.intensity;
				this.sun.color.setHex(this.moonColor);
			}
			else
			{
				t = t*2;
				this.sun.intensity = t * this.intensity;
				this.sun.color.setHex(this.sunColor);
			}
		}
		else if(time < 0.70)
		{
			this.sun.intensity = this.intensity;
			this.sun.color.setHex(this.sunColor);
		}
		else if(time < 0.80)
		{
			var t = (time - 0.70) * 10;
			
			if(t < 0.5)
			{
				var f = 2 - t*2;
				this.sun.intensity = f * this.intensity;
				this.sun.color.setHex(this.sunColor);
			}
			else
			{
				t = t*2;
				this.sun.intensity = t * this.intensity;
				this.sun.color.setHex(this.moonColor);
			}
		}
		else
		{
			this.sun.intensity = this.intensity;
			this.sun.color.setHex(this.moonColor);
		}

		// Update sun position
		var rotation = (MathUtils.PI2 * time) - MathUtils.PID2;
		if(time > 0.25 && time < 0.75)
		{
			this.sun.position.x = this.sunDistance * Math.cos(rotation);
			this.sun.position.y = this.sunDistance * Math.sin(rotation);
		}
		else
		{
			this.sun.position.x = this.sunDistance * Math.cos(rotation + Math.PI);
			this.sun.position.y = this.sunDistance * Math.sin(rotation + Math.PI);	
		}
	};

	Sky.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);
		
		data.object.colorTop = [];
		for(var i = 0; i < this.colorTop.length; i++)
		{
			data.object.colorTop.push(this.colorTop[i].toJSON());
		}
		
		data.object.colorBottom = [];
		for(var i = 0; i < this.colorBottom.length; i++)
		{
			data.object.colorBottom.push(this.colorBottom[i].toJSON());
		}

		data.object.sunColor = this.sunColor;
		data.object.moonColor = this.moonColor;
		data.object.intensity = this.intensity;

		data.object.autoUpdate = this.autoUpdate;
		data.object.sunDistance = this.sunDistance;
		data.object.dayTime = this.dayTime;
		data.object.time = this.time;

		data.object.sun = {};
		data.object.sun.castShadow = this.sun.castShadow;
		data.object.sun.shadow = this.sun.shadow.toJSON();

		return data;
	};

	/**
	 * LensFlare object can be used to simulate lens flare from lights.
	 *
	 * Stores a list of Flares.
	 *
	 * For optimal result LensFlare object should be attached to a light source.
	 *
	 * Works with perspective and orthographic cameras.
	 *
	 * @class LensFlare
	 * @module Misc
	 * @extends {Object3D}
	 * @author mikael emtinger / http:// gomo.se/
	 * @author alteredq / http:// alteredqualia.com/
	 * @author tentone
	 */
	function LensFlare()
	{
		three.Mesh.call(this, three.Lensflare.Geometry, new three.MeshBasicMaterial({opacity: 0, transparent: true}));

		this.name = "lensflare";
		this.type = "LensFlare";

		this.renderOrder = Infinity;
		this.frustumCulled = false;

		this.receiveShadow = false;
		this.castShadow = false;
		
		this.elements = [];

		var positionScreen = new three.Vector3();

		// textures
		var tempMap = new three.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, three.RGBFormat);
		tempMap.minFilter = three.NearestFilter;
		tempMap.magFilter = three.NearestFilter;
		tempMap.wrapS = three.ClampToEdgeWrapping;
		tempMap.wrapT = three.ClampToEdgeWrapping;
		tempMap.needsUpdate = true;

		var occlusionMap = new three.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, three.RGBFormat);
		occlusionMap.minFilter = three.NearestFilter;
		occlusionMap.magFilter = three.NearestFilter;
		occlusionMap.wrapS = three.ClampToEdgeWrapping;
		occlusionMap.wrapT = three.ClampToEdgeWrapping;
		occlusionMap.needsUpdate = true;

		// material
		var geometry = three.Lensflare.Geometry;
		var shader = three.Lensflare.Shader;
		var material1a = new three.RawShaderMaterial(
		{
			uniforms:
			{
				scale: {value: null},
				screenPosition: {value: null}
			},
			vertexShader: 
				"precision highp float;\n\
			uniform vec3 screenPosition;\n\
			uniform vec2 scale;\n\
			attribute vec3 position;\n\
			void main()\n\
			{\n\
				gl_Position = vec4(position.xy * scale + screenPosition.xy, screenPosition.z, 1.0);\n\
			}",
			fragmentShader:
				"precision highp float;\n\
			void main()\n\
			{\n\
				gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n\
			}",
			depthTest: true,
			depthWrite: false,
			transparent: false
		});

		var material1b = new three.RawShaderMaterial(
		{
			uniforms:
			{
				map: {value: tempMap},
				scale: {value: null},
				screenPosition: {value: null}
			},
			vertexShader:
				"precision highp float;\n\
			uniform vec3 screenPosition;\n\
			uniform vec2 scale;\n\
			attribute vec3 position;\n\
			attribute vec2 uv;\n\
			varying vec2 vUV;\n\
			void main()\n\
			{\n\
				vUV = uv;\n\
				gl_Position = vec4(position.xy * scale + screenPosition.xy, screenPosition.z, 1.0);\n\
			}",
			fragmentShader:
				"precision highp float;\n\
			uniform sampler2D map;\n\
			varying vec2 vUV;\n\
			void main()\n\
			{\n\
				gl_FragColor = texture2D(map, vUV);\n\
			}",
			depthTest: false,
			depthWrite: false,
			transparent: false
		});

		// The following object is used for occlusionMap generation
		var mesh1 = new three.Mesh(geometry, material1a);
		var shader = three.LensflareElement.Shader;
		var material2 = new three.RawShaderMaterial(
		{
			uniforms:
			{
				map: {value: null},
				occlusionMap: {value: occlusionMap},
				color: {value: new three.Color(0xFFFFFF)},
				scale: {value: new three.Vector2()},
				screenPosition: {value: new three.Vector3()}
			},
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			blending: three.AdditiveBlending,
			transparent: true,
			depthWrite: false
		});

		var mesh2 = new three.Mesh(geometry, material2);
		var scale = new three.Vector2();
		var screenPositionPixels = new three.Vector2();
		var validArea = new three.Box2();
		var viewport = new three.Vector4();

		this.onBeforeRender = function(renderer, scene, camera)
		{
			renderer.getCurrentViewport(viewport);

			var invAspect = viewport.w / viewport.z;
			var halfViewportWidth = viewport.z / 2.0;
			var halfViewportHeight = viewport.w / 2.0;

			var size = 16 / viewport.w;
			scale.set(size * invAspect, size);

			validArea.min.set(viewport.x, viewport.y);
			validArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));

			// calculate position in screen space
			positionScreen.setFromMatrixPosition(this.matrixWorld);

			positionScreen.applyMatrix4(camera.matrixWorldInverse);
			positionScreen.applyMatrix4(camera.projectionMatrix);

			// horizontal and vertical coordinate of the lower left corner of the pixels to copy
			screenPositionPixels.x = viewport.x + (positionScreen.x * halfViewportWidth) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + (positionScreen.y * halfViewportHeight) + halfViewportHeight - 8;

			// screen cull
			if(validArea.containsPoint(screenPositionPixels))
			{
				// save current RGB to temp texture
				renderer.copyFramebufferToTexture(screenPositionPixels, tempMap);

				// render pink quad
				var uniforms = material1a.uniforms;
				uniforms.scale.value = scale;
				uniforms.screenPosition.value = positionScreen;

				renderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);

				// copy result to occlusionMap
				renderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);

				// restore graphics
				var uniforms = material1b.uniforms;
				uniforms.scale.value = scale;
				uniforms.screenPosition.value = positionScreen;

				renderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);

				// render elements
				var vecX = - positionScreen.x * 2;
				var vecY = - positionScreen.y * 2;

				for(var i = 0, l = this.elements.length; i < l; i++)
				{
					var element = this.elements[i];

					var uniforms = material2.uniforms;

					uniforms.color.value.copy(element.color);
					uniforms.map.value = element.texture;
					uniforms.screenPosition.value.x = positionScreen.x + vecX * element.distance;
					uniforms.screenPosition.value.y = positionScreen.y + vecY * element.distance;

					var size = element.size / viewport.w;
					var invAspect = viewport.w / viewport.z;

					uniforms.scale.value.set(size * invAspect, size);

					material2.uniformsNeedUpdate = true;

					renderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);
				}
			}
		};

		this.dispose = function()
		{
			material1a.dispose();
			material1b.dispose();
			material2.dispose();
			tempMap.dispose();
			occlusionMap.dispose();

			for(var i = 0; i < this.elements.length; i++)
			{
				this.elements[i].texture.dispose();
			}
		};
	}

	LensFlare.prototype = Object.create(three.Mesh.prototype);

	/**
	 * Add texture to the lensFlare object.
	 *
	 * @method add
	 * @param {Texture} texture Texture to be used forthe new layer.
	 * @param {number} size Size in pixels (-1 = use texture.width)
	 * @param {number} distance Distance (0-1) from light source (0=at light source)
	 * @param {Color} color Texture color
	 */
	LensFlare.prototype.addFlare = function(texture, size, distance, color)
	{
		if(size === undefined)
		{
			size = -1;
		}
		if(distance === undefined)
		{
			distance = 0;
		}
		if(color === undefined)
		{
			color = new three.Color(0xFFFFFF);
		}

		distance = Math.min(distance, Math.max(0, distance));
		
		this.addElement(new three.LensflareElement(texture, size, distance, color));
	};

	LensFlare.prototype.addElement = function(element)
	{
		this.elements.push(element);
	};

	LensFlare.prototype.toJSON = function(meta)
	{
		var self = this;
		var elements = [];

		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{
			for(var i = 0; i < self.elements.length; i++)
			{
				var flare = {};
				flare.texture = self.elements[i].texture.toJSON(meta).uuid;
				flare.size = self.elements[i].size;
				flare.distance = self.elements[i].distance;
				flare.color = self.elements[i].color.getHex();
				elements.push(flare);
			}
		});

		data.object.elements = elements;

		return data;
	};

	/**
	 * CSS 3D element projected in the 3D scene.
	 *
	 * Encapsulated a DOM element that is projected into 3D space using the 3D object transform values.
	 *
	 * CSS3D object always stay above everything elese in the 3D scene.
	 *
	 * @class CSS3DObject
	 * @extends {Object3D}
	 * @param {Component} element DOM element encapsulated in the object container.
	 */
	function CSS3DObject(element)
	{
		three.Object3D.call(this);

		/**
		 * The DOM element to be projected in 3D space.
		 *
		 * It is automatically added to the appropiate DOM container used by the renderer.
		 *
		 * @attribute element
		 * @type {Element}
		 */
		this.element = element;
		this.element.style.position = "absolute";
		
		this.addEventListener("removed", function()
		{
			if(this.element.parentNode !== null)
			{
				this.element.parentNode.removeChild(this.element);
			}
		});

		var self = this;
		var visible = true;
		Object.defineProperties(this,
		{
			visible:
			{
				get: function()
				{
					return visible;
				},
				set: function(value)
				{
					visible = value;
					
					self.element.style.display = value ? "block" :"none";
				}
			}
		});
	}
	CSS3DObject.prototype = Object.create(three.Object3D.prototype);
	CSS3DObject.prototype.constructor = CSS3DObject;
	CSS3DObject.prototype.isCSS3DObject = true;

	/**
	 * HTMLView object is used to navigate webpages inside of the 3D scene.
	 *
	 * Can be used to display external web widget using a iframe. Some pages might present limitations regarding their usage inside of a iframe element.
	 * 
	 * @class HTMLView
	 * @extends {CSS3DObject}
	 * @param {string} url URL to be opened by default.
	 */
	function HTMLView(url)
	{
		var element = document.createElement("iframe");
		element.style.border = "none";
		
		CSS3DObject.call(this, element);

		this.type = "HTMLView";
		this.name = "webview";

		var self = this;
		var url, width, height;
		
		Object.defineProperties(this,
		{
			/**
			 * URL of the webpage to open in the view.
			 *
			 * @attribute url
			 * @type {string}
			 */
			url:
			{
				get: function(){return url;},
				set: function(value)
				{
					url = value !== undefined ? HTMLView.processURL(value) : "";
					self.element.src = url;
				}
			},

			/**
			 * Width in pixels of the web view port.
			 *
			 * @attribute size
			 * @type {number}
			 */
			width:
			{
				get: function(){return width;},
				set: function(value)
				{
					width = value;
					self.element.style.width = width + "px";
				}
			},

			/**
			 * Height in pixels of the web view port.
			 *
			 * @attribute height
			 * @type {number}
			 */
			height:
			{
				get: function(){return height;},
				set: function(value)
				{
					height = value;
					self.element.style.height = height + "px";
				}
			}
		});

		this.width = 512;
		this.height = 512;
		this.url = url !== undefined ? url : "";
	}

	HTMLView.prototype = Object.create(CSS3DObject.prototype);

	HTMLView.prototype.constructor = HTMLView;

	/** 
	 * Process URL to transform it into embedded URL when possible for common services.
	 *
	 * @method processURL
	 * @param {string} url
	 */
	HTMLView.processURL = function(url)
	{	
		// Replace youtube url to use embeded link
		return url.replace("watch?v=", "embed/");			
	};

	HTMLView.prototype.toJSON = function(meta)
	{
		var data = CSS3DObject.prototype.toJSON.call(this, meta);

		data.object.height = this.height;
		data.object.width = this.width;
		data.object.url = this.url;

		return data;
	};

	/**
	 * SkinnedMesh is a Mesh that has a Skeleton attached.
	 * 
	 * A skeleton contains bones that are used to animate the vertices of the geometry.
	 * 
	 * Based on SkinnedMesh documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Objects/SkinnedMesh
	 * 
	 * @class SkinnedMesh
	 * @module Meshes
	 * @param {Geometry} geometry Geometry used by this mesh
	 * @param {Material} material Material used to shade the superficie of the geometry
	 * @extends {SkinnedMesh}
	 */
	function SkinnedMesh(geometry, material)
	{
		three.SkinnedMesh.call(this, geometry, material);

		this.name = "skinned";
		
		this.receiveShadow = true;
		this.castShadow = true;

		this.skeleton = null;
	}

	SkinnedMesh.prototype = Object.create(three.SkinnedMesh.prototype);

	/**
	 * Dispose mesh along with its material and geometry.
	 * 
	 * @method dispose
	 */
	SkinnedMesh.prototype.dispose = function()
	{
		if(this.material !== null && this.material.dispose !== undefined)
		{
			this.material.dispose();
		}

		if(this.geometry !== null && this.geometry.dispose !== undefined)
		{
			this.geometry.dispose();
		}

		three.Object3D.prototype.dispose.call(this);
	};

	SkinnedMesh.prototype.toJSON = function(meta)
	{
		var self = this;

		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{	
			if(self.skeleton !== null)
			{
				if(meta.skeletons[self.skeleton.uuid] === undefined)
				{
					meta.skeletons[self.skeleton.uuid] = self.skeleton.toJSON(meta);
				}

				object.skeleton = self.skeleton.uuid;
			}
		});

		if(this.bindMode !== undefined)
		{
			data.object.bindMode = this.bindMode;
		}

		if(this.bindMatrix !== undefined)
		{
			data.object.bindMatrix = this.bindMatrix.toArray();
		}
		
		return data;
	};

	/**
	 * A instanced mesh is a mesh that can be drawn multiple times at once, it can be used to optimize the draw of large amount of the same geometry material combination.
	 * 
	 * The usage of InstancedMesh will help you to reduce the number of draw calls and thus improve the overall rendering performance in your application.
	 *
	 * @class InstancedMesh
	 * @module Meshes
	 * @param {Geometry} geometry Geometry used by this mesh
	 * @param {Material} material Material used to shade the superficie of the geometry
	 * @extends {InstancedMesh}
	 */
	function InstancedMesh(geometry, material, count)
	{
		three.InstancedMesh.call(this, geometry, material, count);

		this.name = "instanced";
		this.type = "InstancedMesh";

		this.receiveShadow = true;
		this.castShadow = true;
		
		Object.defineProperties(this,
		{
			/**
			 * The number of instances. The count value represents the maximum number of instances of this mesh.
			 *
			 * You can change the number of instances at runtime to an integer value in the range [0, count].
			 *
			 * @attribute url
			 * @type {string}
			 */
			count:
			{
				get: function(){return count;},
				set: function(value)
				{
					// Resize the instanceMatrix to fit the number of instances
					if(value > count)
					{
						this.instanceMatrix = new three.BufferAttribute(new Float32Array(value * 16), 16);
					}
					
					count = value;
				}
			}
		});
	}

	InstancedMesh.prototype = Object.create(three.InstancedMesh.prototype);

	InstancedMesh.prototype.dispose = function()
	{
		// Material and geometry
		if(this.material !== null && this.material.dispose !== undefined)
		{
			this.material.dispose();
		}
		if(this.geometry !== null)
		{
			this.geometry.dispose();
		}

		// Children
		three.Object3D.prototype.dispose.call(this);
	};

	InstancedMesh.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.instanceMatrix = this.instanceMatrix.toJSON();
		data.object.count = this.count;

		return data;
	};

	/**
	 * A SpotLight emit light from a point in a specific direction in a cone volume.
	 * 
	 * SpotLight has a target that is always represented in words coordinates, and can be moved to change where the light is pointing at.
	 * 
	 * Based on SpotLight documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Lights/SpotLight
	 *
	 * @param {number} color Light color in hex RGB
	 * @param {number} intensity Light intensity
	 * @param {number} distance SpotLight maximum range
	 * @param {number} angle
	 * @param {number} exponent
	 * @param {number} decay
	 * @class SpotLight
	 * @extends {SpotLight}
	 * @module Lights
	 */
	function SpotLight(hex, intensity, distance, angle, exponent, decay)
	{
		three.SpotLight.call(this, hex, intensity, distance, angle, exponent, decay);

		this.name = "spotlight";
		
		this.castShadow = true;

		this.shadow.camera.near = 0.05;
		this.shadow.camera.far = 5000;
		this.shadow.mapSize.width = 512;
		this.shadow.mapSize.height = 512;
	}

	SpotLight.prototype = Object.create(three.SpotLight.prototype);

	/**
	 * SpotLight looks to the target object coordinates.
	 * 
	 * The target object should always be at the scene root.
	 *
	 * @method setTarget
	 * @param {Object3D} target Target object.
	 */
	SpotLight.prototype.setTarget = function(target)
	{
		this.target = target;
	};

	/**
	 * Update light shadow map atributtes at runtime.
	 * 
	 * @method updateShadowMap
	 */
	SpotLight.prototype.updateShadowMap = function()
	{
		this.shadow.map.dispose();
		this.shadow.map = null;
		this.shadow.camera.updateProjectionMatrix();
	};

	SpotLight.prototype.toJSON = function(meta)
	{
		var data = three.Light.prototype.toJSON.call(this, meta);

		data.object.target = this.target.uuid;

		return data;
	};

	/**
	 * A RectAreLight emit light from a rectagular surface.
	 * 
	 * Based on RectAreaLight documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Lights/RectAreaLight
	 * 
	 * @param {number} color Light color in hex RGB
	 * @param {number} intensity Light intensity
	 * @param {number} width
	 * @param {number} height
	 * @class RectAreaLight
	 * @extends {RectAreaLight}
	 * @module Lights
	 */
	function RectAreaLight(color, intensity, width, height)
	{
		three.RectAreaLight.call(this, color, intensity, width, height);

		this.name = "rectarea";
	}

	RectAreaLight.prototype = Object.create(three.RectAreaLight.prototype);

	RectAreaLight.prototype.toJSON = function(meta)
	{
		var data = three.Light.prototype.toJSON.call(this, meta);

		data.object.width = this.width;
		data.object.height = this.height;

		return data;
	};

	/**
	 * PointLights emit light from a single point in all directions.
	 * 
	 * Based on PointLight documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Lights/PointLight
	 * 
	 * @param {number} hex Light color in hex RGB
	 * @param {number} intensity Light intensity
	 * @param {number} distance Maximum PointLight range
	 * @param {number} decay
	 * @class PointLight
	 * @extends {PointLight}
	 * @module Lights
	 */
	function PointLight(hex, intensity, distance, decay)
	{
		three.PointLight.call(this, hex, intensity, distance, decay);

		this.name = "point";
		
		this.castShadow = true;

		this.shadow.camera.near = 0.1;
		this.shadow.camera.far = 1000;
		this.shadow.bias = 0.0;
	}

	PointLight.prototype = Object.create(three.PointLight.prototype);

	/**
	 * Update light shadow map atributtes at runtime
	 * @method updateShadowMap
	 */
	PointLight.prototype.updateShadowMap = function()
	{
		this.shadow.map.dispose();
		this.shadow.map = null;
		this.shadow.camera.updateProjectionMatrix();
	};

	/**
	 * CubeTextures represent 360 view using six images, these images correspond to the faces of a cube.
	 * 
	 * CubeTextures can be used to simulate reflections and transparency refraction in materials.
	 * 
	 * Is also possible to create dynamic cubetextures using the CubeCamera object.
	 *
	 * @class CubeTexture
	 * @extends {Texture}
	 * @param {Array} images Image array
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} magFilter
	 * @param {number} minFilter
	 * @param {number} format
	 * @param {number} type
	 * @param {number} anisotropy
	 * @param {number} encoding
	 */
	function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)
	{
		if(mapping === undefined)
		{
			mapping = three.CubeReflectionMapping;
		}

		var array = [];
		for(var i = 0; i < 6; i++)
		{
			array.push(document.createElement("canvas"));
		}	

		three.Texture.call(this, array, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.images = (images !== undefined) ? images : [];

		/**
		 * Size of each one of the texture that compose the CubeTexture.
		 *
		 * @property size
		 * @type {number}
		 * @default 512
		 */
		this.size = 512;
		
		this.flipY = false;
		
		/**
		 * Cube texture mode, the mode specifies how the cube texture is created.
		 *
		 * Source format may vary from a mode to another.
		 * @property mode
		 * @type {number}
		 */
		this.mode = (this.images.length === 6) ? CubeTexture.CUBE : CubeTexture.CROSS;

		if(this.images.length > 0)
		{
			this.updateImages();
		}

		this.name = "cubetexture";
		this.category = "Cube";
	}

	CubeTexture.prototype = Object.create(three.Texture.prototype);
	CubeTexture.prototype.constructor = CubeTexture;
	CubeTexture.prototype.isCubeTexture = true;

	/**
	 * Cubemap right image index
	 *
	 * @attribute RIGHT
	 * @type {number}
	 */
	CubeTexture.RIGHT = 0;

	/**
	 * Cubemap left image index
	 *
	 * @attribute LEFT
	 * @type {number}
	 */
	CubeTexture.LEFT = 1;

	/**
	 * Cubemap top image index
	 *
	 * @attribute TOP
	 * @type {number}
	 */
	CubeTexture.TOP = 2;

	/**
	 * Cubemap bottom image index
	 *
	 * @attribute BOTTOM
	 * @type {number}
	 */
	CubeTexture.BOTTOM = 3;

	/**
	 * Cubemap front image index
	 *
	 * @attribute FRONT
	 * @type {number}
	 */
	CubeTexture.FRONT = 4;

	/**
	 * Cubemap back image index
	 *
	 * @attribute BACK
	 * @type {number}
	 */
	CubeTexture.BACK = 5;

	/**
	 * CubeMap mode, 6 images used as source for the texture.
	 *
	 * @attribute CUBE
	 * @type {number}
	 */
	CubeTexture.CUBE = 20;

	/**
	 * CubeMap mode, single image used as source.
	 *
	 * @attribute CROSS
	 * @type {number}
	 */
	CubeTexture.CROSS = 21;

	/**
	 * Equirectangular projection mode, 1 single image used as source.
	 *
	 * Source image should have a 2:1 aspect ratio.
	 *
	 * @attribute EQUIRECTANGULAR
	 * @type {number}
	 */
	CubeTexture.EQUIRECTANGULAR = 22;


	/**
	 * Set resolution of each face of the cubemap.
	 *
	 * The size has to be a power of 2.
	 * 
	 * @method setSize
	 * @param {number} size Cube face resolution.
	 */
	CubeTexture.prototype.setSize = function(size)
	{
		if((size & (size - 1)) !== 0)
		{
			console.warn("nunuStudio: CubeTexture new size is not a power of two.");
			return;
		}

		this.size = size;
	};

	/**
	 * Set new images for this cube texture.
	 *
	 * @method setImages
	 * @param {Array} images Cube texture images.
	 * @param {number} mode Mode to be used.
	 */
	CubeTexture.prototype.setImages = function(images, mode)
	{
		this.mode = (mode !== undefined) ? mode : CubeTexture.CUBE;
		this.images = images;
	};

	/**
	 * Updates the CubeTexture images, should be called after changing the images attached to the texture
	 * 
	 * @method updateImages
	 */
	CubeTexture.prototype.updateImages = function()
	{
		var self = this;

		if(this.mode === CubeTexture.CUBE)
		{
			for(var i = 0; i < this.images.length; i++)
			{
				if(typeof this.images[i] === "string")
				{
					this.images[i] = new Image(this.images[i]);
				}

				var image = document.createElement("img");
				image.crossOrigin = "anonymous";
				image.index = i;
				image.src = this.images[i].data;
				image.onload = function()
				{
					self.image[this.index].width = self.size;
					self.image[this.index].height = self.size;

					var context = self.image[this.index].getContext("2d");
					context.drawImage(this, 0, 0, self.size, self.size);

					self.needsUpdate = true;
				};
			}
		}
		else if(this.mode === CubeTexture.CROSS)
		{
			for(var i = 0; i < this.image.length; i++)
			{
				this.image[i].width = this.size;
				this.image[i].height = this.size;
			}

			var image = document.createElement("img");
			image.src = this.images[0].data;
			image.onload = function()
			{
				var x = this.naturalWidth / 4;
				var y = this.naturalHeight / 3; 

				self.image[CubeTexture.LEFT].getContext("2d").drawImage(this, 0, y, x, y, 0, 0, self.size, self.size);
				self.image[CubeTexture.FRONT].getContext("2d").drawImage(this, x, y, x, y, 0, 0, self.size, self.size);
				self.image[CubeTexture.RIGHT].getContext("2d").drawImage(this, x * 2, y, x, y, 0, 0, self.size, self.size);
				self.image[CubeTexture.BACK].getContext("2d").drawImage(this, x * 3, y, x, y, 0, 0, self.size, self.size);
				self.image[CubeTexture.TOP].getContext("2d").drawImage(this, x, 0, x, y, 0, 0, self.size, self.size);
				self.image[CubeTexture.BOTTOM].getContext("2d").drawImage(this, x, y * 2, x, y, 0, 0, self.size, self.size);

				self.needsUpdate = true;
			};
		}
		else if(this.mode === CubeTexture.EQUIRECTANGULAR)
		{
			for(var i = 0; i < this.image.length; i++)
			{
				this.image[i].width = this.size;
				this.image[i].height = this.size;
			}
			
			var image = document.createElement("img");
			image.src = this.images[0].data;
			image.onload = function()
			{
				var canvas = document.createElement("canvas");
				canvas.width = image.naturalWidth;
				canvas.height = image.naturalHeight;

				var context = canvas.getContext("2d");
				context.drawImage(image, 0, 0);
				var data = context.getImageData(0, 0, canvas.width, canvas.height);

				for(var i = 0; i < 6; i++)
				{
					var out = CubeTexture.renderEquirectFace(data, i, three.Math.PI, self.size);
					self.image[i].getContext("2d").putImageData(out, 0, 0);
				}
				
				self.needsUpdate = true;
			};
		}
	};

	/**
	 * Resample an image pixel from ImageData to ImageData, using bilinear interpolation.
	 *
	 * @method resampleBilinear
	 * @param {ImageData} read Where to read data from.
	 * @param {ImageData} write Where to write data.
	 * @param {number} x Origin pixel x.
	 * @param {number} y Origin pixel y.
	 * @param {number} index Target index.
	 */
	CubeTexture.resampleBilinear = function(read, write, x, y, index)
	{
		var width = read.width;
		var height = read.height;
		var data = read.data;

		var xl = three.Math.clamp(three.Math.floor(x), 0, width - 1);
		var xr = three.Math.clamp(three.Math.ceil(x), 0, width - 1);
		var xf = x - xl;

		var yl = three.Math.clamp(three.Math.floor(y), 0, height - 1);
		var yr = three.Math.clamp(three.Math.ceil(y), 0, height - 1);
		var yf = y - yl;

		var ll = 4 * (yl * width + xl);
		var lr = 4 * (yl * width + xr);
		var rl = 4 * (yr * width + xl);
		var rr = 4 * (yr * width + xr);

		for(var k = 0; k < 3; k++)
		{
			var a = data[ll + k] * (1 - xf) + data[lr + k] * xf;
			var b = data[rl + k] * (1 - xf) + data[rr + k] * xf;
			
			write.data[index + k] = three.Math.ceil(a * (1 - yf) + b * yf);
		}
	};

	/**
	 * Render a cube face from equirectangular projection.
	 *
	 * @method renderEquirectFace
	 * @param {ImageData} read Equirectangular image.
	 * @param {number} face Face to render.
	 * @param {number} rotation Image rotation
	 * @param {number} size Face size.
	 * @return {ImageData} Face data.
	 */
	CubeTexture.renderEquirectFace = function(read, face, rotation, size)
	{
		var out = new ImageData(size, size);
		var orientation = CubeTexture.faces[face];

		for(var x = 0; x < size; x++)
		{
			for(var y = 0; y < size; y++)
			{
				var index = 4 * (y * size + x);

				// Fill alpha channel
				out.data[index + 3] = 255;

				// Get position on cube face cube is centered at the origin with a side length of 2
				var cube = orientation(2 * (x + 0.5) / size - 1, 2 * (y + 0.5) / size - 1);

				// Project cube face onto unit sphere by converting cartesian to spherical coordinates
				var r = three.Math.sqrt(cube.x * cube.x + cube.y * cube.y + cube.z * cube.z);
				var lon = three.Math.euclideanModulo(three.Math.atan2(cube.y, cube.x) + rotation, 2 * three.Math.PI);
				var lat = three.Math.acos(cube.z / r);

				var px = read.width * lon / three.Math.PI / 2 - 0.5;
				var py = read.height * lat / three.Math.PI - 0.5;

				CubeTexture.resampleBilinear(read, out, px, py, index);
			}
		}

		return out;
	};

	CubeTexture.faces =
	[
		function(x, y)
		{
			return new three.Vector3(x, -1, -y);
		},
		function(x, y)
		{
			return new three.Vector3(-x, 1, -y);
		},
		function(x, y)
		{
			return new three.Vector3(-y, -x, 1);
		},
		function(x, y)
		{
			return new three.Vector3(y, -x, -1);
		},
		function(x, y)
		{
			return new three.Vector3(-1, -x, -y);
		},
		function(x, y)
		{
			return new three.Vector3(1, x, -y);
		}
	];

	/**
	 * Serialize cube texture to JSON.
	 * 
	 * All images of the cube texture are stored individually.
	 * 
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	CubeTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);

		data.size = this.size;
		data.mode = this.mode;

		data.images = [];

		if(this.mode === CubeTexture.EQUIRECTANGULAR || this.mode === CubeTexture.CROSS)
		{
			var image = this.images[0].toJSON(meta);
			data.images.push(image.uuid);
		}
		else
		{
			for(var i = 0; i < this.images.length; i++)
			{	
				var image = this.images[i].toJSON(meta);
				data.images.push(image.uuid);
			}
		}

		return data;
	};

	/**
	 * Reflection probes are used to create CubeTextures dinamically.
	 *
	 * These CubeTextures can be attributed to materials programatically.
	 * 
	 * @class CubeCamera
	 * @extends {Object3D}
	 * @module Misc
	 */
	function CubeCamera(near, far, resolution, autoUpdate)
	{
		three.Object3D.call(this);

		this.name = "cubecamera";
		this.type = "CubeCamera";

		/**
		 * CubeCamera near plane.
		 * @property near
		 * @type {number}
		 */
		this.near = (near !== undefined) ? near : 1e-2;

		/**
		 * CubeCamera far plane.
		 * @property far
		 * @type {number}
		 */
		this.far = (far !== undefined) ? far : 1e4;

		/**
		 * Resolution of each face. Should be a power of 2 (32, 64, 128, ...).
		 * @property resolution
		 * @type {number}
		 */
		this.resolution = (resolution !== undefined) ? resolution : 256;

		/**
		 * Auto update indicates if the cube camera is updated automatically each frame.
		 * 
		 * @property autoUpdate
		 * @type {boolean}
		 */
		this.autoUpdate = (autoUpdate !== undefined) ? autoUpdate : false;

		/**
		 * Array of 6 cameras used to render each face of the cube.
		 * @property cameras
		 * @type {Array}
		 */
		this.cameras = [];
		for(var i = 0; i < 6; i++)
		{
			var camera = new three.PerspectiveCamera(90, 1, this.near, this.far);
			camera.parent = this;
			this.cameras.push(camera);
		}

		this.cameras[0].up.set(0, -1, 0);
		this.cameras[0].lookAt(new three.Vector3(1, 0, 0));
		this.cameras[1].up.set(0, -1, 0);
		this.cameras[1].lookAt(new three.Vector3(-1, 0, 0));
		this.cameras[2].up.set(0, 0, 1);
		this.cameras[2].lookAt(new three.Vector3(0, 1, 0));
		this.cameras[3].up.set(0, 0, -1);
		this.cameras[3].lookAt(new three.Vector3(0, -1, 0));
		this.cameras[4].up.set(0, -1, 0);
		this.cameras[4].lookAt(new three.Vector3(0, 0, 1));
		this.cameras[5].up.set(0, -1, 0);
		this.cameras[5].lookAt(new three.Vector3(0, 0, -1));

		/**
		 * WebGL cube render target to where the scene is rendered.
		 * @property target
		 * @type {WebGLCubeRenderTarget}
		 */
		this.renderTarget = new three.WebGLCubeRenderTarget(this.resolution,
		{
			format: three.RGBFormat,
			magFilter: three.LinearFilter,
			minFilter: three.LinearFilter,
			generateMipmaps: false
		});


		var self = this;
		Object.defineProperties(this,
		{
			/**
			 * CubeTexture generated by this CubeCamera.
			 *
			 * Can be attached to materials as envMap.
			 * 
			 * @property cube
			 * @type {CubeTexture}
			 */
			cube:
			{
				get: function(){return self.renderTarget.texture;},
				set: function(value){}
			}
		});

		this.scene = null;
		this.renderer = null;
	}

	three.CubeCamera = CubeCamera;
	CubeCamera = CubeCamera;

	CubeCamera.prototype = Object.create(three.Object3D.prototype);

	/**
	 * Initialize CubeCamera object.
	 * 
	 * Gets the attached scene and the renderer in use.
	 *
	 * @method initialize
	 */
	CubeCamera.prototype.initialize = function()
	{
		var node = this;
		while(node.parent !== null)
		{
			node = node.parent;
			if(node instanceof Scene)
			{
				this.scene = node;
			}
			else if(node instanceof Program)
			{
				this.renderer = node.renderer;
			}
		}

		three.Object3D.prototype.initialize.call(this);
	};


	/**
	 * Update CubeCamera object.
	 *
	 * If autoUpdate is set to true the CubeCamera updates the CubeTexture automatically.
	 * 
	 * @method update
	 */
	CubeCamera.prototype.update = function(delta)
	{
		if(this.autoUpdate)
		{
			this.updateCubeMap(this.renderer, this.scene);
		}

		three.Object3D.prototype.update.call(this, delta);
	};


	/**
	 * Set the CubeCamera resolution.
	 *
	 * @method setResolution
	 * @param {number} resolution CubeCamera resolution (per face). Should be a 2 pot.
	 */
	CubeCamera.prototype.setResolution = function(resolution)
	{
		this.resolution = resolution;
		this.renderTarget.setSize(resolution, resolution);
	};

	/**
	 * Clear cube camera render target.
	 *
	 * @method clear
	 */
	CubeCamera.prototype.clear = function(renderer, color, depth, stencil)
	{
		var currentRenderTarget = renderer.getRenderTarget();

		for(var i = 0; i < 6; i++)
		{
			renderer.setRenderTarget(this.renderTarget, i);
			renderer.clear(color, depth, stencil);
		}

		renderer.setRenderTarget(currentRenderTarget);
	};

	/**
	 * Render new cube faces. 
	 * 
	 * Should be called every time a change in the scene is made.
	 *
	 * @method updateCubeMap
	 * @param {WebGLRenderer} renderer Renderer to be used.
	 * @param {Scene} scene Scene to be renderer.
	 */
	CubeCamera.prototype.updateCubeMap = function(renderer, scene)
	{
		var autoClear = renderer.autoClear;
		renderer.autoClear = false;

		// Backup current render target
		var currentRenderTarget = renderer.getRenderTarget();

		// Disable to render the cube faces
		var generateMipmaps = this.renderTarget.texture.generateMipmaps;
		this.renderTarget.texture.generateMipmaps = false;

		for(var i = 0; i < 6; i++)
		{
			if(i === 5)
			{
				this.renderTarget.texture.generateMipmaps = generateMipmaps;
			}
			this.cameras[i].updateMatrixWorld();
			renderer.setRenderTarget(this.renderTarget, i);
			renderer.clear(true, true, true);
			renderer.render(scene, this.cameras[i]);
		}

		// Restore renderer
		renderer.autoClear = autoClear;
		renderer.setRenderTarget(currentRenderTarget);
	};

	CubeCamera.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.resolution = this.resolution;
		data.object.autoUpdate = this.autoUpdate;

		return data;
	};

	/**
	 * A LightProbe is a source of indirect-diffuse light.
	 *
	 * @param {number} sh Light color in hex RGB
	 * @param {number} intensity Light intensity
	 * @class LightProbe
	 * @extends {LightProbe}
	 * @module Lights
	 */
	function LightProbe(sh, intensity)
	{
		three.LightProbe.call(this, sh, intensity);

		this.type = "LightProbe";
		this.name = "probe";
	}

	LightProbe.prototype = Object.create(three.LightProbe.prototype);

	/**
	 * Generate light probe data from cube camera render.
	 *
	 * @method generate
	 */
	LightProbe.prototype.generate = function()
	{
		var scene = this.getScene();
		if(scene === null)
		{
			console.warn("nunuStudio: LightProbe cannot generate, no scene.", this);
			return;
		}

		var canvas = new OffscreenCanvas(256, 256);

		var renderer = new three.WebGLRenderer({canvas: canvas, alpha: true});
		
		var cubeCamera = new TCubeCamera(1, 1000, 256,
		{	
			format: three.RGBAFormat,
			magFilter: three.LinearFilter,
			minFilter: three.LinearFilter
		});
		cubeCamera.matrixAutoUpdate = false;
		cubeCamera.matrix.copy(this.matrix);
		cubeCamera.matrixWorld.copy(this.matrixWorld);

		// Since gamma is applied during rendering, the cubeCamera renderTarget texture encoding must be sRGBEncoding
		cubeCamera.renderTarget.texture.encoding = THREE.sRGBEncoding;
		cubeCamera.update(renderer, scene);

		// Calculate probe from cube camera result
		var result = LightProbeGenerator.fromCubeRenderTarget(renderer, cubeCamera.renderTarget);
		this.sh = result.sh;
	};

	LightProbe.prototype.toJSON = function(meta)
	{
		var data = three.Light.prototype.toJSON.call(this, meta);

		data.object.sh = this.sh.toArray();

		return data;
	};

	/**
	 * A light source positioned directly above the scene, with color fading from the sky color to the ground color.
	 * 
	 * Based on HemisphereLight documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Lights/HemisphereLight
	 * 
	 * @param {number} skyColor Sky light color in hex RGB
	 * @param {number} groundColor Ground light color in hex RGB
	 * @param {number} intensity Light intensity
	 * @class HemisphereLight
	 * @extends {HemisphereLight}
	 * @module Lights
	 */
	function HemisphereLight(skyColor, groundColor, intensity)
	{
		three.HemisphereLight.call(this, skyColor, groundColor, intensity);

		this.name = "hemisphere";
	}

	HemisphereLight.prototype = Object.create(three.HemisphereLight.prototype);

	/**
	 * Ambient lights are used to create base ilumanition for the scene.
	 *
	 * They are not influenced by position, scale or rotation.
	 * 
	 * Based on AmbientLight documentation for the object can be found at https:// threejs.org/docs/index.html#Reference/Lights/AmbientLight
	 * 
	 * @param {number} hex Light color in hex RGB
	 * @class AmbientLight
	 * @extends {AmbientLight}
	 * @module Lights
	 */
	function AmbientLight(hex)
	{
		three.AmbientLight.call(this, hex);
		
		this.name = "ambient";

		this.matrixAutoUpdate = false;
	}

	AmbientLight.prototype = Object.create(three.AmbientLight.prototype);

	/**
	 * Leap device object based on the official LeapJS runtime.
	 * 
	 * Used to connect nunuStudio to a leap motion hand tracker, works on Windows and MacOS.
	 * 
	 * @class LeapMotion
	 * @module Devices
	 * @extends {Group}
	 */
	function LeapMotion()
	{
		three.Group.call(this);

		this.type = "LeapDevice";
		this.name = "leap";

		/**
		 * Debug model flag.
		 * 
		 * @property debugModel
		 * @default true
		 * @type {boolean}
		 */
		this.debugModel = true;

		/**
		 * Flag to enable gesture detection.
		 * 
		 * @property gesturesEnabled
		 * @default true
		 * @type {boolean}
		 */
		this.gesturesEnabled = true;

		/**
		 * Flag to enable hand pose detection.
		 * 
		 * @property posesEnabled
		 * @default true
		 * @type {boolean}
		 */
		this.posesEnabled = true;

		/**
		 * Hand tracking mode.
		 * 
		 * @property mode
		 * @default DESK
		 * @type {number}
		 */
		this.mode = LeapMotion.DESK;

		/**
		 * Flag to set arm tracking.
		 * 
		 * @property useArm
		 * @default false
		 * @type {boolean}
		 */
		this.useArm = false;

		// Hand and Arm meshes
		this.boneMeshes = [];
		this.armMeshes = [];

		// Debug Hand Material and Geometry
		this.material = new three.MeshPhongMaterial();
		this.geometry = new three.BoxBufferGeometry(1, 1, 1);

		// Gesture
		this.gesture = [];
		for(var i = 0; i < 10; i++)
		{
			this.gesture[i] = false;
		}

		// Poses
		this.pose = [];
		for(var i = 0; i < 3; i++)
		{
			this.pose[i] = false;
		}

		// Data storage
		this.data = null;
	}

	LeapMotion.prototype = Object.create(three.Group.prototype);

	/**
	 * Leap tracking desktop mode
	 * @attribute DESK
	 * @type {number}
	 */
	LeapMotion.DESK = 0;

	/**
	 * Leap tracking HDM mode
	 * @attribute DESK
	 * @type {number}
	 */
	LeapMotion.HDM = 1;

	/**
	 * Leap SWIPE gesture
	 * @attribute SWIPE
	 * @type {number}
	 */
	LeapMotion.SWIPE = 0;
	/**
	 * Leap SWIPE_LEFT gesture
	 * @attribute SWIPE_LEFT
	 * @type {number}
	 */
	LeapMotion.SWIPE_LEFT = 1;
	/**
	 * Leap SWIPE_RIGHT gesture
	 * @attribute SWIPE_RIGHT
	 * @type {number}
	 */
	LeapMotion.SWIPE_RIGHT = 2;
	/**
	 * Leap SWIPE_FRONT gesture
	 * @attribute SWIPE_FRONT
	 * @type {number}
	 */
	LeapMotion.SWIPE_FRONT = 3;
	/**
	 * Leap SWIPE_BACK gesture
	 * @attribute SWIPE_BACK
	 * @type {number}
	 */
	LeapMotion.SWIPE_BACK = 4;
	/**
	 * Leap SWIPE_UP gesture
	 * @attribute SWIPE_UP
	 * @type {number}
	 */
	LeapMotion.SWIPE_UP = 5;
	/**
	 * Leap SWIPE_DOWN gesture
	 * @attribute SWIPE_DOWN
	 * @type {number}
	 */
	LeapMotion.SWIPE_DOWN = 6;
	/**
	 * Leap CIRCLE gesture
	 * @attribute CIRCLE
	 * @type {number}
	 */
	LeapMotion.CIRCLE = 7;
	/**
	 * Leap SCREEN_TAP gesture
	 * @attribute SCREEN_TAP
	 * @type {number}
	 */
	LeapMotion.SCREEN_TAP = 8;
	/**
	 * Leap KEY_TAP gesture
	 * @attribute KEY_TAP
	 * @type {number}
	 */
	LeapMotion.KEY_TAP = 9;

	/**
	 * Hand CLOSED pose
	 * @attribute CLOSED
	 * @type {number}
	 */
	LeapMotion.CLOSED = 0;
	/**
	 * Hand OPEN pose
	 * @attribute OPEN
	 * @type {number}
	 */
	LeapMotion.OPEN = 1;
	/**
	 * Hand POINTING pose
	 * @attribute POINTING
	 * @type {number}
	 */
	LeapMotion.POINTING = 2;

	/**
	 * Initialize LeapMotion object.
	 * 
	 * Connects to the websocket provided by the leap driver.
	 * 
	 * @method initialize
	 */
	LeapMotion.prototype.initialize = function()
	{
		var self = this;

		// Start leap worker to collect data
		Leap.loop({background: true}, function(data)
		{
			self.data = data;
		}).connect();

		three.Object3D.prototype.initialize.call(this);
	};

	/**
	 * Update leap status.
	 * 
	 * @method update
	 */
	LeapMotion.prototype.update = function(delta)
	{
		if(this.data !== null)
		{
			if(this.gesturesEnabled)
			{
				this.updateGestures();	
			}
			if(this.posesEnabled)
			{
				this.updatePoses();
			}
			if(this.debugModel)
			{
				this.updateDebugModel();
			}
		}

		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Check if a gesture is occuring, is true while the gesture is occuring.
	 * 
	 * @method checkGesture
	 * @param {number} gesture Gesture to check
	 * @return {boolean} True if the gesture is occuring
	 */
	LeapMotion.prototype.checkGesture = function(gesture)
	{
		if(this.gesture[gesture] !== undefined)
		{
			return this.gesture[gesture];
		}
		return false;
	};

	/**
	 * Check if hand is in pose.
	 *
	 * @method checkPose
	 * @param {number} pose Pose to be checked
	 * @return {boolean} True is hand is in this pose
	 */
	LeapMotion.prototype.checkPose = function(pose)
	{
		if(this.pose[pose] !== undefined)
		{
			return this.pose[pose];
		}
		return false;
	};

	/**
	 * Set hand tracking mode.
	 * 
	 * Can be set to HDM or Desktop mode.
	 * 
	 * @method setMode
	 * @param {number} mode Mode
	 */
	LeapMotion.prototype.setMode = function(mode)
	{
		this.mode = mode;
	};

	/**
	 * Update leap object pose flags from collected data.
	 * 
	 * Called automatically by the update methos.
	 * 
	 * @method updatePoses
	 */
	LeapMotion.prototype.updatePoses = function()
	{
		// Clean all pose flags
		for(var i = 0; i < this.pose.length; i++)
		{
			this.pose[i] = true;
		}

		for(var j = 0; j < this.data.hands.length; j++)
		{
			var hand = this.data.hands[j];

			var center = hand.sphereCenter;
			center = new three.Vector3(center[0], center[1], center[2]);

			// Fingers position 
			var distance = [];
			var indicatorDistance = 0;
			var fingerJoint = [];

			// Clear pose status list
			for(var i = 0; i < this.pose.length; i++)
			{
				this.pose[i] = true;
			}

			// Fingers direction array
			var fingerDirection = [];

			for(var i = 0; i < hand.fingers.length; i++)
			{
				var finger = hand.fingers[i];

				fingerDirection.push(finger.direction);
				fingerJoint = finger.distal.nextJoint;

				var joint = new three.Vector3(fingerJoint[0], fingerJoint[1], fingerJoint[2]);
				distance.push((center.distanceTo(joint))/hand._scaleFactor);

				if(i !== 0)
				{
					if(fingerDirection[i][2] < 0.3)
					{
						this.pose[LeapMotion.CLOSED] = false;
					}
					
					if(fingerDirection[i][2] > -0.5)
					{
						this.pose[LeapMotion.OPEN] = false;
					}

					if(i === 1)
					{
						indicatorDistance = distance[1];
					}
					else if(indicatorDistance < 2 * distance[i] - 15)
					{
						this.pose[LeapMotion.POINTING] = false;
					}
				}
			}

			if(indicatorDistance < 2 * distance[0] - 15)
			{
				this.pose[LeapMotion.POINTING] = false;
			}
		}
	};

	/**
	 * Update leap object gesture flags from collected data.
	 * 
	 * Called automatically by the update method.
	 * 
	 * @method updateGestures
	 */
	LeapMotion.prototype.updateGestures = function()
	{
		// Clean all event flags
		for(var i = 0; i < this.gesture.length; i++)
		{
			this.gesture[i] = false;
		}
		
		var self = this;

		// Gesture detection
		if(this.data.valid && this.data.gestures.length > 0)
		{
			this.data.gestures.forEach(function(gesture)
			{
				if(gesture.type === "swipe")
				{
					// var direction;
					self.gesture[LeapMotion.SWIPE] = true;

					// X Direction
					if(gesture.direction[0] > 0)
					{	
						self.gesture[LeapMotion.SWIPE_RIGHT] = true;
					}
					else
					{
						self.gesture[LeapMotion.SWIPE_LEFT] = true;
					}

					// Y Direction
					if(gesture.direction[1] > 0)
					{
						self.gesture[LeapMotion.SWIPE_UP] = true;
					}
					else
					{
						self.gesture[LeapMotion.SWIPE_DOWN] = true;
					}

					// Z Direction
					if(gesture.direction[2] > 0)
					{
						self.gesture[LeapMotion.SWIPE_FRONT] = true;
					}
					else
					{
						self.gesture[LeapMotion.SWIPE_BACK] = true;
					}
				}
				else if(gesture.type === "circle")
				{
					self.gesture[LeapMotion.CIRCLE] = true;	
				}
				else if(gesture.type === "keyTap")
				{
					self.gesture[LeapMotion.KEY_TAP] = true;	
				}
				else if(gesture.type === "screenTap")
				{
					self.gesture[LeapMotion.SCREEN_TAP] = true;	
				}
			});
		}
	};

	/**
	 * Update internal hand debug model.
	 * 
	 * Automatically called by the update method if debugModel is set to true.
	 * 
	 * @method updateDebugModel
	 */
	LeapMotion.prototype.updateDebugModel = function()
	{
		// Self pointer
		var self = this;

		// Remove all children
		this.armMeshes.forEach(function(item)
		{
			self.remove(item);
		});
		
		this.boneMeshes.forEach(function(item)
		{
			self.remove(item);
		});

		// Update bones
		var countBones = 0;
		var countArms = 0;

		// TODO <CHECK THIS CODE>
		for(var i = 0; i < this.data.hands.length; i++)
		{
			var hand = this.data.hands[i];

			for(var j = 0; j < hand.fingers.length; j++)
			{
				var finger = hand.fingers[j];

				for(var k = 0; k < finger.bones.length; k++)
				{
					var bone = finger.bones[k];
					if(countBones !== 0)
					{
						var boneMesh = this.boneMeshes[countBones] || this.addMesh(this.boneMeshes);
						this.updateMesh(bone, boneMesh);
					}
					countBones++;
				}
			}
			
			if(this.showArm)
			{
				var arm = hand.arm;
				var armMesh = this.armMeshes[countArms++] || this.addMesh(this.armMeshes);
				this.updateMesh(arm, armMesh);
				armMesh.scale.set(arm.width/1200, arm.width/300, arm.length/150);
			}
		}
	};

	// Add mesh to hand instance
	LeapMotion.prototype.addMesh = function(meshes)
	{
		var mesh = new Mesh(this.geometry, this.material);
		mesh.castShadow = this.castShadow;
		mesh.receiveShadow = this.receiveShadow;
		meshes.push(mesh);
		return mesh;
	};

	// Update mesh position and size
	LeapMotion.prototype.updateMesh = function(bone, mesh)
	{
		mesh.position.fromArray(bone.center());
		mesh.position.divideScalar(150);

		mesh.setRotationFromMatrix((new three.Matrix4()).fromArray(bone.matrix()));
		mesh.scale.set(bone.width/150, bone.width/150, bone.length/150);

		this.add(mesh);
	};

	/**
	 * Get hand speed (temporaly normalized).
	 * 
	 * @method getMovement
	 * @return {number} Hand speed
	 */
	LeapMotion.prototype.getMovement = function()
	{
		var actual = this.data.gestures[0].position;
		var previous = this.data.gestures[0].startPosition;

		var speed = new three.Vector3(actual[0] - previous[0], actual[1] - previous[1], actual[2] - previous[2]);
		speed.divideScalar(this.data.currentFrameRate);

		return speed;
	};

	LeapMotion.prototype.toJSON = function(meta)
	{
		var data = three.Group.prototype.toJSON.call(this, meta);

		data.object.type = this.type;
		data.object.debugModel = this.debugModel;
		data.object.gesturesEnabled = this.gesturesEnabled;
		data.object.posesEnabled = this.posesEnabled;
		data.object.mode = this.mode;
		data.object.useArm = this.useArm;

		return data;
	};

	/**
	 * Kinect device object.
	 * 
	 * This object is used to connect nunuStudio to a Microsoft Kinect V1, it only works in Microsoft Windows.
	 * 
	 * The operation of the kinect object depends on a server program used to connect to kinect that sends the data to nunuStudio via WebSocket.
	 * 
	 * The server software is available inside the tools folder in the nunuStudio repository, and communicates using the port 8181 in the localhost.
	 * 
	 * @class KinectDevice
	 * @extends {Group}
	 * @module Devices
	 */
	function KinectDevice()
	{
		three.Group.call(this);

		this.type = "Kinect";
		this.name = "kinect";

		/**
		 * Websocket object used to connect to the data server.
		 * 
		 * @property socket
		 * @default 127.0.0.1:8181
		 * @type {Object}
		 */
		this.socket = new WebSocket("ws://127.0.0.1:8181");

		/**
		 * Connected flag.
		 * 
		 * @property connected
		 * @type {boolean}
		 */
		this.connected = false;

		/**
		 * Debug model flag.
		 * 
		 * @property debugModel
		 * @default true
		 * @type {boolean}
		 */
		this.debugModel = true;

		/**
		 * Time until data is considered too obsolete to be usable.
		 * 
		 * @property dataTimeout
		 * @type {number}
		 */
		this.dataTimeout = 0;

		/**
		 * Image data sent by the kinnect camera.
		 * 
		 * @property camera
		 * @type {Blob}
		 */
		this.camera = null;

		/**
		 * Skeleton data sent by the kinnect.
		 * 
		 * @property data
		 * @type {Object}
		 */
		this.data = null;
		
		this.dataReceived = false;

		// Self pointer
		var self = this;

		// Connection established
		this.socket.onopen = function()
		{
			self.connected = true;
		};

		// Connection closed
		this.socket.onclose = function()
		{
			self.connected = false;
		};

		// Receive data from the server
		this.socket.onmessage = function(event)
		{
			// Point data received
			if(typeof event.data === "string")
			{
				self.data = JSON.parse(event.data);
				self.dataReceived = true;
				self.dataTimeout = KinectDevice.DATA_TIMEOUT;
			}
			// Camera feed can be collected using URL.createObjectURL(event.data)
			else if(event.data instanceof Blob)
			{
				self.camera = event.data;
			}
		};
	}

	/**
	 * Kinect default data timeout in seconds.
	 * 
	 * @attribute DATA_TIMEOUT
	 * @type {number}
	 */
	KinectDevice.DATA_TIMEOUT = 20;


	/**
	 * Kinect camera depth mode.
	 * 
	 * @attribute DEPTH
	 * @type {number}
	 */
	KinectDevice.DEPTH = 0;

	/**
	 * Kinect camera color mode.
	 * 
	 * @attribute COLOR
	 * @type {number}
	 */
	KinectDevice.COLOR = 1;

	/**
	 * Kinect skeleton joint names in pairs.
	 * 
	 * @attribute JOINTS_NAME
	 * @type {Array}
	 */
	KinectDevice.JOINTS_NAME = [["head","shouldercenter"],["shouldercenter","shoulderright"],["shouldercenter","shoulderleft"],["shoulderright","elbowright"],
								["shoulderleft","elbowleft"],["elbowright","wristright"],["elbowleft","wristleft"],["wristright","handright"],["wristleft","handleft"],
								["shouldercenter","spine"],["spine","hipcenter"],["hipcenter","hipright"],["hipcenter","hipleft"],["hipright","kneeright"],
								["hipleft","kneeleft"],["kneeright","ankleright"],["kneeleft","ankleleft"],["ankleright","footright"],["ankleleft","footleft"]];

	KinectDevice.prototype = Object.create(three.Group.prototype);

	/**
	 * Update kinect device state.
	 * 
	 * @method update
	 */
	KinectDevice.prototype.update = function(delta)
	{
		// Check if there is data to process
		if(this.data !== null)
		{
			if(this.dataReceived)
			{
				// Clear data received flag
				this.dataReceived = false;

				// Remove all children
				while(this.children.length > 0)
				{
					this.children.pop();
				}

				// Show debug model
				if(this.debugModel)
				{
					var geometry = new three.SphereGeometry(0.04, 6, 6);
					var material = new three.MeshPhongMaterial(0xff0000);

					// Fill with new data
					for(var j = 0; j < this.data.skeletons.length; j++)
					{
						var joints = this.data.skeletons[j].joints;
						for(var i = 0; i < joints.length; i++)
						{
							var model = new Mesh(geometry, material);
							model.position.set(joints[i].x, joints[i].y, joints[i].z);
							model.castShadow = true;
							this.add(model);
						}
					}
				}
			}
			else if(this.dataTimeout > 0)
			{
				this.dataTimeout--;

				// If timeout Remove all children
				if(this.dataTimeout === 0)
				{
					while(this.children.length > 0)
					{
						this.children.pop();
					}
				}
			}
		}

		// Update children
		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Check if there is kinect connected.
	 * 
	 * @method isConnected
	 * @return {boolean} True if there is a kinect connected
	 */
	KinectDevice.prototype.isConnected = function()
	{
		return this.connected;
	};

	/**
	 * Set kinect camera mode.
	 * 
	 * @method setCameraMode
	 * @param {boolean} mode Camera mode
	 */
	KinectDevice.prototype.setCameraMode = function(mode)
	{
		if(mode === KinectDevice.COLOR)
		{
			socket.send("Color");
		}
		else if(mode === KinectDevice.DEPTH)
		{
			socket.send("Depth");
		}
	};

	KinectDevice.prototype.toJSON = function(meta)
	{
		var data = three.Group.prototype.toJSON.call(this, meta);

		data.object.debugModel = this.debugModel;

		return data;
	};

	/**
	 * Orbit controls object can be controlled using the mouse.
	 * 
	 * It can be rotated using the mouse left button, moved with the mouse right button or mouse wheel. 
	 * 
	 * @class OrbitControls
	 * @extends {Group}
	 * @module Controls
	 */
	function OrbitControls()
	{
		three.Group.call(this);

		this.name = "orbit";
		this.type = "OrbitControls";

		/**
		 * Initial distance of the object relative to the center.
		 * 
		 * @property distance
		 * @default 3
		 * @type {number}
		 */
		this.distance = 4;

		/**
		 * Maximum Distance allowed.
		 *
		 * @property maxDistance
		 * @type {number}
		 */
		this.maxDistance = 20;

		/**
		 * Minimum distance allowed.
		 *
		 * @property minDistance
		 * @type {number}
		 */
		this.minDistance = 2;

		/**
		 * Mouse sensitivity.
		 * 
		 * @property sensitivity
		 * @type {number}
		 */
		this.sensitivity = 0.002;

		/**
		 * Mouse scroll sensitivity.
		 * 
		 * @property zoomSensitivity
		 * @type {number}
		 */
		this.zoomSensitivity = 0.001;

		/**
		 * Top limit angle.
		 * 
		 * @property limitUp
		 * @default 1.57
		 * @type {number}
		 */
		this.limitUp = 1.57;

		/**
		 * Bottom limit angle.
		 * 
		 * @property limitDown
		 * @default -1.57
		 * @type {number}
		 */
		this.limitDown = -1.57;

		/**
		 * Indicates if the button left button needs to be pressed to rotate the object.
		 * 
		 * @property needsButtonPressed
		 * @default true
		 * @type {boolean}
		 */
		this.needsButtonPressed = true;

		/**
		 * Indicates if its possible to zoom in and out to the center point.
		 * 
		 * @property zoomEnabled
		 * @default true
		 * @type {boolean}
		 */
		this.zoomEnabled = true;

		/**
		 * Indicates if its possible to move the object around.
		 * 
		 * @property movementEnabled
		 * @default true
		 * @type {boolean}
		 */
		this.movementEnabled = true;

		/**
		 * Central point of the orbit.
		 *
		 * @property center
		 * @type {Vector3}
		 */
		this.center = new three.Vector3(0, 0, 0);

		/**
		 * Orientation of the camera.
		 *
		 * X is the horizontal orientation and Y the vertical orientation.
		 *
		 * @property vector
		 * @type {Vector2}
		 */	
		this.vector = new three.Vector2(Math.PI / 2, 0);

		/**
		 * Enables smooth orbit movement.
		 *
		 * @property smooth
		 * @type {boolean}
		 */	
		this.smooth = true;

		/**
		 * Orbit speed friction, higher value allow the orbit to retain more speed.
		 *
		 * Only used when smooth is set true.
		 *
		 * @property friction
		 * @type {number}
		 */	
		this.friction = 0.8;

		/**
		 * Obit movement speed.
		 *
		 * Only used when smooth is set true.
		 *
		 * @property friction
		 * @type {number}
		 */	
		this.speed = 0.3;

		/**
		 * If set true the Y orientation movement is inverted.
		 *
		 * @property invertNavigation
		 * @type {boolean}
		 */
		this.invertNavigation = false;

		this.mouse = null;
		this.keyboard = null;

		this.speedDistance = 0;
		this.speedCenter = new three.Vector3(0, 0, 0);
		this.speedOrientation = new three.Vector2(0, 0);
		this.tempVector = new three.Vector3();
	}

	OrbitControls.UP = new three.Vector3(0, 1, 0);
	OrbitControls.ZERO = new three.Vector3(0, 0, 0);

	OrbitControls.prototype = Object.create(three.Group.prototype);

	OrbitControls.prototype.initialize = function()
	{
		var node = this;
		while(node.parent !== null)
		{
			node = node.parent;

			if(node instanceof Program)
			{
				this.mouse = node.mouse;
				this.keyboard = node.keyboard;
			}
		}

		this.center.copy(this.position);
		this.updateControls();

		three.Group.prototype.initialize.call(this);
	};

	OrbitControls.prototype.update = function(delta)
	{
		var needsUpdate = false;

		if(!this.needsButtonPressed || this.mouse.buttonPressed(Mouse.LEFT))
		{
			if(this.smooth === true)
			{
				this.speedOrientation.y += this.speed * this.sensitivity * (this.invertNavigation ? this.mouse.delta.y : -this.mouse.delta.y);
				this.speedOrientation.x -= this.speed * this.sensitivity * this.mouse.delta.x;
			}
			else
			{
				this.vector.y -= this.sensitivity * (this.invertNavigation ? this.mouse.delta.y : -this.mouse.delta.y);
				this.vector.x -= this.sensitivity * this.mouse.delta.x;
			}
			needsUpdate = true;
		}

		if(this.zoomEnabled)
		{
			if(this.mouse.buttonPressed(Mouse.MIDDLE))
			{
				if(this.smooth === true)
				{
					this.speedCenter.y += this.speed * this.sensitivity * this.mouse.delta.y * this.distance;
				}
				else
				{
					this.center.y += this.sensitivity * this.mouse.delta.y * this.distance;
				}

				needsUpdate = true;
			}

			if(this.mouse.wheel !== 0)
			{
				if(this.smooth === true)
				{
					this.speedDistance += this.speed * this.mouse.wheel * this.position.distanceTo(this.center) * this.sensitivity;
				}
				else
				{
					this.distance += this.mouse.wheel * this.position.distanceTo(this.center) * this.sensitivity;
				}

				needsUpdate = true;
			}
		}
		
		if(this.movementEnabled && this.mouse.buttonPressed(Mouse.RIGHT))
		{
			var direction = this.getWorldDirection(this.tempVector);
			direction.y = 0;
			direction.normalize();

			if(this.smooth === true)
			{
				var y = this.speed * this.mouse.delta.y * this.sensitivity * this.distance;
				this.speedCenter.x +=  (-direction.x * y) ;
				this.speedCenter.z +=  (-direction.z * y) ;
				
				direction.applyAxisAngle(OrbitControls.UP, Math.PI/2);

				var x = this.speed * this.mouse.delta.x * this.sensitivity * this.distance;
				this.speedCenter.x -= direction.x * x;
				this.speedCenter.z -= direction.z * x;
			}
			else
			{
				var y = this.mouse.delta.y * this.sensitivity * this.distance;
				this.center.x +=  (-direction.x * y) ;
				this.center.z +=  (-direction.z * y) ;
				
				direction.applyAxisAngle(OrbitControls.UP, Math.PI/2);

				var x = this.mouse.delta.x * this.sensitivity * this.distance;
				this.center.x -= direction.x * x;
				this.center.z -= direction.z * x;
			}

			needsUpdate = true;
		}

		if(this.smooth === true)
		{
			this.distance += this.speedDistance;
			this.center.add(this.speedCenter);
			this.vector.add(this.speedOrientation);

			this.speedDistance *= this.friction;
			this.speedOrientation.multiplyScalar(this.friction);
			this.speedCenter.multiplyScalar(this.friction);

			this.updateControls();
			return;
		}

		if(needsUpdate === true)
		{
			this.updateControls();
		}

		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Update controls position and rotation.
	 *
	 * Should be called if some of its properties are changed manually.
	 *
	 * @method updateControls
	 */
	OrbitControls.prototype.updateControls = function()
	{
		if(this.vector.y < this.limitDown)
		{
			this.vector.y = this.limitDown;
		}
		else if(this.vector.y > this.limitUp)
		{
			this.vector.y = this.limitUp;
		}

		if(this.distance < this.minDistance)
		{
			this.distance = this.minDistance;
		}
		else if(this.distance > this.maxDistance)
		{
			this.distance = this.maxDistance;
		}

		var cos = this.distance * Math.cos(this.vector.y);
		this.position.set(Math.cos(this.vector.x) * cos, this.distance * Math.sin(this.vector.y), Math.sin(this.vector.x) * cos);
		this.position.add(this.center);

		var matrix = new three.Matrix4();
		matrix.lookAt(this.position, this.center, OrbitControls.UP);
		this.quaternion.setFromRotationMatrix(matrix);	
	};

	OrbitControls.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.distance = this.distance;
		data.object.maxDistance = this.maxDistance;
		data.object.minDistance = this.minDistance;
		data.object.sensitivity = this.sensitivity;
		data.object.limitUp = this.limitUp;
		data.object.limitDown = this.limitDown;

		data.object.needsButtonPressed = this.needsButtonPressed;
		data.object.zoomEnabled = this.zoomEnabled;
		data.object.movementEnabled = this.movementEnabled;

		data.object.smooth = this.smooth;
		data.object.friction = this.friction;
		data.object.speed = this.speed;
		data.object.invertNavigation = this.invertNavigation;

		data.object.center = this.center.toArray();
		data.object.vector = this.vector.toArray();

		return data;
	};

	/**
	 * First person controls can be controlled using the mouse and keyboard.
	 *
	 * Provides a navigations system familiar to the one found on FPS games.
	 * 
	 * The mouse left button can be used to look around, and the keyboard arrows for movement.
	 * 
	 * @class FirstPersonControls
	 * @extends {Group}
	 * @module Controls
	 */
	function FirstPersonControls()
	{
		three.Group.call(this);

		this.name = "controls";
		this.type = "FirstPersonControls";

		/**
		 * Mouse sensitivity.
		 * 
		 * @property sensitivity
		 * @type {number}
		 */
		this.sensitivity = 0.005;

		/**
		 * Flag to indicate if the button left button needs to be pressed to rotate the object.
		 * 
		 * @property needsButtonPressed
		 * @default true
		 * @type {boolean}
		 */
		this.needsButtonPressed = true;

		/**
		 * Indicates if its possible to move the object using the Keyboard keys.
		 * 
		 * @property movementEnabled
		 * @default true
		 * @type {boolean}
		 */
		this.movementEnabled = true;

		/**
		 * Movement speed, relative to the world.
		 * 
		 * @property moveSpeed
		 * @default moveSpeed
		 * @type {number}
		 */
		this.moveSpeed = 0.05;

		/**
		 * If set to true the object will only move on X and Z axis.
		 * 
		 * @property moveOnPlane
		 * @default false
		 * @type {boolean}
		 */
		this.moveOnPlane = false;

		/**
		 * Array with keys to be used to move the object.
		 *  - Forward
		 *  - Backward
		 *  - Left
		 *  - Right
		 * 
		 * @property moveKeys
		 * @type {Array}
		 */
		this.moveKeys = [Keyboard.W, Keyboard.S, Keyboard.A, Keyboard.D];
		
		/**
		 * Orientation of the camera.
		 *
		 * X is the horizontal orientation and Y the vertical orientation.
		 *
		 * @property vector
		 * @type {Vector2}
		 */	
		this.vector = new three.Vector2(0, 0);

		this.mouse = null;
		this.keyboard = null;

		this.tempVector = new three.Vector3();
	}

	FirstPersonControls.UP = new three.Vector3(0, 1, 0);

	FirstPersonControls.prototype = Object.create(three.Group.prototype);

	FirstPersonControls.prototype.initialize = function()
	{
		var node = this;
		while(node.parent !== null)
		{
			node = node.parent;

			if(node instanceof Program)
			{
				this.mouse = node.mouse;
				this.keyboard = node.keyboard;
			}
		}

		this.updateControls();
		
		three.Group.prototype.initialize.call(this);
	};

	FirstPersonControls.prototype.update = function(delta)
	{
		if(!this.needsButtonPressed || this.mouse.buttonPressed(Mouse.LEFT))
		{
			this.vector.y -= this.sensitivity * this.mouse.delta.y;
			this.vector.x -= this.sensitivity * this.mouse.delta.x;

			if(this.vector.y < -1.57)
			{
				this.vector.y = -1.57;
			}
			else if(this.vector.y > 1.57)
			{
				this.vector.y = 1.57;
			}

			this.updateControls();
		}

		if(this.movementEnabled)
		{
			if(this.keyboard.keyPressed(this.moveKeys[0]))
			{
				var direction = this.getWorldDirection(this.tempVector);
				if(this.moveOnPlane)
				{
					direction.y = 0;
				}
				direction.normalize();
				direction.multiplyScalar(this.moveSpeed);
				this.position.sub(direction);
			}
			if(this.keyboard.keyPressed(this.moveKeys[1]))
			{
				var direction = this.getWorldDirection(this.tempVector);
				if(this.moveOnPlane)
				{
					direction.y = 0;
				}
				direction.normalize();
				direction.multiplyScalar(this.moveSpeed);
				this.position.add(direction);
			}
			if(this.keyboard.keyPressed(this.moveKeys[2]))
			{
				var direction = new three.Vector3(Math.sin(this.vector.x - 1.57), 0, Math.cos(this.vector.x - 1.57));
				direction.normalize();
				direction.multiplyScalar(this.moveSpeed);
				this.position.sub(direction);
			}
			if(this.keyboard.keyPressed(this.moveKeys[3]))
			{
				var direction = new three.Vector3(Math.sin(this.vector.x + 1.57), 0, Math.cos(this.vector.x + 1.57));
				direction.normalize();
				direction.multiplyScalar(this.moveSpeed);
				this.position.sub(direction);
			}
		}
		
		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Update controls position and rotation.
	 *
	 * Should be called if some of its properties are changed manually.
	 *
	 * @method updateControls
	 */
	FirstPersonControls.prototype.updateControls = function()
	{
		var cos = Math.cos(this.vector.y);
		var direction = new three.Vector3(Math.sin(this.vector.x) * cos, Math.sin(this.vector.y), Math.cos(this.vector.x) * cos);
		direction.add(this.position);

		var matrix = new three.Matrix4();
		matrix.lookAt(this.position, direction, FirstPersonControls.UP);
		this.quaternion.setFromRotationMatrix(matrix);
	};

	/**
	 * Used to get camera direction for this controller.
	 *
	 * Controller direction can be used to simplify controlling physics objects, create objects in the camera direction, etc.
	 *
	 * @method getDirection
	 * @return {Vector3} Normalized camera direction. 
	 */
	FirstPersonControls.prototype.getDirection = function()
	{
		var direction = this.getWorldDirection(this.tempVector);
		direction.normalize();
		return direction;
	};

	FirstPersonControls.prototype.toJSON = function(meta)
	{
		var data = three.Object3D.prototype.toJSON.call(this, meta);

		data.object.moveSpeed = this.moveSpeed;
		data.object.sensitivity = this.sensitivity;
		data.object.needsButtonPressed = this.needsButtonPressed;
		data.object.movementEnabled = this.movementEnabled;
		data.object.moveOnPlane = this.moveOnPlane;
		data.object.moveKeys = this.moveKeys;
		
		return data;
	};

	/**
	 * Perspective camera, used for 3D scenes with objects getting smaller as they get away from the camera.
	 * 
	 * Based on PerspectiveCamera, original documentation available at https:// threejs.org/docs/index.html#Reference/Cameras/PerspectiveCamera.
	 * 
	 * @class PerspectiveCamera
	 * @extends {PerspectiveCamera}
	 * @module Cameras
	 * @param {number} fov Field of view
	 * @param {number} aspect Aspect ratio
	 * @param {number} near Near projection plane (how closer can be objects visible by this camera)
	 * @param {number} far Far projection plane (how far can be objects visible by this camera)
	 */
	/**
	 * Camera field of view in degrees.
	 * 
	 * @property fov
	 * @default 50
	 * @type {number}
	 */
	/**
	 * Camera aspect ratio X/Y.
	 * 
	 * @property aspect
	 * @default 1.0
	 * @type {number}
	 */
	/**
	 * Camera zoom.
	 * 
	 * @property zoom
	 * @default 1.0
	 * @type {number}
	 */
	function PerspectiveCamera(fov, aspect, near, far)
	{
		/**
		 * Camera viewport indicates where the image is drawn on the screen.
		 * 
		 * @property viewport
		 * @type {Viewport}
		*/
		this.viewport = new Viewport();
		
		three.PerspectiveCamera.call(this, fov, aspect, near, far);

		this.name = "camera";

		/**
		 * Clear screen color flag.
		 * 
		 * @property clearColor
		 * @default false
		 * @type {boolean}
		*/
		this.clearColor = true;

		/**
		 * Clear depth flag.
		 * 
		 * @property clearDepth
		 * @default false
		 * @type {boolean}
		*/
		this.clearDepth = true;

		/**
		 * Clear stencil buffer flag.
		 * 
		 * @property clearDepth
		 * @default false
		 * @type {boolean}
		*/
		this.clearStencil = true;

		/**
		 * Camera draw order preference.
		 * 
		 * If more than one camera has the same order value the draw order is undefined for those cameras.
		 * 
		 * @property order
		 * @default 0
		 * @type {number}
		*/
		this.order = 0;

		/**
		 * Effect composed of this camera. Is used to render the scene to the screen and apply effects.
		 *
		 * It is inialized with a RenderPass attached to it.
		 * 
		 * @property composer
		 * @type {EffectComposer}
		 */
		this.composer = new EffectComposer();

		var renderPass = new RenderPass();
		renderPass.renderToScreen = true;
		this.composer.addPass(renderPass);
	}

	PerspectiveCamera.prototype = Object.create(three.PerspectiveCamera.prototype);

	/**
	 * Resize this camera, should be called every time after resizing the screen.
	 *
	 * Updates the viewport, rendering composer and the camera projection matrix.
	 *
	 * @method resize
	 * @param {number} x Width of the screen.
	 * @param {number} y Height of the screen.
	 * @param {Viewport} viewport Viewport that encapsulates the viewport of the camera.
	 */
	PerspectiveCamera.prototype.resize = function(x, y, viewport)
	{
		this.viewport.width = x;
		this.viewport.height = y;
		this.viewport.update(viewport);

		this.aspect = this.viewport.getAspectRatio();
		this.updateProjectionMatrix();

		this.composer.setSize(this.viewport.viewport.z, this.viewport.viewport.w);
	};


	/**
	 * Prepare the renderer to render the frame using the camera settings.
	 *
	 * Should be called before the render() method to setup clear configuration and viewport.
	 *
	 * @method setupRenderer
	 * @param {WebGLRenderer} renderer WebGL renderer to configure.
	 */
	PerspectiveCamera.prototype.setupRenderer = function(renderer)
	{
		this.viewport.enable(renderer);
		renderer.clear(this.clearColor, this.clearDepth, this.clearStencil);
	};

	/**
	 * Render a scene using this camera and the internal EffectComposer.
	 *
	 * @method render
	 * @param {WebGLRenderer} renderer WebGL renderer to use.
	 * @param {Scene} scene Scene to be rendered.
	 */
	PerspectiveCamera.prototype.render = function(renderer, scene)
	{
		this.composer.render(renderer, scene, this, 0.016);
	};

	/**
	 * Destroy camera object and remove it from the scene.
	 * 
	 * @method destroy
	 */
	PerspectiveCamera.prototype.destroy = function()
	{
		var scene = this.getScene();
		if(scene !== null)
		{
			scene.removeCamera(this);
		}
		
		three.Object3D.prototype.destroy.call(this);
	};

	/**
	 * Update camera projection matrix.
	 * 
	 * Should be called after chaging projection parameters.
	 * 
	 * @method updateProjectionMatrix
	 */
	PerspectiveCamera.prototype.updateProjectionMatrix = function()
	{
		var top = this.near * three.Math.tan(three.Math.DEG2RAD * 0.5 * this.fov) / this.zoom;
		var height = 2 * top;
		var width = this.aspect * height;
		var left = -0.5 * width;

		if(this.filmOffset !== 0)
		{
			left += this.near * this.filmOffset / this.getFilmWidth();
		}

		this.projectionMatrix.makePerspective(left, left + width, top, top - height, this.near, this.far);
		this.projectionMatrixInverse.getInverse(this.projectionMatrix);
	};

	PerspectiveCamera.prototype.toJSON = function(meta)
	{
		var data = three.PerspectiveCamera.prototype.toJSON.call(this, meta);

		data.object.clearColor = this.clearColor;
		data.object.clearDepth = this.clearDepth;
		data.object.clearStencil = this.clearStencil;

		data.object.viewport = this.viewport.toJSON();

		data.object.order = this.order;
		data.object.composer = this.composer.toJSON();

		return data;
	};

	/**
	 * Orthographic Camera is used for 2D like image projection.
	 * 
	 * Based on OrthographicCamera, original documentation available at https:// threejs.org/docs/index.html#Reference/Cameras/OrthographicCamera.
	 * 
	 * @class OrthographicCamera
	 * @extends {OrthographicCamera}
	 * @module Cameras
	 * @param {number} size Camera size relative to resize mode
	 * @param {number} aspect Aspect ratio X/Y
	 * @param {number} mode Camera resize mode (RESIZE_HORIZONTAL or RESIZE_VERTICAL)
	 * @param {number} near Near projection plane
	 * @param {number} far Far projection plane
	 */
	function OrthographicCamera(size, aspect, mode, near, far)
	{
		three.OrthographicCamera.call(this, -1.0, 1.0, 1.0, -1.0, near, far);

		this.name = "camera";

		/**
		 * Camera size relative to resize mode.
		 * 
		 * @property size
		 * @default 10.0
		 * @type {number}
		*/
		this.size = (size != undefined) ? size : 10.0;

		/**
		 * Aspect ratio X/Y.
		 * 
		 * @property aspect
		 * @default 1.0
		 * @type {number}
		*/
		this.aspect = (aspect != undefined) ? aspect : 1.0;

		/**
		 * Camera resize mode.
		 * 
		 * @property mode
		 * @default RESIZE_HORIZONTAL
		 * @type {number}
		*/
		this.mode = (mode !== undefined) ? mode : OrthographicCamera.RESIZE_HORIZONTAL;

		/**
		 * Camera viewport indicates where the image is drawn on the screen.
		 * 
		 * @property viewport
		 * @type {Viewport}
		*/
		this.viewport = new Viewport();

		/**
		 * Clear screen color flag.
		 * 
		 * @property clearColor
		 * @default false
		 * @type {boolean}
		*/
		this.clearColor = true;

		/**
		 * Clear depth flag.
		 * 
		 * @property clearDepth
		 * @default false
		 * @type {boolean}
		*/
		this.clearDepth = true;

		/**
		 * Clear stencil buffer flag.
		 * 
		 * @property clearDepth
		 * @default false
		 * @type {boolean}
		*/
		this.clearStencil = true;

		/**
		 * Camera draw order preference.
		 * 
		 * If more than one camera has the same order value the draw order is undefined for those cameras.
		 * 
		 * @property order
		 * @default 0
		 * @type {number}
		*/
		this.order = 0;

		this.updateProjectionMatrix();
		
		/**
		 * Effect composed of this camera. Is used to render the scene to the screen and apply effects.
		 *
		 * It is inialized with a RenderPass attached to it.
		 * 
		 * @property composer
		 * @type {EffectComposer}
		 */
		this.composer = new EffectComposer();

		var renderPass = new RenderPass();
		renderPass.renderToScreen = true;
		this.composer.addPass(renderPass);
	}

	OrthographicCamera.prototype = Object.create(three.OrthographicCamera.prototype);

	/**
	 * Used to set camera to resize horizontally 
	 * @attribute RESIZE_HORIZONTAL
	 * @type {number}
	 */
	OrthographicCamera.RESIZE_HORIZONTAL = 0;

	/**
	 * Used to set camera to resize vertically.
	 *  
	 * @attribute RESIZE_VERTICAL
	 * @type {number}
	 */
	OrthographicCamera.RESIZE_VERTICAL = 1;

	/**
	 * Resize this camera, should be called every time after resizing the screen.
	 *
	 * Updates the viewport, rendering composer and the camera projection matrix.
	 *
	 * @method resize
	 * @param {number} x Width of the screen.
	 * @param {number} y Height of the screen.
	 * @param {Viewport} viewport Viewport that encapsulates the viewport of the camera.
	 */
	OrthographicCamera.prototype.resize = function(x, y, viewport)
	{
		this.viewport.width = x;
		this.viewport.height = y;
		this.viewport.update(viewport);

		this.aspect = this.viewport.getAspectRatio();
		this.updateProjectionMatrix();

		this.composer.setSize(this.viewport.viewport.z, this.viewport.viewport.w);
	};

	/**
	 * Prepare the renderer to render the frame using the camera settings.
	 *
	 * Should be called before the render() method to setup clear configuration and viewport.
	 *
	 * @method setupRenderer
	 * @param {WebGLRenderer} renderer WebGL renderer to configure.
	 */
	OrthographicCamera.prototype.setupRenderer = function(renderer)
	{
		this.viewport.enable(renderer);
		renderer.clear(this.clearColor, this.clearDepth, this.clearStencil);
	};

	/**
	 * Render a scene using this camera and the internal EffectComposer.
	 *
	 * @method render
	 * @param {WebGLRenderer} renderer WebGL renderer to use.
	 * @param {Scene} scene Scene to be rendered.
	 */
	OrthographicCamera.prototype.render = function(renderer, scene)
	{
		this.composer.render(renderer, scene, this, 0.016);
	};

	/**
	 * Destroy camera object and remove it from the scene.
	 * 
	 * @method destroy
	 */
	OrthographicCamera.prototype.destroy = function()
	{
		var scene = this.getScene();
		if(scene !== null)
		{
			scene.removeCamera(this);
		}
		
		three.Object3D.prototype.destroy.call(this);
	};

	/**
	 * Update camera projection matrix.
	 * 
	 * Also updates left right, top and bottom values from aspect and size.
	 *
	 * Should be called after chaging projection parameters.
	 * 
	 * @method updateProjectionMatrix
	 */
	OrthographicCamera.prototype.updateProjectionMatrix = function()
	{
		if(this.mode === OrthographicCamera.RESIZE_HORIZONTAL)
		{
			this.top = this.size / 2;
			this.bottom = -this.top;
			this.right = this.top * this.aspect;
			this.left = -this.right;
		}
		else if(this.mode === OrthographicCamera.RESIZE_VERTICAL)
		{
			this.right = this.size / 2;
			this.left = -this.right;
			this.top = this.right / this.aspect;
			this.bottom = -this.top;
		}

		three.OrthographicCamera.prototype.updateProjectionMatrix.call(this);
	};

	OrthographicCamera.prototype.toJSON = function(meta)
	{
		var data = three.OrthographicCamera.prototype.toJSON.call(this, meta);

		data.object.size = this.size;
		data.object.aspect = this.aspect;
		data.object.mode = this.mode;

		data.object.clearColor = this.clearColor;
		data.object.clearDepth = this.clearDepth;
		data.object.clearStencil = this.clearStencil;

		data.object.viewport = this.viewport.toJSON();
		
		data.object.order = this.order;
		data.object.composer = this.composer.toJSON();

		return data;
	};

	/**
	 * AudioEmitter is a Object3D used to play audio inside the scene.
	 *
	 * @author mrdoob
	 * @author Reece Aaron Lecrivain
	 * @param {Audio} audio Audio used by this emitter
	 * @class AudioEmitter
	 * @extends {Audio}
	 * @module Audio
	 */
	function AudioEmitter(audio)
	{
		three.Object3D.call(this);

		this.name = "audio";
		this.type = "Audio";

		/**
		 * AudioListener used by this emmiter.
		 *
		 * Every AudioEmitter has a different WebAudio AudioListener.
		 * 
		 * @property listener
		 * @type {AudioListener}
		 */
		this.listener = new three.AudioListener();
		this.context = this.listener.context;
		this.matrixAutoUpdate = false;

		/** 
		 * WebAudio gain node, used to control the volume.
		 *
		 * https:// developer.mozilla.org/en-US/docs/Web/API/GainNode
		 *
		 * @property gain
		 * @type {GainNode}
		 */
		this.gain = this.context.createGain();
		this.gain.connect(this.listener.getInput());

		this.buffer = null;
		
		this.filters = [];

		/**
		 * Audio source type, can have the following values:
		 *  - empty
		 *  - buffer
		 *  - audioNode
		 *
		 * @property sourceType
		 * @type {string}
		 * @default {"empty"}
		 */
		this.sourceType = "empty";

		/**
		 * Audio source resource.
		 *
		 * @property audio
		 * @type {Audio}
		 */
		this.audio = (audio !== undefined) ? audio : null;

		/**
		 * If true the playback starts automatically.
		 *
		 * @property autoplay
		 * @default true
		 * @type {boolean}
		 */
		this.autoplay = true;

		/**
		 * Audio volume.
		 *
		 * @property volume
		 * @default 1.0
		 * @type {number}
		 */
		this.volume = 1.0;

		/**
		 * Start time in seconds.
		 *
		 * @property playbackRate
		 * @default 1.0
		 * @type {number}
		 */
		this.playbackRate = 1.0;

		/**
		 * Start time in seconds.
		 *
		 * @property startTime
		 * @default 0.0
		 * @type {number}
		 */
		this.startTime = 0.0;

		/**
		 * If true the audio plays in loop.
		 *
		 * @property loop
		 * @default true
		 * @type {boolean}
		 */
		this.loop = true;

		/**
		 * Modify pitch, measured in cents. +/- 100 is a semitone. +/- 1200 is an octave.
		 *
		 * @property detune
		 * @type {number}
		 */
		this.detune = 0;

		this.isPlaying = false;
		this.hasPlaybackControl = true;

		this.filters = [];
	}

	AudioEmitter.prototype = Object.create(three.Object3D.prototype);

	/**
	 * Possible source types for the audio emitter.
	 *
	 * @static
	 * @attribute SOURCE
	 * @type {Object}
	 */
	AudioEmitter.SOURCE = {
		EMPTY: "empty",
		BUFFER: "buffer",
		NODE: "audioNode"
	};

	/**
	 * Method called when the audio playback stoped.
	 *
	 * @method onEnded
	 */
	AudioEmitter.prototype.onEnded = function()
	{
		this.isPlaying = false;
	};

	/**
	 * Connect the audio source.
	 *
	 * Used internally on initialisation and when setting / removing
	 *
	 * @method connect
	 */
	AudioEmitter.prototype.connect = function()
	{
		if(this.filters.length > 0)
		{
			this.source.connect(this.filters[0]);

			for (var i = 1, l = this.filters.length; i < l; i ++)
			{
				this.filters[i - 1].connect(this.filters[i]);
			}

			this.filters[this.filters.length - 1].connect(this.getOutput());
		}
		else
		{
			this.source.connect(this.getOutput());
		}

		return this;

	};

	/**
	 * Disconnect the audio source.
	 *
	 * Used internally when setting / removing filters.
	 *
	 * @method disconnect
	 */
	AudioEmitter.prototype.disconnect = function()
	{
		if(this.filters.length > 0)
		{
			this.source.disconnect(this.filters[0]);

			for (var i = 1, l = this.filters.length; i < l; i ++)
			{
				this.filters[i - 1].disconnect(this.filters[i]);
			}

			this.filters[this.filters.length - 1].disconnect(this.getOutput());
		}
		else
		{
			this.source.disconnect(this.getOutput());
		}

		return this;
	};

	/**
	 * Initialize audio object, loads audio data decodes it and starts playback ifautoplay is set to True.
	 * 
	 * @method initialize
	 */
	AudioEmitter.prototype.initialize = function()
	{
		if(this.audio !== null)
		{
			var self = this;

			this.audio.getAudioBuffer(this.context, function(buffer)
			{
				self.setBuffer(buffer);
			});
		}
		else
		{
			console.warn("nunuStudio: AudioEmitter audio is null.");
		}
		
		this.setVolume(this.volume);
		this.setPlaybackRate(this.playbackRate);

		three.Object3D.prototype.initialize.call(this);
	};

	/**
	 * Set audio buffer to be used by this emitter.
	 *
	 * @method setBuffer
	 * @param {AudioBuffer} audioBuffer Audio buffer to be used.
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setBuffer = function(audioBuffer)
	{
		this.buffer = audioBuffer;
		this.sourceType = "buffer";

		if(this.autoplay === true)
		{
			this.play();
		}
		
		return this;
	};

	/**
	 * Play audio.
	 * 
	 * @method play
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.play = function()
	{
		if(this.buffer === null)
		{
			console.warn("nunuStudio: Audio buffer not ready, audio will not play.");
			return;
		}

		if(this.isPlaying)
		{
			console.warn("nunuStudio: Audio is already playing, its only possible to control the last playing instance.");
		}

		var source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.detune.value = this.detune;
		source.loop = this.loop;
		source.onended = this.onEnded.bind(this);
		source.playbackRate.setValueAtTime(this.playbackRate, this.startTime);
		source.start(0, this.startTime);

		this.isPlaying = true;
		this.source = source;

		return this.connect();
	};

	/**
	 * Pauses audio playback.
	 * 
	 * @method pause
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.pause = function()
	{
		this.source.stop();
		this.startTime = this.context.currentTime;
		this.isPlaying = false;

		return this;
	};

	/**
	 * Stops audio playback and resets time to 0.
	 * 
	 * @method pause
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.stop = function()
	{
		this.source.stop();
		this.startTime = 0.0;
		this.isPlaying = false;

		return this;
	};

	/**
	 * Change audio resource.
	 * 
	 * If changed after initialization the audio buffer will be disconnected and reintialized.
	 *
	 * @method setAudio
	 * @param {Audio} audio Audio resource.
	 */
	AudioEmitter.prototype.setAudio = function(audio)
	{
		this.audio = audio;

		if(this.buffer !== null)
		{
			if(this.isPlaying)
			{
				this.stop();
			}
			this.disconnect();
		}

		var self = this;

		this.audio.getAudioBuffer(this.context, function(buffer)
		{
			self.setBuffer(buffer);
		});
	};

	/**
	 * Get audio emitter volume.
	 * 
	 * @param {number} volume
	 * @method getVolume
	 */
	AudioEmitter.prototype.getVolume = function()
	{
		return this.gain.gain.value;
	};

	/**
	 * Set audio emitter volume.
	 * 
	 * @method setVolume
	 * @param {number} value Audio volume
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setVolume = function(value)
	{
		this.volume = value;
		this.gain.gain.value = value;

		return this;
	};

	/**
	 * Set loop mode. If loop set to True the audio repeats after ending.
	 * 
	 * @method setLoop
	 * @param {boolean} loop
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setLoop = function(loop)
	{
		this.loop = loop;

		if(this.isPlaying)
		{
			this.source.loop = this.loop;
		}

		return this;
	};

	/**
	 * Set detune value.
	 * 
	 * @method setDetune
	 * @param {number} value
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setDetune = function(value)
	{
		this.detune = value;

		if(this.isPlaying === true)
		{
			this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
		}

		return this;
	};

	/**
	 * Get loop mode.
	 *
	 * @method getLoop
	 * @return {boolean} Loop mode.
	 */
	AudioEmitter.prototype.getLoop = function()
	{
		return this.loop;
	};

	/**
	 * Set playback speed.
	 * 
	 * @method setPlaybackRate
	 * @param {number} speed
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setPlaybackRate = function (speed)
	{
		this.playbackRate = speed;

		if(this.isPlaying)
		{
			this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime);
		}

		return this;
	};

	/**
	 * Get the playback speed.
	 *
	 * @method getPlaybackRate
	 * @return {number} Playback speed.
	 */
	AudioEmitter.prototype.getPlaybackRate = function()
	{
		return this.playbackRate;
	};

	/**
	 * Get Array with all the filters applied to this audio emitter.
	 *
	 * @method getFilters
	 * @return {Array} Filters in this audio emitter.
	 */
	AudioEmitter.prototype.getFilters = function()
	{
		return this.filters;
	};

	/**
	 * Set the entire filters array.
	 * 
	 * @method setFilters
	 * @param {Array} value
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setFilters = function(value)
	{
		if(!value)
		{
			value = [];
		}

		if(this.isPlaying)
		{
			this.disconnect();
			this.filters = value;
			this.connect();
		}
		else
		{
			this.filters = value;
		}

		return this;
	};

	/**
	 * Get a filter to the filters array.
	 * 
	 * @method getFilter
	 * @param {number} index Index of the filter.
	 * @return Filter.
	 */
	AudioEmitter.prototype.getFilter = function(index)
	{
		return this.getFilters()[index !== undefined ? index : 0];
	};

	/**
	 * Set a filter to the filters array.
	 * 
	 * @method setFilter
	 * @param {Object} filter
	 */
	AudioEmitter.prototype.setFilter = function(filter)
	{
		return this.setFilters(filter ? [filter] : []);
	};

	/**
	 * Change the source audio node.
	 * 
	 * @method setNodeSource
	 * @param {Object} node
	 * @return {AudioEmitter} Self pointer for chaining.
	 */
	AudioEmitter.prototype.setNodeSource = function(node)
	{
		this.hasPlaybackControl = false;
		this.sourceType = "audioNode";
		
		this.source = node;
		this.connect();

		return this;
	};

	/**
	 * Get output audio node.
	 * 
	 * @method getOutput
	 * @return {Object} Output audio node.
	 */
	AudioEmitter.prototype.getOutput = function()
	{
		return this.gain;
	};

	/**
	 * Dispose audio object, stops the playback and disconnects audio node.
	 * 
	 * @method dispose
	 */
	AudioEmitter.prototype.dispose = function()
	{
		if(this.isPlaying)
		{
			this.stop();
			this.disconnect();
		}

		three.Object3D.prototype.dispose.call(this);
	};

	AudioEmitter.prototype.toJSON = function(meta)
	{
		var audio = this.audio;
		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{
			audio = audio.toJSON(meta);
		});

		data.object.audio = audio.uuid;	
		data.object.volume = this.volume;
		data.object.autoplay = this.autoplay;
		data.object.startTime = this.startTime;
		data.object.playbackRate = this.playbackRate;
		data.object.loop = this.loop;

		return data;
	};

	/**
	 * PositionalAudio is used to play audio with positional audio effect using a WebAudio panner.
	 *
	 * Using the positional audio object the sound is controlled by the camera that renders first in the scene.
	 * 
	 * @param {Audio} audio Audio used by this emitter
	 * @class PositionalAudio
	 * @extends {AudioEmitter}
	 * @module Audio
	 */
	function PositionalAudio(audio)
	{
		AudioEmitter.call(this, audio);

		this.type = "PositionalAudio";
		this.matrixAutoUpdate = true;

		/**
		 * Distance model to be applied to the audio panner.
		 *
		 * @property distanceModel
		 * @type {string}
		 */
		this.distanceModel = "inverse";

		/**
		 * Model to be applied to the audio panner.
		 *
		 * @property panningModel
		 * @type {string}
		 */
		this.panningModel = "HRTF";

		/**
		 * WebAudio panner effect.
		 *
		 * https:// developer.mozilla.org/en-US/docs/Web/API/PannerNode
		 * 
		 * @property panner
		 * @type {PannerNode}
		 */
		this.panner = this.context.createPanner();
		this.panner.connect(this.gain);
		this.panner.panningModel = this.panningModel;
		this.panner.distanceModel = this.distanceModel;
		this.panner.refDistance = 1;
		this.panner.maxDistance = 10000;
		this.panner.rolloffFactor = 1;
		this.panner.coneInnerAngle = 360;
		this.panner.coneOuterAngle = 0;
		this.panner.coneOuterGain = 0;

		/**
		 * Runtime pointer to the scene to get the camera list.
		 *
		 * @attribute scene
		 * @type {Scene}
		 */
		this.scene = null;

		this.tempPosition = new three.Vector3();
		this.tempPositionCamera = new three.Vector3();
		this.tempQuaternionCamera = new three.Quaternion();
	}

	PositionalAudio.prototype = Object.create(AudioEmitter.prototype);

	/**
	 * Initialize audio object, loads audio data decodes it and starts playback if autoplay is set to True.
	 * 
	 * @method initialize
	 */
	PositionalAudio.prototype.initialize = function()
	{
		AudioEmitter.prototype.initialize.call(this);
		
		var node = this.parent;
		while(node !== null)
		{
			if(node instanceof Scene)
			{
				this.scene = node;
				break;
			}

			node = node.parent;
		}
	};

	/**
	 * Update positional audio panner relative to the camera.
	 * 
	 * @method update
	 */
	PositionalAudio.prototype.update = function(delta)
	{
		if(this.scene.cameras.length > 0)
		{
			var camera = this.scene.cameras[0];

			this.getWorldPosition(this.tempPosition);
			camera.getWorldPosition(this.tempPositionCamera);
			camera.getWorldQuaternion(this.tempQuaternionCamera);

			this.tempPosition.sub(this.tempPositionCamera);
			this.tempPosition.z = -this.tempPosition.z;
			
			this.tempPosition.applyQuaternion(this.tempQuaternionCamera);
			this.panner.setPosition(this.tempPosition.x, this.tempPosition.z, this.tempPosition.y);
		}
		else
		{
			this.panner.setPosition(0, 0, 0);
			this.panner.setOrientation(0, 0, 0);
		}

		three.Object3D.prototype.update.call(this, delta);
	};

	/**
	 * Get output audio node.
	 * 
	 * @method getOutput
	 * @return {Object} Output audio node.
	 */
	PositionalAudio.prototype.getOutput = function()
	{
		return this.panner;
	};

	/**
	 * Get reference distance.
	 * 
	 * @method getRefDistance
	 * @return {number} Reference distance.
	 */
	PositionalAudio.prototype.getRefDistance = function()
	{
		return this.panner.refDistance;
	};

	/**
	 * Set reference distance.
	 * 
	 * @method setRefDistance
	 * @param {number} value Reference distance.
	 */
	PositionalAudio.prototype.setRefDistance = function(value)
	{
		this.panner.refDistance = value;
	};

	/**
	 * Get rolloff factor.
	 * 
	 * @method getRolloffFactor
	 * @return {number} Rolloff factor.
	 */
	PositionalAudio.prototype.getRolloffFactor = function()
	{
		return this.panner.rolloffFactor;
	};

	/**
	 * Set rolloff factor.
	 * 
	 * @method setRolloffFactor
	 * @param {number} value Rolloff factor.
	 */
	PositionalAudio.prototype.setRolloffFactor = function(value)
	{
		this.panner.rolloffFactor = value;
	};


	/**
	 * Get distance model in use by this audio emitter.
	 *
	 * @method getDistanceModel
	 * @return {string} Distance model.
	 */
	PositionalAudio.prototype.getDistanceModel = function()
	{
		return this.panner.distanceModel;
	};

	/**
	 * Set distance model to be used.
	 *
	 * Distance model defined how the emitter controls its volume from its position in the world, relative to the camera.
	 *
	 * By default the mode used is "inverse", can be also set to:
	 *  - "linear": A linear distance model calculating the gain induced by the distance according to
	 *    - 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance)
	 *  - "inverse": An inverse distance model calculating the gain induced by the distance according to:
	 *    - refDistance / (refDistance + rolloffFactor * (distance - refDistance))
	 *  - "exponential": An exponential distance model calculating the gain induced by the distance according to:
	 *    - pow(distance / refDistance, -rolloffFactor).
	 * 
	 * @method setDistanceModel
	 * @param {string} model Distance Model to be used.
	 */
	PositionalAudio.prototype.setDistanceModel = function(distanceModel)
	{
		this.panner.distanceModel = distanceModel;
	};

	/**
	 * Get maximum distance for this audio emitter.
	 *
	 * @method getMaxDistance
	 * @return Maximum distance.
	 */
	PositionalAudio.prototype.getMaxDistance = function()
	{
		return this.panner.maxDistance;
	};

	/**
	 * Set maximum distance for this audio emitter.
	 *
	 * @method setMaxDistance
	 * @param {number} value Maximum distance.
	 */
	PositionalAudio.prototype.setMaxDistance = function(value)
	{
		this.panner.maxDistance = value;
	};

	PositionalAudio.prototype.toJSON = function(meta)
	{
		var data = AudioEmitter.prototype.toJSON.call(this, meta);

		data.object.distanceModel = this.distanceModel;
		data.object.panningModel = this.panningModel;

		return data;
	};

	/**
	 * VideoLoader can be used to load external video resources.
	 *
	 * @class VideoLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function VideoLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;
	}

	/**
	 * Load video resource from URL.
	 *
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	VideoLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		var self = this;
		
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			onLoad(self.parse(JSON.parse(text)));
		}, onProgress, onError);
	};

	/**
	 * Parse material JSON.
	 *
	 * @method parse
	 * @param {Object} json
	 * @return {Material} material
	 */
	VideoLoader.prototype.parse = function(json)
	{
		var video = new Video((json.data.toArrayBuffer !== undefined) ? json.data.toArrayBuffer() : json.data, json.encoding);
		
		video.name = json.name;
		video.uuid = json.uuid;
		
		return video;
	};

	/**
	 * Webcam texture is used to capture and display video from a webcam in real-time.
	 * 
	 * It uses WebRTC, the host must support it, otherwise WebcamTexture will display a black image.
	 * 
	 * @class WebcamTexture
	 * @extends {Texture}
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} type
	 * @param {number} anisotropy
	 */
	function WebcamTexture(mapping, wrapS, wrapT, type, anisotropy)
	{	
		var video = document.createElement("video");
		video.autoplay = true;
		video.loop = true;

		/**
		 * Image is used to store a DOM video element
		 * 
		 * @property image
		 * @type {Element}
		 */
		three.Texture.call(this, video, mapping, wrapS, wrapT, three.LinearFilter, three.LinearFilter, three.RGBFormat, type, anisotropy);
		
		var self = this;
		
		this.generateMipmaps = false;
		this.disposed = false;
		this.name = "webcam";
		this.category = "Webcam";	
		this.mode = WebcamTexture.USER;

		/**
		 * Webcam video, media stream
		 *
		 * @property stream
		 * @type {MediaStream}
		 */
		this.stream = null;

		this.connect();

		// Webcam video update loop
		function update()
		{
			if(video.readyState >= video.HAVE_CURRENT_DATA)
			{
				self.needsUpdate = true;
			}

			if(!self.disposed)
			{
				requestAnimationFrame(update);
			}
		}	requestAnimationFrame(update);
	}
	/**
	 * Prefer the front facing camera.
	 * 
	 * @static
	 * @attribute USER
	 * @type {number}
	 */
	WebcamTexture.USER = 21;

	/**
	 * Prefer the back camera.
	 * 
	 * @static
	 * @attribute ENVIRONMENT
	 * @type {number}
	 */
	WebcamTexture.ENVIRONMENT = 22;

	WebcamTexture.prototype = Object.create(three.Texture.prototype);
	WebcamTexture.prototype.constructor = WebcamTexture;
	WebcamTexture.isTexture = true;

	/**
	 * Connect to camera.
	 *
	 * @method connect
	 */
	WebcamTexture.prototype.connect = function()
	{
		var constrains = {
			facingMode: (this.mode === WebcamTexture.USER) ?  "user" : {exact: "environment"}
		};

		var self = this;
		
		if(navigator.webkitGetUserMedia !== undefined)
		{
			navigator.getUserMedia = navigator.webkitGetUserMedia;
		}
		
		if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)
		{
			navigator.mediaDevices.getUserMedia({video:constrains}).then(function(stream)
			{
				self.stream = stream;
				self.image.srcObject = stream;
				self.image.play();
			})
			.catch(function(error)
			{
				console.warn("nunuStudio: No webcam available");
			});				
		}
		else if(navigator.getUserMedia)
		{
			navigator.getUserMedia({video:true}, function(stream)
			{
				self.stream = stream;
				self.image.src = URL.createObjectURL(stream);
			},
			function(error)
			{
				console.warn("nunuStudio: No webcam available");
			});		
		}
	};

	/**
	 * Disconnect from camera.
	 *
	 * @method disconnect
	 */
	WebcamTexture.prototype.disconnect = function()
	{
		if(this.stream !== null)
		{
			var tracks = this.stream.getTracks();
			for(var i = 0; i < tracks.length; i++)
			{
				tracks[i].stop();
			}
		}
	};

	/**
	 * Dispose webcam texture.
	 * 
	 * @method dispose
	 */
	WebcamTexture.prototype.dispose = function()
	{	
		three.Texture.prototype.dispose.call(this);

		this.disconnect();
		this.disposed = true;

		if(!this.image.paused)
		{
			this.image.pause();
		}
	};

	/**
	 * Serialize webcam texture to JSON.
	 *
	 * @method toJSON
	 * @param {Object} meta Metadata.
	 */
	WebcamTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);

		data.mode = this.mode;

		return data;
	};

	/**
	 * Video texture, uses a video DOM element instead of a img element.
	 * 
	 * VideoTexture also provides methods for playback control.
	 * 
	 * @class VideoTexture
	 * @extends {Texture}
	 * @module Textures
	 * @param {Video} video
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} type
	 * @param {number} anisotropy
	 */
	function VideoTexture(video, mapping, wrapS, wrapT, type, anisotropy)
	{
		three.Texture.call(this, document.createElement("video"), mapping, wrapS, wrapT, three.LinearFilter, three.LinearFilter, three.RGBFormat, type, anisotropy);

		this.disposed = false;
		this.generateMipmaps = false;

		this.name = "video";
		this.category = "Video";

		/**
		 * If true the video starts playing automatically.
		 *
		 * @property autoplay
		 * @default true
		 * @type {boolean}
		 */
		this.autoplay = true;

		/**
		 * If true the video plays in loop.
		 *
		 * @property loop
		 * @default true
		 * @type {boolean}
		 */
		this.loop = true;

		/**
		 * Start time in seconds.
		 *
		 * @property playbackRate
		 * @default 1.0
		 * @type {number}
		 */
		this.playbackRate = 1.0;

		/**
		 * Video audio volume, its a values between 1.0 and 0.0.
		 *
		 * @property volume
		 * @default 1.0
		 * @type {number}
		 */
		this.volume = 1.0;

		/**
		 * Image is used to store a DOM video element.
		 *
		 * @property image
		 * @type {Element}
		 */
		this.image.crossOrigin = "anonymous";
		this.image.autoplay = this.autoplay;
		this.image.playbackRate = this.playbackRate;
		this.image.loop = this.loop;
		this.image.volume = this.volume;

		/**
		 * Video source resource.
		 *
		 * @property video
		 * @type {Video}
		 */
		this.video = null;
		this.setVideo(video);

		// Video update loop
		var self = this;
		function update()
		{
			if(!self.disposed)
			{
				if(self.image.readyState >= self.image.HAVE_CURRENT_DATA)
				{
					self.needsUpdate = true;
				}

				requestAnimationFrame(update);
			}
		}	update();
	}

	VideoTexture.prototype = Object.create(three.Texture.prototype);

	VideoTexture.isVideoTexture = true;

	/**
	 * Set the video source to be used.
	 *
	 * Can be a Video, VideoStream or a URL String.
	 * 
	 * @param {Video} video
	 * @method setVideo
	 */
	VideoTexture.prototype.setVideo = function(video)
	{
		if(video === null || video === undefined)
		{
			this.video = null;
			this.image.src = null;
			return;
		}

		if(typeof video === "string")
		{
			this.video = new Video(video);
		}
		else if(video instanceof Video)
		{
			this.video = video;
		}

		this.image.src = this.video.data;
	};

	/**
	 * Set video time in seconds.
	 * 
	 * @param {number} time
	 * @method setTime
	 */
	VideoTexture.prototype.setTime = function(time)
	{
		this.image.currentTime = time;
	};

	/**
	 * Set loop mode.
	 * 
	 * @param {boolean} loop
	 * @method setLoop
	 */
	VideoTexture.prototype.setLoop = function(loop)
	{
		this.loop = loop;
		this.image.loop = loop;
	};

	/**
	 * Set video volume.
	 * 
	 * @param {number} volume
	 * @method setVolume
	 */
	VideoTexture.prototype.setVolume = function(volume)
	{
		this.volume = (volume >= 0 && volume <= 1) ? volume : (volume >= 0) ? 1.0 : 0.0;
		this.image.volume = this.volume;
	};

	/**
	 * Set autoplay value.
	 *
	 * If the image is already playing it will not stop playing.
	 *
	 * @method setAutoPlay
	 * @param {boolean} value If true the video will play automatically.
	 */
	VideoTexture.prototype.setAutoPlay = function(value)
	{
		this.autoplay = value;
		this.image.autoplay = this.autoplay;
	};

	/**
	 * Set video playback speed.
	 * 
	 * @method setPlaybackRate
	 * @param {number} playbackRate
	 */
	VideoTexture.prototype.setPlaybackRate = function(playbackRate)
	{
		this.playbackRate = playbackRate;
		this.image.playbackRate = playbackRate;
	};

	/**
	 * Pause video playback.
	 * 
	 * @method pause
	 */
	VideoTexture.prototype.pause = function()
	{
		if(!this.image.paused)
		{
			this.image.pause();
		}
	};

	/**
	 * Start playing video.
	 * 
	 * @method play
	 */
	VideoTexture.prototype.play = function()
	{
		if(this.image.paused)
		{
			this.image.play();
		}
	};

	/**
	 * Dispose video texture.
	 *
	 * Stops the video and cleans the DOM video element inside the VideoTexture.
	 * 
	 * @method dispose
	 */
	VideoTexture.prototype.dispose = function()
	{	
		three.Texture.prototype.dispose.call(this);

		this.disposed = true;
		
		this.image.pause();
		this.image.src = "";
		this.image.load();
	};

	/**
	 * Create Video texture json description.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	VideoTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);
		var video = this.video.toJSON(meta);

		data.video = video.uuid;
		data.loop = this.loop;
		data.autoplay = this.autoplay;
		data.playbackRate = this.playbackRate;
		data.volume = this.volume;

		return data;
	};

	/**
	 * SpriteSheet texture, can be used load spritesheet animations as textures.
	 *
	 * The images have to be aligned in a grid without overlapping if the spritesheet is not full the last rows or blocks should be empty.
	 * 
	 * Images are played row by row, changing every animationSpeed seconds.
	 * 
	 * @class SpriteSheetTexture
	 * @extends {Texture}
	 * @module Textures
	 * @param {Image} image
	 * @param {number} framesHorizontal
	 * @param {number} framesVertical
	 * @param {number} totalFrames
	 * @param {number} mapping
	 * @param {number} type
	 * @param {number} anisotropy
	 */
	function SpriteSheetTexture(source, framesHorizontal, framesVertical, totalFrames, mapping, type, anisotropy)
	{
		three.Texture.call(this, source, mapping, three.RepeatWrapping, three.RepeatWrapping, three.LinearFilter, three.LinearFilter, three.RGBFormat, type, anisotropy);

		this.name = "animation";
		this.category = "SpriteSheet";
		this.disposed = false;
		this.format = this.source.hasTransparency() ? three.RGBAFormat : three.RGBFormat;
		this.repeat.set(1 / framesHorizontal, 1 / framesVertical);

		/**
		 * If true the animation plays in loop.
		 * @property loop
		 * @default true
		 * @type {boolean}
		*/
		this.loop = true;

		/**
		 * Animation speed in seconds.
		 * @property animationSpeed
		 * @default 0.1
		 * @type {number}
		*/
		this.animationSpeed = 0.1;

		this._totalFrames = totalFrames;
		this._beginFrame = 0;
		this._endFrame = 0;
		this._framesHorizontal = framesHorizontal;
		this._framesVertical = framesVertical;

		var self = this;

		Object.defineProperties(this,
		{
			/**
			 * Spritesheet number of frames horizontally.
			 *
			 * When this values is changed the totalFrames value is automatically updated to framesHorizontal * framesVertical.
			 * @property framesHorizontal
			 * @default 1.0
			 * @type {number}
			*/
			framesHorizontal:
			{
				get: function()
				{
					return this._framesHorizontal;
				},
				set: function(value)
				{
					this._framesHorizontal = value;
					this.repeat.x = 1 / value;
					this.totalFrames = this._framesHorizontal * this._framesVertical;
				}
			},

			/**
			 * Spritesheet number of frames vertically.
			 *
			 * When this values is changed the totalFrames value is automatically updated to framesHorizontal * framesVertical.
			 * @property framesVertical
			 * @default 1.0
			 * @type {number}
			*/
			framesVertical:
			{
				get: function()
				{
					return this._framesVertical;
				},
				set: function(value)
				{
					this._framesVertical = value;
					this.repeat.y = 1 / value;
					this.totalFrames = this._framesHorizontal * this._framesVertical;
				}
			},

			/**
			 * The offset frame can be ajusted to control in which frame the animation ends.
			 * 
			 * @property endFrame
			 * @type {number}
			 */
			endFrame:
			{
				get: function()
				{
					return this._endFrame;
				},
				set: function(value)
				{
					if(value > this._totalFrames)
					{
						value = this._totalFrames;
					}
					this._endFrame = value;
				}
			},

			/**
			 * The offset frame can be ajusted to control in which frame the animation starts.
			 * 
			 * @property beginFrame
			 * @default 0
			 * @type {number}
			 */
			beginFrame:
			{
				get: function()
				{
					return this._beginFrame;
				},
				set: function(value)
				{
					if(value < 0)
					{
						value = 0;
					}
					this.currentFrame = value;
					this._beginFrame = value;
				}
			},

			/**
			 * Total number of frames present in the texture.
			 * 
			 * Sometimes a NxM spritesheet does not have all spaces filled, this parameter is used to take care of those cases.
			 * @property totalFrames
			 * @default 1
			 * @type {number}
			*/
			totalFrames:
			{
				get: function()
				{
					return this._totalFrames;
				},
				set: function(value)
				{
					this._beginFrame = 0;
					this._endFrame = value;
					this._totalFrames = value;
				}
			}
		});

		/**
		 * Indicates the current frame of the animation.
		 *
		 * @property currentFrame
		 * @type {number}
		 */
		this.currentFrame = 0;

		function update()
		{
			if(!self.disposed)
			{
				self.step();
				setTimeout(update, self.animationSpeed * 1e3);
			}
		}
		update();
	}

	SpriteSheetTexture.prototype = Object.create(three.Texture.prototype);
	SpriteSheetTexture.isTexture = true;

	/**
	 * Step the sprite sheet animation, move to next frame and recalculate the texture offset.
	 *
	 * @method step
	 */
	SpriteSheetTexture.prototype.step = function()
	{
		this.currentFrame++;

		if(this.currentFrame >= this._endFrame)
		{
			this.currentFrame = this._beginFrame;
		}

		this.offset.x = (this.currentFrame % this.framesHorizontal) / this.framesHorizontal;
		this.offset.y = (1 - this.repeat.y) - Math.floor(this.currentFrame / this.framesHorizontal) / this.framesVertical;
	};


	/**
	 * Set animation playback speed.
	 * 
	 * @method setAnimationSpeed
	 * @param {number} animationSpeed
	 */
	SpriteSheetTexture.prototype.setAnimationSpeed = function(animationSpeed)
	{
		this.animationSpeed = animationSpeed;
	};

	/**
	 * Set the sprite sheet grid dimension.
	 *
	 * Automatically sets the totalFrame value to framesHorizontal * framesVertical.
	 * 	
	 * @method setFrameGrid
	 * @param {number} framesHorizontal
	 * @param {number} framesVertical
	 */
	SpriteSheetTexture.prototype.setFrameGrid = function(framesHorizontal, framesVertical)
	{
		this._framesHorizontal = framesHorizontal;
		this._framesVertical = framesVertical;
		this._totalFrames = framesHorizontal * framesVertical;
		this.repeat.set(1 / framesHorizontal, 1 / framesVertical);
	};

	/**
	 * Set frames to be used for this animation.
	 *
	 * Frame starts counting from 0.
	 * 
	 * @method setAnimationFrames
	 * @param {number} beginFrame
	 * @param {number} endFrame
	 */
	SpriteSheetTexture.prototype.setAnimationFrames = function(beginFrame, endFrame)
	{
		this.beginFrame = beginFrame;
		this.endFrame = endFrame;
	};

	/**
	 * Dispose spritesheet texture.
	 *
	 * @method dispose
	 */
	SpriteSheetTexture.prototype.dispose = function()
	{
		three.Texture.prototype.dispose.call(this);

		this.disposed = true;
	};

	/**
	 * Create texture json description.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	SpriteSheetTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);
		var image = this.source.toJSON(meta);

		data.image = image.uuid;
		data.loop = this.loop;
		data.animationSpeed = this.animationSpeed;
		data.framesHorizontal = this._framesHorizontal;
		data.framesVertical = this._framesVertical;
		data.totalFrames = this._totalFrames;
		data.beginFrame = this._beginFrame;
		data.endFrame = this._endFrame;

		return data;
	};

	/**
	 * Data texture stored binary RAW texture data values.
	 *
	 * Can be used to store render target result or to load custom image formats. Pixels can be manipulated individually in the data array.
	 *
	 * @class DataTexture
	 * @extends {Texture}
	 * @param {Array} data Image data array
	 * @param {number} width
	 * @param {number} height
	 * @param {number} format
	 * @param {number} type
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} magFilter
	 * @param {number} minFilter
	 * @param {number} format
	 * @param {number} type
	 * @param {number} anisotropy
	 * @param {number} encoding
	 */
	function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding)
	{
		three.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.category = "DataTexture";

		this.image = {data: data || null, width: width || 1, height: height || 1};

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
		this.needsUpdate = true;
	}

	DataTexture.prototype = Object.create(three.Texture.prototype);
	DataTexture.prototype.constructor = DataTexture;
	DataTexture.prototype.isDataTexture = true;

	DataTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);

		data.image = {
			height: this.image.height,
			width: this.image.width,
			data: Array.from(this.image.data)
		};

		return data;
	};

	/**
	 * CompressTexture class is used to store textures using GPU compatible compressed data.
	 *
	 * The advantage of using these texture is the fact that the texture does not get uncompressed in the GPU memory saving not only project space but also saving video memory during runtime.
	 *
	 * The problem with compressed textures is that its hardware dependent (they dont work everywhere)
	 *  - DXT: supported on desktop and some Android smartphones
	 *  - PVR: supported on iOS and some Android smartphones
	 *  - ETC1: supported by most Android smartphones
	 *
	 * The usage of these format can free a lot of video memory and is a must for mobile devices.
	 * 
	 * @class CompressedTexture
	 * @extends {Texture}
	 * @param {Array} mipmaps Mipmaps levels
	 * @param {number} width
	 * @param {number} height
	 * @param {number} format
	 * @param {number} type
	 * @param {number} mapping
	 * @param {number} wrapS
	 * @param {number} wrapT
	 * @param {number} magFilter
	 * @param {number} minFilter
	 * @param {number} anisotropy
	 * @param {number} encoding
	 */
	function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding)
	{
		three.Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

		this.category = "Compressed";

		this.image = {width: width, height: height};
		this.mipmaps = mipmaps;
		this.isCubeTexture = false;

		this.flipY = false;
		this.generateMipmaps = false;
	}

	CompressedTexture.prototype = Object.create(three.Texture.prototype);
	CompressedTexture.prototype.constructor = CompressedTexture;
	CompressedTexture.prototype.isCompressedTexture = true;

	CompressedTexture.prototype.toJSON = function(meta)
	{
		var data = three.Texture.prototype.toJSON.call(this, meta);

		data.isCubeTexture = this.isCubeTexture;

		if(this.isCubeTexture)
		{
			data.image = [];

			for(var j = 0; j < this.image.length; j++)
			{	
				var image = 
				{
					mipmaps: [],
					format: this.image[j].format,
					width: this.image[j].width,
					height: this.image[j].height
				};

				for(var i = 0; i < this.image[j].mipmaps.length; i++)
				{
					image.mipmaps.push(
					{
						width: this.image[j].mipmaps[i].width,
						height: this.image[j].mipmaps[i].height,
						data: this.image[j].mipmaps[i].data
					});
				}
				
				data.image.push(image);
			}
		}
		else
		{
			data.mipmaps = [];
			data.width = this.image.width;
			data.height = this.image.height;
			for(var i = 0; i < this.mipmaps.length; i++)
			{
				data.mipmaps.push(
				{
					width: this.mipmaps[i].width,
					height: this.mipmaps[i].height,
					data: this.mipmaps[i].data
				});
			}
		}

		return data;
	};

	/**
	 * TextureLoader can be used to load external textures.
	 *
	 * @class TextureLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function TextureLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;
		
		this.path = "";
		this.crossOrigin = "anonymous";

		this.images = [];
		this.videos = [];
		this.fonts = [];
	}

	/**
	 * Set cross origin path for the loader.
	 * 
	 * @method setCrossOrigin
	 * @param {string} url URL.
	 * @return {TextureLoader} Self for chaining.
	 */
	TextureLoader.prototype.setCrossOrigin = function(url)
	{
		this.crossOrigin = url;
		return this;
	};

	/**
	 * Set base path for texture loading.
	 * 
	 * @method setPath
	 * @param {string} path Path
	 * @return {TextureLoader} Self for chaining.
	 */
	TextureLoader.prototype.setPath = function(path)
	{
		this.path = path;
		return this;
	};

	/**
	 * Set list of images to be used by this loader.
	 *
	 * @method setImages
	 * @param {Array} images
	 */
	TextureLoader.prototype.setImages = function(images)
	{
		this.images = images;
		return this;
	};

	/**
	 * Set list of videos to be used by this loader.
	 *
	 * @method setVideos
	 * @param {Array} videos
	 */
	TextureLoader.prototype.setVideos = function(videos)
	{
		this.videos = videos;
		return this;
	};

	/**
	 * Set list of fonts to be used by this loader.
	 *
	 * @method setFonts
	 * @param {Array} fonts
	 */
	TextureLoader.prototype.setFonts = function(fonts)
	{
		this.fonts = fonts;
		return this;
	};

	/**
	 * Load texture from URL.
	 *
	 * Does the same as creating a new Texture object.
	 * 
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	TextureLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		try
		{
			var texture = new Texture(this.path + url);

			if(onLoad !== undefined)
			{
				onLoad(texture);
			}

			return texture;
		}
		catch(e)
		{
			if(onError !== undefined)
			{
				onError(e);
			}

			console.warn("nunuStudio: Texture not found", e);
			return new Texture();
		}
	};

	/**
	 * Load texture object from JSON.
	 *
	 * @method loadJSON
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	TextureLoader.prototype.loadJSON = function(url, onLoad, onProgress, onError)
	{
		var self = this;
		
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			self.parse(JSON.parse(text), onLoad);
		}, onProgress, onError);
	};

	/**
	 * Parse a texture object JSON description.
	 *
	 * @method parse
	 * @param {string} url
	 * @param {Function} onLoad
	 */
	TextureLoader.prototype.parse = function(json, onLoad)
	{
		var texture = null;
		var category = json.category;

		// Video texture
		if(category === "Video")
		{
			if(json.video === undefined)
			{
				console.warn("TextureLoader: No video specified for", json.uuid);
			}

			if(this.videos[json.video] === undefined)
			{
				console.warn("TextureLoader: Undefined video", json.video);
			}

			texture = new VideoTexture(this.videos[json.video]);
			texture.setLoop(json.loop);
			texture.setAutoPlay(json.autoplay);
			texture.setPlaybackRate(json.playbackRate);
			texture.setVolume(json.volume);
		}
		// Webcam texture
		else if(category === "Webcam")
		{
			texture = new WebcamTexture();

			if(json.mode !== undefined)
			{
				texture.mode = json.mode;
			}
		}
		// Compressed texture
		else if(category === "Compressed")
		{
			if(json.isCubeTexture)
			{
				texture = new CompressedTexture();
				texture.image = [];
				texture.isCubeTexture = true;

				for(var j = 0; j < json.image.length; j++)
				{
					for(var i = 0; i < json.image[j].mipmaps.length; i++)
					{
						if(json.image[j].mipmaps[i].data.toArrayBuffer !== undefined)
						{
							json.image[j].mipmaps[i].data = new Uint8Array(json.image[j].mipmaps[i].data.toArrayBuffer());
						}
					}

					texture.image.push(json.image[j]);
				}
			}
			else
			{
				for(var i = 0; i < json.mipmaps.length; i++)
				{
					if(json.mipmaps[i].data.toArrayBuffer !== undefined)
					{
						json.mipmaps[i].data = new Uint8Array(json.mipmaps[i].data.toArrayBuffer());
					}
				}

				texture = new CompressedTexture(json.mipmaps, json.width, json.height);
			}
		}
		// Cube texture
		else if(category === "Cube")
		{
			var images = [];

			for(var i = 0; i < json.images.length; i++)
			{
				if(this.images[json.images[i]] === undefined)
				{
					console.warn("nunuStudio: TextureLoader, undefined image", json.images[i]);
				}

				images.push(this.images[json.images[i]]);
			}

			texture = new CubeTexture();
			texture.setImages(images, json.mode);
			texture.setSize(json.size);
			texture.updateImages();
		}
		// Canvas texture
		else if(category === "Canvas")
		{
			texture = new CanvasTexture(json.width, json.height);
		}
			// Data texture
		else if(category === "DataTexture")
		{
			var data = new Float32Array(json.image.data);
			texture = new DataTexture(data, json.image.width, json.image.height);
		}
		// Texture
		else
		{
			if(json.image === undefined)
			{
				console.warn("nunuStudio: TextureLoader, no image specified for", json.uuid);
			}

			if(this.images[json.image] === undefined)
			{
				console.warn("nunuStudio: TextureLoader, undefined image", json.image);
			}

			// SpriteSheet texture
			if(category === "SpriteSheet")
			{
				texture = new SpriteSheetTexture(this.images[json.image], json.framesHorizontal, json.framesVertical, json.totalFrames);
				texture.loop = json.loop;
				texture.animationSpeed = json.animationSpeed;
				texture.beginFrame = json.beginFrame;
				texture.endFrame = json.endFrame;
			}
			// Texture
			else
			{
				texture = new Texture(this.images[json.image]);
			}
		}

		texture.needsUpdate = true;
		
		texture.uuid = json.uuid;
		texture.name = json.name;

		texture.mapping = json.mapping;

		texture.repeat.set(json.repeat[0], json.repeat[1]);
		texture.offset.set(json.offset[0], json.offset[1]);

		if(json.center !== undefined) {texture.center.set(json.center[0], json.center[1]);}
		if(json.rotation !== undefined) {texture.rotation = json.rotation;}

		texture.wrapS = json.wrap[0];
		texture.wrapT = json.wrap[1];

		if(json.format !== undefined) {texture.format = json.format;}
		if(json.type !== undefined) {texture.type = json.type;}
		if(json.encoding !== undefined) {texture.encoding = json.encoding;}

		texture.minFilter = json.minFilter;
		texture.magFilter = json.magFilter;
		texture.anisotropy = json.anisotropy;

		texture.flipY = json.flipY;
		if(json.premultiplyAlpha !== undefined) {texture.premultiplyAlpha = json.premultiplyAlpha;}
		if(json.unpackAlignment !== undefined) {texture.unpackAlignment = json.unpackAlignment;}

		if(onLoad !== undefined)
		{
			onLoad(texture);
		}

		return texture;
	};

	/**
	 * MaterialLoader can be used to load external materials.
	 *
	 * @class MaterialLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function MaterialLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;
		this.textures = {};
	}

	/**
	 * Load material file from URL.
	 *
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	MaterialLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		var self = this;

		var loader = new FileLoader(self.manager);
		loader.load(url, function(text)
		{
			onLoad(self.parse(JSON.parse(text)));
		}, onProgress, onError);
	};

	/**
	 * Set texture array to be used when loading materials
	 *
	 * @method setTextures
	 * @param {Array} value
	 */
	MaterialLoader.prototype.setTextures = function(value)
	{
		this.textures = value;
	};

	/**
	 * Parse material JSON.
	 *
	 * @method parse
	 * @param {Object} json
	 * @return {Material} material
	 */
	MaterialLoader.prototype.parse = function(json)
	{
		var material = three.MaterialLoader.prototype.parse.call(this, json);

		// Legacy multi-material
		if(json.materials !== undefined)
		{
			for (var i = 0, l = json.materials.length; i < l; i ++)
			{
				material.materials.push(this.parse(json.materials[i]));
			}
		}

		return material;
	};

	/**
	 * ImageLoader can be used to load external image resources.
	 *
	 * @class ImageLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function ImageLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;

		this.path = "";
		this.crossOrigin = "Anonymous";
	}

	/**
	 * Set cross origin path for the loader.
	 * 
	 * @method setCrossOrigin
	 * @param {string} url URL.
	 * @return {ImageLoader} Self for chaining.
	 */
	ImageLoader.prototype.setCrossOrigin = function(url)
	{
		this.crossOrigin = url;
		return this;
	};

	/**
	 * Set base path for texture loading.
	 * 
	 * @method setPath
	 * @param {string} path Path
	 * @return {ImageLoader} Self for chaining.
	 */
	ImageLoader.prototype.setPath = function(path)
	{
		this.path = path;
		return this;
	};

	/**
	 * Load image resource from url.
	 *
	 * @method loadJSON
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	ImageLoader.prototype.loadJSON = function(url, onLoad, onProgress, onError)
	{
		var self = this;
		
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			onLoad(self.parse(JSON.parse(text)));
		}, onProgress, onError);
	};

	/**
	 * Parse image json and return resource.
	 *
	 * @method parse
	 * @param {Object} json
	 * @return {Image} Image resource
	 */
	ImageLoader.prototype.parse = function(json)
	{
		var image = new Image((json.data.toArrayBuffer !== undefined) ? json.data.toArrayBuffer() : json.data, json.encoding);
		
		image.name = json.name;
		image.uuid = json.uuid;

		if(json.width !== undefined)
		{
			image.width = json.width;
			image.height = json.height;
		}

		return image;
	};

	/**
	 * Legacy geometry loader is used to load the old geometry file format.
	 * 
	 * May be necessary to load old project files.
	 * 
	 * @class LegacyGeometryLoader
	 * @author mrdoob / http:// mrdoob.com/
	 * @author alteredq / http:// alteredqualia.com/
	 */
	function LegacyGeometryLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
		this.withCredentials = false;
	}

	LegacyGeometryLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		var self = this;
		var path = (this.path === undefined) ? LoaderUtils.extractUrlBase(url) : this.path;

		var loader = new three.FileLoader(this.manager);
		loader.setPath(this.path);
		loader.setWithCredentials(this.withCredentials);
		loader.load(url, function (text)
		{
			var json = JSON.parse(text);
			var metadata = json.metadata;

			if(metadata !== undefined)
			{
				var type = metadata.type;

				if(type !== undefined)
				{
					if(type.toLowerCase() === "object")
					{
						console.error("nunuStudio: LegacyGeometryLoader: " + url + " should be loaded with ObjectLoader instead.");
						return;
					}
				}
			}

			var object = self.parse(json, path);
			onLoad(object.geometry, object.materials);

		}, onProgress, onError);
	};

	LegacyGeometryLoader.prototype.setPath = function(value)
	{
		this.path = value;
		return this;
	};

	LegacyGeometryLoader.prototype.setResourcePath = function(value)
	{
		this.resourcePath = value;
		return this;
	};

	LegacyGeometryLoader.prototype.setCrossOrigin = function(value)
	{
		this.crossOrigin = value;
		return this;
	};

	LegacyGeometryLoader.prototype.parse = (function()
	{
		function parseModel(json, geometry)
		{
			function isBitSet(value, position)
			{
				return value & (1 << position);
			}

			var i, j, fi,

			offset, zLength,

			colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

			vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			scale = json.scale,

			nUvLayers = 0;

			if(json.uvs !== undefined)
			{
				// disregard empty arrays
				for(i = 0; i < json.uvs.length; i++)
				{
					if(json.uvs[i].length) nUvLayers++;
				}

				for(i = 0; i < nUvLayers; i++)
				{
					geometry.faceVertexUvs[i] = [];
				}
			}

			offset = 0;
			zLength = vertices.length;

			while(offset < zLength)
			{
				vertex = new three.Vector3();
				vertex.x = vertices[offset++] * scale;
				vertex.y = vertices[offset++] * scale;
				vertex.z = vertices[offset++] * scale;

				geometry.vertices.push(vertex);
			}

			offset = 0;
			zLength = faces.length;

			while(offset < zLength)
			{
				type = faces[offset++];
				isQuad = isBitSet(type, 0);
				hasMaterial = isBitSet(type, 1);
				hasFaceVertexUv = isBitSet(type, 3);
				hasFaceNormal = isBitSet(type, 4);
				hasFaceVertexNormal = isBitSet(type, 5);
				hasFaceColor = isBitSet(type, 6);
				hasFaceVertexColor = isBitSet(type, 7);

				if(isQuad)
				{

					faceA = new three.Face3();
					faceA.a = faces[offset];
					faceA.b = faces[offset + 1];
					faceA.c = faces[offset + 3];

					faceB = new three.Face3();
					faceB.a = faces[offset + 1];
					faceB.b = faces[offset + 2];
					faceB.c = faces[offset + 3];

					offset += 4;

					if(hasMaterial)
					{
						materialIndex = faces[offset++];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;
					}

					// to get face <=> uv index correspondence
					fi = geometry.faces.length;

					if(hasFaceVertexUv)
					{
						for(i = 0; i < nUvLayers; i++)
						{
							uvLayer = json.uvs[i];

							geometry.faceVertexUvs[i][fi] = [];
							geometry.faceVertexUvs[i][fi + 1] = [];

							for(j = 0; j < 4; j++)
							{
								uvIndex = faces[offset++];

								u = uvLayer[uvIndex * 2];
								v = uvLayer[uvIndex * 2 + 1];

								uv = new three.Vector2(u, v);

								if(j !== 2)
								{
									geometry.faceVertexUvs[i][fi].push(uv);
								}
								if(j !== 0)
								{
									geometry.faceVertexUvs[i][fi + 1].push(uv);
								}
							}
						}
					}

					if(hasFaceNormal)
					{
						normalIndex = faces[offset++] * 3;

						faceA.normal.set(
							normals[normalIndex++],
							normals[normalIndex++],
							normals[normalIndex]
						);

						faceB.normal.copy(faceA.normal);
					}

					if(hasFaceVertexNormal)
					{
						for(i = 0; i < 4; i++)
						{
							normalIndex = faces[offset++] * 3;

							normal = new three.Vector3(
								normals[normalIndex++],
								normals[normalIndex++],
								normals[normalIndex]
							);

							if(i !== 2) faceA.vertexNormals.push(normal);
							if(i !== 0) faceB.vertexNormals.push(normal);
						}
					}

					if(hasFaceColor)
					{
						colorIndex = faces[offset++];
						hex = colors[colorIndex];

						faceA.color.setHex(hex);
						faceB.color.setHex(hex);
					}

					if(hasFaceVertexColor)
					{
						for(i = 0; i < 4; i++)
						{
							colorIndex = faces[offset++];
							hex = colors[colorIndex];

							if(i !== 2) faceA.vertexColors.push(new Color(hex));
							if(i !== 0) faceB.vertexColors.push(new Color(hex));
						}
					}

					geometry.faces.push(faceA);
					geometry.faces.push(faceB);

				}
				else
				{
					face = new three.Face3();
					face.a = faces[offset++];
					face.b = faces[offset++];
					face.c = faces[offset++];

					if(hasMaterial)
					{
						materialIndex = faces[offset++];
						face.materialIndex = materialIndex;
					}

					// to get face <=> uv index correspondence
					fi = geometry.faces.length;

					if(hasFaceVertexUv)
					{
						for(i = 0; i < nUvLayers; i++)
						{
							uvLayer = json.uvs[i];
							geometry.faceVertexUvs[i][fi] = [];

							for(j = 0; j < 3; j++)
							{
								uvIndex = faces[offset++];

								u = uvLayer[uvIndex * 2];
								v = uvLayer[uvIndex * 2 + 1];

								uv = new three.Vector2(u, v);

								geometry.faceVertexUvs[i][fi].push(uv);
							}
						}
					}

					if(hasFaceNormal)
					{
						normalIndex = faces[offset++] * 3;

						face.normal.set(
							normals[normalIndex++],
							normals[normalIndex++],
							normals[normalIndex]
						);
					}

					if(hasFaceVertexNormal)
					{
						for(i = 0; i < 3; i++)
						{
							normalIndex = faces[offset++] * 3;

							normal = new three.Vector3(
								normals[normalIndex++],
								normals[normalIndex++],
								normals[normalIndex]
							);

							face.vertexNormals.push(normal);
						}
					}

					if(hasFaceColor)
					{
						colorIndex = faces[offset++];
						face.color.setHex(colors[colorIndex]);
					}

					if(hasFaceVertexColor)
					{
						for(i = 0; i < 3; i++)
						{
							colorIndex = faces[offset++];
							face.vertexColors.push(new Color(colors[colorIndex]));
						}
					}

					geometry.faces.push(face);
				}
			}
		}

		function parseSkin(json, geometry)
		{
			var influencesPerVertex = (json.influencesPerVertex !== undefined) ? json.influencesPerVertex : 2;

			if(json.skinWeights)
			{
				for(var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex)
				{
					var x = json.skinWeights[i];
					var y = (influencesPerVertex > 1) ? json.skinWeights[i + 1] : 0;
					var z = (influencesPerVertex > 2) ? json.skinWeights[i + 2] : 0;
					var w = (influencesPerVertex > 3) ? json.skinWeights[i + 3] : 0;

					geometry.skinWeights.push(new Vector4(x, y, z, w));
				}
			}

			if(json.skinIndices)
			{
				for(var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex)
				{
					var a = json.skinIndices[i];
					var b = (influencesPerVertex > 1) ? json.skinIndices[i + 1] : 0;
					var c = (influencesPerVertex > 2) ? json.skinIndices[i + 2] : 0;
					var d = (influencesPerVertex > 3) ? json.skinIndices[i + 3] : 0;

					geometry.skinIndices.push(new Vector4(a, b, c, d));
				}
			}

			geometry.bones = json.bones;

			if(geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length))
			{
				console.warn("When skinning, number of vertices (" + geometry.vertices.length + "), skinIndices (" + geometry.skinIndices.length + "), and skinWeights (" + geometry.skinWeights.length + ") should match.");
			}
		}

		function parseMorphing(json, geometry)
		{
			var scale = json.scale;

			if(json.morphTargets !== undefined)
			{
				for(var i = 0, l = json.morphTargets.length; i < l; i++)
				{
					geometry.morphTargets[i] = {};
					geometry.morphTargets[i].name = json.morphTargets[i].name;
					geometry.morphTargets[i].vertices = [];

					var dstVertices = geometry.morphTargets[i].vertices;
					var srcVertices = json.morphTargets[i].vertices;

					for(var v = 0, vl = srcVertices.length; v < vl; v += 3)
					{
						var vertex = new three.Vector3();
						vertex.x = srcVertices[v] * scale;
						vertex.y = srcVertices[v + 1] * scale;
						vertex.z = srcVertices[v + 2] * scale;

						dstVertices.push(vertex);
					}
				}
			}

			if(json.morphColors !== undefined && json.morphColors.length > 0)
			{
				var faces = geometry.faces;
				var morphColors = json.morphColors[0].colors;

				for(var i = 0, l = faces.length; i < l; i++)
				{
					faces[i].color.fromArray(morphColors, i * 3);
				}
			}
		}

		function parseAnimations(json, geometry)
		{
			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];
			if(json.animation !== undefined)
			{
				animations.push(json.animation);
			}

			if(json.animations !== undefined)
			{
				if(json.animations.length)
				{
					animations = animations.concat(json.animations);
				}
				else
				{
					animations.push(json.animations);
				}
			}

			for(var i = 0; i < animations.length; i++)
			{
				var clip = three.AnimationClip.parseAnimation(animations[i], geometry.bones);
				if(clip)
				{
					outputAnimations.push(clip);
				}
			}

			// parse implicit morph animations
			if(geometry.morphTargets)
			{
				var morphAnimationClips = three.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
				outputAnimations = outputAnimations.concat(morphAnimationClips);
			}

			if(outputAnimations.length > 0)
			{
				geometry.animations = outputAnimations;
			}
		}

		return function parse(json, path)
		{
			if(json.data !== undefined)
			{
				json = json.data;
			}

			if(json.scale !== undefined)
			{
				json.scale = 1.0 / json.scale;
			}
			else
			{
				json.scale = 1.0;
			}

			var geometry = new three.Geometry();
			parseModel(json, geometry);
			parseSkin(json, geometry);
			parseMorphing(json, geometry);
			parseAnimations(json, geometry);

			geometry.computeFaceNormals();
			geometry.computeBoundingSphere();

			if(json.materials === undefined || json.materials.length === 0)
			{
				return {geometry: geometry};
			}
			else
			{
				var materials = Loader.prototype.initMaterials(json.materials, this.resourcePath || path, this.crossOrigin);
				return {geometry: geometry, materials: materials};
			}
		};
	})();

	/**
	 * Terrrain geometry is a plane like geometry deformed by a height map texture.
	 *
	 * This geometry type can be used to create large terrains. Its possible to generate the height data using scripts and create terrain dynamically.
	 *
	 * @class TerrainBufferGeometry
	 * @constructor
	 * @param {number} width Width of the terrain.
	 * @param {number} height Height of the terrain.
	 * @param {number} widthSegments How many segments compose the terrain width.
	 * @param {number} heightSegments How many segments compose the terrain height.
	 * @param {number} scale Scale of the terrain in height (maximum altitude of the terrain).
	 * @param {Image} image Image containing the height data of the terrain.
	 */
	function TerrainBufferGeometry(width, height, widthSegments, heightSegments, scale, image)
	{
		three.BufferGeometry.call(this);

		this.type = "TerrainBufferGeometry";

		this.parameters =
		{
			width: width || 1,
			height: height || 1,
			widthSegments: widthSegments || 10,
			heightSegments: heightSegments || 10,
			scale: scale || 1
		};

		this.image = image;


		this.generate();
	}
	TerrainBufferGeometry.prototype = Object.create(three.BufferGeometry.prototype);
	TerrainBufferGeometry.constructor = TerrainBufferGeometry;

	TerrainBufferGeometry.prototype.generate = function()
	{
		var width = this.parameters.width;
		var height = this.parameters.height;
		var widthSegments = this.parameters.widthSegments;
		var heightSegments = this.parameters.heightSegments;
		var scale = this.parameters.scale;

		var self = this;
		
		this.image.getImageData(function(data, imgWidth, imgHeight)
		{
			var imgChannels = 4;

			var widthHalf = width / 2;
			var heightHalf = height / 2;

			var gridX = Math.floor(widthSegments) || 1;
			var gridX1 = gridX + 1;
			var gridY = Math.floor(heightSegments) || 1;

			// Size of each individual segment
			var segWidth = width / gridX;
			var segHeight = height / gridY;

			// Buffers
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			var widthRatio = imgWidth / (width + 1);
			var heightRatio = imgHeight / (height + 1);

			// Get image pixel from x, y coordinates in the geometry space, value is normalized
			function getPixel(x, z)
			{
				var imgX = Math.round((x + widthHalf) * widthRatio);
				var imgY = Math.round((z + heightHalf) * heightRatio);
				var iy = (imgY * (imgWidth * imgChannels) + imgX * imgChannels);
				return data.data[iy] / 255;
			}

			// Generate vertices, normals and uvs
			for(var iz = 0; iz <= gridY; iz++)
			{
				var z = iz * segHeight - heightHalf;

				for(var ix = 0; ix <= gridX; ix++)
				{
					var x = ix * segWidth - widthHalf;

					// Read height from the image data
					var y = (getPixel(x, z) * scale);
					vertices.push(x, y, z);
					normals.push(0, 1, 0);

					uvs.push(ix / gridX);
					uvs.push(1 - (iz / gridY));
				}
			}

			// Indices
			for(var iz = 0; iz < gridY; iz ++)
			{
				for(var ix = 0; ix < gridX; ix ++)
				{
					var a = ix + gridX1 * iz;
					var b = ix + gridX1 * (iz + 1);
					var c = (ix + 1) + gridX1 * (iz + 1);
					var d = (ix + 1) + gridX1 * iz;

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			self.setIndex(indices);
			self.setAttribute("position", new three.Float32BufferAttribute(vertices, 3));
			self.setAttribute("normal", new three.Float32BufferAttribute(normals, 3));
			self.setAttribute("uv", new three.Float32BufferAttribute(uvs, 2));

			self.computeVertexNormals();

			self.boundingBox = null;
			self.boundingSphere = null;
		});
	};

	TerrainBufferGeometry.prototype.toJSON = function()
	{
		var data = three.BufferGeometry.prototype.toJSON.call(this);
		
		data.image = this.image.uuid;

		return data;
	};

	/**
	 * Rounded corners box buffer geometry, composed of a box with spherical corners and cylindrical edges.
	 *
	 * The rounded parts of the geometry can be configured in detail level.
	 *
	 * @author pailhead / http://dusanbosnjak.com
	 * @class RoundedBoxBufferGeometry
	 * @constructor
	 */
	function RoundedBoxBufferGeometry(width, height, depth, radius, radiusSegments)
	{
		three.BufferGeometry.call(this);

		this.type = "RoundedBoxBufferGeometry";

		// Validate params
		radiusSegments = !isNaN(radiusSegments) ? Math.max(1, Math.floor(radiusSegments)) : 1;
		width = !isNaN(width) ? width : 1;
		height = !isNaN(height) ? height : 1;
		depth = !isNaN(depth) ? depth : 1;
		radius = !isNaN(radius) ? radius : .15;
		radius = Math.min(radius, Math.min(width, Math.min(height, Math.min(depth))) / 2);

		var edgeHalfWidth = width / 2 - radius;
		var edgeHalfHeight = height / 2 - radius;
		var edgeHalfDepth = depth / 2 - radius;

		// Serialization parameters
		this.parameters =
		{
			width: width,
			height: height,
			depth: depth,
			radius: radius,
			radiusSegments: radiusSegments
		};

		// Calculate vertices count
		var rs1 = radiusSegments + 1; // Radius segments + 1 
		var totalVertexCount = (rs1 * radiusSegments + 1) << 3;

		// Make buffers
		var positions = new three.BufferAttribute(new Float32Array(totalVertexCount * 3), 3);
		var normals = new three.BufferAttribute(new Float32Array(totalVertexCount * 3), 3);

		// Some vars
		var cornerVerts = [];
		var cornerNormals = [];
		var normal = new three.Vector3();
		var vertex = new three.Vector3();
		var vertexPool = [];
		var normalPool = [];
		var indices = [];

		var lastVertex = rs1 * radiusSegments;
		var cornerVertNumber = lastVertex + 1;

		doVertices();
		doFaces();
		doCorners();
		doHeightEdges();
		doWidthEdges();
		doDepthEdges();

		// Calculate vert positions
		function doVertices() {

			// Corner offsets
			var cornerLayout = [
				new three.Vector3(1, 1, 1),
				new three.Vector3(1, 1, -1),
				new three.Vector3(-1, 1, -1),
				new three.Vector3(-1, 1, 1),
				new three.Vector3(1, -1, 1),
				new three.Vector3(1, -1, -1),
				new three.Vector3(-1, -1, -1),
				new three.Vector3(-1, -1, 1)
			];

			// Corner holder 
			for(var j = 0; j < 8; j++)
			{
				cornerVerts.push([]);
				cornerNormals.push([]);
			}

			// Construct 1/8 sphere
			var PIhalf = Math.PI / 2;
			var cornerOffset = new three.Vector3(edgeHalfWidth, edgeHalfHeight, edgeHalfDepth);

			for(var y = 0; y <= radiusSegments; y++)
			{
				var v = y / radiusSegments;
				var va = v * PIhalf; // Arrange in 90 deg

				var cosVa = Math.cos(va); // Scale of vertical angle 
				var sinVa = Math.sin(va);

				if(y == radiusSegments)
				{
					vertex.set(0, 1, 0);

					var vert = vertex.clone().multiplyScalar(radius).add(cornerOffset);
					cornerVerts[0].push(vert);
					vertexPool.push(vert);

					var norm = vertex.clone();
					cornerNormals[0].push(norm);
					normalPool.push(norm);

					continue; // Skip row loop
				}

				for(var x = 0; x <= radiusSegments; x++)
				{
					var u = x / radiusSegments;
					var ha = u * PIhalf;

					// Make 1/8 sphere points
					vertex.x = cosVa * Math.cos(ha);
					vertex.y = sinVa;
					vertex.z = cosVa * Math.sin(ha);

					// Copy sphere point, scale by radius, offset by half whd
					var vert = vertex.clone().multiplyScalar(radius).add(cornerOffset);
					cornerVerts[0].push(vert);
					vertexPool.push(vert);

					// Sphere already normalized, just clone
					var norm = vertex.clone().normalize();
					cornerNormals[0].push(norm);
					normalPool.push(norm);
				}
			}

			// Distribute corner verts
			for(var i = 1; i < 8; i++)
			{
				for(var j = 0; j < cornerVerts[0].length; j++)
				{
					var vert = cornerVerts[0][j].clone().multiply(cornerLayout[i]);
					cornerVerts[i].push(vert);
					vertexPool.push(vert);

					var norm = cornerNormals[0][j].clone().multiply(cornerLayout[i]);
					cornerNormals[i].push(norm);
					normalPool.push(norm);
				}
			}
		}

		// Weave corners
		function doCorners()
		{
			var flips = [true, false, true, false, false, true, false, true];

			var lastRowOffset = rs1 * (radiusSegments - 1);
			for(var i = 0; i < 8; i++)
			{
				var cornerOffset = cornerVertNumber * i;

				for(var v = 0; v < radiusSegments - 1; v++)
				{
					var r1 = v * rs1; // Row offset
					var r2 = (v + 1) * rs1; // Next row

					for(var u = 0; u < radiusSegments; u++)
					{
						var u1 = u + 1;
						var a = cornerOffset + r1 + u;
						var b = cornerOffset + r1 + u1;
						var c = cornerOffset + r2 + u;
						var d = cornerOffset + r2 + u1;

						if(!flips[i])
						{
							indices.push(a, b, c, b, d, c);
						}
						else
						{
							indices.push(a, c, b, b, c, d);
						}
					}

				}

				for(var u = 0; u < radiusSegments; u++)
				{
					var a = cornerOffset + lastRowOffset + u;
					var b = cornerOffset + lastRowOffset + u + 1;
					var c = cornerOffset + lastVertex;

					if(!flips[i])
					{
						indices.push(a, b, c);
					}
					else
					{
						indices.push(a, c, b);
					}
				}
			}
		}


		// Plates
		function doFaces()
		{
			// Top
			var a = lastVertex; // + cornerVertNumber * 0;
			var b = lastVertex + cornerVertNumber; // * 1;
			var c = lastVertex + cornerVertNumber * 2;
			var d = lastVertex + cornerVertNumber * 3;
			indices.push(a, b, c, a, c, d);

			// Bottom
			a = lastVertex + cornerVertNumber * 4; // + cornerVertNumber * 0;
			b = lastVertex + cornerVertNumber * 5; // * 1;
			c = lastVertex + cornerVertNumber * 6;
			d = lastVertex + cornerVertNumber * 7;
			indices.push(a, c, b, a, d, c);

			// Left 
			a = 0;
			b = cornerVertNumber;
			c = cornerVertNumber * 4;
			d = cornerVertNumber * 5;
			indices.push(a, c, b, b, c, d);

			// Right 
			a = cornerVertNumber * 2;
			b = cornerVertNumber * 3;
			c = cornerVertNumber * 6;
			d = cornerVertNumber * 7;
			indices.push(a, c, b, b, c, d);

			// Front 
			a = radiusSegments;
			b = radiusSegments + cornerVertNumber * 3;
			c = radiusSegments + cornerVertNumber * 4;
			d = radiusSegments + cornerVertNumber * 7;
			indices.push(a, b, c, b, d, c);

			// Back 
			a = radiusSegments + cornerVertNumber;
			b = radiusSegments + cornerVertNumber * 2;
			c = radiusSegments + cornerVertNumber * 5;
			d = radiusSegments + cornerVertNumber * 6;
			indices.push(a, c, b, b, c, d);
		}

		// Weave edges
		function doHeightEdges()
		{
			for(var i = 0; i < 4; i++)
			{
				var cOffset = i * cornerVertNumber;
				var cRowOffset = 4 * cornerVertNumber + cOffset;
				var needsFlip = i & 1 === 1;

				for(var u = 0; u < radiusSegments; u++)
				{
					var u1 = u + 1;
					var a = cOffset + u;
					var b = cOffset + u1;
					var c = cRowOffset + u;
					var d = cRowOffset + u1;

					if(!needsFlip)
					{
						indices.push(a, b, c, b, d, c);
					}
					else
					{
						indices.push(a, c, b, b, c, d);
					}
				}
			}
		}

		function doDepthEdges()
		{
			var cStarts = [0, 2, 4, 6];
			var cEnds = [1, 3, 5, 7];

			for(var i = 0; i < 4; i++)
			{
				var cStart = cornerVertNumber * cStarts[i];
				var cEnd = cornerVertNumber * cEnds[i];
				var needsFlip = 1 >= i;

				for(var u = 0; u < radiusSegments; u++)
				{
					var urs1 = u * rs1;
					var u1rs1 = (u + 1) * rs1;
					var a = cStart + urs1;
					var b = cStart + u1rs1;
					var c = cEnd + urs1;
					var d = cEnd + u1rs1;

					if(needsFlip)
					{
						indices.push(a, c, b, b, c, d);
					}
					else
					{
						indices.push(a, b, c, b, d, c);
					}
				}
			}
		}

		function doWidthEdges()
		{
			var end = radiusSegments - 1;
			var cStarts = [0, 1, 4, 5];
			var cEnds = [3, 2, 7, 6];
			var needsFlip = [0, 1, 1, 0];

			for(var i = 0; i < 4; i++)
			{
				var cStart = cStarts[i] * cornerVertNumber;
				var cEnd = cEnds[i] * cornerVertNumber;

				for(var u = 0; u <= end; u++)
				{
					var a = cStart + radiusSegments + u * rs1;
					var b = cStart + (u != end ? radiusSegments + (u + 1) * rs1 : cornerVertNumber - 1);

					var c = cEnd + radiusSegments + u * rs1;
					var d = cEnd + (u != end ? radiusSegments + (u + 1) * rs1 : cornerVertNumber - 1);

					if(!needsFlip[i])
					{
						indices.push(a, b, c, b, d, c);
					}
					else
					{
						indices.push(a, c, b, b, c, d);
					}
				}
			}
		}


		// Fill buffers
		var index = 0;
		for(var i = 0; i < vertexPool.length; i++)
		{
			positions.setXYZ(index, vertexPool[i].x, vertexPool[i].y, vertexPool[i].z);
			normals.setXYZ(index, normalPool[i].x, normalPool[i].y, normalPool[i].z);
			index++;
		}

		this.setIndex(new three.BufferAttribute(new Uint16Array(indices), 1));
		this.addAttribute("position", positions);
		this.addAttribute("normal", normals);
	}
	RoundedBoxBufferGeometry.prototype = Object.create(three.BufferGeometry.prototype);
	RoundedBoxBufferGeometry.constructor = RoundedBoxBufferGeometry;

	/**
	 * Capsule like geometry shape consisting of a cylinder with hemispherical ends.
	 *
	 * The geometry is fully configurable booth in size and details, and can also be used to generate sections of capsule.
	 *
	 * @author maximequiblier
	 * @class CapsuleBufferGeometry
	 * @constructor
	 */
	function CapsuleBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, capsTopSegments, capsBottomSegments, thetaStart, thetaLength) {

		three.BufferGeometry.call(this);

		this.type = "CapsuleBufferGeometry";

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			capsTopSegments: capsTopSegments,
			capsBottomSegments: capsBottomSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height !== undefined ? height : 2;

		radialSegments = Math.floor(radialSegments) || 8;
		heightSegments = Math.floor(heightSegments) || 1;
		capsTopSegments = Math.floor(capsTopSegments) || 2;
		capsBottomSegments = Math.floor(capsBottomSegments) || 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

		// Alpha is the angle such that Math.PI/2 - alpha is the cone part angle.
		var alpha = Math.acos((radiusBottom-radiusTop)/height);

		var vertexCount = calculateVertexCount();
		var indexCount = calculateIndexCount();

		// buffers
		var indices = new three.BufferAttribute(new (indexCount > 65535 ? Uint32Array : Uint16Array)(indexCount), 1);
		var vertices = new three.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var normals = new three.BufferAttribute(new Float32Array(vertexCount * 3), 3);
		var uvs = new three.BufferAttribute(new Float32Array(vertexCount * 2), 2);

		// Helper variables
		var index = 0,
			indexOffset = 0,
			indexArray = [],
			halfHeight = height / 2;

		// Generate geometry
		generateTorso();

		// Build geometry
		this.setIndex(indices);
		this.addAttribute("position", vertices);
		this.addAttribute("normal", normals);
		this.addAttribute("uv", uvs);

		// Helper functions
		function calculateVertexCount()
		{
			var count = (radialSegments + 1) * (heightSegments + 1 + capsBottomSegments + capsTopSegments);
			return count;
		}

		function calculateIndexCount()
		{
			var count = radialSegments * (heightSegments + capsBottomSegments + capsTopSegments) * 2 * 3;
			return count;
		}

		function generateTorso()
		{
			var x, y;
			var normal = new three.Vector3();
			var vertex = new three.Vector3();

			var cosAlpha = Math.cos(alpha);
			var sinAlpha = Math.sin(alpha);

			var cone_length = new three.Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).sub(new three.Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();

			// Total length forv texture coord
			var vl = radiusTop*alpha + cone_length + radiusBottom*(Math.PI/2-alpha);

			// generate vertices, normals and uvs
			var v = 0;
			for(y = 0; y <= capsTopSegments; y++)
			{
				var indexRow = [];

				var a = Math.PI/2 - alpha*(y / capsTopSegments);

				v += radiusTop*alpha/capsTopSegments;

				var cosA = Math.cos(a);
				var sinA = Math.sin(a);

				// calculate the radius of the current row
				var radius = cosA*radiusTop;

				for(x = 0; x <= radialSegments; x++)
				{
					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);

					// Vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight + sinA*radiusTop;
					vertex.z = radius * cosTheta;
					vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

					// Normal
					normal.set(cosA*sinTheta, sinA, cosA*cosTheta);
					normals.setXYZ(index, normal.x, normal.y, normal.z);

					// uv
					uvs.setXY(index, u, 1 - v/vl);

					// Save index of vertex in respective row
					indexRow.push(index);

					// Increase index
					index++;

				}

				// Now save vertices of the row in our index array
				indexArray.push(indexRow);

			}

			var cone_height = height + cosAlpha*radiusTop - cosAlpha*radiusBottom;
			var slope = sinAlpha * (radiusBottom - radiusTop) / cone_height;
			for(y = 1; y <= heightSegments; y++) {

				var indexRow = [];

				v += cone_length/heightSegments;

				// calculate the radius of the current row
				var radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);

				for(x = 0; x <= radialSegments; x++) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);

					// Vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight + cosAlpha*radiusTop - y * cone_height / heightSegments;
					vertex.z = radius * cosTheta;
					vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

					// Normal
					normal.set(sinTheta, slope, cosTheta).normalize();
					normals.setXYZ(index, normal.x, normal.y, normal.z);

					// uv
					uvs.setXY(index, u, 1 - v/vl);

					// Save index of vertex in respective row
					indexRow.push(index);

					// Increase index
					index++;

				}

				// Now save vertices of the row in our index array
				indexArray.push(indexRow);

			}

			for(y = 1; y <= capsBottomSegments; y++) {

				var indexRow = [];

				var a = (Math.PI/2 - alpha) - (Math.PI - alpha)*(y / capsBottomSegments);

				v += radiusBottom*alpha/capsBottomSegments;

				var cosA = Math.cos(a);
				var sinA = Math.sin(a);

				// calculate the radius of the current row
				var radius = cosA*radiusBottom;

				for(x = 0; x <= radialSegments; x++)
				{
					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin(theta);
					var cosTheta = Math.cos(theta);

					// Vertex
					vertex.x = radius * sinTheta;
					vertex.y = -halfHeight + sinA*radiusBottom;				vertex.z = radius * cosTheta;
					vertices.setXYZ(index, vertex.x, vertex.y, vertex.z);

					// Normal
					normal.set(cosA*sinTheta, sinA, cosA*cosTheta);
					normals.setXYZ(index, normal.x, normal.y, normal.z);

					// uv
					uvs.setXY(index, u, 1 - v/vl);

					// Save index of vertex in respective row
					indexRow.push(index);

					// Increase index
					index++;
				}

				// Now save vertices of the row in our index array
				indexArray.push(indexRow);
			}

			// Generate indices
			for(x = 0; x < radialSegments; x++)
			{
				for(y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++)
				{

					// We use the index array to access the correct indices
					var i1 = indexArray[ y ][ x ];
					var i2 = indexArray[ y + 1 ][ x ];
					var i3 = indexArray[ y + 1 ][ x + 1 ];
					var i4 = indexArray[ y ][ x + 1 ];

					// Face one
					indices.setX(indexOffset, i1); indexOffset++;
					indices.setX(indexOffset, i2); indexOffset++;
					indices.setX(indexOffset, i4); indexOffset++;

					// Face two
					indices.setX(indexOffset, i2); indexOffset++;
					indices.setX(indexOffset, i3); indexOffset++;
					indices.setX(indexOffset, i4); indexOffset++;
				}
			}
		}
	}

	CapsuleBufferGeometry.prototype = Object.create(three.BufferGeometry.prototype);
	CapsuleBufferGeometry.prototype.constructor = CapsuleBufferGeometry;

	/**
	 * Geometry loader can be used to load geometry files.
	 * 
	 * @class GeometryLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function GeometryLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;

		this.shapes = {};

		this.images = {};
	}

	/**
	 * Set list of images to be used by the loader.
	 *
	 * @method setImages
	 * @param {Array} images
	 */
	GeometryLoader.prototype.setImages = function(images)
	{
		this.images = images;
		return this;
	};

	/**
	 * Set list of shapes to be used by this loader.
	 *
	 * @method setShapes
	 * @param {Array} shapes
	 */
	GeometryLoader.prototype.setShapes = function(shapes)
	{
		this.shapes = shapes;
		return this;
	};


	/**
	 * Load geometry json file from URL.
	 *
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	GeometryLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			onLoad(self.parse(JSON.parse(text)));
		}, onProgress, onError);
	};

	/**
	 * Parse geometry json.
	 *
	 * @method parse
	 * @param {Object} json
	 * @return {Geometry} Geometry loaded from json.
	 */
	GeometryLoader.prototype.parse = function(data)
	{
		var geometry = null;
		
		if(data.type === "CapsuleBufferGeometry")
		{
			geometry = new CapsuleBufferGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.capsTopSegments, data.capsBottomSegments, data.thetaStart, data.thetaLength);
		}
		else if(data.type === "RoundedBoxBufferGeometry")
		{
			geometry = new RoundedBoxBufferGeometry(data.width, data.height, data.depth, data.radius, data.radiusSegments);
		}
		else if(data.type === "TerrainBufferGeometry")
		{
			geometry = new TerrainBufferGeometry(data.width, data.height, data.widthSegments, data.heightSegments, data.scale, this.images[data.image]);
		}

		else if(data.type === "Geometry")
		{
			var loader = new LegacyGeometryLoader();
			geometry = loader.parse(data.data).geometry;
		}

		else
		{
			var geometries = three.ObjectLoader.prototype.parseGeometries([data], this.shapes);
			for(var i in geometries)
			{
				geometry = geometries[i];
				break;
			}
		}

		geometry.uuid = data.uuid;
		geometry.name = data.name !== undefined ? data.name : "geometry";

		return geometry;
	};

	/**
	 * FontLoader can be used to load external font resources.
	 *
	 * @class FontLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function FontLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;
	}

	/**
	 * Load font file from URL.
	 *
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	FontLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			onLoad(new Font(JSON.parse(text)));
		}, onProgress, onError);
	};

	/**
	 * Parse font json and return resource.
	 *
	 * @method parse
	 * @param {Object} json
	 * @return {Font} Font resource
	 */
	FontLoader.prototype.parse = function(json)
	{
		if(json.data !== undefined)
		{
			var font = new Font();

			font.name = json.name;
			font.uuid = json.uuid;
			font.encoding = json.encoding;
			
			if(json.reversed !== undefined)
			{
				font.reversed = json.reversed;
			}
			
			if(json.format === "arraybuffer")
			{
				font.format = json.format;
				font.data = (json.data.toArrayBuffer !== undefined) ? json.data.toArrayBuffer() : json.data;
				font.loadTTF();
			}
			else if(json.format === "base64")
			{
				font.format = "arraybuffer";
				font.data = ArraybufferUtils.fromBase64(json.data);
				font.loadTTF();
			}
			else
			{
				font.format = json.format;
				font.data = json.data;
				font.font = json.data;
			}

			return font;
		}
		else
		{
			return new Font(json);
		}
	};

	/**
	 * Audio loader can be used to load external audio resources.
	 * 
	 * @class AudioLoader
	 * @module Loaders
	 * @param {Object} manager
	 */
	function AudioLoader(manager)
	{
		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;
	}

	/**
	 * Load audio file from URL.
	 *
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	AudioLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			onLoad(self.parse(JSON.parse(text)));
		}, onProgress, onError);
	};

	/**
	 * Parse audio json and return resource.
	 *
	 * @method parse
	 * @param {Object} json
	 * @return {Audio} Audio resource
	 */
	AudioLoader.prototype.parse = function(json)
	{
		var audio = new Audio();

		audio.name = json.name;
		audio.uuid = json.uuid;
		audio.encoding = json.encoding;

		if(json.format === "base64")
		{
			audio.format = "arraybuffer";
			audio.data = ArraybufferUtils.fromBase64(json.data);
		}
		else if(json.format === "arraybuffer")
		{
			audio.format = json.format;
			audio.data = (json.data.toArrayBuffer !== undefined) ? json.data.toArrayBuffer() : json.data;
		}
		else
		{
			audio.format = json.format;
			audio.data = json.data;
		}

		return audio;
	};

	/**
	 * Objectloader can be used to load external objects from files.
	 *
	 * Also loads all resources attached to the objects being loaded.
	 * 
	 * Can parse be used to load on runtime resources and objects from external project files.
	 * 
	 * @module Loaders
	 * @class ObjectLoader
	 * @param {Object} manager
	 */
	function ObjectLoader(manager)
	{
		ResourceContainer.call(this);

		this.manager = (manager !== undefined) ? manager : three.DefaultLoadingManager;
		this.texturePath = "";
	}

	ObjectLoader.prototype = Object.create(ResourceContainer.prototype);

	/**
	 * Load object file from URL.
	 *
	 * @method load
	 * @param {string} url
	 * @param {Function} onLoad
	 * @param {Function} onProgress
	 * @param {Function} onError
	 */
	ObjectLoader.prototype.load = function(url, onLoad, onProgress, onError)
	{
		if(this.texturePath === "")
		{
			this.texturePath = url.substring(0, url.lastIndexOf("/") + 1);
		}

		var self = this;
		var loader = new three.FileLoader(this.manager);
		loader.load(url, function(text)
		{
			self.parse(JSON.parse(text), onLoad);
		}, onProgress, onError);
	};

	/**
	 * Parse JSON object and create the correct Object structure. 
	 * 
	 * Data can be loaded from a file and should be parsed into Object.
	 *
	 * @method parse
	 * @param {Object} json JSON data to be loaded.
	 * @param {Function} onLoad onLoad callback.
	 * @return {Object} Program loaded from json data.
	 */
	ObjectLoader.prototype.parse = function(json, onLoad)
	{
		this.parseResources(json.resources);
		this.parseShape(json.shapes);
		this.parseImages(json.images);
		this.parseGeometries(json.geometries);
		this.parseVideos(json.videos);
		this.parseAudio(json.audio);
		this.parseFonts(json.fonts);
		this.parseTextures(json.textures);
		this.parseMaterials(json.materials);

		var object = this.parseObject(json.object);

		// Bind sekeletons
		if(json.skeletons !== undefined)
		{
			this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object);
		}

		// Load images and process callback
		if(json.images === undefined || json.images.length === 0)
		{
			if(onLoad !== undefined)
			{
				onLoad(object);
			}
		}

		return object;
	};

	/**
	 * Define base path for external texture loading.
	 *
	 * @method setTexturePath
	 * @param {string} path
	 */
	ObjectLoader.prototype.setTexturePath = function(path)
	{
		this.texturePath = path;
	};

	/**
	 * Set cross origin.
	 *
	 * @method setCrossOrigin
	 * @param {string} origin
	 */
	ObjectLoader.prototype.setCrossOrigin = function(origin)
	{
		this.crossOrigin = origin;
	};

	/**
	 * Parse resources on JSON.
	 *
	 * @method parseResources
	 * @param {Object} json
	 * @return {Array} resources
	 */
	ObjectLoader.prototype.parseResources = function(json)
	{
		if(json !== undefined)
		{
			for(var i in json)
			{
				var resource = new TextFile(json[i].data, json[i].encoding);
				resource.format = json[i].format;
				resource.name = json[i].name;
				resource.uuid = json[i].uuid;

				this.resources[resource.uuid] = resource;
			}
		}

		return this.resources;
	};

	/**
	 * Parse geometries on JSON.
	 *
	 * @method parseShape
	 * @param {Object} json
	 * @return {Array} geometries
	 */
	ObjectLoader.prototype.parseShape = function(json)
	{
		if(json !== undefined)
		{
			for(var i = 0, l = json.length; i < l; i ++)
			{
				var shape = new Shape().fromJSON(json[i]);
				this.shapes[shape.uuid] = shape;
			}
		}

		return this.shapes;
	};

	/**
	 * Parse geometries on JSON.
	 *
	 * @method parseGeometries
	 * @param {Object} array
	 * @return {Array} geometries
	 */
	ObjectLoader.prototype.parseGeometries = function(array)
	{
		if(array !== undefined)
		{
			var loader = new GeometryLoader();
			loader.setShapes(this.shapes);
			loader.setImages(this.images);

			for(var i = 0; i < array.length; i++)
			{	
				this.geometries[array[i].uuid] = loader.parse(array[i]);
			}
		}

		return this.geometries;
	};

	/**
	 * Parse materials on json.
	 *
	 * @method parseMaterials
	 * @param {Object} json
	 * @return {Array} materials
	 */
	ObjectLoader.prototype.parseMaterials = function(json)
	{
		if(json !== undefined)
		{
			var loader = new MaterialLoader();
			loader.setTextures(this.textures);

			for(var i in json)
			{
				this.materials[json[i].uuid] = loader.parse(json[i]);
			}
		}

		return this.materials;
	};

	/**
	 * Parse images on json.
	 *
	 * @method parseImages
	 * @param {Object} json
	 * @return {Array} images
	 */
	ObjectLoader.prototype.parseImages = function(json)
	{
		if(json !== undefined)
		{
			var loader = new ImageLoader();
			for(var i in json)
			{
				this.images[json[i].uuid] = loader.parse(json[i]);
			}
		}

		return this.images;
	};

	/**
	 * Parse videos on json.
	 *
	 * @method parseVideos
	 * @param {Object} json
	 * @return {Array} videos
	 */
	ObjectLoader.prototype.parseVideos = function(json)
	{
		if(json !== undefined)
		{
			var loader = new VideoLoader();
			for(var i in json)
			{
				this.videos[json[i].uuid] = loader.parse(json[i]);
			}
		}

		return this.videos;
	};

	/**
	 * Parse audio on json.
	 *
	 * @method parseAudio
	 * @param {Object} json
	 * @return {Array} audio
	 */
	ObjectLoader.prototype.parseAudio = function(json)
	{
		if(json !== undefined)
		{
			var loader = new AudioLoader();
			for(var i in json)
			{
				this.audio[json[i].uuid] = loader.parse(json[i]);
			}
		}

		return this.audio;
	};

	/**
	 * Parse fonts on json.
	 *
	 * @method parseFonts
	 * @param {Object} json
	 * @return {Array} fonts
	 */
	ObjectLoader.prototype.parseFonts = function(json)
	{
		if(json !== undefined)
		{
			var loader = new FontLoader();
			for(var i in json)
			{
				this.fonts[json[i].uuid] = loader.parse(json[i]);
			}
		}

		return this.fonts;
	};

	/**
	 * Parse textures on json.
	 *
	 * @method parseTextures
	 * @param {Object} json
	 * @return {Array} textures
	 */
	ObjectLoader.prototype.parseTextures = function(json)
	{
		if(json !== undefined)
		{
			var loader = new TextureLoader();
			loader.setImages(this.images);
			loader.setVideos(this.videos);

			for(var i in json)
			{
				this.textures[json[i].uuid] = loader.parse(json[i]);
			}
		}
		
		return this.textures;
	};

	/**
	 * Parse array of skeletons from JSON object.
	 *
	 * @method parseSkeletons
	 * @param {Object} json
	 * @param {Object} object
	 */
	ObjectLoader.prototype.parseSkeletons = function(json, object)
	{
		if(json !== undefined)
		{
			for(var i = 0; i < json.length; i++)
			{
				this.skeletons[json[i].uuid] = three.Skeleton.fromJSON(json[i], object, this);
			}
		}

		return this.skeletons;
	};

	/**
	 * Auxiliar method to bind skeletons to loaded objects.
	 *
	 * Look for skeletonUUID property, wich is a placeholder with the skeleton UUID and replace it with the skeleton object.
	 *
	 * @method bindSkeletons
	 * @param {Object3D} object Object3D that contains objects
	 */
	ObjectLoader.prototype.bindSkeletons = function(object)
	{
		var self = this;

		object.traverse(function(child)
		{
			if(child.isSkinnedMesh && child.skeletonUUID !== undefined)
			{
				var skeleton = self.skeletons[child.skeletonUUID];
				if(skeleton === undefined)
				{
					console.warn("ObjectLoader: Skeleton not found.", child.skeletonUUID);
					return
				}

				delete child.skeletonUUID;
				child.bind(skeleton, child.bindMatrix);
			}
		});
	};


	/**
	 * Parse objects from json data,
	 *
	 * @method parseObjects
	 */
	ObjectLoader.prototype.parseObject = function(data)
	{
		var object;

		try
		{
			switch(data.type)
			{
				case "SpineAnimation":
					for(var i = 0; i < data.textures.length; i++)
					{
						data.textures[i].texture = this.getTexture(data.textures[i].texture);
					}

					object = new SpineAnimation(data.json, data.atlas, "", data.textures);
					
					if(data.animation !== undefined)
					{
						object.animation = data.animation;
						object.track = data.track;
						object.loop = data.loop;
					}
					if(data.skin !== undefined)
					{
						object.skin = data.skin;
					}
					break;

				case "Audio":
					object = new AudioEmitter(this.getAudio(data.audio));
					object.autoplay = data.autoplay;
					object.startTime = data.startTime;
					object.playbackRate = data.playbackRate;
					object.loop = (data.source !== undefined) ? data.source.loop : data.loop;
					if(data.volume !== undefined)
					{
						object.volume = data.volume;
					}
					break;

				case "PositionalAudio":
					object = new PositionalAudio(this.getAudio(data.audio));
					object.autoplay = data.autoplay;
					object.startTime = data.startTime;
					object.playbackRate = data.playbackRate;
					object.loop = (data.source !== undefined) ? data.source.loop : data.loop;
					if(data.volume !== undefined)
					{
						object.volume = data.volume;
					}
					object.distanceModel = data.distanceModel;
					object.panningModel = data.panningModel;
					break;

				case "Physics":
					object = PhysicsObject.fromJSON(data);
					break;

				case "ParticleEmiter":
					object = ParticleEmitter.fromJSON(data, this); 
					break;

				case "LensFlare":
					object = new LensFlare();
					
					if(data.lensFlares !== undefined)
					{
						data.elements = data.lensFlares;
					}

					for(var i = 0; i < data.elements.length; i++)
					{
						object.addFlare(this.getTexture(data.elements[i].texture), data.elements[i].size, data.elements[i].distance, new three.Color(data.elements[i].color));
					}

					break;

				case "TextMesh":
				case "Text3D":
					object = new TextMesh(data.text, this.getMaterial(data.material), this.getFont(data.font), data.height, data.bevel, data.bevelThickness, data.bevelSize, data.size, data.curveSegments, data.extruded);
					break;

				case "Program":
					object = new Program(data.name);
					
					object.description = data.description;
					object.author = data.author;
					object.version = data.version;

					object.vr = data.vr;
					object.vrScale = data.vrScale;

					if(data.rendererConfig !== undefined)
					{
						object.rendererConfig.fromJSON(data.rendererConfig);
					}
					else
					{
						object.rendererConfig.antialiasing = data.antialiasing;
						object.rendererConfig.shadows = data.shadows;
						object.rendererConfig.shadowsType = data.shadowsType;
						object.rendererConfig.toneMapping = data.toneMapping;
						object.rendererConfig.toneMappingWhitePoint = data.toneMappingWhitePoint;
						object.rendererConfig.toneMappingExposure = data.toneMappingExposure;
					}

					if(data.lockPointer !== undefined)
					{
						object.lockPointer = data.lockPointer;
					}

					if(data.defaultScene !== undefined)
					{
						object.defaultScene = data.defaultScene;
					}
					
					if(data.handlePixelRatio !== undefined)
					{
						object.handlePixelRatio = data.handlePixelRatio;	
					}

					break;

				case "LeapDevice":
					object = new LeapMotion();
					object.mode = data.mode;
					object.useArm = data.useArm;
					if(data.debugModel !== undefined)
					{
						object.debugModel = data.debugModel;
					}
					if(data.gesturesEnabled !== undefined)
					{
						object.gesturesEnabled = data.gesturesEnabled;
					}
					if(data.posesEnabled !== undefined)
					{
						object.posesEnabled = data.posesEnabled;
					}
					break;

				case "Kinect":
					object = new KinectDevice();
					if(data.debugModel !== undefined)
					{
						object.debugModel = data.debugModel;
					}
					break;

				case "Sky":
					object = new Sky(data.autoUpdate, data.dayTime, data.sunDistance, data.time);
					
					if(data.sun !== undefined)
					{
						object.sun.shadow.fromJSON(data.sun.shadow);
						
						if(data.sun.castShadow !== undefined)
						{
							object.sun.castShadow = data.sun.castShadow;
						}
					}

					if(data.colorTop !== undefined)
					{
						object.colorTop = [];
						for(var i = 0; i < data.colorTop.length; i++)
						{
							object.colorTop.push(new three.Color(data.colorTop[i])); 
						}
					}
					if(data.colorBottom !== undefined)
					{
						object.colorBottom = [];
						for(var i = 0; i < data.colorBottom.length; i++)
						{
							object.colorBottom.push(new three.Color(data.colorBottom[i])); 
						}
					}
					if(data.sunColor !== undefined)
					{
						object.sunColor = data.sunColor;
					}
					if(data.moonColor !== undefined)
					{
						object.moonColor = data.moonColor;
					}
					if(data.intensity !== undefined)
					{
						object.intensity = data.intensity;
					}

					break;

				case "CubeCamera":
					object = new CubeCamera(data.near, data.far, data.resolution, data.autoUpdate);
					break;
					
				case "FirstPersonControls":
					object = new FirstPersonControls();
					object.sensitivity = data.sensitivity;
					object.needsButtonPressed = data.needsButtonPressed;
					object.movementEnabled = data.movementEnabled;
					object.moveSpeed = data.moveSpeed;
					object.moveOnPlane = data.moveOnPlane;
					object.moveKeys = data.moveKeys;
					break;

				case "OrbitControls":
					object = new OrbitControls();
					object.distance = data.distance;
					object.maxDistance = data.maxDistance;
					object.minDistance = data.minDistance;
					object.sensitivity = data.sensitivity;
					object.limitUp = data.limitUp;
					object.limitDown = data.limitDown;
					object.needsButtonPressed = data.needsButtonPressed;
					object.zoomEnabled = data.zoomEnabled;
					object.movementEnabled = data.movementEnabled;
					
					if(data.smooth !== undefined)
					{
						object.smooth = data.smooth;
						object.friction = data.friction;
						object.speed = data.speed;
						object.invertNavigation = data.invertNavigation;
					}
					if(data.center !== undefined)
					{
						object.center.fromArray(data.center);
						object.vector.fromArray(data.vector);
					}

					break;
					
				case "Scene":
					object = new Scene();

					if(data.background !== undefined)
					{
						if(Number.isInteger(data.background))
						{
							object.background = new three.Color(data.background);
						}
						else
						{
							object.background = this.getTexture(data.background);
						}
					}

					if(data.environment !== undefined)
					{
						object.environment = this.getTexture(data.environment);
					}

					if(data.fog !== undefined)
					{
						if(data.fog.type === "Fog")
						{
							object.fog = new three.Fog(data.fog.color, data.fog.near, data.fog.far);
						}
						else if(data.fog.type === "FogExp2")
						{
							object.fog = new three.FogExp2(data.fog.color, data.fog.density);
						}
					}

					if(data.defaultCamera !== undefined)
					{
						object.defaultCamera = this.parse(data.defaultCamera);
					}

					if(data.cameras !== undefined)
					{
						object.cameras = data.cameras;
					}

					if(data.usePhysics !== undefined)
					{
						object.usePhysics = data.usePhysics;
					}

					if(data.world !== undefined)
					{
						object.world.gravity.set(data.world.gravity.x, data.world.gravity.y, data.world.gravity.z);
						object.world.quatNormalizeSkip = data.world.quatNormalizeSkip;
						object.world.quatNormalizeFast = data.world.quatNormalizeFast;
						
						object.world.solver.tolerance = data.world.solver.tolerance;
						object.world.solver.iterations = data.world.solver.iterations;
					}
					break;

				case "PerspectiveCamera":
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					
					if(data.focus !== undefined) 
					{
						object.focus = data.focus;
					}
					if(data.zoom !== undefined)
					{
						object.zoom = data.zoom;
					}
					if(data.filmGauge !== undefined)
					{
						object.filmGauge = data.filmGauge;
					}
					if(data.filmOffset !== undefined)
					{
						object.filmOffset = data.filmOffset;
					}
					if(data.view !== undefined)
					{
						object.view = Object.assign({}, data.view);
					}

					if(data.viewport !== undefined)
					{
						if(data.viewport instanceof Array)
						{
							object.viewport.size.fromArray(data.viewport);
							object.viewport.offset.fromArray(data.offset);
						}
						else
						{
							object.viewport.fromJSON(data.viewport);
						}
					}

					if(data.clearColor !== undefined)
					{
						object.clearColor = data.clearColor;
					}
					if(data.clearDepth !== undefined)
					{
						object.clearDepth = data.clearDepth;
					}
					if(data.clearStencil !== undefined)
					{
						object.clearStencil = data.clearStencil;
					}
					if(data.order !== undefined)
					{
						object.order = data.order;
					}

					if(data.composer !== undefined)
					{
						object.composer = EffectComposer.fromJSON(data.composer);
					}
					break;

				case "OrthographicCamera":
					object = new OrthographicCamera(data.size, data.aspect, data.mode, data.near, data.far);

					if(data.viewport !== undefined)
					{
						if(data.viewport instanceof Array)
						{
							object.viewport.size.fromArray(data.viewport);
							object.viewport.offset.fromArray(data.offset);
						}
						else
						{
							object.viewport.fromJSON(data.viewport);
						}
					}

					if(data.clearColor !== undefined)
					{
						object.clearColor = data.clearColor;
					}
					if(data.clearDepth !== undefined)
					{
						object.clearDepth = data.clearDepth;
					}
					if(data.clearStencil !== undefined)
					{
						object.clearStencil = data.clearStencil;
					}
					if(data.order !== undefined)
					{
						object.order = data.order;
					}
					if(data.composer !== undefined)
					{
						object.composer = EffectComposer.fromJSON(data.composer);
					}
					if(data.zoom !== undefined)
					{
						object.zoom = data.zoom;
					}
					if(data.view !== undefined)
					{
						object.view = Object.assign({}, data.view);
					}
					break;

				case "Script":
					object = new Script(data.code, data.mode);
					break;

				case "RectAreaLight":
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case "AmbientLight":
					object = new AmbientLight(data.color, data.intensity);
					break;

				case "DirectionalLight":
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case "PointLight":
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case "SpotLight":
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case "HemisphereLight":
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case "HTMLView":
					object = new HTMLView();
					object.height = data.height;
					object.width = data.width;
					object.url = data.url;
					break;

				case "LightProbe":
					object = new LightProbe();
					object.sh.fromArray(data.sh);
					break;

				case "InstancedMesh":
					object = new InstancedMesh(this.getGeometry(data.geometry), this.getMaterial(data.material), data.count);
					object.instanceMatrix = new three.BufferAttribute(new Float32Array(data.instanceMatrix.array), 16);
					break;

				case "SkinnedMesh":
					object = new SkinnedMesh(this.getGeometry(data.geometry), this.getMaterial(data.material));

					// Rebinds with skeleton whose uuid is data.skeleton later.
					if(data.skeleton !== undefined) {object.skeletonUUID = data.skeleton;}
					if(data.bindMode !== undefined) {object.bindMode = data.bindMode;}
					if(data.bindMatrix !== undefined) {object.bindMatrix.fromArray(data.bindMatrix);}

					break;

				case "Mesh":
					object = new Mesh(this.getGeometry(data.geometry), this.getMaterial(data.material));
					break;

				case "TextBitmap":
					object = TextBitmap.fromJSON(data, this.getTexture(data.texture));
					break;

				case "TextSprite":
					object = TextSprite.fromJSON(data);
					break;

				case "LOD":
					object = new three.LOD();
					break;

				case "Line":
					object = new three.Line(this.getGeometry(data.geometry), this.getMaterial(data.material), data.mode);
					break;

				case "LineLoop":
					object = new three.LineLoop(this.getGeometry(data.geometry), this.getMaterial(data.material));
					break;

				case "LineSegments":
					object = new three.LineSegments(this.getGeometry(data.geometry), this.getMaterial(data.material));
					break;

				case "PointCloud":
				case "Points":
					object = new three.Points(this.getGeometry(data.geometry), this.getMaterial(data.material));
					break;

				case "Sprite":
					object = new Sprite(this.getMaterial(data.material));
					break;

				case "Group":
					object = new Container();
					break;

				case "Bone":
					object = new three.Bone();
					break;

				default:
					object = new Container();
			}
		}
		catch(e)
		{
			console.error("nunuStudio: Error parsing and creating object " + data.uuid + ", object skiped.", e, data);
			object = new Container();
		}

		object.uuid = data.uuid;
		object.name = data.name;

		object.locked = data.locked === true || data.hidden === true;
		object.folded = data.folded === true;

		if(data.frustumCulled !== undefined)
		{
			object.frustumCulled = data.frustumCulled;
		}
		
		if(data.renderOrder !== undefined)
		{
			object.renderOrder = data.renderOrder;
		}
		
		// Animations
		if(data.animations !== undefined)
		{
			object.animations = [];

			for(var i = 0; i < data.animations.length; i++)
			{
				var clip = three.AnimationClip.parse(data.animations[i]);

				if(data.animations[i].uuid !== undefined)
				{
					clip.uuid = data.animations[i].uuid;
				}

				object.animations.push(clip);
			}
		}

		// Get or generate tranformation matrix if necessary
		if(data.matrix !== undefined)
		{
			object.matrix.fromArray(data.matrix);
			object.matrix.decompose(object.position, object.quaternion, object.scale);
		}

		// If available use position rotation and quarternion stored in file
		if(data.position !== undefined) {object.position.fromArray(data.position);}
		if(data.rotation !== undefined) {object.rotation.fromArray(data.rotation);}
		if(data.quaternion !== undefined) {object.quaternion.fromArray(data.quaternion);}
		if(data.scale !== undefined) {object.scale.fromArray(data.scale);}

		// Shadow casting
		object.castShadow = data.castShadow === true;
		object.receiveShadow = data.receiveShadow === true;

		// Shadowmap data
		if(data.shadow !== undefined) {object.shadow.fromJSON(data.shadow);}

		// Visibility
		object.visible = data.visible === true;

		// Aditional user data
		if(data.userData !== undefined) {object.userData = data.userData;}
		if(data.layers !== undefined) {object.layers.mask = data.layers;}
		
		// Add children
		if(data.children !== undefined)
		{
			for(var child in data.children)
			{
				object.add(this.parseObject(data.children[child]));
			}
		}

		// Set static and update transformation matrix if necessary
		if(data.matrixAutoUpdate !== undefined)
		{
			object.matrixAutoUpdate = data.matrixAutoUpdate;
			
			if(!object.matrixAutoUpdate)
			{
				object.updateMatrix();
				object.updateMatrixWorld(true);
			}
		}

		// Attach resources to program
		if(data.type === "Program")
		{
			object.copyResources(this);
		}
		// Get scene default cameras
		else if(data.type === "Scene")
		{
			for(var i = 0; i < object.cameras.length; i++)
			{
				var camera = object.getCamera(object.cameras[i]);
				if(camera !== null)
				{
					object.cameras[i] = camera;
				}
				else
				{
					object.cameras.splice(i, 1);
				}
			}
		}
		// LOD objects
		else if(data.type === "LOD")
		{
			var levels = data.levels;
			for(var l = 0; l < levels.length; l++)
			{
				var level = levels[l];
				var child = object.getObjectByProperty("uuid", level.object);
				if(child !== undefined)
				{
					object.addLevel(child, level.distance);
				}
			}
		}

		return object;
	};

	/**
	 * Particle emitter is a wrapper for SPE particle system.
	 *
	 * SPE is a threejs based particle emitter engine.
	 * 
	 * Documentation for SPE particle engine can be found here https:// squarefeet.github.io/ShaderParticleEngine/docs/api/index.html
	 * 
	 * @class ParticleEmitter
	 * @extends {Points}
	 * @module Particles
	 */
	function ParticleEmitter(group, emitter)
	{
		/**
		 * Particle group instance.
		 * 
		 * @property group
		 * @type {ParticleGroup}
		 */
		this.group = new ParticleGroup(group !== undefined ? group : ParticleEmitter.defaultGroup);

		/**
		 * Emitter instance.
		 * 
		 * Emitter has attributes that can be used to controll the particle system
		 * 
		 * @property emitter
		 * @type {ParticleEmitterControl}
		 */
		this.emitter = new ParticleEmitterControl(emitter !== undefined ? emitter : ParticleEmitter.defaultEmitter);
		this.group.addEmitter(this.emitter);

		three.Points.call(this, this.group.geometry, this.group.material);

		this.type = "ParticleEmiter";
		this.name = "particle";
		this.frustumCulled = false;

		/**
		 * A dynamic particle emmiter ignores the position in its transform and applies it directly to the emitter origin.
		 *
		 * @property dinamicEmitter
		 * @type {boolean} 
		 */
		this.dynamicEmitter = false;

		this.clock = new three.Clock();
		this.temp = new three.Vector4();

		/**
		 * Texture attached to the group of this particle emitter.
		 *
		 * @property texture
		 * @type {Texture} 
		 */
		var self = this;
		Object.defineProperties(this,
		{
			texture:
			{
				get: function(){return self.group.texture;},
				set: function(value){self.group.texture = value;}
			}
		});
	}


	/**
	 * Set this value to however many "steps" you want value-over-lifetime properties to have.
	 *
	 * Its adjustable to fix an interpolation problem:
	 *
	 * Assuming you specify an opacity value as [0, 1, 0] and the valueOverLifetimeLength is 4, then the opacity value array will be reinterpolated to be [0, 0.66, 0.66, 0].
	 * This isn't ideal, as particles would never reach full opacity.
	 *
	 * This property affects the length of ALL value-over-lifetime properties for ALL  emitters and ALL groups. Only values >= 3 && <= 4 are allowed.
	 *
	 * @attribute valueOverLifetimeLength
	 * @type {number}
	 */
	ParticleEmitter.valueOverLifetimeLength = 4;

	ParticleEmitter.prototype = Object.create(three.Points.prototype);

	/**
	 * Default particle emitter configuration.
	 *
	 * @attribute defaultEmitter
	 * @type {Object}
	 */
	ParticleEmitter.defaultEmitter =
	{		
		particleCount: 200,
		velocity:
		{
			value: new three.Vector3(0, 0, 0),
			spread: new three.Vector3(3, 3, 3)
		},
		acceleration:
		{
			value: new three.Vector3(0, 0, 0),
			spread: new three.Vector3(0, 0, 0)
		}
	};

	/**
	 * Default particle emitter group configuration.
	 *
	 * @attribute defaultGroup
	 * @type {Object}
	 */
	ParticleEmitter.defaultGroup = 
	{
		texture:
		{
			value: null
		},
		maxParticleCount: 200,
		blending: three.AdditiveBlending,
		fog: false,
		depthWrite: false,
		depthTest: true,
		transparent: true,
		hasPerspective: true
	};

	/**
	 * Reload internal material and geometry of this particle emitter.
	 *
	 * Recretes the group and emitter object attached to the particle.
	 *
	 * May be required after changing material related parameters.
	 * 
	 * @method reload
	 */
	ParticleEmitter.prototype.reload = function()
	{
		this.dispose();

		var children = this.children;
		this.children = [];
		var particle = new ObjectLoader().parse(this.toJSON());
		this.children = children;

		this.group = particle.group;
		this.emitter = particle.emitter;
		this.geometry = this.group.geometry;
		this.material = this.group.material;
	};

	/**
	 * Update particle object matrix.
	 *
	 * Ignores the particle position if the moveEmitter attribute is set true.
	 * 
	 * @method updateMatrix
	 */
	ParticleEmitter.prototype.updateMatrix = function()
	{
		if(this.dynamicEmitter)
		{
			this.matrix.makeRotationFromQuaternion(this.quaternion);
			this.matrix.scale(this.scale);
		}
		else
		{
			this.matrix.compose(this.position, this.quaternion, this.scale);
		}

		this.matrixWorldNeedsUpdate = true;
	};

	/**
	 * Particle emitter state is automatically updated before rendering.
	 * 
	 * @method onBeforeRender
	 */
	ParticleEmitter.prototype.onBeforeRender = function(renderer, scene, camera, renderTarget)
	{
		this.group.uniforms.scale.value = renderer.getCurrentViewport(this.temp).w;
		this.group.tick(this.clock.getDelta());

		if(this.dynamicEmitter === true)
		{
			this.emitter.position.value = this.position;	
		}
	};

	/**
	 * Dispose particle emitter.
	 *
	 * Should be called when destroying particle emitter.
	 * 
	 * @method dispose
	 */
	ParticleEmitter.prototype.dispose = function()
	{
		this.group.dispose();

		three.Object3D.prototype.dispose.call(this);
	};

	ParticleEmitter.prototype.toJSON = function(meta)
	{
		var material = this.material;
		var geometry = this.geometry;
		this.material = undefined;
		this.geometry = undefined;

		var texture = this.group.texture;
		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{	
			texture = texture.toJSON(meta);
		});

		this.material = material;
		this.geometry = geometry;

		// Group 
		data.object.group = this.group.toJSON(meta);
		
		// Emitter
		data.object.emitter = this.emitter.toJSON(meta);

		return data;
	};

	ParticleEmitter.fromJSON = function(data, resources)
	{
		function loadVector3(data)
		{
			return Array.isArray(data) ? new three.Vector3().fromArray(data) : new three.Vector3(data.x, data.y, data.z);
		}

		if(data.group !== undefined)
		{
			var group = data.group;
			group.texture.value = resources.getTexture(group.texture.value);
			group.texture.frames = new three.Vector2().fromArray(group.texture.frames || [1, 1]);
		}

		if(data.emitter !== undefined)
		{
			var emitter = data.emitter;
			emitter.position.value = loadVector3(emitter.position.value);
			emitter.position.spread = loadVector3(emitter.position.spread);
			emitter.velocity.value = loadVector3(emitter.velocity.value);
			emitter.velocity.spread = loadVector3(emitter.velocity.spread);
			emitter.acceleration.value = loadVector3(emitter.acceleration.value);
			emitter.acceleration.spread = loadVector3(emitter.acceleration.spread);
			
			for(var i = 0; i < emitter.color.value.length; i++)
			{
				emitter.color.value[i] = new three.Color(emitter.color.value[i]);
				emitter.color.spread[i] = loadVector3(emitter.color.spread[i]);
			}
		}

		return new ParticleEmitter(data.group, data.emitter);
	};

	/**
	 * Resource manager is used to manage available resources used by objects
	 * 
	 * The resource manager is used to extend Object3D elements and is not meant to be used as a standalone.
	 *
	 * For standalone resource management use the resource container.
	 * 
	 * @class ResourceManager
	 * @module Resources
	 * @extends {Object3D}
	 */
	function ResourceManager()
	{
		three.Object3D.call(this);
		ResourceContainer.call(this);
	}

	ResourceManager.prototype = Object.create(three.Object3D.prototype);
	Object.assign(ResourceManager.prototype, ResourceContainer.prototype);

	/**
	 * Dispose all the resources present in the resource manager.
	 *
	 * @method dispose
	 */
	ResourceManager.prototype.dispose = function()
	{
		for(var i = 0; i < ResourceContainer.libraries.length; i++)
		{
			var library = ResourceContainer.libraries[i];

			for(var a in this[library])
			{
				if(this[library][a].dispose instanceof Function)
				{
					this[library][a].dispose();
				}
			}
		}
	};

	/**
	 * Remove geometry from the list and replace by other.
	 * 
	 * @method removeGeometry
	 * @param {Resource} geometry
	 */
	ResourceManager.prototype.removeGeometry = function(geometry, defaultGeometry)
	{
		this.traverse(function(child)
		{
			if(child.geometry !== undefined && child.geometry.uuid === geometry.uuid)
			{
				child.geometry = defaultGeometry;
			}
		});

		delete this.geometries[geometry.uuid];
	};

	/**
	 * Get resource by name.
	 * 
	 * @method getResourceByName
	 * @param {string} name Resource name
	 * @return {Resource} Resource if found else null
	 */
	ResourceManager.prototype.getResourceByName = function(name)
	{
		for(var i in this.resources)
		{
			if(this.resources[i].name === name)
			{
				return this.resources[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Add resource to resources manager.
	 * 
	 * @method addResource
	 * @param {Resource} Resource to add.
	 */
	ResourceManager.prototype.addResource = function(resource)
	{
		if(resource instanceof Resource)
		{
			this.resources[resource.uuid] = resource;
		}
	};

	/**
	 * Remove resource from font list.
	 * 
	 * @method removeResource
	 * @param {Resource} resource
	 */
	ResourceManager.prototype.removeResource = function(resource)
	{
		delete this.resources[resource.uuid];
	};

	/**
	 * Get image by name.
	 * 
	 * @method getImageByName
	 * @param {string} name Image name
	 * @return {Image} Image if found else null
	 */
	ResourceManager.prototype.getImageByName = function(name)
	{
		for(var i in this.images)
		{
			if(this.images[i].name === name)
			{
				return this.images[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Remove image.
	 * 
	 * @param {Image} image
	 * @method removeImage
	 */
	ResourceManager.prototype.removeImage = function(image)
	{
		if(image instanceof Image)
		{
			delete this.images[image.uuid];
		}
	};


	/**
	 * Get video by name.
	 * 
	 * @method getVideoByName
	 * @param {string} name Video name
	 * @return {Video} Video if found else null
	 */
	ResourceManager.prototype.getVideoByName = function(name)
	{
		for(var i in this.videos)
		{
			if(this.videos[i].name === name)
			{
				return this.videos[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Remove video.
	 * 
	 * @param {Video} video
	 * @method removeVideo
	 */
	ResourceManager.prototype.removeVideo = function(video)
	{
		if(video instanceof Video)
		{
			delete this.videos[video.uuid];
		}
	};

	/**
	 * Get material by its name.
	 * 
	 * @method getMaterialByName
	 * @param {string} name Material name
	 * @return {Material} Material if found else null
	 */
	ResourceManager.prototype.getMaterialByName = function(name)
	{
		for(var i in this.materials)
		{
			if(this.materials[i].name === name)
			{
				return this.materials[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Add material to materials list.
	 * 
	 * @method addMaterial
	 * @param {Material} material Material to be added
	 */
	ResourceManager.prototype.addMaterial = function(material)
	{
		if(material instanceof three.Material)
		{
	 		this.materials[material.uuid] = material;
	 	}
	};

	/**
	 * Remove material from materials list, also receives default material used to replace.
	 * 
	 * @method removeMaterial
	 * @param {Material} material Material to be removed from manager.
	 * @param {Material} defaultMeshMaterial Default mesh material to replace objects mesh materials.
	 * @param {Material} defaultSpriteMaterial Defaul sprite material.
	 */
	ResourceManager.prototype.removeMaterial = function(material, defaultMeshMaterial, defaultSpriteMaterial)
	{
		if(defaultMeshMaterial === undefined)
		{
			defaultMeshMaterial = new three.MeshBasicMaterial();
		}

		if(defaultSpriteMaterial === undefined)
		{
			defaultSpriteMaterial = new three.SpriteMaterial();
		}

		if(material instanceof three.Material)
		{
			delete this.materials[material.uuid];
			
			this.traverse(function(child)
			{
				if(child.material !== undefined && child.material.uuid === material.uuid)
				{
					if(child instanceof three.Sprite)
					{
						child.material = defaultSpriteMaterial;
					}
					else
					{
						child.material = defaultMeshMaterial;
					}
				}
			});
		}
	};

	/**
	 * Get texture by name.
	 * 
	 * @method getTextureByName
	 * @param {string} name Texture name.
	 * @return {Texture} Texture is found else null.
	 */
	ResourceManager.prototype.getTextureByName = function(name)
	{
		for(var i in this.textures)
		{
			if(this.textures[i].name === name)
			{
				return this.textures[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Add texture to texture list.
	 * 
	 * @method addTexture
	 * @param {Texture} texture
	 */
	ResourceManager.prototype.addTexture = function(texture)
	{
		if(material instanceof three.Texture)
		{
	 		this.textures[texture.uuid] = texture;
		}
	};

	/**
	 * Remove texture from textures list (also receives default used to replace).
	 * 
	 * @method removeTexture
	 * @param {Texture} texture
	 * @param {Texture} defaultTexture
	 * @return {Texture} Texture if found, else null
	 */
	ResourceManager.prototype.removeTexture = function(texture, defaultTexture)
	{
		if(defaultTexture === undefined)
		{
			defaultTexture = new three.Texture();
		}

		if(texture instanceof three.Texture)
		{
			delete this.textures[texture.uuid];
			
			this.traverse(function(child)
			{
				if(child.material !== undefined)
				{
					var material = child.material;
					
					if(material.map != null && material.map.uuid === texture.uuid)
					{
						material.map = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.bumpMap != null && material.bumpMap.uuid === texture.uuid)
					{
						material.bumpMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.normalMap != null && material.normalMap.uuid === texture.uuid)
					{
						material.normalMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.displacementMap != null && material.displacementMap.uuid === texture.uuid)
					{
						material.displacementMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.specularMap != null && material.specularMap.uuid === texture.uuid)
					{
						material.specularMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.emissiveMap != null && material.emissiveMap.uuid === texture.uuid)
					{
						material.emissiveMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.alphaMap != null && material.alphaMap.uuid === texture.uuid)
					{
						material.alphaMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.roughnessMap != null && material.roughnessMap.uuid === texture.uuid)
					{
						material.roughnessMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.metalnessMap != null && material.metalnessMap.uuid === texture.uuid)
					{
						material.metalnessMap = defaultTexture;
						material.needsUpdate = true;
					}
					if(material.envMap != null && material.envMap.uuid === texture.uuid)
					{
						material.envMap = null;
						material.needsUpdate = true;
					}
				}
				else if(child instanceof ParticleEmitter)
				{
					if(child.group.texture.uuid === texture.uuid)
					{
						child.group.texture = defaultTexture;
					}
				}
			});
		}
	};

	/**
	 * Get font by name.
	 * 
	 * @method getFontByName
	 * @param {string} name
	 * @return {Font} Font if found, else null
	 */
	ResourceManager.prototype.getFontByName = function(name)
	{
		for(var i in this.fonts)
		{
			if(this.fonts[i].name === name)
			{
				return this.fonts[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Add font to fonts list.
	 * 
	 * @method addFont
	 * @param {Font} font
	 */
	ResourceManager.prototype.addFont = function(font)
	{
		if(font instanceof Font)
		{
	 		this.fonts[font.uuid] = font;
	 	}
	};

	/**
	 * Remove font from font list.
	 * 
	 * @method removeFont
	 * @param {Font} font
	 * @param {Font} defaultFont
	 */
	ResourceManager.prototype.removeFont = function(font, defaultFont)
	{
		if(defaultFont === undefined)
		{
			defaultFont = new Font();
		}

		if(font instanceof Font)
		{
			delete this.fonts[font.uuid];
			
			this.traverse(function(child)
			{
				if(child.font !== undefined && child.font.uuid === font.uuid)
				{
					child.setFont(defaultFont);
				}
			});
		}
	};

	/**
	 * Get audio by name.
	 * 
	 * @method getAudioByName
	 * @param {string} name
	 * @return {Audio} Audio if found, else null
	 */
	ResourceManager.prototype.getAudioByName = function(name)
	{
		for(var i in this.audio)
		{
			if(this.audio[i].name === name)
			{
				return this.audio[i];
			}
		}

		console.warn("nunuStudio: Resource " + name + " not found");
		return null;
	};

	/**
	 * Add audio to audio list.
	 * 
	 * @param {Audio} audio
	 * @method addAudio
	 */
	ResourceManager.prototype.addAudio = function(audio)
	{
		if(audio instanceof Audio)
		{
	 		this.audio[audio.uuid] = audio;
	 	}
	};

	/**
	 * Remove audio resource from the manager, replace on objects that are using it with another resource.
	 * 
	 * @param {Audio} audio
	 * @param {Audio} defaultAudio
	 * @method removeAudio
	 */
	ResourceManager.prototype.removeAudio = function(audio, defaultAudio)
	{
		if(defaultAudio === undefined)
		{
			defaultAudio = new Audio();
		}

		if(audio instanceof Audio)
		{
			delete this.audio[audio.uuid];
			
			this.traverse(function(child)
			{
				if(child.audio !== undefined && child.audio.uuid === audio.uuid)
				{
					child.setAudio(defaultAudio);
				}
			});
		}
	};

	/** 
	 * Renderer configuration stores all the WebGL renderer related parameters.
	 *
	 * @constructor
	 * @class RendererConfiguration
	 * @param {Object} options Options object with the values to be used in the rendere configuration, values not specified are set to default.
	 */
	function RendererConfiguration(options)
	{
		/**
		 * Canvas background color, optional only used if specified.
		 *
		 * Different from the clear color used to clear the render target.
		 *
		 * @property backgroundColor
		 * @type {string}
		 */
		this.backgroundColor = null;

		/**
		 * Prefered redering backend API to use if available.
		 *
		 * If the selected backend is not available it defaults to WebGL.
		 *
		 * Shader code might not be cross compatible between rendering backends.
		 *
		 * @property backend
		 * @type {number}
		 */
		this.backend = RendererConfiguration.WEBGL2;

		/** 
		 * Defines whether the renderer should automatically clear its output before rendering a frame.
		 *
		 * @property autoClear
		 * @type {boolean}
		 */
		this.autoClear = false;

		/** 
		 * Defines whether the renderer should clear the color buffer.
		 *
		 * @property autoClearColor
		 * @type {boolean}
		 */
		this.autoClearColor = false;

		/** 
		 * Defines whether the renderer should clear the depth buffer.
		 *
		 * @property autoClearDepth
		 * @type {boolean}
		 */
		this.autoClearDepth = false;
		
		/** 
		 * Defines whether the renderer should clear the stencil buffer.
		 *
		 * @property autoClearStencil
		 * @type {boolean}
		 */
		this.autoClearStencil = false;

		/**
		 * Antialiasing flag.
		 *
		 * @property antialiasing
		 * @type {boolean}
		 * @default false
		 */
		this.antialiasing = true;

		/**
		 * If true the program is rendered with shadows.
		 *
		 * @property shadows
		 * @type {boolean}
		 * @default true
		 */
		this.shadows = true;

		/** 
		 * Whether the drawing buffer has a stencil buffer of at least 8 bits.
		 *
		 * @property @stencil
		 * @type {boolean}
		 */
		this.stencil = true;

		/**
		 * Shadow map filtering type.
		 *
		 * @property shadowsType
		 * @type {number}
		 * @default PCFSoftShadowMap
		 */
		this.shadowsType = three.PCFSoftShadowMap;

		/** 
		 * Enables automatic updates to the shadows in the scene.
		 *
		 * If you do not require dynamic lighting / shadows, you may set this to false.
		 *
		 * Use renderer.shadowMap.needsUpdate to update the shadow map.
		 *
		 * @property shadowsAutoUpdate
		 * @type {boolean}
		 */
		this.shadowsAutoUpdate = true;

		/**
		 * Tonemapping can be used to remap the color of the image to a diferent set giving the scene a different color mood and/or dynamic color based on global luminosity.
		 *
		 * @property toneMapping
		 * @type {number}
		 * @default NoToneMapping
		 */
		this.toneMapping = three.NoToneMapping;

		/**
		 * Exposure level of tone mapping.
		 *
		 * @property toneMappingExposure
		 * @type {number}
		 */
		this.toneMappingExposure = 1.0;

		/**
		 * Tone mapping white point.
		 *
		 * @property toneMappingWhitePoint
		 * @type {number}
		 */
		this.toneMappingWhitePoint = 1.0;

		/** 
		 * If true the renderer sorts the objects from back to front for rendering.
		 *
		 * Important if using multiple transparent objects.
		 *
		 * @property sortObjects
		 * @type {boolean}
		 */
		this.sortObjects = true;

		/**
		 * Gamma factor applied to the image.
		 *
		 * @property gammaFactor
		 * @type {number}
		 */
		this.gammaFactor = 2.0;

		/**
		 * Shader precision. Can be "highp", "mediump" or "lowp". Defaults to "highp" if supported by the device.
		 *
		 * @property precision
		 * @type {string}
		 */
		this.precision = "highp";

		/**
		 * Whether the canvas contains an alpha (transparency) buffer or not.
		 *
		 * @property alpha
		 * @type {boolean}
		 */
		this.alpha = false;

		/**
		 * Whether the renderer will assume that colors have premultiplied alpha.
		 *
		 * @property premultipliedAlpha
		 * @type {boolean}
		 */
		this.premultipliedAlpha = true;

		/** 
		 * Whether to preserve the buffers until manually cleared or overwritten.
		 *
		 * @property preserveDrawingBuffer
		 * @type {boolean}
		 */
		this.preserveDrawingBuffer = false;

		/**
		 * Provides a hint to the user agent indicating what configuration of GPU is suitable for this WebGL context. Can be "high-performance", "low-power" or "default".
		 *
		 * @property powerPreference
		 * @type {string}
		 */
		this.powerPreference = "high-performance";

		/**
		 * Whether to use a logarithmic depth buffer. It may be neccesary to use this if dealing with huge differences in scale in a single scene.
		 *
		 * @property logarithmicDepthBuffer
		 * @type {boolean}
		 */
		this.logarithmicDepthBuffer = false;

		/**
		 * Whether to use physically correct lighting mode.
		 *
		 * @property physicallyCorrectLights
		 * @type {boolean}
		 */
		this.physicallyCorrectLights = false;

		/**
		 * Defines whether material shader programs are checked for errors during compilation and linkage process.
		 *
		 * @property checkShaderErrors
	 	 * @type {boolean}
		 */
		this.checkShaderErrors = true;
		
		/**
		 * The maximum number of MorphTargets allowed in a shader.
		 *
		 * @property maxMorphTargets
		 * @type {number}
		 */
		this.maxMorphTargets = 8;

		/**
		 * The maximum number of MorphNormals allowed in a shader.
		 *
		 * @property maxMorphNormals
		 * @type {number}
		 */
		this.maxMorphNormals = 4;

		// Copy values received from the options parameter
		if(options !== undefined)
		{	
			for(var i in this)
			{
				if(options[i] !== undefined)
				{
					this[i] = options[i];
				}
			}
		}
	}

	/** 
	 * Use WebGL 1.0 to render data.
	 *
	 * Most devices fully support WebGL 1.0 at this point, should work for any type of device.
	 *
	 * @static
	 * @attribute WEBGL
	 * @type {number}
	 */
	RendererConfiguration.WEBGL = 1;

	/** 
	 * Use WebGL 2.0 to render data, should be faster for some types of data.
	 *
	 * Additinal features of GLSL can be used in WebGL 2.0. Most mobile device still dont support WebGL 2.0.
	 *
	 * @static
	 * @attribute WEBGL2
	 * @type {number}
	 */
	RendererConfiguration.WEBGL2 = 2;

	/**
	 * Create a THREE renderer object based on the renderer configuration.
	 *
	 * @method createRenderer
	 * @return {WebGLRenderer} Renderer created from the configuration.
	 */
	RendererConfiguration.prototype.createRenderer = function(canvas)
	{
		var context = null;

		if(this.backend === RendererConfiguration.WEBGL2)
		{
			try
			{
				context = canvas.getContext("webgl2");
			}
			catch(e){}
		}

		var renderer = new three.WebGLRenderer(
		{
			canvas: canvas,
			context: context,
			precision: this.precision,
			alpha: this.alpha,
			premultipliedAlpha: this.premultipliedAlpha,
			antialias: this.antialiasing,
			stencil: this.stencil,
			preserveDrawingBuffer: this.preserveDrawingBuffer,
			powerPreference: this.powerPreference,
			logarithmicDepthBuffer: this.logarithmicDepthBuffer
		});

		this.apply(renderer);

		if(this.backgroundColor !== null)
		{
			canvas.style.backgroundColor = this.backgroundColor;
		}



		return renderer;
	};

	RendererConfiguration.prototype.apply = function(renderer)
	{
		renderer.autoClear = this.autoClear;
		renderer.autoClearColor = this.autoClearColor;
		renderer.autoClearDepth = this.autoClearDepth;
		renderer.autoClearStencil = this.autoClearStencil;

		renderer.shadowMap.enabled = this.shadows;
		renderer.shadowMap.type = this.shadowsType;
		renderer.shadowMap.autoUpdate = this.shadowsAutoUpdate;
		renderer.shadowMap.needsUpdate = true;

		renderer.toneMapping = this.toneMapping;
		renderer.toneMappingExposure = this.toneMappingExposure;
		renderer.toneMappingWhitePoint = this.toneMappingWhitePoint;

		renderer.debug.checkShaderErrors = this.checkShaderErrors;
		renderer.sortObjects = this.sortObjects;

		renderer.gammaFactor = this.gammaFactor;
		renderer.physicallyCorrectLights = this.physicallyCorrectLights;

		renderer.maxMorphTargets = this.maxMorphTargets;
		renderer.maxMorphNormals = this.maxMorphNormals;
	};

	RendererConfiguration.prototype.toJSON = function()
	{
		return {
			backgroundColor: this.backgroundColor,
			backend: this.backend,
			autoClear: this.autoClear,
			autoClearColor: this.autoClearColor,
			autoClearDepth: this.autoClearDepth,
			autoClearStencil: this.autoClearStencil,
			antialiasing: this.antialiasing,
			shadows: this.shadows,
			stencil: this.stencil,
			shadowsType: this.shadowsType,
			shadowsAutoUpdate: this.shadowsAutoUpdate,
			toneMapping: this.toneMapping,
			toneMappingExposure: this.toneMappingExposure,
			toneMappingWhitePoint: this.toneMappingWhitePoint,
			sortObjects: this.sortObjects,
			checkShaderErrors: this.checkShaderErrors,
			gammaFactor: this.gammaFactor,
			precision: this.precision,
			alpha: this.alpha,
			premultipliedAlpha: this.premultipliedAlpha,
			preserveDrawingBuffer: this.preserveDrawingBuffer,
			powerPreference: this.powerPreference,
			logarithmicDepthBuffer: this.logarithmicDepthBuffer,
			physicallyCorrectLights: this.physicallyCorrectLights,
			maxMorphTargets: this.maxMorphTargets,
			maxMorphNormals: this.maxMorphNormals
		};
	};

	RendererConfiguration.prototype.fromJSON = function(data)
	{
		this.backgroundColor = data.backgroundColor;
		this.backend = data.backend;
		this.autoClear = data.autoClear;
		this.autoClearColor = data.autoClearColor;
		this.autoClearDepth = data.autoClearDepth;
		this.autoClearStencil = data.autoClearStencil;
		this.antialiasing = data.antialiasing;
		this.shadows = data.shadows;
		this.stencil = data.stencil;
		this.shadowsType = data.shadowsType;
		this.shadowsAutoUpdate = data.shadowsAutoUpdate;
		this.toneMapping = data.toneMapping;
		this.toneMappingExposure = data.toneMappingExposure;
		this.toneMappingWhitePoint = data.toneMappingWhitePoint;
		this.sortObjects = data.sortObjects;
		this.checkShaderErrors = data.checkShaderErrors;
		this.gammaFactor = data.gammaFactor;
		this.precision = data.precision;
		this.alpha = data.alpha;
		this.premultipliedAlpha = data.premultipliedAlpha;
		this.preserveDrawingBuffer = data.preserveDrawingBuffer;
		this.powerPreference = data.powerPreference;
		this.logarithmicDepthBuffer = data.logarithmicDepthBuffer;
		this.physicallyCorrectLights = data.physicallyCorrectLights;
		this.maxMorphTargets = data.maxMorphTargets;
		this.maxMorphNormals = data.maxMorphNormals;
	};

	/**
	 * Target configuration stores platform specific configurations used when exporting the application to a platform.
	 *
	 * @class TargetConfig
	 */
	function TargetConfig()
	{
		/**
		 * Desktop related export properties.
		 *
		 * @attribute desktop
		 * @type {Object}
		 */
		this.desktop =
		{
			fullscreen: false,
			frame: true,
			resizable: true
		};
	}

	/**
	 * Utils to maanipulate DOM elements. 
	 *
	 * @class DOMUtils
	 */
	function DOMUtils(){}

	/**
	 * Get CSS variable value from the DOM tree.
	 *
	 * The value is obtained from the document body.
	 *
	 * @method getCSSVariable
	 * @param {string} variable Variable name to retrieve.
	 * @return {string} Calculated value associated with the CSS variable.
	 */
	DOMUtils.getCSSVariable = function(variable)
	{
		return getComputedStyle(document.body).getPropertyValue(variable);
	};

	/**
	 * Check if a DOM element in completely visible in the viewport
	 *
	 * @method isVisible
	 * @param {Element} element DOM element to test.
	 * @return {boolean} True if the element is inside of the browser viewport.
	 */
	DOMUtils.isVisible = function(element)
	{
		if(element.isElement === true)
		{
			element = element.element;
		}

		var top = element.offsetTop;
		var left = element.offsetLeft;
		var width = element.offsetWidth;
		var height = element.offsetHeight;

		while(element.offsetParent)
		{
			element = element.offsetParent;
			top += element.offsetTop;
			left += element.offsetLeft;
		}

		return value = top >= window.pageYOffset && left >= window.pageXOffset && (top + height) <= (window.pageYOffset + window.innerHeight) && (left + width) <= (window.pageXOffset + window.innerWidth);
	};

	/**
	 * Get position of the dom element in the client window.
	 *
	 * This method considers the window scrolling position.
	 *
	 * @method getPosition
	 * @param {Element} element DOM element to test.
	 */
	DOMUtils.getPosition = function(element)
	{
		if(element.isElement === true)
		{
			element = element.element;
		}
		
		var rect = element.getBoundingClientRect();

		return {x: rect.left + window.scrollX, y: rect.top + window.scrollY};
	};

	/**
	 * Check if a DOM element is out of the window and how far it is, returns object with x and y values.
	 * 
	 * If the value is 0 the element is inside the window on that axis.
	 *
	 * @method checkBorder
	 * @param {Element} element DOM element to test.
	 * @return {Vector2} Distance outside of the viewport.
	 */
	DOMUtils.checkBorder = function(element)
	{
		if(element.isElement === true)
		{
			element = element.element;
		}

		var top = element.offsetTop;
		var left = element.offsetLeft;
		var width = element.offsetWidth;
		var height = element.offsetHeight;

		while(element.offsetParent)
		{
			element = element.offsetParent;
			top += element.offsetTop;
			left += element.offsetLeft;
		}

		var result = {x: 0, y: 0};

		// Over the top of the window
		if(top < window.pageYOffset)
		{
			result.y = top - window.pageYOffset;
		}
		// Bellow the window
		else if((top + height) > (window.pageYOffset + window.innerHeight))
		{
			result.y = (top + height) - (window.pageYOffset + window.innerHeight);
		}

		// Left to the window
		if(left < window.pageXOffset)
		{
			result.x = left - window.pageXOffset;
		}
		// Right to the window
		else if((left + width) > (window.pageXOffset + window.innerWidth))
		{
			result.x = (left + width) - (window.pageXOffset + window.innerWidth);
		}

		return result;
	};

	/**
	 * Text element without background.
	 * 
	 * @class Text
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function Text(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.pointerEvents = "none";
		this.element.style.display = "flex";

		/** 
		 * Span DOM element used to represent the text.
		 *
		 * @attribute span
		 * @type {Element}
	 	 */
		this.span = document.createElement("span");
		this.span.style.overflow = "hidden";
		this.element.appendChild(this.span);

		/**
		 * Text DOM node where the text is stored.
		 *
		 * @attribute text
		 * @type {Element}
		 */
		this.text = document.createTextNode("");
		this.span.appendChild(this.text);

		/**
		 * If set to true the text container will automatically fit the text size.
		 *
		 * @attribute fitContent
		 * @type {boolean}
		 */
		this.fitContent = false;

		this.allowWordBreak(false);
		this.setVerticalAlignment(Text.CENTER);
		this.setAlignment(Text.CENTER);
	}

	Text.CENTER = 0;
	Text.LEFT = 1;
	Text.RIGHT = 2;
	Text.TOP = 3;
	Text.BOTTOM = 4;

	Text.CLIP = 10;
	Text.ELLIPSIS = 11;

	Text.prototype = Object.create(Component.prototype);

	/**
	 * Set font to use for the text.
	 * 
	 * @method setFont
	 * @param {string} fontFamily Font family.
	 * @param {number} fontWeight Font weigth, sets how thick or thin characters in text should be displayed.
	 * @param {string} fontStyle Font style, specifies the font style for a text.
	 */
	Text.prototype.setFont = function(fontFamily, fontWeight, fontStyle)
	{
		this.span.style.fontFamily = fontFamily;

		if(fontWeight !== undefined)
		{
			this.span.style.fontWeight = fontWeight;
		}

		if(fontStyle !== undefined)
		{
			this.span.style.fontStyle = fontStyle;
		}
	};

	/**
	 * Enable of disable word breaking.
	 *
	 * @method allowWordBreak
	 * @param {boolean} line If true words can be breaked.
	 */
	Text.prototype.allowWordBreak = function(value)
	{
		if(value === true)
		{
			this.span.style.whiteSpace = "normal";
			this.span.style.wordBreak = "break-word";
		}
		else
		{
			this.span.style.whiteSpace = "pre";
			this.span.style.wordBreak = "normal";
		}
	};

	/**
	 * Set text displayed in the component.
	 *
	 * @method setText
	 * @param {string} text Text. 
	 */
	Text.prototype.setText = function(text)
	{
		this.text.data = text;
	};

	/**
	 * Set text border size in px. The border is set as a solid centered shadow with a defined color.
	 *
	 * @method setTextBorder
	 * @param {number} size Border size in pixels.
	 * @param {string} color CSS Color. 
	 */
	Text.prototype.setTextBorder = function(size, color)
	{
		this.span.style.textShadow = "-" + size + "px 0 " + color + ", 0 " + size + "px " + color + ", " + size + "px 0 " + color + ", 0 -" + size + "px " + color;
	};

	/**
	 * Set Text size, in pixels.
	 * 
	 * @method setTextSize
	 * @param {number} size Size in pixel for this text element.
	 */
	Text.prototype.setTextSize = function(size)
	{
		this.element.style.fontSize = size + "px";
	};

	/**
	 * Set text color.
	 * 
	 * @method setTextColor
	 * @param {string} color Color code.
	 */
	Text.prototype.setTextColor = function(color)
	{
		this.span.style.color = color;
	};

	/**
	 * Set text overflow handling
	 *
	 * @method setOverflow
	 * @param {number} overflow
	 */
	Text.prototype.setOverflow = function(overflow)
	{
		if(overflow === Text.ELLIPSIS)
		{
			this.span.style.whiteSpace = "nowrap";
			this.span.style.textOverflow = "ellipsis";
		}
		else
		{
			this.span.style.whiteSpace = "pre";
			this.span.style.textOverflow = "clip";
		}
	};

	/**
	 * Set text horizontal alignment.
	 *  - Text.CENTER
	 *  - Text.LEFT
	 *  - Text.RIGHT
	 * 
	 * @method setAlignment
	 * @param {number} align Alingment mode.
	 */
	Text.prototype.setAlignment = function(align)
	{
		if(align === Text.CENTER)
		{
			this.element.style.justifyContent = "center";
			this.element.style.textAlign = "center";
		}
		else if(align === Text.LEFT)
		{
			this.element.style.justifyContent = "flex-start";
			this.element.style.textAlign = "left";
		}
		else if(align === Text.RIGHT)
		{
			this.element.style.justifyContent = "flex-end";
			this.element.style.textAlign = "right";
		}
	};

	/**
	 * Set text vertical alignment.
	 *  - Text.CENTER
	 *  - Text.TOP
	 *  - Text.BOTTOM
	 * 
	 * @method setVerticalAlignment
	 * @param {number} align Alingment mode.
	 */
	Text.prototype.setVerticalAlignment = function(align)
	{
		if(align === Text.CENTER)
		{
			this.element.style.alignItems = "center";
		}
		else if(align === Text.TOP)
		{
	 		this.element.style.alignItems = "flex-start";
		}
		else if(align === Text.BOTTOM)
		{
			this.element.style.alignItems = "flex-end";
		}
	};

	/**
	 * Get size of the text inside of this component in px.
	 * 
	 * @method measure
	 * @return {Vector2} A vector with the size of the text. 
	 */
	Text.prototype.measure = function()
	{
	 	return new three.Vector2(this.span.offsetWidth, this.span.offsetHeight);
	};

	/**
	 * Set text internal margin in pixels.
	 * 
	 * @method setMargin
	 * @param {number} margin Margin size in pixels.
	 */
	Text.prototype.setMargin = function(margin)
	{
		this.span.style.margin = margin + "px";
	};

	Text.prototype.updateVisibility = function()
	{
		this.element.style.visibility = this.visible ? "visible" : "hidden";
	};

	Text.prototype.updateSize = function()
	{
		if(this.fitContent)
		{
			this.size.x = this.span.clientWidth;
			this.size.y = this.span.clientHeight;
		}
		
		Component.prototype.updateSize.call(this);
	};

	/**
	 * Graph element is used to draw interactive line graphs.
	 *
	 * It is meant to be used as input in forms to controls values in arrays.
	 *
	 * Multiple sub graphs can be displayed, each graph has a name that can be used to access its properties.
	 * 
	 * @class Graph
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 * @param {string} name Name of the default graph.
	 * @param {string} color CSS hex color code of the default graph.
	 */
	function Graph(parent, name, color)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";

		/**
		 * Scale margin in pixels.
		 *
		 * @property scaleMargin
		 * @type {number}
		 */
		this.scaleMargin = 22;

		/**
		 * Value button size.
		 *
		 * @property buttonRadius
		 * @type {number}
		 */
		this.buttonRadius = 10;

		/**
		 * Maximum value displayed vertically.
		 *
		 * @property max
		 * @type {number}
		 */
		this.max = 1.0;

		/**
		 * Minimum value displayed vertically.
		 *
		 * @property min
		 * @type {number}
		 */
		this.min = 0.0;

		/**
		 * Grid drawing canvas element.
		 *
		 * @property grid
		 * @type {Element}
		 */
		this.grid = document.createElement("canvas");
		this.grid.style.position = "absolute";
		this.grid.style.marginLeft = this.scaleMargin + "px";
		this.element.appendChild(this.grid);

		/**
		 * The graph lines stored in this graph.
		 *
		 * @property graph
		 * @type {Array}
		 */
		this.graph = [];
		this.addGraph(name, color);
		
		/**
		 * Scale DOM elements.
		 *
		 * @property scale
		 * @type {Array}
		 */
		this.scale = [];
		this.createScale(3);
	}

	Graph.prototype = Object.create(Component.prototype);

	/**
	 * Graph lines represents a subgraph in the graph GUI object.
	 *
	 * @constructor
	 * @class SubGraph
	 * @param {Element} canvas Drawing canvas.
	 * @param {string} name Name of the graph used to acces its data.
	 * @param {string} color Color of this subgraph.
	 */
	function SubGraph(canvas, name, color)
	{
		if(canvas === undefined)
		{
			canvas = document.createElement("canvas");
			canvas.style.position = "absolute";
		}

		this.canvas = canvas;
		this.name = (name !== undefined) ? name : "default";
		this.color = (color !== undefined) ? color : DOMUtils.getCSSVariable("--color-light");
		this.values = [];
		this.buttons = [];
		this.onchange = null;
	}
	/**
	 * Create numeric scale for this graph.
	 *
	 * @method createScale
	 * @param {number} size Number of values in the scale.
	 */
	Graph.prototype.createScale = function(size)
	{
		for(var i = 0; i < this.scale; i++)
		{
			this.element.removeChild(this.scale[i]);
		}
		
		var step = (this.max - this.min) / (size - 1);

		for(var i = 0; i < size; i++)
		{
			var scale = document.createElement("div");
			scale.style.position = "absolute";
			scale.style.pointerEvents = "none";
			scale.style.color = DOMUtils.getCSSVariable("--color-light");

			var text = document.createTextNode(this.max - (step * i));
			scale.text = text;
			scale.appendChild(text);

			this.scale.push(scale);
			this.element.appendChild(scale);
		}
	};

	/**
	 * Update values of the scale.
	 *
	 * @method updateScale
	 */
	Graph.prototype.updateScale = function()
	{
		var step = (this.max - this.min) / (this.scale.length - 1);

		for(var i = 0; i < this.scale.length; i++)
		{
			this.scale[(this.scale.length - 1) - i].text.data = this.min + (step * i);
		}
	};

	/**
	 * Add new graph line.
	 *
	 * @method addGraph
	 * @param {string} name Name of the graph.
	 * @param {Color} color Color of the graph.
	 */
	Graph.prototype.addGraph = function(name, color)
	{
		var canvas = document.createElement("canvas");
		canvas.style.position = "absolute";
		canvas.style.marginLeft = this.scaleMargin + "px";
		this.element.appendChild(canvas);

		this.graph.push(new SubGraph(canvas, name, color));
	};

	/** 
	 * Attach onchange callback to a graph by its name.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 * @param {string} name Graph name.
	 */
	Graph.prototype.setOnChange = function(onChange, name)
	{
		var graph = this.getGraph(name);
		graph.onchange = onChange;
	};

	/**
	 * Set value range of the graph.
	 *
	 * @method setRange.
	 * @param {number} min
	 * @param {number} max
	 */
	Graph.prototype.setRange = function(min, max)
	{
		this.min = min;
		this.max = max;

		// Limit graphs values
		for(var i in this.graph)
		{
			var graph = this.graph[i];

			for(var j = 0; j < graph.values.length; j++)
			{
				if(graph.values[j] < min)
				{
					graph.values[j] = min;

					if(graph.onchange !== null)
					{
						graph.onchange(graph.values);
					}
				}
				else if(graph.values[j] > max)
				{
					graph.values[j] = max;

					if(graph.onchange !== null)
					{
						graph.onchange(graph.values);
					}
				}
			}
		}

		this.updateScale();

		// Update grid to fit new scale
		for(var i = 0; i < this.graph.length; i++)
		{
			this.updateGraph(this.graph[i]);
		}
	};

	/**
	 * Set values array to a graph using its name.
	 *
	 * @method setValue
	 * @param {Array} values Array of numeric values.
	 * @param {string} name Name of the graph line.
	 */
	Graph.prototype.setValue = function(values, name)
	{	
		var self = this;
		var graph = this.getGraph(name);

		// Set values
		graph.values = values;

		// Add buttons if necessary
		while(graph.buttons.length < graph.values.length)
		{
			var button = document.createElement("div");
			button.style.borderRadius = "5px";
			button.style.backgroundColor = graph.color;
			button.style.cursor = "pointer";
			button.style.position = "absolute";
			button.style.marginTop = "-" + (this.buttonRadius / 2) + "px";
			button.style.marginLeft = (this.scaleMargin - (this.buttonRadius / 2)) + "px";
			button.style.width = this.buttonRadius + "px";
			button.style.height = this.buttonRadius + "px";
			button.index = graph.buttons.length;
			button.graph = graph;

			button.onmousedown = function(event)
			{
				var index = this.index;
				var graph = this.graph;
				var manager = new EventManager();

				manager.add(window, "mousemove", function(event)
				{
					var delta = event.movementY;

					graph.values[index] -= (delta * ((self.max - self.min) / self.size.y));

					if(graph.values[index] > self.max)
					{
						graph.values[index] = self.max;
					}
					else if(graph.values[index] < self.min)
					{
						graph.values[index] = self.min;
					}

					if(graph.onchange !== null)
					{
						graph.onchange(graph.values);
					}
					self.updateGraph(graph);
				});

				manager.add(window, "mouseup", function(event)
				{	
					manager.destroy();
				});
				manager.create();

				event.stopPropagation();
			};

			this.element.appendChild(button);
			graph.buttons.push(button);
		}

		// Remove buttons if necessary
		while(graph.buttons.length > graph.values.length)
		{
			this.element.removeChild(graph.buttons.pop());
		}

		// Check if new values are in range
		var update = false;
		for(var i = 0; i < values.length; i++)
		{
			if(values[i] < this.min)
			{
				this.min = Math.ceil(values[i]);
				update = true;
				break;
			}
			else if(values[i] > this.max)
			{
				this.max = Math.ceil(values[i] + 1.0);
				update = true;
				break;
			}
		}

		// If some value not in range update range
		if(update)
		{
			this.setRange(this.min, this.max);
		}

		// Update graph
		this.updateGraph(graph);
	};

	/**
	 * Return value array of a graph by its name.
	 *
	 * @method getValue
	 * @param {string} name Graph name.
	 */
	Graph.prototype.getValue = function(name)
	{
		var graph = this.getGraph(name);

		if(graph !== null)
		{
			return graph.values;
		}

		return null;
	};

	/**
	 * Get graph object by name.
	 *
	 * @method getGraph
	 * @param {string} name Graph name.
	 */
	Graph.prototype.getGraph = function(name)
	{
		if(name !== undefined)
		{
			for(var i = 0; i < this.graph.length; i++)
			{
				if(this.graph[i].name === name)
				{
					return this.graph[i];
				}
			}
		}

		if(this.graph.length > 0)
		{
			return this.graph[0];
		}

		return null;
	};

	/**
	 * Update graph canvas and buttons.
	 *
	 * @method updateGraph
	 * @param {Object} graph Graph object.
	 */
	Graph.prototype.updateGraph = function(graph)
	{
		var width = this.size.x - this.scaleMargin;

		// Get canvas context
		var context = graph.canvas.getContext("2d");
		context.clearRect(0, 0, width, this.size.y);
		context.strokeStyle = graph.color;
		context.lineWidth = "2";

		// Draw graph and set button positions
		var step = width / (graph.values.length - 1);
		var delta = this.max - this.min;

		context.moveTo(0, graph.values[0] * this.size.y);
		context.beginPath();

		for(var i = 0; i < graph.values.length; i++)
		{
			var x = i * step;
			var y = (1 - ((graph.values[i] - this.min) / delta)) * this.size.y;

			context.lineTo(x, y);

			var button = graph.buttons[i];
			button.style.left = x + "px";
			button.style.top = y + "px";
		}

		context.stroke();
	};

	/**
	 * Draw background grid canvas.
	 *
	 * @method updateGrid
	 */
	Graph.prototype.updateGrid = function()
	{
		var width = this.size.x - this.scaleMargin;

		var context = this.grid.getContext("2d");
		context.clearRect(0, 0, width, this.size.y);
		context.strokeStyle = DOMUtils.getCSSVariable("--bar-color");
		context.lineWidth = "1";

		// Border
		context.beginPath();
		context.rect(0, 0, width - 1, this.size.y);
		context.stroke();
		context.moveTo(0, 0);

		var step = width / 10;
		if(step <= 0)
		{
			return;
		}

		// Vertical lines	
		for(var i = 0; i < width - 1; i += step)
		{
			context.beginPath();
			context.moveTo(i, 0);
			context.lineTo(i, this.size.y);
			context.stroke();
		}

		// Horizontal lines
		for(var i = 0; i < this.size.y; i += step)
		{
			context.beginPath();
			context.moveTo(0, i);
			context.lineTo(width, i);
			context.stroke();
		}
	};

	Graph.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		var width = this.size.x - this.scaleMargin;

		// Grid
		this.grid.width = width;
		this.grid.height = this.size.y;
		this.grid.style.width = width + "px";
		this.grid.style.height = this.size.y + "px";
		this.updateGrid();

		// Graph
		for(var i = 0; i < this.graph.length; i++)
		{
			var graph = this.graph[i];
			graph.canvas.width = width;
			graph.canvas.height = this.size.y;
			graph.canvas.style.width = width + "px";
			graph.canvas.style.height = this.size.y + "px";
			this.updateGraph(graph);
		}

		// Scale
		var step = (this.size.y - 14) / (this.scale.length - 1);
		for(var i = 0; i < this.scale.length; i++)
		{
			this.scale[i].style.top = (i * step) + "px";
		}
	};

	/**
	 * DOM canvas element.
	 * 
	 * @class Canvas
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function Canvas(parent)
	{
		Component.call(this, parent, "canvas");

		this.preventDragEvents();
	}

	Canvas.prototype = Object.create(Component.prototype);

	/**
	 * Get a context from this canvas.
	 * 
	 * @method getContext
	 * @param {string} type Type of context to get "2d", "webgl", etc
	 * @return {Object} Context obtained from the canvas.
	 */
	Canvas.prototype.getContext = function(type)
	{
		return this.element.getContext(type);
	};

	Canvas.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		var pixelRatio = Editor$1.getPixelRatio();
		
		this.element.width = this.size.x * pixelRatio;
		this.element.height = this.size.y * pixelRatio;
	};

	/**
	 * Program class contains all the data of a nunuStudio program.
	 * 
	 * Is stores and manages all available resources used by the children objects.
	 *
	 * Is responsible for handling runtime tasks, initialization, update, resizes etc.
	 * 
	 * @class Program
	 * @module Core
	 * @param {string} name Program name
	 * @extends {ResourceManager}
	 */
	function Program(name)
	{
		ResourceManager.call(this);

		this.type = "Program";

		this.matrixAutoUpdate = false;

		/**
		 * NunuRuntime instance used to communication between nunu app and the host webpage.
		 *
		 * Inside the editor communication with the app is simulated on the debug console.
		 *
		 * @property app
		 * @type {NunuApp}
		 */
		this.app = null;

		/**
		 * Program name.
		 *
		 * @property name
		 * @type {string}
		 */
		this.name = (name !== undefined) ? name : "program";

		/**
		 * Program description, will be stamped when the app is exported.
		 *
		 * @property description
		 * @type {string}
		 */
		this.description = "";

		/**
		 * Program author, will be stamped when the app is exported.
		 *
		 * @property author
		 * @type {string}
		 */
		this.author = "";

		/**
		 * Program version should adhere to semantic versioning, but it is not mandatory.
		 *
		 * @property version
		 * @type {string}
		 * @default "0.0.0"
		 */
		this.version = "0.0.0";

		/**
		 * Flag to control pointer locking, when set true the cursor is locked into the application window.
		 *
		 * @property lockPointer
		 * @type {boolean}
		 * @default false
		 */
		this.lockPointer = false;

		/**
		 * Flag to indicate if the runtime should handle device pixel ratio.
		 *
		 * If set false the runtime will ignore the pixel ratio, and use in browser coordinates.
		 *
		 * @property handlePixelRatio
		 * @type {boolean}
		 * @default false
		 */
		this.handlePixelRatio = false;

		/**
		 * Enable virtual reality flag, allows the application to run in VR mode.
		 *
		 * VR mode can only be enabled if the system and browser have support for VR.
		 *
		 * @property vr
		 * @default false
		 * @type {boolean}
		 */
		this.vr = false;

		/**
		 * Virtual reality movement scale.
		 * 
		 * Indicates the relation between the real movement and virtual world movement.
		 *
		 * @property vrScale
		 * @type {number}
		 * @default 1.0
		 */
		this.vrScale = 1.0;

		/** 
		 * Renderer configuration applied to the WebGL renderer.
		 *
		 * @property rendererConfig
		 * @type {RendererConfiguration}
		 */
		this.rendererConfig = new RendererConfiguration();

		/**
		 * Target related configurations applied when exporting the app.
		 *
		 * @property targetConfig
		 * @type {TargetConfig}
		 */
		this.targetConfig = new TargetConfig();

		/**
		 * Scene loaded as default on startup.
		 *
		 * @property defaultScene
		 * @type {Scene}
		 */
		this.defaultScene = null;

		/**
		 * Default camera to be used by scenes where there is no camera.
		 *
		 * On the editor this value is automatically set to the last editor camera point used
		 *
		 * @property defaultCamera
		 * @type {Camera}
		 */
		this.defaultCamera = null;

		/**
		 * Scene currently running in the program, runtime variable.
		 *
		 * Should never be manually defined, change it using the setScene(scene) method.
		 *
		 * @property scene
		 * @type {Scene}
		 */
		this.scene = null;

		/**
		 * Keyboard input object, runtime variable.
		 *
		 * @property keyboard
		 * @type {Keyboard}
		 */
		this.keyboard = null;

		/**
		 * Mouse input object, runtime variable.
		 *
		 * @property mouse
		 * @type {Mouse}
		 */
		this.mouse = null;

		/**
		 * Renderer being used during runtime.
		 *
		 * @property renderer
		 * @type {WebGLRenderer}
		 */
		this.renderer = null;

		/**
		 * Canvas being used to draw content by the renderer.
		 *
		 * This canvas is where the WebGL rendering context was created.
		 *
		 * @property canvas
		 * @type {Element}
		 */
		this.canvas = null;

		/**
		 * DOM Division element that can be used to add html content to the app.
		 *
		 * All content added to this division should be manually removed before the app exits.
		 *
		 * @property division
		 * @type {Element}
		 */
		this.division = null;

		/**
		 * Event manager used to attach and manage program events.
		 *
		 * Its created on initialization and destroys on disposal, scripts can attach events to the manager safely during runtime.
		 * 
		 * @property manager
		 * @type {EventManager}
		 */
		this.manager = new EventManager();

		/**
		 * Clock object used to measure times between frames.
		 *
		 * The time measured is passed down to the scene and its children elements.
		 *
		 * @property clock
		 * @type {Clock}
		 */
		this.clock = new three.Clock();

		/**
		 * VR runtime control, true when the app is running in VR mode.
		 *
		 * @property vrRunning
		 * @type {boolean}
		 */
		this.vrRunning = false;
	}

	Program.prototype = Object.create(ResourceManager.prototype);

	/**
	 * Select initial scene and initialize that scene.
	 * 
	 * Automatically called by the runtime.
	 * 
	 * @method initialize
	 */
	Program.prototype.initialize = function()
	{
		if(this.mouse === null)
		{
			this.mouse = new Mouse();
			this.mouse.setCanvas(this.canvas);
			this.mouse.create();
		}

		if(this.keyboard === null)
		{
			this.keyboard = new Keyboard();
			this.keyboard.create();
		}

		// Create manager events
		this.manager.create();

		// Get default scene from children
		if(this.defaultScene !== null)
		{
			for(var i = 0; i < this.children.length; i++)
			{
				if(this.children[i].uuid === this.defaultScene)
				{
					this.setScene(this.children[i]);
					break;
				}
			}
		}
		else if(this.children.length > 0)
		{
			this.setScene(this.children[0]);
		}
		
		// Lock mouse pointer
		if(this.lockPointer)
		{
			this.mouse.setLock(true);
		}

		this.clock.start();
	};

	/**
	 * Set program mouse and keyboard.
	 *
	 * Should be set before initialize() is called otherwise a keyboard and mouse are created by default.
	 * 
	 * @method setMouseKeyboard
	 * @param {Mouse} mouse
	 * @param {Keyboard} keyboard
	 */
	Program.prototype.setMouseKeyboard = function(mouse, keyboard)
	{
		if(this.mouse !== mouse)
		{
			if(this.mouse !== null)
			{
				this.mouse.dispose();
			}

			this.mouse = mouse;
		}

		if(this.keyboard !== keyboard)
		{
			if(this.keyboard !== null)
			{
				this.keyboard.dispose();
			}

			this.keyboard = keyboard;	
		}
	};

	/**
	 * Set program renderer to be used by this program.
	 *
	 * Gets the renderer canvas and uses the parent DOM element of the canvas for DOM division property.
	 *
	 * @method setRenderer
	 * @param {WebGLRenderer} renderer Three.js renderer to be used by this program
	 * @param {bool} configure If true also updates renderer configuration to match rendering quality specified in the program.
	 */
	Program.prototype.setRenderer = function(renderer, configure)
	{
		this.renderer = renderer;
		this.renderer.autoClear = false;

		this.canvas = renderer.domElement;
		this.division = this.canvas.parentElement;

		if(configure)
		{
			this.updateRenderer();
		}
	};

	/**
	 * Update program state, this updated all current scene children elements.
	 * 
	 * @method update
	 */
	Program.prototype.update = function()
	{
		var delta = this.clock.getDelta();

		this.mouse.update();
		this.keyboard.update();

		this.scene.update(delta);
	};

	/**
	 * Render current scene to canvas.
	 *
	 * When rendering in VR mode all effects and camera parameters are ignored.
	 * 
	 * Renderer should be initialized and passed as argument.
	 * 
	 * @method render
	 * @param {Renderer} renderer
	 */
	Program.prototype.render = function(renderer)
	{
		this.scene.render(renderer);
	};

	/**
	 * Resize the current scene elements.
	 * 
	 * @method resize
	 * @param {number} x Width.
	 * @param {number} y Height.
	 */
	Program.prototype.resize = function(x, y)
	{
		// Resize the default camera
		if(this.defaultCamera !== null)
		{
			this.defaultCamera.resize(x, y);
		}

		this.scene.resize(x, y);
	};

	/**
	 * This method updated the webgl renderer configuration.
	 *
	 * Should be called after changing any rendering related parameter.
	 *
	 * @method updateRenderer
	 */
	Program.prototype.updateRenderer = function()
	{
		if(this.renderer !== null)
		{
			this.rendererConfig.apply(this.renderer);
		}
	};


	/**
	 * Check if virtual reality is available. 
	 * 
	 * @method vrAvailable
	 */
	Program.prototype.vrAvailable = function()
	{
		return this.vr && Nunu.vrAvailable();
	};

	/**
	 * Enter virtual reality mode.
	 * 
	 * @method enterVR
	 */
	Program.prototype.enterVR = function()
	{
		if(this.vr)
		{
			var self = this;
			Nunu.enterVR(this.renderer, function()
			{
				self.vrRunning = true;
			});
		}
	};

	/**
	 * Exit virtual relity mode.
	 * 
	 * @method exitVR
	 */
	Program.prototype.exitVR = function()
	{
		if(this.vr)
		{
			Nunu.exitVR(this.renderer);
			this.vrRunning = false;
		}
	};

	/**
	 * Change scene during runtime, this method can receive booth a scene name or a scene object.
	 * 
	 * This method should be used inside of script objects during runtime.
	 * 
	 * @method setScene
	 * @param {Scene|String} scene Scene object or name of the scene to be used.
	 */
	Program.prototype.setScene = function(scene)
	{
		// Try to get scene by UUID
		if(typeof scene === "string")
		{
			scene = this.getObjectByName(scene);
		}

		// Dispose old scene to free up resources
		if(this.scene !== null)
		{
			this.scene.dispose();
		}

		// Set new scene and inialize its resources
		this.scene = scene;

		if(this.scene !== null)
		{
			if(this.scene.defaultCamera === null)
			{
				this.scene.defaultCamera = this.defaultCamera;
			}

			this.scene.initialize();
		}
		else
		{
			console.warn("nunuStudio: Program setScene scene is null.");
		}
	};

	/**
	 * Remove Scene from program.
	 * 
	 * @method remove
	 * @param {Scene} scene
	 */
	Program.prototype.remove = function(scene)
	{
		if(scene instanceof three.Scene)
		{
			// Remove scene from the children list
			var index = this.children.indexOf(scene);
			if(index > -1)
			{
				this.children.splice(index, 1);
				scene.parent = null;
			}

			// If the scene remove was in use, dispose it
			if(scene === this.scene)
			{
				this.scene.dispose();
				this.scene = null;
			}
			
			// If there are no scenes on program set actual scene to null
			if(this.children.length === 0)
			{
				this.scene = null;
			}
		}
		else
		{
			console.warn("nunuStudio: Trying to remove Object3D from program, only Scene objects allowed.");
		}
	};

	/**
	 * Add new scene to this program.
	 * 
	 * On the program class only scenes can be added as children.
	 * 
	 * @method add
	 * @param {Scene} scene
	 */
	Program.prototype.add = function(scene)
	{
		if(scene instanceof three.Scene)
		{
			scene.parent = this;
			this.children.push(scene);
		}
		else
		{
			console.warn("nunuStudio: Trying to add Object3D to program, only Scene objects allowed.");
		}
	};

	/**
	 * Clone program, keeping uuids and every identification attribute.
	 * 
	 * Clone method uses the ObjectLoad to serialize and create a new program instance with the same data.
	 * 
	 * @method clone
	 * @return {Program} Cloned program
	 */
	Program.prototype.clone = function()
	{
		return new ObjectLoader().parse(this.toJSON());
	};

	/**
	 * Set a scene as initial scene using its uuid.
	 * 
	 * This method is used by the editor.
	 * 
	 * @method setInitialScene
	 * @param {string} uuid Scene uuid
	 */
	Program.prototype.setInitialScene = function(scene)
	{
		this.defaultScene = scene.uuid;
	};

	/**
	 * Dispose program data to avoid memory leaks.
	 * 
	 * Called when exiting the program.
	 * 
	 * @method dispose
	 */
	Program.prototype.dispose = function()
	{
		if(this.lockPointer)
		{
			this.mouse.setLock(false);
		}

		if(this.mouse !== null)
		{
			this.mouse.dispose();
		}

		if(this.keyboard !== null)
		{
			this.keyboard.dispose();
		}

		this.manager.destroy();

		if(this.scene !== null)
		{
			this.scene.dispose();
		}
		else
		{
			console.warn("nunuStudio: Program dispose() scene is null.", this);
		}
		
		ResourceManager.prototype.dispose.call(this);
		three.Object3D.prototype.dispose.call(this);
	};

	/**
	 * Receive external data and pass it to all script instances.
	 * 
	 * @param {Object} data
	 * @method receiveDataApp
	 */
	Program.prototype.receiveDataApp = function(data)
	{
		var found = false;

		// Check if there is a script with onAppData method available
		this.traverse(function(child)
		{
			if(child instanceof Script)
			{
				child.appData(data);
				found = true;
			}
		});

		// Show warning message
		if(!found)
		{
			console.warn("nunuStudio: No script with onAppData found", data);
		}
	};

	/**
	 * Send data to external app instance.
	 * 
	 * @param {Object} data
	 * @method sendDataApp
	 */
	Program.prototype.sendDataApp = function(data)
	{
		if(this.app !== null)
		{
			if(this.app.onDataReceived !== undefined)
			{
				this.app.onDataReceived(data);
			}
			else
			{
				console.warn("nunuStudio: Send app data communication", data);
			}
		}
		else
		{
			console.warn("nunuStudio: Data sent to app", data);
		}
	};

	/**
	 * Serialize the object to JSON format.
	 * 
	 * @method toJSON
	 * @param {Object} meta Metadata object passed to the objects and resources toJSON method to store data.
	 * @param {boolean} exportResources If true all resouces in the program are exported, else only resources attached to objects are exported.
	 * @return {Object} json Serialized JSON data containing the program, all scenes and resources stored.
	 */
	Program.prototype.toJSON = function(meta, exportResources)
	{
		var self = this;

		var data = three.Object3D.prototype.toJSON.call(this, meta, function(meta, object)
		{
			if(exportResources !== false)
			{
				for(var k = 0; k < ResourceContainer.libraries.length; k++)
				{
					var lib = self[ResourceContainer.libraries[k]];
					for(var i in lib)
					{
						var resource = lib[i];
						if(meta[ResourceContainer.libraries[k]][resource.uuid] === undefined)
						{
							meta[ResourceContainer.libraries[k]][resource.uuid] = resource.toJSON(meta);
						}
					}
				}
			}
		});

		// Initial scene
		if(this.defaultScene !== null)
		{
			data.object.defaultScene = this.defaultScene;
		}

		// Information
		data.object.author = this.author;
		data.object.description = this.description;
		data.object.version = this.version;

		// Pointer
		data.object.lockPointer = this.lockPointer;
		data.object.handlePixelRatio = this.handlePixelRatio;
		
		// VR
		data.object.vr = this.vr;
		data.object.vrScale = this.vrScale;

		// Rendering
		data.object.rendererConfig = this.rendererConfig.toJSON();

		return data;
	};

	/**
	 * Physics generator is used to create Cannon.js shapes from three.js geometries.
	 * 
	 * Can be used with any object that contains a geometry.
	 * 
	 * It is based on the original Mesh2Shape converted by @donmccurdy.
	 * 
	 * @author tentone
	 * @class PhysicsGenerator
	 * @static
	 * @module Physics
	 */
	function PhysicsGenerator(){}

	/**
	 * Type is used to indentify the type of cannonjs:
	 *  - BOX
	 *  - CYLINDER
	 *  - SPHERE
	 *  - HULL
	 * 
	 * @attribute Type
	 * @type {Object}
	 */
	PhysicsGenerator.Type =
	{
		BOX: "Box",
		CYLINDER: "Cylinder",
		SPHERE: "Sphere",
		HULL: "ConvexPolyhedron"
	};

	/**
	 * Given a Object3D instance, creates a corresponding CANNON shape.
	 *
	 * @method createShape
	 * @param {Object3D} object
	 * @param {string} type PhysicsGenerator.Type
	 * @return {Shape} shape
	 */
	PhysicsGenerator.createShape = function(object, type)
	{
		if(type !== undefined)
		{
			if(type === PhysicsGenerator.Type.BOX)
			{
				return PhysicsGenerator.createBoundingBoxShape(object);
			}
			else if(type === PhysicsGenerator.Type.CYLINDER)
			{
				return PhysicsGenerator.createBoundingCylinderShape(object);
			}
			else if(type === PhysicsGenerator.Type.SPHERE)
			{
				return PhysicsGenerator.createBoundingSphereShape(object);
			}
			else if(type === PhysicsGenerator.Type.HULL)
			{
				return PhysicsGenerator.createConvexPolyhedron(object);
			}
			
			return null;
		}

		var geometry = PhysicsGenerator.getGeometry(object);
		if(!geometry)
		{
			return null;
		}

		switch(geometry.type)
		{
			case "BoxGeometry":
			case "BoxBufferGeometry":
				return PhysicsGenerator.createBoxShape(geometry);
			case "CylinderGeometry":
			case "CylinderBufferGeometry":
				return PhysicsGenerator.createCylinderShape(geometry);
			case "PlaneGeometry":
			case "PlaneBufferGeometry":
				return PhysicsGenerator.createPlaneShape(geometry);
			case "SphereGeometry":
			case "SphereBufferGeometry":
				return PhysicsGenerator.createSphereShape(geometry);
			case "TubeGeometry":
				return PhysicsGenerator.createTubeShape(geometry);
			case "Geometry":
			case "BufferGeometry":
				return PhysicsGenerator.createConvexPolyhedron(object);
			default:
				return PhysicsGenerator.createBoxShape(geometry);
		}
	};

	/**
	 * Create box shape from geometry.
	 *
	 * @method createBoxShape
	 * @param {Geometry} geometry
	 * @return {Box} shape
	 */
	PhysicsGenerator.createBoxShape = function(geometry)
	{
		var vertices = PhysicsGenerator.getVertices(geometry);

		if(!vertices.length)
		{
			return null;
		}

		geometry.computeBoundingBox();
		
		var box = geometry.boundingBox;
		
		return new cannon.Box(new cannon.Vec3((box.max.x - box.min.x) / 2,(box.max.y - box.min.y) / 2,(box.max.z - box.min.z) / 2));
	};

	/**
	 * Bounding box needs to be computed with the entire mesh, not just geometry.
	 *
	 * @method createBoundingBoxShape
	 * @param {Geometry} geometry
	 * @return {Box} shape
	 */
	PhysicsGenerator.createBoundingBoxShape = function(object)
	{
		var box = new Box3();
		box.setFromObject(object);

		if(!isFinite(box.min.lengthSq()))
		{
			return null;
		}

		var shape = new cannon.Box(new cannon.Vec3((box.max.x - box.min.x) / 2, (box.max.y - box.min.y) / 2, (box.max.z - box.min.z) / 2));

		object.updateMatrixWorld();

		var worldPosition = new three.Vector3();
		worldPosition.setFromMatrixPosition(object.matrixWorld);

		return shape;
	};

	/**
	 * Computes 3D convex hull as a ConvexPolyhedron.
	 *
	 * @method createConvexPolyhedron
	 * @param {ConvexPolyhedron} geometry
	 * @return {Shape} shape
	 */
	PhysicsGenerator.createConvexPolyhedron = function(object)
	{
		var quickhull = new three.QuickHull();
		quickhull.setFromObject(object);

		var vertices = [];
		var faces = [];
		var normals = [];

		// Generate vertices and normals
		for(var i = 0; i < quickhull.faces.length; i++)
		{
			var face = quickhull.faces[i];
			var edge = face.edge;
			
			// We move along a doubly-connected edge list to access all face points
			do
			{
				var point = edge.head().point;
				vertices.push(new cannon.Vec3(point.x, point.y, point.z));
				edge = edge.next;
			}
			while(edge !== face.edge);

			// The face always has 3 points
			faces.push([vertices.length - 3, vertices.length - 2, vertices.length - 1]);
			normals.push(new cannon.Vec3(face.normal.x, face.normal.y, face.normal.z));
		}

		return new cannon.ConvexPolyhedron(vertices, faces, normals);
	};

	/**
	 * Create cylinder shape from geometry.
	 *
	 * @method createCylinderShape
	 * @param {Geometry} geometry
	 * @return {Cylinder} shape
	 */
	PhysicsGenerator.createCylinderShape = function(geometry)
	{
		var params = geometry.parameters;

		var shape = new cannon.Cylinder(params.radiusTop, params.radiusBottom, params.height, params.radialSegments);
		shape.orientation = new cannon.Quaternion();
		shape.orientation.setFromEuler(0, 0, 0, "XYZ").normalize();

		return shape;
	};

	/**
	 * Create cylinder shape from bounding cylinder calculated from bounding box and bouding sphere.
	 *
	 * @method createBoundingCylinderShape
	 * @param {Object3D} object
	 * @return {Cylinder} shape
	 */
	PhysicsGenerator.createBoundingCylinderShape = function(object)
	{
		var axes = ["x", "y", "z"];
		var minorAxes = axes.splice(axes.indexOf("y"), 1) && axes;

		// Compute cylinder dimensions
		var geometry = PhysicsGenerator.getGeometry(object);
		geometry.computeBoundingBox();
		geometry.computeBoundingSphere();
		
		var height = geometry.boundingBox.max.y - geometry.boundingBox.min.y;
		var radius = 0.5 * Math.max(geometry.boundingBox.max[minorAxes[0]] - geometry.boundingBox.min[minorAxes[0]],geometry.boundingBox.max[minorAxes[1]] - geometry.boundingBox.min[minorAxes[1]]);

		// Create shape
		var shape = new cannon.Cylinder(radius, radius, height, 12);
		shape.orientation = new cannon.Quaternion();
		shape.orientation.setFromEuler(Math.PI / 2, 0, 0, "XYZ").normalize();
		
		return shape;
	};

	/**
	 * Plane shape from geometry.
	 *
	 * @method createPlaneShape
	 * @param {Geometry} geometry
	 * @return {Box} shape
	 */
	PhysicsGenerator.createPlaneShape = function(geometry)
	{
		geometry.computeBoundingBox();
		var box = geometry.boundingBox;

		return new cannon.Box(new cannon.Vec3((box.max.x - box.min.x) / 2, (box.max.y - box.min.y) / 2, (box.max.z - box.min.z) / 2));
	};

	/**
	 * Sphere shape from geometry.
	 *
	 * @method createSphereShape
	 * @param {Geometry} geometry
	 * @return {Sphere} shape
	 */
	PhysicsGenerator.createSphereShape = function(geometry)
	{
		return new cannon.Sphere(geometry.parameters.radius);
	};

	/**
	 * Sphere shape from bouding sphere.
	 *
	 * @method createBoundingSphereShape
	 * @param {Geometry} geometry
	 * @return {Sphere} shape
	 */
	PhysicsGenerator.createBoundingSphereShape = function(object)
	{
		var geometry = PhysicsGenerator.getGeometry(object);
		geometry.computeBoundingSphere();

		return new cannon.Sphere(geometry.boundingSphere.radius);
	};

	/**
	 * Sphere shape from bouding sphere.
	 *
	 * @method createTubeShape
	 * @param {Geometry} geometry
	 * @return {Trimesh} shape
	 */
	PhysicsGenerator.createTubeShape = function(geometry)
	{
		var tmp = new three.BufferGeometry();
		tmp.fromGeometry(geometry);
		return createTrimeshShape(tmp);
	};

	/**
	 * Trimesh shape from geometry.
	 * 
	 * @method createTrimeshShape
	 * @param {Geometry} geometry
	 * @return {Trimesh} shape
	 */
	PhysicsGenerator.createTrimeshShape = function(geometry)
	{
		var indices, vertices = PhysicsGenerator.getVertices(geometry);

		if(!vertices.length)
		{
			return null;
		}

		indices = Object.keys(vertices).map(Number);
		return new cannon.Trimesh(vertices, indices);
	};

	/**
	 * Returns a single geometry for the given object.
	 * 
	 * If the object is compound, its geometries are automatically merged.
	 * 
	 * @method getGeometry
	 * @param {Object3D} object
	 * @return {Geometry} Geometry that contains all merger geometry
	 */
	PhysicsGenerator.getGeometry = function(object)
	{
		var meshes = PhysicsGenerator.getMeshes(object);

		if(meshes.length === 0)
		{
			return null;
		}

		var tmp = new three.Geometry();
		
		// Apply scale (it can't easily be applied to a Shape later)
		if(meshes.length === 1)
		{
			var position = new three.Vector3();
			var quaternion = new three.Quaternion();
			var scale = new three.Vector3(1, 1, 1);

			tmp = meshes[0].geometry.clone();
			meshes[0].updateMatrixWorld();
			meshes[0].matrixWorld.decompose(position, quaternion, scale);

			return tmp.scale(scale.x, scale.y, scale.z);
		}
		// If more than one mesh found merge into single geometry
		else
		{
			var combined = new three.Geometry();
			var mesh;

			// Recursively merge geometry, preserving local transforms
			while((mesh = meshes.pop()))
			{
				mesh.updateMatrixWorld();

				if(mesh.geometry instanceof three.BufferGeometry)
				{
					tmp.fromBufferGeometry(mesh.geometry);
					combined.merge(tmp, mesh.matrixWorld);
				}
				else
				{
					combined.merge(mesh.geometry, mesh.matrixWorld);
				}
			}

			var matrix = new three.Matrix4();
			matrix.scale(object.scale);
			combined.applyMatrix4(matrix);
			return combined;
		}
	};

	/**
	 * Get geometry vertices.
	 *
	 * @method getVertices
	 * @param {Geometry} geometry
	 * @return {Array} array
	 */
	PhysicsGenerator.getVertices = function(geometry)
	{
		if(!geometry.attributes)
		{
			geometry = new three.BufferGeometry().fromGeometry(geometry);
		}
		return geometry.attributes.position.array;
	};

	/**
	 * Returns a array of Mesh instances from the given object.
	 * 
	 * If nested transformations are found, they are applied to child meshes as mesh.userData.matrix, so that each mesh has its position/rotation/scale independently of all of its parents except the top-level object.
	 *
	 * @method getMeshes
	 * @param {Object3D} object
	 * @return {Array} meshes found inside the Object3D
	 */
	PhysicsGenerator.getMeshes = function(object)
	{
		var meshes = [];

		object.traverse(function(child)
		{
			if(child instanceof three.Mesh)
			{
				meshes.push(child);
			}
		});

		return meshes;
	};

	/**
	 * Object utils is a collection of methods to apply operations to Object3D instances.
	 *
	 * @static
	 * @class ObjectUtils
	 * @module Utils
	 */
	function ObjectUtils(){}

	/**
	 * Get object tree root by traversing the tree upwards.
	 *
	 * For a object placed inside a running scene the root is always the program.
	 *
	 * @method getRoot
	 * @param {Object3D} obj
	 * @return {Object3D} root
	 */
	ObjectUtils.getRoot = function(obj)
	{
		var node = obj;
		
		while(node.parent !== null)
		{
			node = node.parent;
		}

		return node;
	};

	/**
	 * Scale and center object into a unitary box.
	 *
	 * Useful to scale objects to fit into a known size box.
	 * 
	 * @method centerUnitary
	 * @param {Object3D} object Object to be positioned and scaled.
	 */
	ObjectUtils.centerUnitary = function(object)
	{
		var box = ObjectUtils.calculateBoundingBox(object);
		
		if(box !== null)
		{
			var size = new three.Vector3();
			box.getSize(size);

			var scale = 1 / (size.x > size.y ? size.x > size.z ? size.x : size.z : size.y > size.z ? size.y : size.z);
			
			var center = new three.Vector3();
			box.getCenter(center);
			center.multiplyScalar(scale);

			object.scale.set(scale, scale, scale);
			object.position.set(-center.x, -scale * box.min.y, -center.z);
		}
	};

	/**
	 * Calculates a bouding box for an object considering all its children.
	 *
	 * Includes booth the object and all of its children, the box is ajusted to world space coordinates.
	 *
	 * @method calculateBoudingBox
	 * @param {Object3D} object Root object to be traversed.
	 * @return {Box3} Bouding box of the object considering all of its children.
	 */
	ObjectUtils.calculateBoundingBox = function(object)
	{
		var box = null;

		object.traverse(function(children)
		{
			var boundingBox = null;

			// Sprites
			if(children.isSprite === true)
			{
				var position = new three.Vector3();
				children.getWorldPosition(position);
				boundingBox = new three.Box3(position.clone().subScalar(0.5), position.clone().addScalar(0.5));
			}
			// Mesh, Points, Lines
			else if(children.geometry !== undefined)
			{
				children.geometry.computeBoundingBox();
				boundingBox = children.geometry.boundingBox.clone();
				boundingBox.applyMatrix4(children.matrixWorld);

				children.geometry.computeBoundingBox();
				var boundingBox = children.geometry.boundingBox;
			}

			// Update bouding box size
			if(boundingBox !== null)
			{
				// First box
				if(box === null)
				{
					box = boundingBox;
				}
				// Ajust box size to contain new box
				else
				{
					if(boundingBox.min.x < box.min.x) {box.min.x = boundingBox.min.x;}
					if(boundingBox.max.x > box.max.x) {box.max.x = boundingBox.max.x;}
					if(boundingBox.min.y < box.min.y) {box.min.y = boundingBox.min.y;}
					if(boundingBox.max.y > box.max.y) {box.max.y = boundingBox.max.y;}
					if(boundingBox.min.z < box.min.z) {box.min.z = boundingBox.min.z;}
					if(boundingBox.max.z > box.max.z) {box.max.z = boundingBox.max.z;}
				}
			}
		});

		return box;
	};

	/**
	 * Recalculate all children origins, to be centered with their geometry.
	 *
	 * @method centerGeometryOrigin
	 * @param {Object3D} object Object to recalculate origin of.
	 */
	ObjectUtils.centerGeometryOrigin = function(object)
	{
		object.traverse(function(children)
		{
			if(children.geometry !== undefined)
			{
				children.geometry.computeBoundingBox();

				var box = children.geometry.boundingBox.clone();

				var center = box.getCenter(new three.Vector3());
				children.position.add(center);

				// Recenter geometry
				var matrix = new three.Matrix4();
				matrix.makeTranslation(-center.x, -center.y, -center.z);
				children.geometry.applyMatrix4(matrix);
			}
		});
	};

	/**
	 * Covert all the geometries found in the object to BufferGeometry format.
	 *
	 * @method convertToBufferGeometry
	 * @param {Object3D} object Object to search for geometries
	 */
	ObjectUtils.convertToBufferGeometry = function(object)
	{
		object.traverse(function(children)
		{
			if(children.geometry !== undefined && children.geometry.isGeometry === true)
			{
				children.geometry = new three.BufferGeometry().fromGeometry(children.geometry);
			}
		});
	};

	/**
	 * Stores and manages icons of the object types available in the platform.
	 *
	 * @static
	 * @class ObjectIcons
	 */
	var ObjectIcons = {};

	/**
	 * Path of to the base icon files directory.
	 *
	 * @static
	 * @attribute path
	 * @type {string}
	 */
	ObjectIcons.path = "source/files/icons/";

	ObjectIcons.default = ObjectIcons.path + "misc/question.png";
	ObjectIcons.locked = ObjectIcons.path + "misc/padlock.png";

	ObjectIcons.icons = new Map([
		// Devices
		["Kinect", ObjectIcons.path + "hw/kinect.png"],
		["LeapDevice", ObjectIcons.path + "hw/leap.png"],

		// Ligths
		["Sky", ObjectIcons.path + "lights/sky.png"],
		["SpotLight", ObjectIcons.path + "lights/spot.png"],
		["PointLight", ObjectIcons.path + "lights/point.png"],
		["HemisphereLight", ObjectIcons.path + "lights/hemisphere.png"],
		["DirectionalLight", ObjectIcons.path + "lights/directional.png"],
		["AmbientLight", ObjectIcons.path + "lights/ambient.png"],
		["RectAreaLight", ObjectIcons.path + "lights/rectarea.png"],
		["LightProbe", ObjectIcons.path + "misc/probe.png"],

		// Cameras
		["PerspectiveCamera", ObjectIcons.path + "camera/prespective.png"],
		["OrthographicCamera", ObjectIcons.path + "camera/orthographic.png"],

		// Objects
		["SpineAnimation", ObjectIcons.path + "misc/spine.png"],
		["InstancedMesh", ObjectIcons.path + "models/cubes.png"],
		["SkinnedMesh", ObjectIcons.path + "misc/skeleton.png"],
		["Mesh", ObjectIcons.path + "models/cube.png"],
		["ParticleEmiter", ObjectIcons.path + "misc/particles.png"],
		["Script", ObjectIcons.path + "script/script.png"],
		["Sprite", ObjectIcons.path + "misc/image.png"],
		["Points", ObjectIcons.path + "models/points.png"],
		["Line", ObjectIcons.path + "misc/nodes.png"],
		["LineSegments", ObjectIcons.path + "misc/nodes.png"],
		
		// Text
		["TextMesh", ObjectIcons.path + "text/textmesh.png"],
		["TextBitmap", ObjectIcons.path + "text/text.png"],
		["TextSprite", ObjectIcons.path + "text/textcanvas.png"],

		// Program
		["Program", ObjectIcons.path + "script/script.png"],
		["Scene", ObjectIcons.path + "models/models.png"],

		// Audio
		["Audio", ObjectIcons.path + "misc/audio.png"],
		["PositionalAudio", ObjectIcons.path + "misc/audio_positional.png"],

		// Physics
		["Physics", ObjectIcons.path + "misc/physics.png"],

		// Others
		["Object3D", ObjectIcons.path + "misc/scene.png"],
		["CubeCamera", ObjectIcons.path + "misc/probe.png"],
		["Bone", ObjectIcons.path + "misc/bone.png"],
		["Group", ObjectIcons.path + "misc/container.png"],
		["LensFlare", ObjectIcons.path + "misc/flare.png"],
		["OrbitControls", ObjectIcons.path + "misc/orbit.png"],
		["FirstPersonControls", ObjectIcons.path + "misc/crosshair.png"]
	]);

	/**
	 * Get icon path from object type, if no icon available a default icon is returned.
	 * 
	 * @static
	 * @method get
	 * @param {string} Object type.
	 */
	ObjectIcons.get = function(type)
	{
		if(ObjectIcons.icons.has(type))
		{
			return ObjectIcons.icons.get(type);
		}

		return ObjectIcons.default;
	};

	/**
	 * Resource utils contains multiple tools to manipulate data in the resource manager on the editor.
	 *
	 * @static
	 * @class ResourceCrawler
	 */
	function ResourceCrawler(){}

	/**
	 * Auxiliar method to traverse any type of JS object in depth.
	 *
	 * Is called recursively for every Array or Object found, the callback receives the (value, parent, attribute) as parameters.
	 *
	 * If the callback method returns false it does not traverse the object.
	 * 
	 * @static
	 * @method traverseDeep
	 * @param {Object} object Object to be traversed.
	 * @param {Function} callback Callback to process every attribute from the object.
	 */
	ResourceCrawler.traverseDeep = function(object, callback)
	{
		if(callback === undefined)
		{
			return;
		}

		for(var i in object)
		{
			var value = object[i];

			if(typeof value === "object")
			{
				if(callback(value, object, i) !== false)
				{
					ResourceCrawler.traverseDeep(value, callback);
				}
			}
			else
			{
				callback(value, object, i);
			}
		}
	};

	/**
	 * Swap a resource from the program, changes the resource in the manager.
	 *
	 * Searches and replaces all usages of the old resource.
	 *
	 * @static
	 * @method swapResource
	 * @param {ResourceManager} manager Resource manage with program.
	 * @param {string} category Name of the resource category.
	 * @param {Resource} oldResource Old resource being replaced.
	 * @param {Resource} newResource New resource used to replace the old one.
	 */
	ResourceCrawler.swapResource = function(manager, category, oldResource, newResource)
	{	
		if(manager[category][oldResource.uuid] === undefined)
		{
			throw new Error("Old resource not found in the resource manager.");
		}
		
		// Swap resource in the manager
		delete manager[category][oldResource.uuid];

		// Replace all instances found
		ResourceCrawler.traverseDeep(manager, function(value, object, attribute)
		{
			if(value === oldResource)
			{
				object[attribute] = newResource;
				return false;
			}

			return true;
		});

		manager[category][newResource.uuid] = newResource;
	};

	/**
	 * Remove all duplicate resources from object.
	 *
	 * @static
	 * @method removeDuplicated
	 */
	ResourceCrawler.removeDuplicated = function(object)
	{

		// Fetch resources to be optimized
		ResourceCrawler.traverseDeep(object, function(value)
		{
		});

	};

	/**
	 * Add resource (of any type) to category.
	 *
	 * @static
	 * @method addResource
	 * @param {ResourceManager} manager
	 * @param {Resource} resource
	 * @param {string} category
	 */
	ResourceCrawler.addResource = function(manager, resource, category)
	{
		manager[category][resource.uuid] = resource;
	};

	/**
	 * Remove resource of any type from category.
	 *
	 * If any resource needs replacement in an object is uses the default scene resources.
	 *
	 * @static
	 * @method removeResource
	 * @param {ResourceManager} manager
	 * @param {Resource} resource
	 * @param {string} category
	 */ 
	ResourceCrawler.removeResource = function(manager, resource, category)
	{
		if(category === "materials")
		{
			manager.removeMaterial(resource, Editor$1.defaultMaterial, Editor$1.defaultSpriteMaterial);
		}
		else if(category === "textures")
		{
			manager.removeTexture(resource, Editor$1.defaultTexture);
		}
		else if(category === "fonts")
		{
			manager.removeFont(resource, Editor$1.defaultFont);
		}
		else if(category === "audio")
		{
			manager.removeAudio(resource, Editor$1.defaultAudio);
		}
		else if(category === "geometries")
		{
			manager.removeGeometry(resource, Editor$1.defaultGeometry);
		}
		else
		{
			if(manager[category] !== undefined && manager[category][resource.uuid] !== undefined)
			{
				delete manager[category][resource.uuid];
			}
		}
	};

	/**
	 * Get a resource from any category by its name, only returns the first resource found.
	 *
	 * @static
	 * @param {ResourceManager} manager
	 * @param {string} name
	 */
	ResourceCrawler.getResourceByName = function(manager, name)
	{
		for(var category in manager)
		{
			for(var resources in category)
			{
				if(resources[i].name === name)
				{
					return resources[i];
				}
			}
		}

		return null;
	};

	/**
	 * Searches the object and all its children for resources that still dont exist in the resource manager.
	 *
	 * Stores them in a resource container object that is returned.
	 *
	 * @static
	 * @method searchObject
	 * @param {Object3D} object Object to search for resources.
	 * @param {ResourceManager} manager Resource manager object.
	 * @param {ResourceContainer} target Optional resource container object that can be used to store the found resources.
	 * @return {ResourceContainer} Object with the new resources found in the object.
	 */
	ResourceCrawler.searchObject = function(object, manager, target)
	{
		var resources;

		if(target !== undefined)
		{
			resources = target;
		}
		else
		{
			resources = new ResourceContainer();
		}
		
		object.traverse(function(child)
		{
			if(child.locked)
			{
				return;
			}

			// Fonts
			if(child.font instanceof Font)
			{
				if(manager.fonts[child.font.uuid] === undefined)
				{
					resources.fonts[child.font.uuid] = child.font;
				}
			}

			// Audio
			if(child.audio instanceof Audio)
			{
				if(manager.audio[child.audio.uuid] === undefined)
				{
					resources.audio[child.audio.uuid] = child.audio;
				}
			}

			// Material/textures
			if(child.material !== undefined && !(child instanceof TextBitmap || child instanceof TextSprite ||child instanceof LensFlare || child instanceof ParticleEmitter || child instanceof Sky || child instanceof SpineAnimation))
			{
				if(child.material instanceof three.Material)
				{
					addMaterial(child.material);
				}
				else if(child.material instanceof Array)
				{
					for(var j = 0; j < child.material.length; j++)
					{
						addMaterial(child.material[j]);
					}
				}
				else if(child.materials instanceof Array)
				{
					for(var j = 0; j < child.materials.length; j++)
					{
						addMaterial(child.materials[j]);
					}
				}
				else if(child.material instanceof three.MultiMaterial)
				{
					var materials = child.material.materials;
					for(var j = 0; j < materials.length; j++)
					{
						addMaterial(materials[j]);
					}
				}
			}

			// Geometries
			if((child instanceof three.Mesh || child instanceof three.SkinnedMesh) && !(child instanceof TextBitmap))
			{
				if(child.geometry instanceof three.BufferGeometry || child.geometry instanceof three.Geometry)
				{
					if(manager.geometries[child.geometry.uuid] === undefined)
					{
						resources.geometries[child.geometry.uuid] = child.geometry;
					}			
				}
			}

			// Textures
			if(child.texture !== undefined && !(child instanceof TextSprite))
			{
				addTexture(child.texture);
			}
			if(child instanceof LensFlare)
			{
				for(var i = 0; i < child.elements.length; i++)
				{
					addTexture(child.elements[i].texture);
				}
			}
		});

		function addMaterial(material)
		{
			addTexturesFromMaterial(material);

			if(manager.materials[material.uuid] === undefined)
			{
				resources.materials[material.uuid] = material;
			}
		}

		function addTexturesFromMaterial(material)
		{
			addTexture(material.map);
			addTexture(material.bumpMap);
			addTexture(material.normalMap);
			addTexture(material.displacementMap);
			addTexture(material.specularMap);
			addTexture(material.emissiveMap);
			addTexture(material.alphaMap);
			addTexture(material.roughnessMap);
			addTexture(material.metalnessMap);
			addTexture(material.envMap);
		}

		function addTexture(texture)
		{
			if(texture !== null && texture !== undefined)
			{
				addResourcesTexture(texture);

				if(manager.textures[texture.uuid] === undefined)
				{
					resources.textures[texture.uuid] = texture;	
				}
			}
		}

		function addImage(image)
		{
			if(manager.images[image.uuid] === undefined)
			{
				resources.images[image.uuid] = image;
			}
		}

		function addResourcesTexture(texture)
		{
			// Image
			if(texture.source instanceof Image)
			{
				addImage(texture.source);
			}
			// Video
			if(texture.video instanceof Video)
			{
				if(manager.videos[texture.video.uuid] === undefined)
				{
					resources.videos[texture.video.uuid] = texture.video;
				}
			}
			// Images array
			if(texture.images !== undefined)
			{
				for(var i = 0; i < texture.images.length; i++)
				{
					addImage(texture.images[i]);
				}
			}
		}

		for(var i in manager.materials)
		{
			addTexturesFromMaterial(manager.materials[i]);
		}

		for(var i in manager.textures)
		{
			addResourcesTexture(manager.textures[i]);
		}

		return resources;
	};

	/**
	 * Manages the history state of multiple objects.
	 *
	 * @class History
	 * @param {number} limit Maximum actions stored in the object.
	 */
	function History(limit)
	{
		this.actions = [];

		this.position = -1;
		this.limit = limit !== undefined ? limit : 50;
	}

	/**
	 * Get action from its id.
	 * 
	 * @method getAction
	 * @param {number} id Action identifier.
	 * @return {Action} The action requested, if it is not found returns null.
	 */
	History.prototype.getAction = function(id)
	{
		for(var i = 0; i < this.actions.length; i++)
		{
			if(this.actions[i].id === id)
			{
				return this.actions[i];
			}
		}

		return null;
	};

	/**
	 * Add an Action to the history.
	 *
	 * @method add
	 * @param {Actions} action Actions that represent the change.
	 * @param {EditorScreen} editor Editor instance for the action to update status of.
	 */
	History.prototype.add = function(action, editor)
	{	
		// If there are more recent changes remove them
		while(this.actions.length > this.position + 1)
		{
			this.actions.pop();
		}

		// Add action to list
		this.actions.push(action);
		this.position++;

		// Apply action
		action.apply(editor, true);

		// Limit actions size
		while(this.actions.length > this.limit)
		{
			this.actions.splice(0, 1);
			this.position = this.actions.length - 1;
		}
	};

	/**
	 * Revert last action
	 *
	 * @method undo
	 * @param {EditorScreen} editor Editor instance for the action to update status of.
	 */
	History.prototype.undo = function(editor)
	{
		if(this.actions.length > 0 && this.position >= 0)
		{
			var action = this.actions[this.position];
			action.revert(editor, true);

			this.position--;
			
			return action;
		}

		return null;
	};

	/**
	 * Redo last reverted action.
	 *
	 * @method redo
	 * @param {EditorScreen} editor Editor instance for the action to update status of.
	 */
	History.prototype.redo = function(editor)
	{
		if(this.position < this.actions.length - 1)
		{
			this.position++;

			var action = this.actions[this.position];
			action.apply(editor, true);

			return action;
		}

		return null;
	};

	/**
	 * Action defines the interface to apply and revert a history state.
	 *
	 * Actions are inserted and managed by a History object.
	 * 
	 * @class Action
	 */
	function Action()
	{
		this.id = Action._id++;
	}

	Action._id = 1;

	/** 
	 * Apply the action.
	 *
	 * Change objects, update the editor and send data to server.
	 *
	 * @method apply
	 */
	Action.prototype.apply = function(){};

	/** 
	 * Revert the action.
	 *
	 * Change objects, update the editor and send data to server.
	 *
	 * @method revert
	 */
	Action.prototype.revert = function(){};

	/**
	 * Remove a resource from the manager.
	 *
	 * Usages of the resource being removed are replaced with a default resource of the same category.
	 *
	 * @class RemoveResourceAction
	 * @param {Resource} resource Resource to remove.
	 * @param {ResourceManager} manager Manager to insert the resource into.
	 * @param {string} category Category of the resource.
	 */
	function RemoveResourceAction(resource, manager, category)
	{
		Action.call(this);
		
		this.resource = resource;
		this.category = category;
		this.manager = manager;
	}

	RemoveResourceAction.prototype.apply = function()
	{
		ResourceCrawler.removeResource(this.manager, this.resource, this.category);

		if(this.resource.dispose !== undefined)
		{
			this.resource.dispose();
		}

		RemoveResourceAction.updateGUI();
	};

	RemoveResourceAction.prototype.revert = function()
	{
		ResourceCrawler.addResource(this.manager, this.resource, this.category);

		AddResourceAction.updateGUI();
	};

	RemoveResourceAction.updateGUI = function()
	{
		Editor$1.updateObjectsViewsGUI();
	};

	/**
	 * Add resource to the resource manager.
	 *
	 * @class AddResourceAction
	 * @param {Resource} resource Resource to add.
	 * @param {ResourceManager} manager Manager to insert the resource into.
	 * @param {string} category Category of the resource.
	 */
	function AddResourceAction(resource, manager, category)
	{
		Action.call(this);
		
		this.resource = resource;
		this.manager = manager;
		this.category = category;
	}

	AddResourceAction.prototype.apply = function()
	{
		ResourceCrawler.addResource(this.manager, this.resource, this.category);
		
		AddResourceAction.updateGUI();
	};

	AddResourceAction.prototype.revert = function()
	{
		ResourceCrawler.removeResource(this.manager, this.resource, this.category);

		if(this.resource.dispose !== undefined)
		{
			this.resource.dispose();
		}

		RemoveResourceAction.updateGUI();
	};

	AddResourceAction.updateGUI = function()
	{
		Editor$1.updateObjectsViewsGUI();
	};

	var Global =
	{
		FILE_PATH: "./source/files/",
		RUNTIME_PATH: "./source/runtime/",
		BUILD_PATH: "./build/nunu.min.js"
	};

	/**
	 * Animation timer is a special type of timer that uses the requestAnimationFrame() method.
	 *
	 * This timer calls the method with the same rate as the screen refresh rate.
	 *
	 * @class AnimationTimer
	 * @param {Function} callback Timer callback function.
	 */
	function AnimationTimer(callback)
	{
		/**
		 * Task of the timer, executed at the timer defined rate.
		 * 
		 * @attribute callback
		 * @type {Function}
		 */
		this.callback = callback;
		/**
		 * Indicates if the timer is currently running, it is set to true on start and reset to false on stop.
		 * 
		 * @attribute running
		 * @type {boolean}
		 */
		this.running = false;

		/**
		 * ID of the currently waiting timeout clock. Used to cancel the already request execution of the next clock tick.
		 * 
		 * @attribute running
		 * @type {number}
		 */
		this.id = -1;
	}

	/**
	 * Start timer, is the timer is already running dosen't do anything.
	 * 
	 * @method start
	 */
	AnimationTimer.prototype.start = function()
	{
		if(this.running)
		{
			return;
		}

		this.running = true;

		var self = this;
		function loop()
		{
			self.callback();

			if(self.running)
			{
				self.id = requestAnimationFrame(loop);
			}
		}

		loop();
	};

	/**
	 * Stop animation timer.
	 * 
	 * @method stop
	 */
	AnimationTimer.prototype.stop = function()
	{
		this.running = false;
		cancelAnimationFrame(this.id);
	};

	/**
	 * Container for DOM image element.
	 * 
	 * @class ImageContainer
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function ImageContainer(parent)
	{
		Component.call(this, parent, "img");

		this.element.style.borderStyle = "none";
		this.element.style.objectFit = "contain"; // contain | cover | fill
	}

	ImageContainer.prototype = Object.create(Component.prototype);

	/**
	 * Set image from URL or source content.
	 * 
	 * @method setImage
	 * @param {string} source Image URL.
	 */
	ImageContainer.prototype.setImage = function(source)
	{
		this.element.src = source;
	};

	/**
	 * Loading box, used to force the user to wait for data from a request.
	 *
	 * Blocks every input event (cancels propagation).
	 * 
	 * @class LoadingModal
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function LoadingModal(parent)
	{
		Component.call(this, parent, "div");
		
		var self = this;

		this.element.style.backgroundColor = "var(--color-black-alpha-20)";
		this.element.style.zIndex = "200";

		/**
		 * Counter keeps the amount of requests to show the loadingBox.
		 *
		 * Is is incremented each time the box is show and decremented each time it is hidden.
		 *
		 * The box is only hidden if counter goes bellow 1.
		 *
		 * @attribute counter
		 * @type {number}
		 */
		this.counter = 0;

		/**
		 * Loading text.
		 *
		 * @attribute text
		 * @type {Text}
		 */
		this.text = new Text(this);
		this.text.setText("Loading data");
		this.text.setStyle("color", "var(--color-light)");

		/**
		 * Message presented in the loading box.
		 *
		 * @attribute message
		 * @type {Text}
		 */
		this.message = new Text(this);
		this.message.setText("Please wait");
		this.message.setStyle("color", "var(--color-light)");
		this.message.allowWordBreak(true);

		// Icon
		this.icon = new ImageContainer(this);
		this.icon.setImage("source/files/loading.png");
		
		var rotation = 0.0;
		
		// Animation
		this.timer = new AnimationTimer(function()
		{
			rotation += 0.05;
			self.icon.setStyle("transform", "rotate(" + rotation + "rad)");
		});
		
		// Event manager
		this.manager = new EventManager();
		this.manager.add(window, "resize", function(event)
		{
			self.updateInterface();
		});
	}

	LoadingModal.prototype = Object.create(Component.prototype);

	/**
	 * Show the loading box.
	 * 
	 * @method show
	 * @param {boolean} showCancel If true shows the cancel button.
	 * @param {Function} callback Callback function.
	 */
	LoadingModal.prototype.show = function()
	{	
		this.counter++;

		if(this.counter === 1)
		{
			this.timer.start();
			this.manager.create();
			this.visible = true;
			this.updateInterface();
		}
	};

	/**
	 * Hide modal box.
	 *
	 * @method hide
	 * @param {boolean} force Hide box and reset counter;
	 */
	LoadingModal.prototype.hide = function(force)
	{
		this.counter--;

		if(this.counter < 1 || force === true)
		{
			this.counter = 0;
			this.timer.stop();
			this.manager.destroy();
			this.setVisibility(false);
		}
	};

	LoadingModal.prototype.destroy = function()
	{
		Component.prototype.destroy.call(this);

		this.counter = 0;
		this.timer.stop();
		this.manager.destroy();
	};

	LoadingModal.prototype.updateSize = function()
	{
		this.size.copy(this.parent.size);

		Component.prototype.updateSize.call(this);

		// Text
		this.text.setStyle("fontSize", "38px");
		this.text.size.set(this.size.x, 100);
		this.text.center();
		this.text.position.y -= this.text.size.y;
		this.text.updateInterface();
		
		// Message
		this.message.setStyle("fontSize", "20px");
		this.message.size.set(this.size.x, 100);
		this.message.center();
		this.message.position.y -= this.message.size.y / 2;
		this.message.updateInterface();

		// Icon
		this.icon.size.set(80, 80);
		this.icon.center();
		this.icon.position.y += 30;
		this.icon.updateInterface();
	};

	/**
	 * DOM form element.
	 * 
	 * This element should be used to encapsulate input elements that require autocompletion.
	 * 
	 * @class Form
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function Form(parent)
	{
		Component.call(this, parent, "form");

		this.element.autocomplete = true;
		this.element.noValidate = true;
		this.element.action = "javascript:void(0)";
		this.element.addEventListener("submit", function(event)
		{
			event.preventDefault();
			return false;
		});
	}

	Form.prototype = Object.create(Component.prototype);

	/**
	 * Simulate the form submission.
	 * 
	 * Should be called when sending data to the server to trigger the browser autocomplete system.
	 * 
	 * Some form implementation might actually implement submission login under this method.
	 *
	 * @method submit
	 */
	Form.prototype.submit = function()
	{
		this.element.submit();
	};

	/**
	 * Body to represent the document.body 
	 * 
	 * It does not extend the Component class, but has the same base attributes and can be used as a parent for components.
	 *
	 * @static
	 * @class DocumentBody
	 */
	var DocumentBody = 
	{
		parent: null,
		element: document.body,
		mode: Component.TOP_LEFT,
		isComponent: true,
		visible: true,
		position: new three.Vector2(0, 0),
		_size: new three.Vector2(0, 0)
	};

	Object.defineProperties(DocumentBody,
	{
		size:
		{
			get: function()
			{
				this._size.set(window.innerWidth, window.innerHeight);
				return this._size;
			},
			set: function(){}
		}
	});

	function Loaders() {}

	/**
	 * Load texture from file object, checks the type of the file, can be used to load all types of textures
	 *
	 * Supports browser supported format (png, jpeg, bmp, gif, etc), and GPU compressed formats (pvr, dds, ktx, etc).
	 *
	 * @static
	 * @method loadTexture
	 * @param {File} file
	 * @param {Function} onLoad
	 */
	Loaders.loadTexture = function(file, onLoad)
	{
		// Load compressed texture from data parsed by the texture loaders.
		function loadCompressedTexture(data)
		{
			var texture = new CompressedTexture();
			
			if(data.isCubemap === true)
			{
				var faces = data.mipmaps.length / data.mipmapCount;

				texture.isCubeTexture = true;
				texture.image = [];

				for(var f = 0; f < faces; f++)
				{
					texture.image[f] = {mipmaps: []};

					for(var i = 0; i < data.mipmapCount; i ++)
					{
						texture.image[f].mipmaps.push(data.mipmaps[f * data.mipmapCount + i]);
						texture.image[f].format = data.format;
						texture.image[f].width = data.width;
						texture.image[f].height = data.height;
					}
				}

				texture.magFilter = three.LinearFilter;
				texture.minFilter = three.LinearFilter;
				texture.mapping = three.CubeReflectionMapping;
			}
			else
			{
				texture.image.width = data.width;
				texture.image.height = data.height;
				texture.mipmaps = data.mipmaps;
			}

			if(data.mipmapCount === 1)
			{
				texture.minFilter = three.LinearFilter;
			}

			texture.format = data.format;
			texture.needsUpdate = true;

			return texture;
		}

		var name = FileSystem.getFileName(file.name);
		var extension = FileSystem.getFileExtension(file.name);

		var reader = new FileReader();
		reader.onload = function()
		{
			if(extension === "dds")
			{
				var loader = new three.DDSLoader();
				var texture = loadCompressedTexture(loader.parse(reader.result));
				texture.name = name;
				Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
			}
			else if(extension === "pvr")
			{
				var loader = new three.PVRLoader();
				var texture = loadCompressedTexture(loader.parse(reader.result));
				texture.name = name;
				Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
			}
			else if(extension === "ktx")
			{
				var loader = new three.KTXLoader();
				var texture = loadCompressedTexture(loader.parse(reader.result));
				texture.name = name;
				Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
			}
			else if(extension === "tga")
			{
				var loader = new three.TGALoader();
				var jpeg = loader.parse(reader.result).toDataURL("image/jpeg", 1.0);

				var image = new Image(jpeg, "jpeg");
				Editor$1.addAction(new AddResourceAction(image, Editor$1.program, "images"));
				
				var texture = new Texture(image);
				texture.name = name;
				Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
			}
			else if(extension === "basis")
			{
				var renderer = new three.WebGLRenderer({alpha: true});

				var loader = new three.BasisTextureLoader();
				loader.setTranscoderPath(Global.FILE_PATH + "wasm/basis/");
				loader.detectSupport(renderer);
				loader._createTexture(reader.result).then(function(texture)
				{
					texture.encoding = THREE.sRGBEncoding;
					texture.name = name;
					Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
				}).catch(function(error)
				{
					Editor$1.alert("Error decoding basis texture.");
					console.error("nunuStudio: Error decoding basis texture.", error);
				});

				renderer.dispose();
			}
			else
			{
				var image = new Image(reader.result, extension);
				var texture = new Texture(image);
				texture.name = name;
				Editor$1.addAction(new AddResourceAction(image, Editor$1.program, "images"));
				Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
			}

			if(onLoad !== undefined)
			{
				onLoad(texture);
			}
		};
		reader.readAsArrayBuffer(file);
	};

	/**
	 * Load video file as texture from file object.
	 *
	 * @static
	 * @method loadVideoTexture
	 * @param {File} file
	 * @param {Function} onLoad Callback function called after the resource is loaded.
	 */
	Loaders.loadVideoTexture = function(file, onLoad)
	{
		var name = FileSystem.getFileName(file.name);
		var extension = FileSystem.getFileExtension(file.name);

		var reader = new FileReader();
		reader.onload = function()
		{
			var video = new Video(reader.result, extension);
			video.name = name;

			var texture = new VideoTexture(video);
			texture.name = name;

			Editor$1.addAction(new AddResourceAction(video, Editor$1.program, "videos"));
			Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));

			if(onLoad !== undefined)
			{
				onLoad(texture);
			}
		};

		reader.readAsArrayBuffer(file);
	};

	// Load audio from file object
	Loaders.loadAudio = function(file, onLoad)
	{
		var name = FileSystem.getFileName(file.name);
		var reader = new FileReader();

		reader.onload = function()
		{
			var audio = new Audio(reader.result);
			audio.name = name;
			
			if(onLoad !== undefined)
			{
				onLoad(audio);
			}

			Editor$1.addAction(new AddResourceAction(audio, Editor$1.program, "audio"));
		};

		reader.readAsArrayBuffer(file);
	};

	// Load font from file object
	Loaders.loadFont = function(file, onLoad)
	{
		var name = FileSystem.getFileName(file.name);
		var extension = FileSystem.getFileExtension(file.name);
		var reader = new FileReader();
		
		reader.onload = function()
		{
			if(extension === "json")
			{
				var font = new Font(JSON.parse(reader.result));
			}
			else
			{
				var font = new Font(reader.result);
				font.encoding = extension;
			}
			font.name = name;

			if(onLoad !== undefined)
			{
				onLoad(font);
			}

			Editor$1.addAction(new AddResourceAction(font, Editor$1.program, "fonts"));
		};

		if(extension === "json")
		{
			reader.readAsText(file);
		}
		else
		{
			reader.readAsArrayBuffer(file);
		}
	};

	/**
	 * Load spine animation file from file.
	 *
	 * Also searches for the .atlas file on the file path.
	 *
	 * @static
	 * @method loadSpineAnimation
	 * @param {File} file File to load.
	 */
	Loaders.loadSpineAnimation = function(file)
	{
		try
		{
			var path = FileSystem.getFilePath(file.path);

			var atlasFile = null;
			var files = FileSystem.getFilesDirectory(path);
			for(var i = 0; i < files.length; i++)
			{
				if(files[i].endsWith("atlas"))
				{
					atlasFile = path + files[i];
					break;
				}
			}

			if(atlasFile === null)
			{
				Editor$1.alert(Locale.failedLoadSpine);
				console.warn("nunuStudio: No atlas file found in the directory.");
				return;
			}

			var data = FileSystem.readFile(file.path);
			var atlas = FileSystem.readFile(atlasFile);

			var animation = new SpineAnimation(data, atlas, path);
			animation.name = FileSystem.getFileName(file.path);
			Editor$1.addObject(animation);
		}
		catch(e)
		{
			Editor$1.alert(Locale.failedLoadSpine + "(" + e + ")");
		}
	};

	/**
	 * Load text from file and add it as a resource to the program.
	 *
	 * @static
	 * @method loadText
	 * @param {File} file File to load.
	 */
	Loaders.loadText = function(file)
	{
		var reader = new FileReader();
		var name = FileSystem.getFileNameWithExtension(file.name);

		reader.onload = function()
		{
			var resource = new TextFile(reader.result, FileSystem.getFileExtension(name));
			resource.name = name;

			Editor$1.addAction(new AddResourceAction(resource, Editor$1.program, "resources"));
		};

		reader.readAsText(file);
	};

	/**
	 * Load a 3D file containing objects to be added to the scene.
	 *
	 * If no parent is specified it adds the objects to currently open scene.
	 * 
	 * @method loadModel
	 * @param {File} file File to be read and parsed.
	 * @param {Object3D} parent Object to add the objects.
	 */
	Loaders.loadModel = function(file, parent)
	{
		var name = file.name;
		var extension = FileSystem.getFileExtension(name);
		var path = (file.path !== undefined) ? FileSystem.getFilePath(file.path) : "";
		var modal = new LoadingModal(DocumentBody);
		modal.show();

		try
		{
			// GCode
			if(extension === "gcode")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					var loader = new three.GCodeLoader();
					var obj = loader.parse(reader.result);
					Editor$1.addObject(obj, parent);
					modal.destroy();
				};

				reader.readAsText(file);
			}
			// Wavefront OBJ
			else if(extension === "obj")
			{
				var materials = null;
				
				// Look for MTL file
				if(Nunu.runningOnDesktop())
				{
					try
					{
						var mtl = FileSystem.getNameWithoutExtension(file.path) + ".mtl";

						if(FileSystem.fileExists(mtl))
						{
							console.log("nunuStudio: MTL file found.", path);
							var mtlLoader = new three.MTLLoader();
							mtlLoader.setPath(path);
							materials = mtlLoader.parse(FileSystem.readFile(mtl), path);
						}
					}
					catch(f)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + f + ")");
						console.error("nunuStudio: Error loading file", f);
					}
				}

				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.OBJLoader();

						if(materials !== null)
						{
							loader.setMaterials(materials);
						}

						var obj = loader.parse(reader.result);
						obj.name = FileSystem.getFileName(name);
						Editor$1.addObject(obj, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};

				reader.readAsText(file);
			}
			//3MF
			else if(extension === "3mf")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.ThreeMFLoader();
						loader.parse(reader.result, function(obj)
						{
							Editor$1.addObject(obj, parent);
							modal.destroy();
						});
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// AWD
			else if(extension === "awd")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.AWDLoader();
						loader._baseDir = path;
						var awd = loader.parse(reader.result);
						Editor$1.addObject(awd, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// AMF
			else if(extension === "amf")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.AMFLoader();
						var amf = loader.parse(reader.result);
						Editor$1.addObject(amf, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// Assimp
			else if(extension === "assimp")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.AssimpLoader();
						var assimp = loader.parse(reader.result, path);
						Editor$1.addObject(assimp.object, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// Assimp JSON
			else if(name.endsWith(".assimp.json"))
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.AssimpJSONLoader();
						var json = JSON.parse(reader.result);
						var assimp = loader.parse(json, path);
						Editor$1.addObject(assimp, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			// Babylon
			else if(extension === "babylon")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.BabylonLoader();
						var json = JSON.parse(reader.result);
						var babylon = loader.parse(json, path);
						babylon.type = "Group";
						babylon.traverse(function(object)
						{
							if(object instanceof three.Mesh)
							{
								object.material = new three.MeshPhongMaterial();
							}
						});
						Editor$1.addObject(babylon, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			// Blender
			else if(extension === "blend")
			{	
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						JSBLEND(reader.result).then(function(blend)
						{
							var container = new Container();
							container.name = FileSystem.getNameWithoutExtension(name);
							blend.three.loadScene(container);
							Editor$1.addObject(container, parent);
							modal.destroy();
						});
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			//3DS
			else if(extension === "3ds")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.TDSLoader();
						loader.setPath(path);
						var group = loader.parse(reader.result);
						Editor$1.addObject(group, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// Collada
			else if(extension === "dae")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.ColladaLoader();
						var collada = loader.parse(reader.result, path);
						
						var scene = collada.scene;
						var animations = collada.animations;

						if(animations.length > 0)
						{
							scene.traverse(function(child)
							{
								if(child instanceof three.SkinnedMesh)
								{
									child.animations = animations;
								}
							});
						}
						
						Editor$1.addObject(scene, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			// Draco
			else if(extension === "drc")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.DRACOLoader();
						loader.setDecoderPath(Global.FILE_PATH + "wasm/draco/");
						loader.setDecoderConfig({type: "wasm"});
						loader.decodeDracoFile(reader.result, function(geometry)
						{
							loader.releaseDecoderModule();

							if(geometry.isBufferGeometry === true)
							{
								var normals = geometry.getAttribute("normal");
								if(normals === undefined)
								{
									geometry.computeVertexNormals();
								}
							}

							var mesh = new three.Mesh(geometry, Editor$1.defaultMaterial);
							Editor$1.addObject(mesh, parent);
							modal.destroy();
						});
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// GLTF
			else if(extension === "gltf" || extension === "glb")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var dracoLoader = new three.DRACOLoader();
						dracoLoader.setDecoderPath(Global.FILE_PATH + "wasm/draco/");
						dracoLoader.setDecoderConfig({type: "wasm"});

						var loader = new three.GLTFLoader();
						loader.dracoLoader = dracoLoader;
						loader.parse(reader.result, path, function(gltf)
						{
							dracoLoader.dispose();

							var scene = gltf.scene;
							scene.type = "Group";
							scene.name = FileSystem.getNameWithoutExtension(name);

							var animations = gltf.animations;
							if(animations.length > 0)
							{
								scene.traverse(function(child)
								{
									if(child instanceof three.SkinnedMesh)
									{
										child.animations = animations;
									}
								});
							}

							Editor$1.addObject(scene, parent);
							modal.destroy();
						});
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// PLY
			else if(extension === "ply")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.PLYLoader();
						var modelName = FileSystem.getNameWithoutExtension(name);

						var geometry = loader.parse(reader.result);
						geometry.name = modelName;

						var mesh = new three.Mesh(geometry, Editor$1.defaultMaterial);
						mesh.name = modelName;
						Editor$1.addObject(mesh, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			// VTK
			else if(extension === "vtk" || extension === "vtp")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.VTKLoader();
						var modelName = FileSystem.getNameWithoutExtension(name);
						var geometry = loader.parse(reader.result);
						geometry.name = modelName;

						var mesh = new three.Mesh(geometry, Editor$1.defaultMaterial);
						mesh.name = modelName;
						Editor$1.addObject(mesh, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// PRWM
			else if(extension === "prwm")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.PRWMLoader();
						var modelName = FileSystem.getNameWithoutExtension(name);

						var geometry = loader.parse(reader.result);
						geometry.name = modelName;

						var mesh = new three.Mesh(geometry, Editor$1.defaultMaterial);
						mesh.name = modelName;
						Editor$1.addObject(mesh, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			
			// VRML
			else if(extension === "wrl" || extension === "vrml")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.VRMLLoader();
						var scene = loader.parse(reader.result);

						for(var i = 0; i < scene.children.length; i++)
						{
							Editor$1.addObject(scene.children[i], parent);
						}

						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			// FBX
			else if(extension === "fbx")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.FBXLoader();
						var object = loader.parse(reader.result, path);
						
						if(object.animations !== undefined && object.animations.length > 0)
						{					
							object.traverse(function(child)
							{
								if(child instanceof three.SkinnedMesh)
								{
									child.animations = object.animations;
								}
							});
						}

						Editor$1.addObject(object, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// X
			else if(extension === "x")
			{
				function convertAnimation(baseAnime, name)
				{
					var animation = {};
					animation.fps = baseAnime.fps;
					animation.name = name;
					animation.hierarchy = [];

					for(var i = 0; i < baseAnime.hierarchy.length; i++)
					{
						var firstKey = -1;
						var lastKey = -1;

						var frame = {};
						frame.name = baseAnime.hierarchy[i].name;
						frame.parent = baseAnime.hierarchy[i].parent;
						frame.keys = [];

						for(var m = 1; m < baseAnime.hierarchy[i].keys.length; m++)
						{
							if(baseAnime.hierarchy[i].keys[m].time > 0)
							{
								if(firstKey === -1)
								{
									firstKey = m - 1;
									frame.keys.push(baseAnime.hierarchy[i].keys[m - 1]);
								}

								frame.keys.push(baseAnime.hierarchy[i].keys[m]);
							}

							animation.length = baseAnime.hierarchy[i].keys[m].time;

							if(m >= baseAnime.hierarchy[i].keys.length - 1)
							{
								break;
							}

						}

						animation.hierarchy.push(frame);
					}

					return animation;
				}

				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.XLoader();
						loader.baseDir = path;
						loader.parse(reader.result, function(object)
						{
							for(var i = 0; i < object.FrameInfo.length; i ++)
							{
								var model = object.FrameInfo[i];

								if(model instanceof three.SkinnedMesh)
								{
									if(object.XAnimationObj !== undefined && object.XAnimationObj.length > 0)
									{
										var animations = object.XAnimationObj;
										for(var j = 0; j < animations.length; j++)
										{
											model.animationSpeed = 1000;
											model.animations.push(three.AnimationClip.parseAnimation(convertAnimation(animations[j], animations[j].name), model.skeleton.bones));
										}
									}
								}

								Editor$1.addObject(model, parent);
							}
							modal.destroy();
						});
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// PCD
			else if(extension === "pcd")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.PCDLoader();
						var pcd = loader.parse(reader.result, file.name);
						pcd.material.name = "points";

						Editor$1.addObject(pcd, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// SVG
			else if(extension === "svg")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.SVGLoader();
						var paths = loader.parse(reader.result);

						var group = new Container();
						var position = 0;

						for(var i = 0; i < paths.length; i ++)
						{
							var material = new three.MeshBasicMaterial({color: paths[i].color});
							var shapes = paths[i].toShapes(true);

							for(var j = 0; j < shapes.length; j++)
							{
								var shape = shapes[j];
								var geometry = new three.ShapeBufferGeometry(shape);
								var mesh = new three.Mesh(geometry, material);
								mesh.position.z = position;
								position += 0.1;
								group.add(mesh);
							}
						}

						Editor$1.addObject(group, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			// STL
			else if(extension === "stl")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.STLLoader();

						var modelName = FileSystem.getNameWithoutExtension(name);
						var geometry = loader.parse(reader.result);
						geometry.name = modelName;

						Editor$1.addObject(new three.Mesh(geometry, Editor$1.defaultMaterial), parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsArrayBuffer(file);
			}
			// threejs JSON
			else if(extension === "json")
			{
				var reader = new FileReader();
				reader.onload = function()
				{
					try
					{
						var loader = new three.JSONLoader();
						var data = loader.parse(JSON.parse(reader.result));
						var materials = data.materials;
						var geometry = data.geometry;

						// Material
						var material = null;
						if(materials === undefined || materials.length === 0)
						{
							material = Editor$1.defaultMaterial;
						}
						else if(materials.length === 1)
						{
							material = materials[0];
						}
						else if(materials.length > 1)
						{
							material = materials;
						}

						// Mesh
						var mesh = null;
						if(geometry.bones.length > 0)
						{
							mesh = new three.SkinnedMesh(geometry, material);
						}
						else
						{
							mesh = new three.Mesh(geometry, material);
						}

						Editor$1.addObject(mesh, parent);
						modal.destroy();
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
						console.error("nunuStudio: Error loading file", e);
					}
				};
				reader.readAsText(file);
			}
			else
			{
				modal.destroy();
				Editor$1.alert(Locale.unknownFileFormat);
				console.warn("nunuStudio: Unknown file format");
			}
		}
		catch(e)
		{
			modal.destroy();
			Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
			console.error("nunuStudio: Error loading file", e);
		}
	};

	/**
	 * Add an object to the scene.
	 *
	 * The object can be inserted at a specific index inside the children list.
	 *
	 * @class AddAction
	 * @extends {Action}
	 * @param {Object3D} object Object to be added.
	 * @param {Object3D} parent Parent to add the object.
	 * @param {number} index Index to add the object to.
	 */
	function AddAction(object, parent, index)
	{
		Action.call(this);
		
		this.object = object;
		this.index = (index !== undefined) ? index : -1;

		this.parent = parent;
	}

	AddAction.prototype.apply = function()
	{
		if(this.index !== -1)
		{
			this.parent.children.splice(this.index, 0, this.object);
			this.object.parent = this.parent;
		}
		else
		{
			this.parent.add(this.object);
			this.index = this.parent.children.indexOf(this.object);
		}

		AddAction.updateGUI(this.object, this.parent, this.index);
	};

	AddAction.prototype.revert = function()
	{
		this.parent.remove(this.object);

		RemoveAction.updateGUI(this.object, this.parent);
	};

	AddAction.updateGUI = function(object, parent, index)
	{
		Editor$1.gui.tree.addObject(object, parent, index);
	};

	/**
	 * Remove object from the scene.
	 *
	 * @class RemoveAction
	 * @extends {Action}
	 * @param {Object3D} object
	 * @param {Object3D} parent Optional.
	 */
	function RemoveAction(object, parent)
	{
		Action.call(this);
		
		this.object = object;

		this.parent = (parent !== undefined) ? parent : object.parent;
		this.index = -1;
	}

	RemoveAction.prototype.apply = function()
	{
		if(this.object instanceof three.Camera)
		{
			var scene = this.object.getScene();
			if(scene !== null)
			{
				scene.removeCamera(this.object);
			}
		}
		
		this.index = this.parent.children.indexOf(this.object);
		this.parent.remove(this.object);

		RemoveAction.updateGUI(this.object, this.parent);
	};

	RemoveAction.prototype.revert = function()
	{
		if(this.index === -1)
		{
			this.parent.add(this.object);
		}
		else
		{
			this.parent.children.splice(this.index, 0, this.object);
			this.object.parent = this.parent;
		}

		AddAction.updateGUI(this.object, this.parent, this.index);
	};

	RemoveAction.updateGUI = function(object, parent)
	{
		if(Editor$1.isSelected(object))
		{
			Editor$1.unselectObject(object);
		}

		Editor$1.gui.tree.removeObject(object, parent);
	};

	/**
	 * Swap an object for another one.
	 *
	 * The children of the original object can be moved to the new object.
	 *
	 * @class SwapAction
	 * @extends {Action}
	 * @param {Object3D} originalObject Object originally in place, to be replaced.
	 * @param {Object3D} newObject Object to take place of the old one.
	 * @param {boolean} moveChildren If true move the children from the original object to the new.
	 */
	function SwapAction(originalObject, newObject, moveChildren)
	{
		Action.call(this);
		
		this.originalObject = originalObject;
		this.newObject = newObject;

		this.parent = this.originalObject.parent;
		this.index = -1;
		
		this.moveChildren = moveChildren !== undefined ? moveChildren : true;
	}

	SwapAction.prototype.apply = function()
	{	
		// Check the index
		this.index = this.parent.children.indexOf(this.originalObject);

		// Remove object
		this.parent.remove(this.originalObject);

		// Add new object to parent
		this.newObject.parent = this.parent;
		this.parent.children.splice(this.index, 0, this.newObject);

		// Move children from original to new
		if(this.moveChildren)
		{
			while(this.originalObject.children.length > 0)
			{
				var children = this.originalObject.children[0];
				this.originalObject.remove(children);
				this.newObject.add(children);
			}
		}

		RemoveAction.updateGUI(this.originalObject, this.parent);
		AddAction.updateGUI(this.newObject, this.parent, this.index);
	};

	SwapAction.prototype.revert = function()
	{
		this.parent.remove(this.newObject);

		// Add original object to parent
		this.originalObject.parent = this.parent;
		this.parent.children.splice(this.index, 0, this.originalObject);

		// Move children from new back to original
		if(this.moveChildren)
		{
			while(this.newObject.children.length > 0)
			{
				var children = this.newObject.children[0];
				this.newObject.remove(children);
				this.originalObject.add(children);
			}
		}

		RemoveAction.updateGUI(this.newObject, this.parent);
		AddAction.updateGUI(this.originalObject, this.parent, this.index);
	};

	/**
	 * Action to represent a object move in the children tree.
	 *
	 * Objects can be moved between parents, and to specific positions (index).
	 *
	 * If necessary the action can also calculate the inverse tranform to estimate new pose values to keep the global pose of the moved object the same.
	 *
	 * @class MoveAction
	 * @extends {Action}
	 * @param {Object3D} object Object to be moved.
	 * @param {Object3D} newParent New parent of the object.
	 * @param {number} newIndex Index to insert the object.
	 */
	function MoveAction(object, newParent, newIndex, keepGlobalPose)
	{
		Action.call(this);
		
		this.object = object;

		this.oldParent = object.parent;
		this.oldIndex = this.oldParent.children.indexOf(this.object);

		this.newParent = newParent;
		this.newIndex = newIndex;

		this.keepGlobalPose = keepGlobalPose !== undefined ? keepGlobalPose : Editor$1.settings.editor.keepTransformMove;
	}

	MoveAction.prototype.apply = function()
	{
		this.oldParent.remove(this.object);
		
		if(this.keepGlobalPose)
		{
			this.inverseTransform(this.oldParent, this.newParent);
		}

		if(this.newIndex === undefined)
		{
			this.newParent.add(this.object);
			this.newIndex = this.newParent.children.indexOf(this.object);
		}
		else
		{
			var children = this.newParent.children;
			children.splice(this.newIndex, 0, this.object);
			this.object.parent = this.newParent;
		}

		MoveAction.updateGUI(this.object, this.oldParent, this.newParent, this.newIndex);
	};

	MoveAction.prototype.revert = function()
	{
		this.newParent.remove(this.object);

		if(this.keepGlobalPose)
		{
			this.inverseTransform(this.newParent, this.oldParent);
		}

		var children = this.oldParent.children;
		children.splice(this.oldIndex, 0, this.object);
		this.object.parent = this.oldParent;

		MoveAction.updateGUI(this.object, this.newParent, this.oldParent, this.oldIndex);
	};

	MoveAction.prototype.inverseTransform = function(oldParent, newParent)
	{
		var matrix = this.object.matrix;

		// Apply world matrix to object (calculate transform as if it was on the root)
		matrix.multiplyMatrices(oldParent.matrixWorld, matrix);

		// Get inverse of the world matrix of the new parent
		var inverse = new three.Matrix4();
		inverse.getInverse(newParent.matrixWorld);

		// Apply inverse transform to the object matrix
		matrix.multiplyMatrices(inverse, matrix);

		// Decompose matrix into components
		matrix.decompose(this.object.position, this.object.quaternion, this.object.scale);
	};

	MoveAction.updateGUI = function(object, oldParent, newParent, newIndex)
	{
		if(this.keepGlobalPose)
		{
			Editor$1.gui.inspector.updateValues();
		}
		
		Editor$1.gui.tree.moveObject(object, oldParent, newParent, newIndex);
	};

	/**
	 * Stores change to one object attribute.
	 * 
	 * @class ChangeAction
	 * @extends {Action}
	 * @param {Object} object Object to be changed.
	 * @param {string} attribute Name of the attribute.
	 * @param {Object} newValue New value for the object attribute.
	 * @param {Object} oldValue Optionally we can pass the old value.
	 */
	function ChangeAction(object, attribute, newValue, oldValue)
	{
		Action.call(this);

		this.object = object;
		this.attribute = attribute;
		this.newValue = newValue;
		this.oldValue = oldValue !== undefined ? oldValue : (ChangeAction.isVetorial(object[attribute]) ? object[attribute].clone() : object[attribute]);
	}

	ChangeAction.prototype.apply = function()
	{
		if(ChangeAction.isVetorial(this.object[this.attribute]))
		{
			this.object[this.attribute].copy(this.newValue);
		}
		else
		{
			this.object[this.attribute] = this.newValue;
		}

		ChangeAction.updateGUI(this.object, this.attribute, this.newValue);
	};

	ChangeAction.prototype.revert = function()
	{
		if(ChangeAction.isVetorial(this.object[this.attribute]))
		{
			this.object[this.attribute].copy(this.oldValue);
		}
		else
		{
			this.object[this.attribute] = this.oldValue;
		}

		ChangeAction.updateGUI(this.object, this.attribute, this.oldValue);
	};

	ChangeAction.updateGUI = function(object, attribute, newValue)
	{
		if(object instanceof three.Material)
		{
			object.needsUpdate = true;
		}
		else if(object instanceof three.Texture)
		{
			object.needsUpdate = true;
		}

		Editor$1.updateObjectsViewsGUI();

		if(Editor$1.isSelected(object))
		{
			Editor$1.gui.inspector.updateValues();
		}
	};

	/**
	 * Check if a attribute is a THREE vectorial data type.
	 * 
	 * Vetorial types have some common methods (toArray, copy, fromArray).
	 *
	 * (Matrix3, Matrix4, Vector2, Vector3, Vector4, Quaternion, Euler).
	 * 
	 * @static
	 * @method isVetorial
	 * @param {Object} object To be checked.
	 */
	ChangeAction.isVetorial = function(object)
	{
		if(object === null || object === undefined)
		{
			return false;
		}

		return object.isVector3 === true || object.isEuler === true || (object instanceof three.Quaternion) || object.isVector2 === true || object.isVector4 === true || object.isMatrix3 === true || object.isMatrix4 === true;
	};

	/**
	 * Stores a bundle of ordered actions.
	 * 
	 * Actions are applied in the same order as they were inserted and reverted in inverse order.
	 * 
	 * @class ActionBundle
	 * @extends {Action}
	 * @param {Array} actions Array of actions to create the bundle.
	 */
	function ActionBundle(actions)
	{
		Action.call(this);

		this.actions = actions;
	}

	ActionBundle.prototype.apply = function()
	{
		for(var i = 0; i < this.actions.length; i++)
		{
			this.actions[i].apply();
		}
	};

	ActionBundle.prototype.revert = function()
	{
		for(var i = 0; i < this.actions.length; i++)
		{
			this.actions[i].revert();
		}
	};

	/**
	 * The unit convertor is responsible for performing unit conversion between values.
	 *
	 * Units are represented by their natural texture unit representation (m/s, km/s, n/m, etc).
	 *
	 * @static
	 * @class UnitConverter
	 */
	function UnitConverter(){}

	/**
	 * Scale levels.
	 *
	 * Is a map containing the scale symbol and its value.
	 *
	 * @static
	 * @attribute scales
	 * @type {Map}
	 */
	UnitConverter.scales = new Map(
	[
		["Y", 1e24],
		["Z", 1e21],
		["E", 1e18],
		["P", 1e15],
		["T", 1e12],
		["G", 1e9],
		["M", 1e6],
		["k", 1e3],
		["m", 1e-3],
		["u", 1e-6],
		["n", 1e-9],
		["p", 1e-12],
		["f", 1e-15],
		["a", 1e-18],
		["z", 1e-21],
		["y", 1e-24]
	]);

	/**
	 * List of known units.
	 *
	 * It a map containing sub maps that contains methods that allow getting to the unit refered.
	 *
	 * @static
	 * @attribute units
	 * @type {Map}
	 */
	UnitConverter.units = new Map(
	[
		// Distance
		["m", new Map([["i", function(i){return i / 39.3701;}]])], // Meter
		["i", new Map([["m", function(m){return m * 39.3701;}]])], // Inch

		// Mass
		["g", null], // Gram
		
		// Time
		["s", null], // Second

		// Temperature
		["c", new Map([["k", function(k){return k - 273.15;}], ["f", function(f){return (f - 32) / 1.8;}]])], // Celsius
		["k", new Map([["c", function(c){return c + 273.15;}], ["f", function(f){return (f - 32) / 1.8 + 273.15;}]])], // Kelvin
		["f", new Map([["c", function(c){return c * 1.8 + 32;}], ["k", function(k){return k * 1.8 - 459.67;}]])], // Fahrenheit

		// Angle
		["d", new Map([["r", function(r){return r * (180 / Math.PI);}]])], // Degrees
		["r", new Map([["d", function(d){return d / (180 / Math.PI);}]])] // Radians
	]);

	/**
	 * Convert a unit form one input unit to another unit.
	 * 
	 * @static
	 * @method convert
	 * @param {Number} value Input value to be converted.
	 * @param {Number} inUnit Input original unit.
	 * @param {Number} outUnit Input output unit.
	 * @return {Number} Retuns the value converted based on input and output units, if the value cannot be converted returns null.
	 */
	UnitConverter.convert = function(value, inUnit, outUnit)
	{
		if(inUnit.length > 1)
		{
			value *= UnitConverter.scales.get(inUnit.charAt(0));
			inUnit = inUnit.slice(1);
		}

		var outScale = 1;
		if(outUnit.length > 1)
		{
			outScale = UnitConverter.scales.get(outUnit.charAt(0));
			outUnit = outUnit.slice(1);
		}
		
		if(inUnit === outUnit)
		{
			return value / outScale;
		}

		return UnitConverter.units.get(outUnit).get(inUnit)(value) / outScale;
	};

	/**
	 * Utils to access the browser local storage.
	 *
	 * @static
	 * @class LocalStorage
	 */
	function LocalStorage(){}

	/**
	 * Store value in the local storage.
	 * 
	 * @static
	 * @method set
	 * @param {string} key
	 * @param {Object} value
	 */
	LocalStorage.set = function(key, value)
	{
		if(typeof value === "object")
		{
			window.localStorage.setItem(key, JSON.stringify(value));
		}
		else
		{
			window.localStorage.setItem(key, value);
		}
	};

	/**
	 * Get value from the local storage.
	 * 
	 * @static
	 * @method get
	 * @param {string} key
	 * @return {Object} Value obtained from the storage.
	 */
	LocalStorage.get = function(key)
	{
		var value = window.localStorage.getItem(key);

		try
		{
			return JSON.parse(value);
		}
		catch(e)
		{
			return value;
		}
	};

	/**
	 * Check if a key exists in the local storage.
	 * 
	 * @static
	 * @method exists
	 * @param {string} key
	 * @return {boolean} True if the key exists false otherwise.
	 */
	LocalStorage.exists = function(key)
	{
		return window.localStorage.getItem(key) !== null;
	};

	/**
	 * Delete a key from the local storage.
	 * 
	 * @static
	 * @method delete
	 * @param {string} key
	 */
	LocalStorage.delete = function(key)
	{
		return window.localStorage.removeItem(key);
	};

	/** 
	 * Settings store all user configurable settings of the editor.
	 *
	 * Everything regarding editor, code analysis, rendering etc is stored in this object.
	 *
	 * @constructor
	 * @class Settings
	 */
	function Settings()
	{
		this.loadDefault();
	}

	/**
	 * Path to the configuration file if running ouside of the browser.
	 *
	 * @static
	 * @attribute CONFIG_FILE
	 * @type {string}
	 */
	Settings.CONFIG_FILE = "config.json";

	/**
	 * Angle in radians, stores the radian symbol as used in the UnitConverter.
	 *
	 * @static
	 * @attribute RADIAN
	 * @type {string}
	 */
	Settings.RADIAN = "r";

	/**
	 * Angle in degrees, stores the degree symbol as used in the UnitConverter.
	 *
	 * @static
	 * @attribute RADIAN
	 * @type {string}
	 */
	Settings.DEGREE = "d";

	// Distance
	Settings.METER = "m";

	// Navigation
	Settings.FIRST_PERSON = 10;
	Settings.ORBIT = 11;
	Settings.PLANAR_LEFT = 12;
	Settings.PLANAR_RIGHT = 13;
	Settings.PLANAR_FRONT = 14;
	Settings.PLANAR_BACK = 15;
	Settings.PLANAR_TOP = 16;
	Settings.PLANAR_BOTTOM = 17;

	// Update channel
	Settings.STABLE = 30;
	Settings.BETA = 31;

	// Load default settings
	Settings.prototype.loadDefault = function()
	{
		// General
		this.general =
		{		
			autoUpdate: false,
			theme: "dark",
			filePreviewSize: 70,
			showStats: true,
			showUUID: true,
			showType: true,
			immediateMode: false,
			historySize: 20,
			ignorePixelRatio: false,
		};

		// Units
		this.units =
		{
			/**
			 * The units to use for angle in the editor, for most object the base units are radians. Use the UnitConvert to ensure the correct format.
			 *
			 * For example if the object data is natively in radians call UnitConverter.convert(angle, "r", Editor.settings.units.angle);
			 *
			 * @type {string}
			 * @attribute angle
			 */
			angle: Settings.RADIAN,

			distance: Settings.METER
		};

		// Editor
		this.editor =
		{
			snap: false,
			snapAngle: 0.1,
			keepTransformMove: true,
			gridSize: 500,
			gridSpacing: 5,
			gridEnabled: true,
			gridFixed: false,
			axisEnabled: true,
			cameraPreviewEnabled: true,
			cameraPreviewSize: 200,
			cameraPreviewPosition: Viewport.BOTTOM_RIGHT,
			lockMouse: true,
			transformationSpace: "world",
			navigation: Settings.ORBIT,
			invertNavigation: false,
			keyboardNavigation: false,
			keyboardNavigationSpeed: 0.5,
			mouseLookSensitivity: 0.002,
			mouseMoveSpeed: 0.001,
			mouseWheelSensitivity: 0.0005,
			cameraRotationCube: true,
			cameraRotationCubeSize: 120
		};

		// Render
		this.render = new RendererConfiguration();
		this.render.followProject = true;

		// Code
		this.code =
		{
			theme: "monokai",
			keymap: "sublime",
			fontSize: 14,
			lineNumbers: true,
			lineWrapping: false,
			autoCloseBrackets: true,
			highlightActiveLine: false,
			showMatchesOnScrollbar: true,
			dragFiles: true,
			indentWithTabs: true,
			tabSize: 4,
			indentUnit: 4,
			vimMode: false,
			smartIndent: false,
			matchBrackets: true
		};

		// JSLint
		this.jslint =
		{
			// Error
			maxerr: 50, // {int} Maximum error before stopping

			// Enforcing
			bitwise: false, // true: Prohibit bitwise operators (&, |, ^, etc.)
			curly: false, // true: Require {} for every new block or scope
			eqeqeq: false, // true: Require triple equals (===) for comparison
			forin: false, // true: Require filtering for..in loops with obj.hasOwnProperty()
			freeze: true, // true: prohibits overwriting prototypes of native objects such as Array, Date etc.
			latedef: false, // true: Require variables/functions to be defined before being used
			noarg: true, // true: Prohibit use of `arguments.caller` and `arguments.callee`
			nonbsp: true, // true: Prohibit non-breaking whitespace characters.
			nonew: false, // true: Prohibit use of constructors for side-effects (without assignment)
			plusplus: false, // true: Prohibit use of `++` and `--`
			undef: false, // true: Require all non-global variables to be declared (prevents global leaks)
			unused: false, // Unused variables:
							// true: all variables, last function parameter
							// "vars": all variables only
							// "strict": all variables, all function parameters
			strict: false, // true: Requires all functions run in ES5 Strict Mode
			maxparams: false, // {int} Max number of formal params allowed per function
			maxdepth: false, // {int} Max depth of nested blocks (within functions)
			maxstatements: false, // {int} Max number statements per function
			maxcomplexity: false, // {int} Max cyclomatic complexity per function
			varstmt: false, // true: Disallow any var statements. Only `let` and `const` are allowed.

			// Relaxing
			asi: true, // true: Tolerate Automatic Semicolon Insertion (no semicolons)
			boss: true, // true: Tolerate assignments where comparisons would be expected
			debug: true, // true: Allow debugger statements e.g. browser breakpoints.
			eqnull: true, // true: Tolerate use of `== null`
			esversion: 6, // {int} Specify the ECMAScript version to which the code must adhere.
			moz: true, // true: Allow Mozilla specific syntax (extends and overrides esnext features)
			evil: true, // true: Tolerate use of `eval` and `new Function()`
			expr: true, // true: Tolerate `ExpressionStatement` as Programs
			funcscope: true, // true: Tolerate defining variables inside control statements
			iterator: true, // true: Tolerate using the `__iterator__` property
			lastsemic: true, // true: Tolerate omitting a semicolon for the last statement of a 1-line block
			laxbreak: false, // true: Tolerate possibly unsafe line breakings
			loopfunc: true, // true: Tolerate functions being defined in loops
			noyield: false, // true: Tolerate generator functions with no yield statement in them.
			notypeof: true, // true: Tolerate invalid typeof operator values
			proto: true, // true: Tolerate using the `__proto__` property
			scripturl: false, // true: Tolerate script-targeted URLs
			shadow: true, // true: Allows re-define variables later in code e.g. `var x=1; x=2;`
			sub: true, // true: Tolerate using `[]` notation when it can still be expressed in dot notation
			supernew: true, // true: Tolerate `new function () { ... };` and `new Object;`
			validthis: true, // true: Tolerate using this in a non-constructor function

			// Environment
			browser: true, // Web Browser (window, document, etc)
			browserify: false, // Browserify (node.js code in the browser)
			couch: false, // CouchDB
			devel: true, // Development/debugging (alert, confirm, etc)
			dojo: false, // Dojo Toolkit
			jasmine: false, // Jasmine
			jquery: false, // jQuery
			mocha: true, // Mocha
			mootools: false, // MooTools
			node: false, // Node.js
			nonstandard: false, // Widely adopted globals (escape, unescape, etc)
			phantom: false, // PhantomJS
			prototypejs: false, // Prototype and Scriptaculous
			qunit: false, // QUnit
			rhino: false, // Rhino
			shelljs: false, // ShellJS
			typed: false, // Globals for typed array constructions
			worker: false, // Web Workers
			wsh: false, // Windows Scripting Host
			yui: false, // Yahoo User Interface
		};
	};

	/**
	 * Store settings in the local storage.
	 *
	 * @method store
	 */
	Settings.prototype.store = function()
	{
		var data = JSON.stringify(
		{
			general: this.general,
			editor: this.editor,
			units: this.units,
			render: this.render,
			code: this.code,
			jslint: this.jslint
		}, null, "\t");

		// Make json file human readable
		data.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, "$1");
		
		// Store file
		if(Nunu.runningOnDesktop())
		{
			FileSystem.writeFile(Settings.CONFIG_FILE, data);
		}
		// Cookie
		else
		{
			LocalStorage.set("config", data);
		}
	};

	/**
	 * Load settings from the local storage.
	 *
	 * @method load
	 */
	Settings.prototype.load = function()
	{
		try
		{
			if(Nunu.runningOnDesktop())
			{
				var data = JSON.parse(FileSystem.readFile(Settings.CONFIG_FILE));
			}
			else
			{
				var data = LocalStorage.get("config");
			}

			for(var i in data)
			{
				if(this[i] === undefined)
				{
					this[i] = {};
				}

				for(var j in data[i])
				{
					this[i][j] = data[i][j];
				}
			}
		}
		catch(e)
		{
			console.warn("nunuStudio: Failed to load configuration file");
		}
	};

	/** 
	 * Orietantion cube can be used to preview and change the rotation of an object.
	 * 
	 * Is used in the editor to preview and manipulate the camera prespective.
	 * 
	 * @class OrientationCube
	 */
	function OrientationCube()
	{
		/**
		 * Orientation cube viewport.
		 * 
		 * @attribute viewport
		 * @type {Viewport}
		 */
		this.viewport = new Viewport(Viewport.ABSOLUTE);
		this.viewport.size.set(150, 150);
		this.viewport.offset.set(10, 10);
		this.viewport.anchor = Viewport.TOP_RIGHT;
		
		/**
		 * Cube visualization camera
		 *
		 * @attribute camera
		 * @type {PerspectiveCamera}
		 */
		this.camera = new three.PerspectiveCamera(60, 1, 0.1, 10);
		this.camera.position.z = 2;

		// Raycaster
		this.raycaster = new three.Raycaster();
		this.normalized = new three.Vector2(0, 0);

		// Scene
		this.scene = new three.Scene();
		this.scene.matrixAutoUpdate = false;

		// Selected face
		this.selected = null;

		var plane = new three.PlaneBufferGeometry(1, 1);

		// Cube faces
		var texture = new Texture(Global.FILE_PATH + "camera/xPos.png");
		texture.format = three.RGBFormat;
		this.xPos = new three.Mesh(plane, new three.MeshBasicMaterial({map: texture}));
		this.xPos.code = OrientationCube.X_POS;
		this.xPos.position.set(0.5, 0, 0);
		this.xPos.rotation.set(0, Math.PI / 2, 0);
		this.xPos.matrixAutoUpdate = false;
		this.xPos.updateMatrix();
		this.scene.add(this.xPos);

		var texture = new Texture(Global.FILE_PATH + "camera/xNeg.png");
		texture.format = three.RGBFormat;
		this.xNeg = new three.Mesh(plane, new three.MeshBasicMaterial({map: texture}));
		this.xNeg.code = OrientationCube.X_NEG;
		this.xNeg.position.set(-0.5, 0, 0);
		this.xNeg.rotation.set(0, -Math.PI / 2, 0);
		this.xNeg.matrixAutoUpdate = false;
		this.xNeg.updateMatrix();
		this.scene.add(this.xNeg);

		var texture = new Texture(Global.FILE_PATH + "camera/yPos.png");
		texture.format = three.RGBFormat;
		this.yPos = new three.Mesh(plane, new three.MeshBasicMaterial({map: texture}));
		this.yPos.code = OrientationCube.Y_POS;
		this.yPos.position.set(0, 0.5, 0);
		this.yPos.rotation.set(-Math.PI / 2, 0, 0);
		this.yPos.matrixAutoUpdate = false;
		this.yPos.updateMatrix();
		this.scene.add(this.yPos);

		var texture = new Texture(Global.FILE_PATH + "camera/yNeg.png");
		texture.format = three.RGBFormat;
		this.yNeg = new three.Mesh(plane, new three.MeshBasicMaterial({map: texture}));
		this.yNeg.code = OrientationCube.Y_NEG;
		this.yNeg.position.set(0, -0.5, 0);
		this.yNeg.rotation.set(Math.PI / 2, 0, 0);
		this.yNeg.matrixAutoUpdate = false;
		this.yNeg.updateMatrix();
		this.scene.add(this.yNeg);

		var texture = new Texture(Global.FILE_PATH + "camera/zPos.png");
		texture.format = three.RGBFormat;
		this.zPos = new three.Mesh(plane, new three.MeshBasicMaterial({map: texture}));
		this.zPos.code = OrientationCube.Z_POS;
		this.zPos.position.set(0, 0, 0.5);
		this.zPos.matrixAutoUpdate = false;
		this.zPos.updateMatrix();
		this.scene.add(this.zPos);

		var texture = new Texture(Global.FILE_PATH + "camera/zNeg.png");
		texture.format = three.RGBFormat;
		this.zNeg = new three.Mesh(plane, new three.MeshBasicMaterial({map: texture}));
		this.zNeg.code = OrientationCube.Z_NEG;
		this.zNeg.position.set(0, 0, -0.5);
		this.zNeg.rotation.set(0, Math.PI, 0);
		this.zNeg.matrixAutoUpdate = false;
		this.zNeg.updateMatrix();
		this.scene.add(this.zNeg);
	}

	OrientationCube.X_POS = 0;
	OrientationCube.X_NEG = 1;
	OrientationCube.Y_POS = 2;
	OrientationCube.Y_NEG = 3;
	OrientationCube.Z_POS = 4;
	OrientationCube.Z_NEG = 5;

	/**
	 * Raycast cube from mouse normalized coordinates.
	 *
	 * @method raycast
	 */
	OrientationCube.prototype.raycast = function(mouse, canvas)
	{
		if(this.viewport.isInside(canvas, mouse))
		{
			this.raycaster.setFromCamera(this.viewport.getNormalized(canvas, mouse), this.camera);

			var intersects = this.raycaster.intersectObjects(this.scene.children, true);
			if(intersects.length > 0)
			{
				this.selected = intersects[0].object;
				this.selected.material.color.set(0xFFFF00);
				return intersects[0].object.code
			}
		}

		return null;
	};

	// Update cube position from camera
	OrientationCube.prototype.updateRotation = function(camera)
	{
		this.scene.quaternion.copy(camera.quaternion);
		this.scene.updateMatrix();
		this.scene.matrix.getInverse(this.scene.matrix);
	};

	/**
	 * Render cube to canvas using a renderer orientation.
	 *
	 * @method render
	 */
	OrientationCube.prototype.render = function(renderer, canvas)
	{
		this.viewport.width = renderer.domElement.width;
		this.viewport.height = renderer.domElement.height;
		this.viewport.update();
		this.viewport.enable(renderer);

		renderer.render(this.scene, this.camera);

		if(this.selected !== null)
		{
			this.selected.material.color.set(0xFFFFFF);
			this.selected = null;
		}
	};

	/**
	 * Basic material to represent the solid portion of a gizmo.
	 *
	 * @class GizmoMaterial
	 * @extends {MeshBasicMaterial}
	 */
	function GizmoMaterial(parameters)
	{
		three.MeshBasicMaterial.call(this);

		this.depthTest = false;
		this.depthWrite = false;
		this.side = three.FrontSide;
		this.transparent = true;

		this.setValues(parameters);

		this.baseColor = this.color.clone();
		this.baseOpacity = this.opacity;
	}

	GizmoMaterial.prototype = Object.create(three.MeshBasicMaterial.prototype);

	GizmoMaterial.red = new GizmoMaterial({color: 0xff0000});
	GizmoMaterial.green = new GizmoMaterial({color: 0x00ff00});
	GizmoMaterial.blue = new GizmoMaterial({color: 0x0000ff});
	GizmoMaterial.yellow = new GizmoMaterial({color: 0xFFFF00});
	GizmoMaterial.yellowAlpha = new GizmoMaterial({color: 0xFFFF00, opacity: 0.25});
	GizmoMaterial.cyan = new GizmoMaterial({color: 0x00ffff});
	GizmoMaterial.cyanAlpha = new GizmoMaterial({color: 0x00ffff, opacity: 0.25});
	GizmoMaterial.magenta = new GizmoMaterial({color: 0xff00ff});
	GizmoMaterial.magentaAlpha = new GizmoMaterial({color: 0xff00ff, opacity: 0.25});
	GizmoMaterial.grey = new GizmoMaterial({color: 0x787878});
	GizmoMaterial.whiteAlpha = new GizmoMaterial({color: 0xFFFFFF, opacity: 0.25});

	/**
	 * Toggle the highlight state of a gizmo material.
	 *
	 * @method highlight
	 * @param {boolean} highlighted
	 */
	GizmoMaterial.prototype.highlight = function(highlighted)
	{
		if(highlighted)
		{
			this.color.setRGB(1.0, 1.0, 0);
			this.opacity = 1.0;
		}
		else
		{
			this.color.copy(this.baseColor);
			this.opacity = this.baseOpacity;
		}
	};

	/**
	 * Basic material to represent the line portions of a gizmo.
	 *
	 * @class GizmoMaterial
	 * @extends {LineBasicMaterial}
	 */
	function GizmoLineMaterial(parameters)
	{
		three.LineBasicMaterial.call(this);

		this.depthTest = false;
		this.depthWrite = false;
		this.transparent = true;
		this.linewidth = 1;

		this.setValues(parameters);

		this.baseColor = this.color.clone();
		this.baseOpacity = this.opacity;
	}

	GizmoLineMaterial.prototype = Object.create(three.LineBasicMaterial.prototype);

	GizmoLineMaterial.red = new GizmoLineMaterial({color: 0xff0000});
	GizmoLineMaterial.green = new GizmoLineMaterial({color: 0x00ff00});
	GizmoLineMaterial.blue = new GizmoLineMaterial({color: 0x0000ff});
	GizmoLineMaterial.yellow = new GizmoLineMaterial({color: 0xFFFF00});
	GizmoLineMaterial.grey = new GizmoLineMaterial({color: 0x787878});

	/**
	 * Toggle the highlight state of a gizmo material.
	 *
	 * @method highlight
	 * @param {boolean} highlighted
	 */
	GizmoLineMaterial.prototype.highlight = function(highlighted)
	{
		if(highlighted)
		{
			this.color.setRGB(1.0, 1.0, 0);
			this.opacity = 1.0;
		}
		else
		{
			this.color.copy(this.baseColor);
			this.opacity = this.baseOpacity;
		}
	};

	/**
	 * A transform gizmo is a object used to transform a property of an entity.
	 *
	 * Should be used as basis for other transform gizmos. This base implementation does not apply any trasnforms to objects.
	 *
	 * @class TransformGizmo
	 */
	function TransformGizmo()
	{
		three.Object3D.call(this);

		this.handles = new three.Object3D();
		this.pickers = new three.Object3D();
		this.planes = new three.Object3D();

		this.add(this.handles);
		this.add(this.pickers);
		this.add(this.planes);

		// Planes
		var planeGeometry = new three.PlaneBufferGeometry(50, 50, 2, 2);
		var planeMaterial = new three.MeshBasicMaterial({visible: false, side: three.DoubleSide});
		var planes =
		{
			"XY": new three.Mesh(planeGeometry, planeMaterial),
			"YZ": new three.Mesh(planeGeometry, planeMaterial),
			"XZ": new three.Mesh(planeGeometry, planeMaterial),
			"XYZE": new three.Mesh(planeGeometry, planeMaterial)
		};

		this.activePlane = planes["XYZE"];

		planes["YZ"].rotation.set(0, Math.PI / 2, 0);
		planes["XZ"].rotation.set(-Math.PI / 2, 0, 0);

		for(var i in planes)
		{
			planes[i].name = i;
			this.planes.add(planes[i]);
			this.planes[i] = planes[i];
		}

		// Handlers and pickers
		function setupGizmos(gizmoMap, parent)
		{
			for(var name in gizmoMap)
			{
				for(i = gizmoMap[name].length; i--;)
				{
					var object = gizmoMap[name][i][0];
					var position = gizmoMap[name][i][1];
					var rotation = gizmoMap[name][i][2];

					object.name = name;

					if(position)
					{
						object.position.set(position[0], position[1], position[2]);
					}
					
					if(rotation)
					{
						object.rotation.set(rotation[0], rotation[1], rotation[2]);
					}

					parent.add(object);
				}
			}
		}

		setupGizmos(this.handleGizmos, this.handles);
		setupGizmos(this.pickerGizmos, this.pickers);

		// Reset transformations
		this.traverse(function(child)
		{
			if(child.geometry !== undefined)
			{
				child.updateMatrix();

				// Move geometry to origin
				var tempGeometry = child.geometry.clone();
				tempGeometry.applyMatrix4(child.matrix);
				child.geometry = tempGeometry;

				// Reset pose
				child.position.set(0, 0, 0);
				child.rotation.set(0, 0, 0);
				child.scale.set(1, 1, 1);
			}
		});
	}

	TransformGizmo.prototype = Object.create(three.Object3D.prototype);

	/**
	 * Invisible material used for the picking regions.
	 *
	 * These regions are not shown to the user but are raycasted as normal drawable geometries.
	 *
	 * @static
	 * @attribute pickerMaterial
	 * @type {GizmoMaterial}
	 */
	TransformGizmo.pickerMaterial = new GizmoMaterial({visible: false, transparent: false});

	/**
	 * Set the currently active plane in the gizmo object.
	 *
	 * Planes are used for user interaction relative to the plane, and these can be toggled based on view direction.
	 *
	 * @method setActivePlane
	 * @param {string} axis Axis stored as text. (e.g X, Y, XY, XZ).
	 * @param {Matrix4} eye Eye view camera combined (projection and pose) matrix.
	 */
	TransformGizmo.prototype.setActivePlane = function(axis, eye){};

	/**
	 * Called when the controls button is released and there was object being edited.
	 *
	 * Changes made to the object should be applied to the editor action history here.
	 *
	 * @method onPointerUp
	 * @param {TransformControls} controls Transform controls object that contain this gizmo.
	 */
	TransformGizmo.prototype.applyChanges = function(controls){};

	/**
	 * Called while the pointer is moving around the canvas.
	 *
	 * Used to contantly tranform the object. Final changes are not applied in this method.
	 *
	 * @method transformObject
	 * @param {TransformControls} controls Transform controls object that contain this gizmo.
	 */
	TransformGizmo.prototype.transformObject = function(controls){};

	/**
	 * Called everytime that the controls button is pressed to start transforming the object.
	 *
	 * @method startTransform
	 * @param {TransformControls} controls Transform controls object that contain this gizmo.
	 */
	TransformGizmo.prototype.startTransform = function(controls){};

	/**
	 * Update transform of the gizmo, called everytime on update to calculate size of the gizmo on screen.
	 *
	 * @method updatePose
	 * @param {TransformControls} controls Transform controls object that contain this gizmo.
	 */
	TransformGizmo.prototype.updatePose = function(controls)
	{
		if(controls.space === TransformControls.LOCAL)
		{
			controls.gizmo.update(controls.attributes[0].worldRotation, controls.eye);
		}
		else if(controls.space === TransformControls.WORLD)
		{
			controls.gizmo.update(new three.Euler(), controls.eye);
		}

		controls.gizmo.highlight(controls.axis);
	};


	/**
	 * Update the transformation of the gizmo from rotation and combined view matrix.
	 *
	 * @method update
	 * @param {Eurler} rotation Euler rotation.
	 * @param {Matrix4} eye Eye view camera combined (projection and pose) matrix.
	 */
	TransformGizmo.prototype.update = function(rotation, eye)
	{
		var vec1 = new three.Vector3(0, 0, 0);
		var vec2 = new three.Vector3(0, 1, 0);
		var lookAtMatrix = new three.Matrix4();

		this.traverse(function(child)
		{
			if(child.name.search("E") !== - 1)
			{
				child.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));
			}
			else if(child.name.search("X") !== - 1 || child.name.search("Y") !== - 1 || child.name.search("Z") !== - 1)
			{
				child.quaternion.setFromEuler(rotation);
			}
		});
	};

	/**
	 * Hightlight axis in the gizmo object.
	 *
	 * @method highlight
	 * @param {string} axis Exact name of the axis to be highlighted (assumes that the material uses the same name as the axis).
	 */
	TransformGizmo.prototype.highlight = function(axis)
	{
		this.traverse(function(child)
		{
			if(child.material && child.material.highlight)
			{
				child.material.highlight(child.name === axis);
			}
		});
	};

	/**
	 * Gizmo used to change position of an object. Can be used with Object3D objects.
	 *
	 * @class TransformGizmoTranslate
	 * @extends {TransformGizmo}
	 */
	function TransformGizmoTranslate()
	{
		var arrowGeometry = new three.Geometry();
		var mesh = new three.Mesh(new three.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));
		mesh.position.y = 0.5;
		mesh.updateMatrix();

		arrowGeometry.merge(mesh.geometry, mesh.matrix);

		var lineXGeometry = new three.BufferGeometry();
		lineXGeometry.setAttribute("position", new three.Float32BufferAttribute([0, 0, 0,  1, 0, 0], 3));

		var lineYGeometry = new three.BufferGeometry();
		lineYGeometry.setAttribute("position", new three.Float32BufferAttribute([0, 0, 0,  0, 1, 0], 3));

		var lineZGeometry = new three.BufferGeometry();
		lineZGeometry.setAttribute("position", new three.Float32BufferAttribute([0, 0, 0,  0, 0, 1], 3));

		this.handleGizmos =
		{
			X: [[new three.Mesh(arrowGeometry, GizmoMaterial.red), [0.5, 0, 0], [0, 0, - Math.PI / 2]],[new three.Line(lineXGeometry, GizmoLineMaterial.red)]],
			Y: [[new three.Mesh(arrowGeometry, GizmoMaterial.green), [0, 0.5, 0]],[new three.Line(lineYGeometry, GizmoLineMaterial.green)]],
			Z: [[new three.Mesh(arrowGeometry, GizmoMaterial.blue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],[new three.Line(lineZGeometry, GizmoLineMaterial.blue)]],
			XY: [[new three.Mesh(TransformGizmoTranslate.plane, GizmoMaterial.yellowAlpha), [0.15, 0.15, 0]]],
			YZ: [[new three.Mesh(TransformGizmoTranslate.plane, GizmoMaterial.cyanAlpha), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],
			XZ: [[new three.Mesh(TransformGizmoTranslate.plane, GizmoMaterial.magentaAlpha), [0.15, 0, 0.15], [- Math.PI / 2, 0, 0]]],
			XYZ: [[new three.Mesh(TransformGizmoTranslate.box, GizmoMaterial.whiteAlpha), [0, 0, 0], [0, 0, 0]]]
		};

		this.pickerGizmos =
		{
			X: [[new three.Mesh(TransformGizmoTranslate.cylinder, TransformGizmo.pickerMaterial), [0.6, 0, 0], [0, 0, - Math.PI / 2]]],
			Y: [[new three.Mesh(TransformGizmoTranslate.cylinder, TransformGizmo.pickerMaterial), [0, 0.6, 0]]],
			Z: [[new three.Mesh(TransformGizmoTranslate.cylinder, TransformGizmo.pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
			XY: [[new three.Mesh(TransformGizmoTranslate.planeBig, TransformGizmo.pickerMaterial), [0.2, 0.2, 0]]],
			YZ: [[new three.Mesh(TransformGizmoTranslate.planeBig, TransformGizmo.pickerMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
			XZ: [[new three.Mesh(TransformGizmoTranslate.planeBig, TransformGizmo.pickerMaterial), [0.2, 0, 0.2], [- Math.PI / 2, 0, 0]]],
			XYZ: [[new three.Mesh(TransformGizmoTranslate.box, TransformGizmo.pickerMaterial)]]
		};

		TransformGizmo.call(this);
	}

	TransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);

	TransformGizmoTranslate.cylinder = new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false);
	TransformGizmoTranslate.box = new three.BoxBufferGeometry(0.1, 0.1, 0.1);
	TransformGizmoTranslate.plane = new three.PlaneBufferGeometry(0.29, 0.29);
	TransformGizmoTranslate.planeBig = new three.PlaneBufferGeometry(0.4, 0.4);

	TransformGizmoTranslate.prototype.setActivePlane = function(axis, eye)
	{
		var tempMatrix = new three.Matrix4();
		eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

		if(axis === "X")
		{
			this.activePlane = this.planes["XY"];
			if(Math.abs(eye.y) > Math.abs(eye.z))
			{
				this.activePlane = this.planes["XZ"];
			}
		}
		else if(axis === "Y")
		{
			this.activePlane = this.planes["XY"];
			if(Math.abs(eye.x) > Math.abs(eye.z))
			{
				this.activePlane = this.planes["YZ"];
			}
		}
		else if(axis === "Z")
		{
			this.activePlane = this.planes["XZ"];
			if(Math.abs(eye.x) > Math.abs(eye.y))
			{
				this.activePlane = this.planes["YZ"];
			}
		}
		else if(axis === "XYZ")
		{
			this.activePlane = this.planes["XYZE"];
		}
		else if(axis === "XY")
		{
			this.activePlane = this.planes["XY"];
		}
		else if(axis === "YZ")
		{
			this.activePlane = this.planes["YZ"];
		}
		else if(axis === "XZ")
		{
			this.activePlane = this.planes["XZ"];
		}
	};

	TransformGizmoTranslate.prototype.applyChanges = function(controls)
	{
		var actions = [];

		for(var i = 0; i < controls.objects.length; i++)
		{
			var object = controls.objects[i].position;
			actions.push(new ChangeAction(object, "x", object.x, controls.attributes[i].oldPosition.x));
			actions.push(new ChangeAction(object, "y", object.y, controls.attributes[i].oldPosition.y));
			actions.push(new ChangeAction(object, "z", object.z, controls.attributes[i].oldPosition.z));
		}

		Editor$1.addAction(new ActionBundle(actions));
	};


	TransformGizmoTranslate.prototype.transformObject = function(controls)
	{
		var planeIntersect = controls.intersectObjects([controls.gizmo.activePlane]);
		if(planeIntersect === false) 
		{
			return;
		}

		for(var i = 0; i < controls.objects.length; i++)
		{
			controls.point.copy(planeIntersect.point);
			controls.point.sub(controls.offset);
			controls.point.multiply(controls.attributes[i].parentScale);

			if(controls.axis.search("X") === -1)
			{
				controls.point.x = 0;
			}
			if(controls.axis.search("Y") === -1) 
			{
				controls.point.y = 0;
			}
			if(controls.axis.search("Z") === -1)
			{
				controls.point.z = 0;
			}
					
			if(controls.space === TransformControls.WORLD || controls.axis.search("XYZ") !== -1)
			{
				controls.point.applyMatrix4(controls.tempMatrix.getInverse(controls.attributes[i].parentRotationMatrix));

				for(var j = 0; j < controls.objects.length; j++)
				{
					controls.objects[j].position.copy(controls.attributes[j].oldPosition);
					controls.objects[j].position.add(controls.point);
				}
			}
			else if(controls.space === TransformControls.LOCAL)
			{
				if(controls.axis.length > 1)
				{
					controls.point.applyMatrix4(controls.tempMatrix.getInverse(controls.attributes[i].worldRotationMatrix));
					controls.point.applyMatrix4(controls.attributes[i].oldRotationMatrix);
				}
				else
				{
					controls.point.applyMatrix4(controls.attributes[i].oldRotationMatrix);
				}

				for(var j = 0; j < controls.objects.length; j++)
				{
					controls.objects[j].position.copy(controls.attributes[j].oldPosition);
					controls.objects[j].position.add(controls.point);
				}
			}

			if(controls.snap)
			{
				if(controls.space === TransformControls.LOCAL)
				{
					controls.objects[i].position.applyMatrix4(controls.tempMatrix.getInverse(controls.attributes[i].worldRotationMatrix));
				}

				if(controls.axis.search("X") !== -1)
				{
					controls.objects[i].position.x = Math.round(controls.objects[i].position.x / controls.translationSnap) * controls.translationSnap;
				}
				if(controls.axis.search("Y") !== -1)
				{
					controls.objects[i].position.y = Math.round(controls.objects[i].position.y / controls.translationSnap) * controls.translationSnap;
				}
				if(controls.axis.search("Z") !== -1)
				{
					controls.objects[i].position.z = Math.round(controls.objects[i].position.z / controls.translationSnap) * controls.translationSnap;
				}

				if(controls.space === TransformControls.LOCAL)
				{
					controls.objects[i].position.applyMatrix4(controls.attributes[i].worldRotationMatrix);
				}
			}
		}
	};

	/**
	 * Gizmo used to change scale of an object. Can be used with Object3D objects.
	 *
	 * @class TransformGizmoScale
	 * @extends {TransformGizmo}
	 */
	function TransformGizmoScale()
	{
		var arrowGeometry = new three.Geometry();
		var mesh = new three.Mesh(new three.BoxGeometry(0.125, 0.125, 0.125));
		mesh.position.y = 0.5;
		mesh.updateMatrix();

		arrowGeometry.merge(mesh.geometry, mesh.matrix);

		var x = new three.BufferGeometry();
		x.setAttribute("position", new three.Float32BufferAttribute([0, 0, 0,  1, 0, 0], 3));

		var y = new three.BufferGeometry();
		y.setAttribute("position", new three.Float32BufferAttribute([0, 0, 0,  0, 1, 0], 3));

		var z = new three.BufferGeometry();
		z.setAttribute("position", new three.Float32BufferAttribute([0, 0, 0,  0, 0, 1], 3));

		this.handleGizmos =
		{
			X: [[new three.Mesh(arrowGeometry, GizmoMaterial.red), [0.5, 0, 0], [0, 0, - Math.PI / 2]],[new three.Line(x, GizmoLineMaterial.red)]],
			Y: [[new three.Mesh(arrowGeometry, GizmoMaterial.green), [0, 0.5, 0]],[new three.Line(y, GizmoLineMaterial.green)]],
			Z: [[new three.Mesh(arrowGeometry, GizmoMaterial.blue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],[new three.Line(z, GizmoLineMaterial.blue)]],
			XYZ: [[new three.Mesh(new three.BoxBufferGeometry(0.125, 0.125, 0.125), GizmoMaterial.whiteAlpha)]]
		};

		this.pickerGizmos =
		{
			X: [[new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), TransformGizmo.pickerMaterial), [0.6, 0, 0], [0, 0, - Math.PI / 2]]],
			Y: [[new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), TransformGizmo.pickerMaterial), [0, 0.6, 0]]],
			Z: [[new three.Mesh(new three.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), TransformGizmo.pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
			XYZ: [[new three.Mesh(new three.BoxBufferGeometry(0.4, 0.4, 0.4), TransformGizmo.pickerMaterial)]]
		};

		TransformGizmo.call(this);
	}

	TransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);

	TransformGizmoScale.prototype.setActivePlane = function(axis, eye)
	{
		var tempMatrix = new three.Matrix4();
		eye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes["XY"].matrixWorld)));

		if(axis === "X")
		{
			this.activePlane = this.planes["XY"];
			if(Math.abs(eye.y) > Math.abs(eye.z))
			{
				this.activePlane = this.planes["XZ"];
			}
		}
		else if(axis === "Y")
		{
			this.activePlane = this.planes["XY"];
			if(Math.abs(eye.x) > Math.abs(eye.z))
			{
				this.activePlane = this.planes["YZ"];
			}
		}
		else if(axis === "Z")
		{
			this.activePlane = this.planes["XZ"];
			if(Math.abs(eye.x) > Math.abs(eye.y))
			{
				this.activePlane = this.planes["YZ"];
			}
		}
		else if(axis === "XYZ") 
		{
			this.activePlane = this.planes["XYZE"];
		}
	};

	TransformGizmoScale.prototype.updatePose = function(controls)
	{
		controls.gizmo.update(controls.attributes[0].worldRotation, controls.eye);
		controls.gizmo.highlight(controls.axis);
	};

	TransformGizmoScale.prototype.applyChanges = function(controls)
	{
		var actions = [];

		for(var i = 0; i < controls.objects.length; i++)
		{
			var object = controls.objects[i].scale;
			actions.push(new ChangeAction(object, "x", object.x, controls.attributes[i].oldScale.x));
			actions.push(new ChangeAction(object, "y", object.y, controls.attributes[i].oldScale.y));
			actions.push(new ChangeAction(object, "z", object.z, controls.attributes[i].oldScale.z));
		}
		
		Editor$1.addAction(new ActionBundle(actions));
	};

	TransformGizmoScale.prototype.transformObject = function(controls)
	{
		var planeIntersect = controls.intersectObjects([controls.gizmo.activePlane]);
		if(planeIntersect === false) 
		{
			return;
		}
		
		for(var i = 0; i < controls.objects.length; i++)
		{
			controls.point.copy(planeIntersect.point);
			controls.point.sub(controls.offset);
			controls.point.multiply(controls.attributes[i].parentScale);

			if(controls.axis === "XYZ")
			{
				controls.toolScale = 1 + controls.point.y;

				controls.objects[i].scale.copy(controls.attributes[i].oldScale);
				controls.objects[i].scale.multiplyScalar(controls.toolScale);
			}
			else
			{
				controls.point.applyMatrix4(controls.tempMatrix.getInverse(controls.attributes[i].worldRotationMatrix));

				if(controls.axis === "X")
				{
					controls.objects[i].scale.x = controls.attributes[i].oldScale.x * (1 + controls.point.x);
				}
				else if(controls.axis === "Y")
				{
					controls.objects[i].scale.y = controls.attributes[i].oldScale.y * (1 + controls.point.y);
				}
				else if(controls.axis === "Z")
				{
					controls.objects[i].scale.z = controls.attributes[i].oldScale.z * (1 + controls.point.z);
				}
			}

			// Update physics objects
			if(controls.objects[i] instanceof PhysicsObject)
			{
				var shapes = controls.objects[i].body.shapes;
				var scale = controls.objects[i].scale;

				for(var i = 0; i < shapes.length; i++)
				{
					var shape = shapes[i];
					
					if(shape.type === cannon.Shape.types.BOX)
					{
						shape.halfExtents.x = scale.x / 2.0;
						shape.halfExtents.y = scale.y / 2.0;
						shape.halfExtents.z = scale.z / 2.0;
					}
					else if(shape.type === cannon.Shape.types.SPHERE)
					{
						shape.radius = scale.x;
					}
				}
			}
		}
	};

	/**
	 * Gizmo used to change rotation of an object. Can be used with Object3D objects.
	 *
	 * @class TransformGizmoRotate
	 * @extends {TransformGizmo}
	 */
	function TransformGizmoRotate()
	{
		this.handleGizmos =
		{
			X: [[new three.Line(new CircleGeometry(1, "x", 0.5), GizmoLineMaterial.red)]],
			Y: [[new three.Line(new CircleGeometry(1, "y", 0.5), GizmoLineMaterial.green)]],
			Z: [[new three.Line(new CircleGeometry(1, "z", 0.5), GizmoLineMaterial.blue)]],
			E: [[new three.Line(new CircleGeometry(1.25, "z", 1), GizmoLineMaterial.yellow)]],
			XYZE: [[new three.Line(new CircleGeometry(1, "z", 1), GizmoLineMaterial.grey)]]
		};

		this.pickerGizmos =
		{
			X: [[new three.Mesh(TransformGizmoRotate.torus, TransformGizmo.pickerMaterial), [0, 0, 0], [0, - Math.PI / 2, - Math.PI / 2]]],
			Y: [[new three.Mesh(TransformGizmoRotate.torus, TransformGizmo.pickerMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],
			Z: [[new three.Mesh(TransformGizmoRotate.torus, TransformGizmo.pickerMaterial), [0, 0, 0], [0, 0, - Math.PI / 2]]],
			E: [[new three.Mesh(TransformGizmoRotate.torusBig, TransformGizmo.pickerMaterial)]],
			XYZE: [[new three.Mesh(new three.Geometry())]]
		};

		TransformGizmo.call(this);
	}

	TransformGizmoRotate.torus = new three.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI);
	TransformGizmoRotate.torusBig = new three.TorusBufferGeometry(1.25, 0.12, 2, 24);

	/**
	 * Circle geometry used for the rotation gizmo rings.
	 *
	 * @class CircleGeometry
	 */
	function CircleGeometry(radius, facing, arc)
	{
		three.BufferGeometry.call(this);
		var vertices = [];

		var arcLen = (arc !== undefined) ? (arc * 64) : 64;

		for(var i = 0; i < arcLen; i++)
		{
			if(facing === "x")
			{
				vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
			}
			else if(facing === "y")
			{
				vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);
			}
			else if(facing === "z")
			{
				vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);
			}
		}

		this.setAttribute("position", new three.Float32BufferAttribute(vertices, 3));
	}
	CircleGeometry.prototype = Object.create(three.BufferGeometry.prototype);

	TransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);

	TransformGizmoRotate.prototype.setActivePlane = function(axis)
	{
		if(axis === "E")
		{
			this.activePlane = this.planes["XYZE"];
		}
		else if(axis === "X")
		{
			this.activePlane = this.planes["YZ"];
		}
		else if(axis === "Y")
		{
			this.activePlane = this.planes["XZ"];
		}
		else if(axis === "Z")
		{
			this.activePlane = this.planes["XY"];
		}
	};

	TransformGizmoRotate.prototype.update = function(rotation, eye2)
	{
		TransformGizmo.prototype.update.apply(this, arguments);

		var group =
		{
			handles: this.handles,
			pickers: this.pickers
		};

		var tempMatrix = new three.Matrix4();
		var worldRotation = new three.Euler(0, 0, 1);
		var tempQuaternion = new three.Quaternion();
		var unitX = new three.Vector3(1, 0, 0);
		var unitY = new three.Vector3(0, 1, 0);
		var unitZ = new three.Vector3(0, 0, 1);
		var quaternionX = new three.Quaternion();
		var quaternionY = new three.Quaternion();
		var quaternionZ = new three.Quaternion();
		var eye = eye2.clone();

		worldRotation.copy(this.planes["XY"].rotation);
		tempQuaternion.setFromEuler(worldRotation);

		tempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);
		eye.applyMatrix4(tempMatrix);

		this.traverse(function(child)
		{
			tempQuaternion.setFromEuler(worldRotation);

			if(child.name === "X")
			{
				quaternionX.setFromAxisAngle(unitX, Math.atan2(- eye.y, eye.z));
				tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);
				child.quaternion.copy(tempQuaternion);
			}
			else if(child.name === "Y")
			{
				quaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));
				tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);
				child.quaternion.copy(tempQuaternion);
			}
			else if(child.name === "Z")
			{
				quaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));
				tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);
				child.quaternion.copy(tempQuaternion);
			}
		});
	};

	TransformGizmoRotate.prototype.applyChanges = function(controls)
	{
		var actions = [];

		for(var i = 0; i < controls.objects.length; i++)
		{
			var object = controls.objects[i].quaternion;
			actions.push(new ChangeAction(object, "x", object.x, controls.attributes[i].oldQuaternion.x));
			actions.push(new ChangeAction(object, "y", object.y, controls.attributes[i].oldQuaternion.y));
			actions.push(new ChangeAction(object, "z", object.z, controls.attributes[i].oldQuaternion.z));
			actions.push(new ChangeAction(object, "w", object.w, controls.attributes[i].oldQuaternion.w));
		}
		
		Editor$1.addAction(new ActionBundle(actions));
	};

	TransformGizmoRotate.prototype.transformObject = function(controls)
	{
		var planeIntersect = controls.intersectObjects([controls.gizmo.activePlane]);
		if(planeIntersect === false) 
		{
			return;
		}
		
		for(var i = 0; i < controls.objects.length; i++)
		{
			controls.point.copy(planeIntersect.point);
			controls.point.sub(controls.attributes[i].worldPosition);
			controls.point.multiply(controls.attributes[i].parentScale);
			controls.tempVector.copy(controls.offset).sub(controls.attributes[i].worldPosition);
			controls.tempVector.multiply(controls.attributes[i].parentScale);

			if(controls.axis === "E")
			{
				controls.point.applyMatrix4(controls.tempMatrix.getInverse(controls.lookAtMatrix));
				controls.tempVector.applyMatrix4(controls.tempMatrix.getInverse(controls.lookAtMatrix));

				controls.toolRotation.set(Math.atan2(controls.point.z, controls.point.y), Math.atan2(controls.point.x, controls.point.z), Math.atan2(controls.point.y, controls.point.x));
				controls.offsetRotation.set(Math.atan2(controls.tempVector.z, controls.tempVector.y), Math.atan2(controls.tempVector.x, controls.tempVector.z), Math.atan2(controls.tempVector.y, controls.tempVector.x));

				controls.tempQuaternion.setFromRotationMatrix(controls.tempMatrix.getInverse(controls.attributes[i].parentRotationMatrix));

				controls.quaternionE.setFromAxisAngle(controls.eye, controls.toolRotation.z - controls.offsetRotation.z);
				controls.quaternionXYZ.setFromRotationMatrix(controls.attributes[i].worldRotationMatrix);

				controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionE);
				controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionXYZ);

				controls.objects[i].quaternion.copy(controls.tempQuaternion);
			}
			else if(controls.axis === "XYZE")
			{
				controls.quaternionE.setFromEuler(controls.point.clone().cross(controls.tempVector).normalize()); // rotation axis

				controls.tempQuaternion.setFromRotationMatrix(controls.tempMatrix.getInverse(controls.attributes[i].parentRotationMatrix));
				controls.quaternionX.setFromAxisAngle(controls.quaternionE, - controls.point.clone().angleTo(controls.tempVector));
				controls.quaternionXYZ.setFromRotationMatrix(controls.attributes[i].worldRotationMatrix);

				controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionX);
				controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionXYZ);

				controls.objects[i].quaternion.copy(controls.tempQuaternion);
			}
			else if(controls.space === TransformControls.LOCAL)
			{
				controls.point.applyMatrix4(controls.tempMatrix.getInverse(controls.attributes[i].worldRotationMatrix));

				controls.tempVector.applyMatrix4(controls.tempMatrix.getInverse(controls.attributes[i].worldRotationMatrix));

				controls.toolRotation.set(Math.atan2(controls.point.z, controls.point.y), Math.atan2(controls.point.x, controls.point.z), Math.atan2(controls.point.y, controls.point.x));
				controls.offsetRotation.set(Math.atan2(controls.tempVector.z, controls.tempVector.y), Math.atan2(controls.tempVector.x, controls.tempVector.z), Math.atan2(controls.tempVector.y, controls.tempVector.x));

				controls.quaternionXYZ.setFromRotationMatrix(controls.attributes[i].oldRotationMatrix);

				if(controls.snap)
				{
					controls.quaternionX.setFromAxisAngle(controls.unitX, Math.round((controls.toolRotation.x - controls.offsetRotation.x) / controls.rotationSnap) * controls.rotationSnap);
					controls.quaternionY.setFromAxisAngle(controls.unitY, Math.round((controls.toolRotation.y - controls.offsetRotation.y) / controls.rotationSnap) * controls.rotationSnap);
					controls.quaternionZ.setFromAxisAngle(controls.unitZ, Math.round((controls.toolRotation.z - controls.offsetRotation.z) / controls.rotationSnap) * controls.rotationSnap);
				}
				else
				{
					controls.quaternionX.setFromAxisAngle(controls.unitX, controls.toolRotation.x - controls.offsetRotation.x);
					controls.quaternionY.setFromAxisAngle(controls.unitY, controls.toolRotation.y - controls.offsetRotation.y);
					controls.quaternionZ.setFromAxisAngle(controls.unitZ, controls.toolRotation.z - controls.offsetRotation.z);
				}

				if(controls.axis === "X")
				{
					controls.quaternionXYZ.multiplyQuaternions(controls.quaternionXYZ, controls.quaternionX);
				}
				else if(controls.axis === "Y")
				{
					controls.quaternionXYZ.multiplyQuaternions(controls.quaternionXYZ, controls.quaternionY);
				}
				else if(controls.axis === "Z")
				{
					controls.quaternionXYZ.multiplyQuaternions(controls.quaternionXYZ, controls.quaternionZ);
				}

				controls.objects[i].quaternion.copy(controls.quaternionXYZ);
			}
			else if(controls.space === TransformControls.WORLD)
			{
				controls.toolRotation.set(Math.atan2(controls.point.z, controls.point.y), Math.atan2(controls.point.x, controls.point.z), Math.atan2(controls.point.y, controls.point.x));
				controls.offsetRotation.set(Math.atan2(controls.tempVector.z, controls.tempVector.y), Math.atan2(controls.tempVector.x, controls.tempVector.z), Math.atan2(controls.tempVector.y, controls.tempVector.x));
				controls.tempQuaternion.setFromRotationMatrix(controls.tempMatrix.getInverse(controls.attributes[i].parentRotationMatrix));

				if(controls.snap)
				{
					controls.quaternionX.setFromAxisAngle(controls.unitX, Math.round((controls.toolRotation.x - controls.offsetRotation.x) / controls.rotationSnap) * controls.rotationSnap);
					controls.quaternionY.setFromAxisAngle(controls.unitY, Math.round((controls.toolRotation.y - controls.offsetRotation.y) / controls.rotationSnap) * controls.rotationSnap);
					controls.quaternionZ.setFromAxisAngle(controls.unitZ, Math.round((controls.toolRotation.z - controls.offsetRotation.z) / controls.rotationSnap) * controls.rotationSnap);
				}
				else
				{
					controls.quaternionX.setFromAxisAngle(controls.unitX, controls.toolRotation.x - controls.offsetRotation.x);
					controls.quaternionY.setFromAxisAngle(controls.unitY, controls.toolRotation.y - controls.offsetRotation.y);
					controls.quaternionZ.setFromAxisAngle(controls.unitZ, controls.toolRotation.z - controls.offsetRotation.z);
				}

				controls.quaternionXYZ.setFromRotationMatrix(controls.attributes[i].worldRotationMatrix);

				if(controls.axis === "X")
				{
					controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionX);
				}
				else if(controls.axis === "Y")
				{
					controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionY);
				}
				else if(controls.axis === "Z")
				{
					controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionZ);
				}

				controls.tempQuaternion.multiplyQuaternions(controls.tempQuaternion, controls.quaternionXYZ);

				controls.objects[i].quaternion.copy(controls.tempQuaternion);
			}
		}
	};

	/*
	 * TranformControls is used to manipulate object in 3D space. It can be used to manipulate multiple Object3D instances simultaneously.
	 *
	 * The objects are transformed by Gizmos managed by the transform controls object, gizmos may be compatible with multiple types of objects (Object3D, Vector3, etc).
	 *
	 * @class TransformControls
	 * @author arodic (github.com/arodic)
	 * @param {Camera} camera
	 * @param {Canvas} canvas
	 * @param {Mouse} mouse
	 */
	function TransformControls(camera, canvas, mouse)
	{
		three.Object3D.call(this);

		this.visible = false;

		/**
		 * View camera, the controls scale and behavior is calculated relative to the camera.
		 *
		 * The rotation and direction of the camera affects the appearence of the gizmos and the vectors applied to transform objects.
		 *
		 * Booth perspective or orthographic cameras are supported.
		 * 
		 * @attribute camera
		 * @type {Camera}
		 */
		this.camera = camera;

		/**
		 * DOM canvas where the scene is rendererd.
		 *
		 * Mouse input is calculated relative to this canvas position on screen.
		 *
		 * @attribute canvas
		 * @type {DOM} 
		 */
		this.canvas = canvas;
		
		/**
		 * Mouse to get user input from. Should be updated before updating the controls.
		 *
		 * @attribute mouse
		 * @type {Mouse}
		 */
		this.mouse = mouse;

		/**
		 * Object currently attached to the transform controls.
		 *
		 * @attribute objects
		 * @type {Array}
		 */
		this.objects = [];

		/**
		 * Object transform attributes for each selected object.
		 *
		 * Can be reused between selected objects.
		 *
		 * @attribute attributes
		 * @type {Array} 
		 */
		this.attributes = [];

		/**
		 * Transformation space defines how the transformations are applied.
		 *
		 * If set to WORLD the transformations are applied on the world referential.
		 *
		 * If set to LOCAL the transformations are applied relative to the object current transform
		 *
		 * After chaging 
		 *
		 * @attribute space
		 * @type {number}
		 */
		this.space = TransformControls.WORLD;

		/**
		 * Scale of the transform gizmo.
		 *
		 * Size of the gizmos is adjusted relative to the view camera distance.*
		 *
		 * @attribute size
		 * @type {number}
		 */
		this.size = 1;

		/**
		 * Axis of transformation selected stored as text. (e.g X, Y, Z).
		 *
		 * Can be a combination of multiple axis (e.g XYZ, XZ, etc)
		 *
		 * @attribute axis
		 * @type {string}
		 */
		this.axis = null;

		/**
		 * If set true the value set by the transform is always multiple of the snap ratio.
		 *
		 * Snap ratios are different for each transform gizmo.
		 *
		 * @attribute snap
		 * @type {boolean}
		 */
		this.snap = false;

		/**
		 * Snap ratio applies to translation transform.
		 *
		 * @attribute translationSnap
		 * @type {number}
		 */
		this.translationSnap = 1.0;

		/**
		 * Snap ratio applies to rotation transform.
		 *
		 * @attribute rotationSnap
		 * @type {number}
		 */
		this.rotationSnap = 0.1;

		/**
		 * Mode indicates the gizmo currently being used.
		 *
		 * @attribute mode
		 * @type {string}
		 */
		this.mode = TransformControls.TRANSLATE;

		/**
		 * If set true the pointer is currently being dragged around.
		 *
		 * @attribute dragging
		 * @type {boolean}
		 */
		this.dragging = false;

		/**
		 * If set true a object is currently being edited.
		 *
		 * @attribute editing
		 * @type {boolean}
		 */
		this.editing = false;

		/**
		 * Gizmo tools currenctly in use to edit the object.
		 *
		 * Defines what and how the attribute of the object is manipulated.
		 *
		 * @attribute gizmo
		 * @type {TransformGizmo}
		 */
		this.gizmo = new TransformGizmo();

		/**
		 * Raycaster object used to pick the gizmo sections.
		 *
		 * @attribute raycaster
		 * @type {Raycaster}
		 */
		this.raycaster = new three.Raycaster();

		/**
		 * Normalized vector containing the pointer coordinates used with the raycaster.
		 *
		 * @attribute pointerVector
		 * @type {Vector2}
		 */
		this.pointerVector = new three.Vector2();

		this.point = new three.Vector3();
		this.offset = new three.Vector3();

		this.toolRotation = new three.Vector3();
		this.toolScale = 1;
		this.offsetRotation = new three.Vector3();

		/**
		 * View and projection matrix combined.
		 *
		 * @attribute lookAtMatrix
		 * @type {Matrix4}
		 */
		this.lookAtMatrix = new three.Matrix4();

		/**
		 * Camera normalized direction vector relative to the selected object.
		 *
		 * @attribute eye
		 * @type {Vector3}
		 */
		this.eye = new three.Vector3();
		
		/**
		 * View camera position.
		 *
		 * @attribute camPosition
		 * @type {Vector3}
		 */
		this.camPosition = new three.Vector3();

		/**
		 * View camera rotation.
		 *
		 * @attribute camRotation
		 * @type {Vector3}
		 */
		this.camRotation = new three.Euler();

		// Temporary variables used for runtime calcs
		this.tempMatrix = new three.Matrix4();
		this.tempVector = new three.Vector3();
		this.tempQuaternion = new three.Quaternion();
		this.unitX = new three.Vector3(1, 0, 0);
		this.unitY = new three.Vector3(0, 1, 0);
		this.unitZ = new three.Vector3(0, 0, 1);
		this.quaternionXYZ = new three.Quaternion();
		this.quaternionX = new three.Quaternion();
		this.quaternionY = new three.Quaternion();
		this.quaternionZ = new three.Quaternion();
		this.quaternionE = new three.Quaternion();
	}

	/**
	 * Attributes that need to be stored for each object to keep their transform state.
	 *
	 * Each selected object has one state.
	 *
	 * @class TransformControlAtttributes
	 */
	function TransformControlAtttributes()
	{
		this.parentRotationMatrix = new three.Matrix4();
		this.parentScale = new three.Vector3();
		this.worldRotationMatrix = new three.Matrix4();
		this.worldPosition = new three.Vector3();
		this.worldRotation = new three.Euler();
		this.oldPosition = new three.Vector3();
		this.oldScale = new three.Vector3();
		this.oldQuaternion = new three.Quaternion();
		this.oldRotationMatrix = new three.Matrix4();
	}

	TransformControls.NONE = "none";
	TransformControls.TRANSLATE = "translate";
	TransformControls.ROTATE = "rotate";
	TransformControls.SCALE = "scale";

	TransformControls.LOCAL = "local";
	TransformControls.WORLD = "world";

	TransformControls.prototype = Object.create(three.Object3D.prototype);

	/**
	 * Attach a list of objects to the transform controls.
	 *
	 * @method attach
	 * @param {Array} objects Array of objects to be attached.
	 */
	TransformControls.prototype.attach = function(objects)
	{
		this.objects = [];

		for(var i = 0; i < objects.length; i++)
		{
			if(objects[i].isObject3D && !objects[i].locked && objects[i].parent !== null)
			{
				this.objects.push(objects[i]);
			}
		}

		// Add more temporary attributes if necessary
		while(this.attributes.length < this.objects.length)
		{
			this.attributes.push(new TransformControlAtttributes());
		}

		if(this.objects.length > 0)
		{
			this.updatePose();
		}
		else
		{
			this.clear();
		}
	};

	/**
	 * Detach/clear all objects attached to the transform controls.
	 * 
	 * @method clear
	 */
	TransformControls.prototype.clear = function()
	{
		this.objects = [];
		this.visible = false;
		this.axis = null;
	};

	/**
	 * Set canvas where the scene is being rendered.
	 *
	 * @method setCanvas
	 * @param {DOM} canvas Canvas element.
	 */
	TransformControls.prototype.setCanvas = function(canvas)
	{
		this.canvas = canvas;
	};

	/**
	 * Set the transform gizmo to be used by the transform controls.
	 *
	 * @method setMode
	 * @param {string} mode Name of the gizmo to be activated.
	 */
	TransformControls.prototype.setMode = function(mode)
	{
		if(this.mode === mode)
		{
			return;
		}

		this.mode = mode;

		// Remove old gizmo
		if(this.gizmo !== null)
		{
			if(this.gizmo.dismiss !== undefined)
			{
				this.gizmo.dismiss();
			}

			this.remove(this.gizmo);
			this.gizmo = null;
		}

		// Create gizmo for the mode selected
		if(this.mode === TransformControls.TRANSLATE)
		{
			this.gizmo = new TransformGizmoTranslate();
		}
		else if(this.mode === TransformControls.ROTATE)
		{
			this.gizmo = new TransformGizmoRotate();
		}
		else if(this.mode === TransformControls.SCALE)
		{
			// If scale mode force local space
			this.space = TransformControls.LOCAL;
			this.gizmo = new TransformGizmoScale();
		}

		if(this.gizmo !== null)
		{
			this.add(this.gizmo);
		}


		this.visible = this.objects.length > 0;
	};

	/**
	 * Update the controls using mouse input provided takes camera of all the functionality of the controls.
	 *
	 * Should be called every frame to update the controls state.
	 *
	 * @method update
	 */
	TransformControls.prototype.update = function()
	{
		if(this.mouse.buttonJustPressed(Mouse.LEFT))
		{
			this.onPointerDown();
		}
		
		if(this.mouse.buttonJustReleased(Mouse.LEFT))
		{
			this.onPointerUp();
		}

		if(this.mouse.delta.x !== 0 || this.mouse.delta.y !== 0)
		{
			this.onPointerHover();
			this.onPointerMove();
		}

		this.updatePose();

		return this.editing;
	};

	/**
	 * Update the pose and transform of the controls and gizmos based on the selected objects and view camera.
	 *
	 * @method updatePose
	 */
	TransformControls.prototype.updatePose = function()
	{
		if(this.objects.length === 0 || this.gizmo === null)
		{
			return;
		}

		this.visible = true;

		// Calculate position from the avegare of all selected objects.
		this.position.set(0, 0, 0);
		for(var i = 0; i < this.objects.length; i++)
		{
			this.attributes[i].worldPosition.setFromMatrixPosition(this.objects[i].matrixWorld);
			this.attributes[i].worldRotation.setFromRotationMatrix(this.tempMatrix.extractRotation(this.objects[i].matrixWorld));
			this.position.add(this.attributes[i].worldPosition);
		}

		if(this.objects.length > 0)
		{
			this.position.divideScalar(this.objects.length);
		}

		// Get camera rotation and position
		this.camPosition.setFromMatrixPosition(this.camera.matrixWorld);
		this.camRotation.setFromRotationMatrix(this.tempMatrix.extractRotation(this.camera.matrixWorld));

		// Set controls scale based of camera dsitance to object
		if(this.camera instanceof three.PerspectiveCamera)
		{
			this.toolScale = this.position.distanceTo(this.camPosition) / 6 * this.size;
			this.scale.set(this.toolScale, this.toolScale, this.toolScale);
		}
		else
		{
			this.toolScale = this.camera.size / 6 * this.size;
			this.scale.set(this.toolScale, this.toolScale, this.toolScale);
		}
			
		// Camera direction vector
		this.eye.copy(this.camPosition).sub(this.position).normalize();

		// Update gizmo specific pose
		this.gizmo.updatePose(this);
	};

	/**
	 * Check if the pointer if over any of the picker objects.
	 *
	 * If it is set the axis to the picker object detected.
	 *
	 * @method onPointerHover
	 */
	TransformControls.prototype.onPointerHover = function()
	{
		if(this.objects.length === 0 || this.dragging === true || this.gizmo === null)
		{
			return;
		}

		var intersect = this.intersectObjects(this.gizmo.pickers.children);
		if(intersect)
		{
			var axis = intersect.object.name;
			if(this.axis !== axis)
			{
				this.axis = axis;
			}
		}
		else
		{
			this.axis = null;
		}
	};

	TransformControls.prototype.onPointerDown = function()
	{
		if(this.objects.length === 0 || this.dragging === true || this.gizmo === null)
		{
			return;
		}

		var intersect = this.intersectObjects(this.gizmo.pickers.children);
		if(intersect)
		{
			this.editing = true;
			this.axis = intersect.object.name;

			this.updatePose();

			this.eye.copy(this.camPosition).sub(this.position).normalize();
			this.gizmo.setActivePlane(this.axis, this.eye);

			var planeIntersect = this.intersectObjects([this.gizmo.activePlane]);
			if(planeIntersect)
			{
				for(var i = 0; i < this.objects.length; i++)
				{
					this.attributes[i].oldPosition.copy(this.objects[i].position);
					this.attributes[i].oldScale.copy(this.objects[i].scale);
					this.attributes[i].oldQuaternion.copy(this.objects[i].quaternion);
					this.attributes[i].oldRotationMatrix.extractRotation(this.objects[i].matrix);
					this.attributes[i].worldRotationMatrix.extractRotation(this.objects[i].matrixWorld);
					this.attributes[i].parentRotationMatrix.extractRotation(this.objects[i].parent.matrixWorld);
					this.attributes[i].parentScale.setFromMatrixScale(this.tempMatrix.getInverse(this.objects[i].parent.matrixWorld));
				}

				this.offset.copy(planeIntersect.point);
			}

			this.gizmo.startTransform(this);
		}

		this.dragging = true;
	};

	/**
	 * Called whenever the mouse is moved inside of the canvas.
	 *
	 * Constantly recaulculates the transforms being applied.
	 *
	 * @method onPointerMove
	 */
	TransformControls.prototype.onPointerMove = function()
	{
		if(this.objects.length === 0 || this.axis === null || this.dragging === false || this.gizmo === null)
		{
			return;
		}

		this.gizmo.transformObject(this);
	};

	/**
	 * Method called when user input button is released.
	 *
	 * Changes made to the object are added to the editor action history.
	 * 
	 * @method onPointerUp
	 */
	TransformControls.prototype.onPointerUp = function()
	{
		if(this.editing)
		{
			this.gizmo.applyChanges(this);
		}

		this.editing = false;
		this.dragging = false;
	};

	/**
	 * Check if the mouse is currently intersecting objects inside of the canvas.
	 *
	 * @method intersectObjects
	 * @param {Array} objects Object to be tested.
	 * @return {Object} Object intersected is any, false otherwise.
	 */
	TransformControls.prototype.intersectObjects = function(objects)
	{
		var rect = this.canvas.getBoundingClientRect();
		var x = this.mouse.position.x / rect.width;
		var y = this.mouse.position.y / rect.height;

		this.pointerVector.set((x * 2) - 1, - (y * 2) + 1);
		this.raycaster.setFromCamera(this.pointerVector, this.camera);

		var intersections = this.raycaster.intersectObjects(objects, true);

		return intersections.length > 0 ? intersections[0] : false;
	};

	/**
	 * Base button class.
	 * 
	 * @class Button
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function Button(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.cursor = "pointer";

		/**
		 * If the button is disabled, it cannot be clicked.
		 *
		 * @attribute disabled
		 * @type {boolean}
		 */
		var disabled = false;
		Object.defineProperty(this, "disabled",
		{
			get: function(){return disabled;},
			set: function(value){this.setDisabled(value);}
		});

		/**
		 * Base style of the button shown normally.
		 *
		 * @attribute styleBase
		 * @type {Object}
		 */
		this.styleBase = {backgroundColor: "var(--bar-color)"};

		/**
		 * Base style of the button shown when the mouse is over the button.
		 *
		 * @attribute stylePointerOver
		 * @type {Object}
		 */
		this.stylePointerOver = {backgroundColor: "var(--button-over-color)"};

		/**
		 * Disabled style shown when the button is disabled.
		 *
		 * @attribute styleDisabled
		 * @type {Object}
		 */
		this.styleDisabled = {backgroundColor: "var(--color-graph)"};

		this.setStyles(this.styleBase);
		this.preventDragEvents();

		var self = this;

		this.addEvent("mouseenter", function()
		{
			if(!self.disabled)
			{
				self.setStyles(self.stylePointerOver);
			}
		});

		this.addEvent("mouseleave", function()
		{
			if(!self.disabled)
			{
				self.setStyles(self.styleBase);
			}
		});
	}

	Button.prototype = Object.create(Component.prototype);

	/**
	 * Set disabled state of a button element.
	 *
	 * A disabled button cannot be pressed and does not react to interactions.
	 *
	 * @method setDisabled
	 * @param {boolean} disabled
	 */
	Button.prototype.setDisabled = function(disabled)
	{
		this.disabled = disabled;

		if(this.disabled === true)
		{
			this.setStyles(this.styleDisabled);
		}
		else
		{
			this.setStyles(this.styleBase);
		}
	};

	/**
	 * Updates the buttons styles can also change them providing new ones as parameters.
	 *
	 * @method updateSyles
	 * @param {Object} styleBase Style to be applied as base.
	 * @param {Object} stylePointerOver Style to be applied when mouse is over.
	 * @param {Object} styleDisabled Style to be applied when the button is disabled.
	 */
	Button.prototype.updateSyles = function(styleBase, stylePointerOver, styleDisabled)
	{
		if(styleBase !== undefined)
		{
			this.styleBase = styleBase;
		}

		if(stylePointerOver !== undefined)
		{
			this.stylePointerOver = stylePointerOver;
		}

		if(styleDisabled !== undefined)
		{
			this.styleDisabled = styleDisabled;
		}
	};

	/**
	 * A button that can be toggled on and off and keeps its state stored internally.
	 *
	 * Can be used as a base for other buttons that share the same toggle logic.
	 * 
	 * @class ButtonToggle
	 * @extends {Button}
	 * @param {Component} parent Parent element.
	 */
	function ButtonToggle(parent)
	{
		Button.call(this, parent);

		/**
		 * Indicates if the toggle button is currently selected.
		 *
		 * @attribute selected
		 * @type {boolean}
		 */
		this.selected = false;

		/**
		 * Style to be used when the button is selected. If set to null the over style is used.
		 *
		 * @attribute styleSelected
		 */
		this.styleSelected = {backgroundColor: "var(--button-over-color)"};

		var self = this;

		this.addEvent("click", function()
		{
			self.setSelected(!self.selected);
		});

		this.replaceEvent("mouseleave", function()
		{
			if(!self.disabled)
			{
				if(self.selected)
				{
					self.setStyles(self.styleSelected !== null ? self.styleSelected : self.stylePointerOver);
				}
				else
				{
					self.setStyles(self.styleBase);
				}
			}
		});
	}

	ButtonToggle.prototype = Object.create(Button.prototype);

	/**
	 * Set the selected state of the toggle button.
	 *
	 * @param {boolean} value Selected state of the button.
	 */
	ButtonToggle.prototype.setSelected = function(value)
	{
		this.selected = value;

		if(this.selected)
		{
			this.setStyles(this.styleSelected !== null ? this.styleSelected : this.stylePointerOver);	
		}
		else
		{
			this.setStyles(this.styleBase);
		}
	};

	/**
	 * Button with a centered icon.
	 *
	 * @class ButtonIconToggle
	 * @extends {Button}
	 * @param {Component} parent Parent element.
	 */
	function ButtonIcon(parent)
	{
		Button.call(this, parent);

		/**
		 * Icon of the button displayed in the middle.
		 * 
		 * @attribute icon
		 * @type {Component}
		 */
		this.icon = document.createElement("img");
		this.icon.style.pointerEvents = "none";
		this.icon.style.position = "absolute";
		this.icon.style.top = "15%";
		this.icon.style.left = "15%";
		this.icon.style.width = "70%";
		this.icon.style.height = "70%";
		this.element.appendChild(this.icon);
	}

	ButtonIcon.prototype = Object.create(Button.prototype);

	/**
	 * Set button drawer icon.
	 *
	 * @method setImage
	 * @param {string} image Image URL.
	 */
	ButtonIcon.prototype.setImage = function(image)
	{
		this.icon.src = image;
	};

	/**
	 * Set icon scale, the icon will be centered.
	 *
	 * @method setImageScale
	 */
	ButtonIcon.prototype.setImageScale = function(x, y)
	{
		this.icon.style.top = ((1 - y) / 2 * 100) + "%";
		this.icon.style.left = ((1 - x) / 2 * 100) + "%";
		this.icon.style.width = (x * 100) + "%";
		this.icon.style.height = (y * 100) + "%";
	};

	/**
	 * A image button that can be toggled.
	 * 
	 * @class ButtonIconToggle
	 * @extends {ButtonToggle}
	 * @param {Component} parent Parent element.
	 */
	function ButtonIconToggle(parent)
	{
		ButtonToggle.call(this, parent);

		this.element.style.display = "flex";
		this.element.style.justifyContent = "center";
		this.element.style.alignItems = "center";

		/**
		 * Icon of the button displayed in the middle.
		 * 
		 * @attribute icon
		 * @type {Component}
		 */
		this.icon = document.createElement("img");
		this.icon.style.pointerEvents = "none";
		this.icon.style.position = "absolute";
		this.icon.style.top = "15%";
		this.icon.style.left = "15%";
		this.icon.style.width = "70%";
		this.icon.style.height = "70%";
		this.element.appendChild(this.icon);
	}

	ButtonIconToggle.prototype = Object.create(ButtonToggle.prototype);

	/**
	 * Set button drawer icon.
	 *
	 * @method setImage
	 * @param {string} image Image URL.
	 */
	ButtonIconToggle.prototype.setImage = function(image)
	{
		this.icon.src = image;
	};

	/**
	 * Set icon scale, the icon will be centered.
	 *
	 * @method setImageScale
	 */
	ButtonIconToggle.prototype.setImageScale = function(x, y)
	{
		this.icon.style.top = ((1 - y) / 2 * 100) + "%";
		this.icon.style.left = ((1 - x) / 2 * 100) + "%";
		this.icon.style.width = (x * 100) + "%";
		this.icon.style.height = (y * 100) + "%";
	};

	/**
	 * Editor tool bar button.
	 * 
	 * @class ToolBarToogleButton
	 * @extends {ButtonIconToggle}
	 * @param {Component} parent Parent element.
	 */
	function ToolBarToogleButton(parent)
	{
		ButtonIconToggle.call(this, parent);

		var self = this;

		this.setStyle("borderRadius", "5px");
		this.setStyle("overflow", "visible");

		this.icon.style.left = "25%";
		this.icon.style.top = "25%";
		this.icon.style.width = "50%";
		this.icon.style.height = "50%";

		/** 
		 * Component to display the text on mouse over.
		 *
		 * @attribute text
		 * @type {Text}
		 */
		this.text = new Text(this);
		this.text.setMode(Component.BOTTOM_LEFT);
		this.text.setStyle("backgroundColor", "var(--panel-color)");
		this.text.setStyle("borderRadius", "5px");
		this.text.setTextColor("var(--color-light)");
		this.text.setVisibility(false);
		this.element.onmouseenter = function()
		{	
			self.text.setVisibility(true);
		};
		this.element.onmouseleave = function()
		{
			self.text.setVisibility(false);
		};
	}

	ToolBarToogleButton.prototype = Object.create(ButtonIconToggle.prototype);

	/**
	 * Set button text, the text is displayed when mouse passes over the button.
	 *
	 * @method setText
	 * @param {String} text Text to display on mouse over.
	 */
	ToolBarToogleButton.prototype.setText = function(text)
	{
		this.text.setText(text);
	};

	ToolBarToogleButton.prototype.updateSize = function()
	{
		ButtonIcon.prototype.updateSize.call(this);

		this.text.size.set(this.text.measure().x + 20, 30);
		this.text.updateSize();
		this.text.position.set((this.size.x - this.text.size.x) / 2, this.size.y + 2);
		this.text.updatePosition();
	};

	/**
	 * Editor tool bar button.
	 * 
	 * @class ToolBarButton
	 * @extends {ButtonIcon}
	 * @param {Component} parent Parent element.
	 */
	function ToolBarButton(parent)
	{
		ButtonIcon.call(this, parent);

		var self = this;

		this.setStyle("borderRadius", "5px");
		this.setStyle("overflow", "visible");

		this.icon.style.left = "25%";
		this.icon.style.top = "25%";
		this.icon.style.width = "50%";
		this.icon.style.height = "50%";

		/** 
		 * Component to display the text on mouse over.
		 *
		 * @attribute text
		 * @type {Text}
		 */
		this.text = new Text(this);
		this.text.setMode(Component.BOTTOM_LEFT);
		this.text.setStyle("backgroundColor", "var(--panel-color)");
		this.text.setStyle("borderRadius", "5px");
		this.text.setTextColor("var(--color-light)");
		this.text.setVisibility(false);
		this.element.onmouseenter = function()
		{	
			self.text.setVisibility(true);
		};
		this.element.onmouseleave = function()
		{
			self.text.setVisibility(false);
		};
	}

	ToolBarButton.prototype = Object.create(ButtonIcon.prototype);

	/**
	 * Set button text, the text is displayed when mouse passes over the button.
	 *
	 * @method setText
	 * @param {String} text Text to display on mouse over.
	 */
	ToolBarButton.prototype.setText = function(text)
	{
		this.text.setText(text);
	};

	ToolBarButton.prototype.updateSize = function()
	{
		ButtonIcon.prototype.updateSize.call(this);

		this.text.size.set(this.text.measure().x + 20, 30);
		this.text.updateSize();
		this.text.position.set((this.size.x - this.text.size.x) / 2, this.size.y + 2);
		this.text.updatePosition();
	};

	/**
	 * Group of tools contained inside of the ToolBar object.
	 * 
	 * @class ToolBarGroup
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function ToolBarGroup(parent)
	{
		Component.call(this, parent, "div");

		this.setStyle("overflow", "visible");
		this.setStyle("backgroundColor", "var(--bar-color)");
		this.setStyle("borderRadius", "5px");

		this.buttons = [];
	}

	ToolBarGroup.prototype = Object.create(Component.prototype);

	/**
	 * Add new toggle button to this tool bar group.
	 *
	 * @method addOption
	 * @return {ButtonIcon} The button created for the new option
	 */
	ToolBarGroup.prototype.addToggleOption = function(text, icon, callback)
	{
		var button = new ToolBarToogleButton(this);
		button.text.setText(text);
		button.setImage(icon);
		button.size.set(this.size.y, this.size.y);
		button.position.set(this.buttons.length * this.size.y, 0);
		button.updateInterface();
		button.element.onclick = callback;
		this.buttons.push(button);

		this.size.x = this.buttons.length * this.size.y;

		return button;
	};

	/**
	 * Add new button to this tool bar group.
	 *
	 * @method addOption
	 * @return {ButtonIcon} The button created for the new option
	 */
	ToolBarGroup.prototype.addOption = function(text, icon, callback)
	{
		var button = new ToolBarButton(this);
		button.text.setText(text);
		button.setImage(icon);
		button.size.set(this.size.y, this.size.y);
		button.position.set(this.buttons.length * this.size.y, 0);
		button.updateInterface();
		button.element.onclick = callback;
		this.buttons.push(button);

		this.size.x = this.buttons.length * this.size.y;

		return button;
	};

	/**
	 * The tool bar is used to store tool groups.
	 * 
	 * Tools are organized by category, the toolbar size is automatically calculated from the amount of elements.
	 * 
	 * @class ToolBar
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function ToolBar(parent)
	{
		Component.call(this, parent, "div");

		this.setStyle("overflow", "visible");

		/**
		 * Spacing in px between the tool groups.
		 * 
		 * @attribute spacing
		 * @type {Number}
		 */
		this.spacing = 10;

		/**
		 * Groups contained inside this tool bar.
		 * 
		 * @attribute groups
		 * @type {Array}
		 */
		this.groups = [];
		
		this.size.y = 45;

		var self = this;

		var tool = this.addGroup();
		this.select = tool.addToggleOption(Locale.select + " (CTRL+1)", Global.FILE_PATH + "icons/tools/select.png", function()
		{
			self.parent.selectTool(SceneEditor.SELECT);
		});
		this.move = tool.addToggleOption(Locale.move + " (CTRL+2)", Global.FILE_PATH + "icons/tools/move.png", function()
		{
			self.parent.selectTool(SceneEditor.MOVE);
		});
		this.scale = tool.addToggleOption(Locale.scale + " (CTRL+3)", Global.FILE_PATH + "icons/tools/resize.png", function()
		{
			self.parent.selectTool(SceneEditor.SCALE);
		});
		this.rotate = tool.addToggleOption(Locale.rotate + " (CTRL+4)", Global.FILE_PATH + "icons/tools/rotate.png", function()
		{
			self.parent.selectTool(SceneEditor.ROTATE);
		});

		var zoom = this.addGroup();
		this.zoom = zoom.addOption(Locale.focusObject + " (CTRL+F)", Global.FILE_PATH + "icons/misc/focus.png", function()
		{
			self.parent.focusObject();
		});

		this.updateGroups();
	}

	ToolBar.prototype = Object.create(Component.prototype);

	ToolBar.prototype.selectTool = function(tool)
	{
		this.select.setSelected(tool === SceneEditor.SELECT);
		this.move.setSelected(tool === SceneEditor.MOVE);
		this.scale.setSelected(tool === SceneEditor.SCALE);
		this.rotate.setSelected(tool === SceneEditor.ROTATE);
	};

	/**
	 * Add new group to this tool bar.
	 *
	 * @method addGroup
	 * @return {ToolBarGroup} The new group created.
	 */
	ToolBar.prototype.addGroup = function()
	{
		var group = new ToolBarGroup(this);
		group.size.y = this.size.y;
		this.groups.push(group);
		return group;
	};

	/**
	 * Update the groups position and recalculate the bar size.
	 *
	 * Should be manually called after adding new elements to the toolbar.
	 * 
	 * @method updateGroups
	 */
	ToolBar.prototype.updateGroups = function()
	{
		this.size.x = 0;

		for(var i = 0; i < this.groups.length; i++)
		{
			this.groups[i].position.x = this.size.x;
			this.groups[i].updateInterface();

			this.size.x += this.groups[i].size.x;
		
			if(i + 1 < this.groups.length)
			{
				this.size.x += this.spacing;
			}
		}
	};

	/**
	 * Button with text, inherits all methods available on the Text class.
	 * 
	 * Used in menu bars, panels, etc.
	 *
	 * @class ButtonDrawer
	 * @extends {ButtonIcon}
	 * @param {Component} parent Parent element.
	 */
	function ButtonDrawer(parent)
	{
		ButtonIcon.call(this, parent);

		this.element.style.zIndex = "200";
		this.element.style.overflow = "visible";

		this.panel = new Component(this, "div");
		this.panel.element.style.overflow = "visible";
		this.panel.element.style.backgroundColor = "var(--bar-color)";
		this.panel.element.style.zIndex = "250";

		/** 
		 * List of the options in this panel.
		 *
		 * @attribute options
		 * @type {Array}
		 */
		this.options = [];

		/**
		 * Number of maximum options per row
		 *
		 * @attribute optionsPerLine
		 * @type {number}
		 */
		this.optionsPerLine = 3;
		
		/**
		 * Size of each option, also affects the size of the panel.
		 *
		 * @attribute optionsSize
		 * @type {Vector2}
		 */
		this.optionsSize = new three.Vector2(40, 40);

		/**
		 * Scale of the inner icon of the options created from the addOption() method.
		 *
		 * @attribute optionsScale
		 * @type {Vector2}
		 */
		this.optionsScale = new three.Vector2(0.7, 0.7);

		/**
		 * Indicates if the button drawer panel is visible.
		 *
		 * @attribute expanded
		 * @type {boolean}
		 */
		this.expanded = false;
		this.setExpanded(false);

		var self = this;

		this.addEvent("mouseenter", function()
		{
			if(self.disabled === false)
			{
				self.setExpanded(true);
			}
		});

		this.addEvent("mouseleave", function()
		{
			self.setExpanded(false);
		});

		this.panel.addEvent("mouseenter", function()
		{
			self.setExpanded(true);
		});

		this.panel.addEvent("mouseleave", function()
		{
			self.setExpanded(false);
		});
	}

	ButtonDrawer.prototype = Object.create(ButtonIcon.prototype);

	ButtonDrawer.prototype.clear = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].destroy();
		}
		
		this.options = [];
	};

	/**
	 * Expand or close the button drawer panel.
	 *
	 * @method setExpanded
	 * @param {boolean} expanded
	 */
	ButtonDrawer.prototype.setExpanded = function(expanded)
	{
		this.expanded = expanded;
		this.panel.element.style.display = this.expanded ? "block" : "none";
	};

	/** 
	 * Insert new option from already created element.
	 *
	 * @method insertOption
	 * @param {Component} Element of the option to be inserted in the drawer
	 */
	ButtonDrawer.prototype.insertOption = function(element)
	{
		element.attachTo(this.panel);
		this.options.push(element);
	};

	/**
	 * Add new option to the menu.
	 * 
	 * @method addOption
	 * @param {string} image
	 * @param {Function} callback
	 * @param {string} altText
	 */
	ButtonDrawer.prototype.addOption = function(image, callback, altText)
	{
		var self = this;

		var button = new ButtonIcon(this.panel);
		button.setImage(image);
		button.setOnClick(function()
		{
			callback();
			self.expanded = false;
			self.updateInterface();
		});

		if(altText !== undefined)
		{
			button.setAltText(altText);
		}

		this.options.push(button);
	};

	/**
	 * Remove an option from the menu.
	 *
	 * @method removeOption
	 * @param {number} index
	 */
	ButtonDrawer.prototype.removeOption = function(index)
	{
		if(index >= 0 && index < this.options.length)
		{
			this.options[index].destroy();
			this.options.splice(index, 1);
		}
	};

	/**
	 * Updates drawer panel size based on the number of options available.
	 * 
	 * @method updatePanelSize
	 */
	ButtonDrawer.prototype.updatePanelSize = function()
	{
		var optionsPerLine = (this.options.length < this.optionsPerLine) ? this.options.length : this.optionsPerLine;

		this.panel.size.x = (this.optionsSize.x * optionsPerLine);
		this.panel.size.y = (this.optionsSize.y * (Math.floor((this.options.length - 1) / optionsPerLine) + 1));
		this.panel.updateSize();

		this.panel.position.set(this.optionsSize.x, 0);
		this.panel.updatePosition();
	};

	/**
	 * Update drawer options position and size.
	 *
	 * Should be called after change in options displacement variables).
	 *
	 * @method updateOptions
	 */
	ButtonDrawer.prototype.updateOptions = function()
	{
		this.updatePanelSize();

		var optionsPerLine = (this.options.length < this.optionsPerLine) ? this.options.length : this.optionsPerLine;

		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].size.set(this.optionsSize.x, this.optionsSize.y);
			this.options[i].position.x = this.optionsSize.x * (i % optionsPerLine);
			this.options[i].position.y = this.optionsSize.y * Math.floor(i / optionsPerLine);
			this.options[i].updateInterface();
		}
	};

	ButtonDrawer.prototype.updateVisibility = function()
	{
		this.element.style.display = this.visible ? "block" : "none";
	};

	/**
	 * Side bar is presented in the editor to add more objects to the scene.
	 *
	 * @class SideBar
	 * @extends {Component}
	 */
	function SideBar(parent)
	{
		Component.call(this, parent, "div");

		this.preventDragEvents();

		this.setStyle("overflow", "visible");
		this.setStyle("backgroundColor", "var(--bar-color)");

		/**
		 * Scene editor to where this sidebar is attached.
		 *
		 * @attribute editor
		 * @type {SceneEditor}
		 */
		this.editor = parent;

		/**
		 * List of object placing buttons.
		 *
		 * @attribute buttons
		 * @type {Array}
		 */	
		this.buttons = [];

		this.createObject();

		this.addText = new Text(this);
		this.addText.setText(Locale.add);
		this.addText.size.set(40, 20);
		this.addText.position.set(0, 5);
		this.addText.updateInterface();

		/**
		 * More button is displayed when there is no space for the buttons placed in the side bar.
		 *
		 * @attribute more
		 * @type {ButtonDrawer}
		 */
		this.more = new ButtonDrawer(this);
		this.more.setImage(Global.FILE_PATH + "icons/misc/more.png");
		this.more.optionsPerLine = 1;
	}

	SideBar.prototype = Object.create(Component.prototype);

	SideBar.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		var size = this.size.x;
		var y = 30, i = 0;

		// Update buttons size
		while(y < this.size.y - 2 * size && i < this.buttons.length)
		{
			this.buttons[i].attachTo(this);
			this.buttons[i].size.set(size, size);
			this.buttons[i].position.set(0, y);
			this.buttons[i].optionsSize.set(size, size);
			this.buttons[i].visible = true;
			this.buttons[i].updateInterface();

			i++;
			y += size;
		}

		if(this.size.y < 250)
		{
			this.more.setVisibility(false);
		}
		else
		{
			if(i < this.buttons.length)
			{
				this.more.clear();
				this.more.optionsSize.set(size, size);
				this.more.size.set(size, size);
				this.more.position.set(0, y);
				this.more.visible = true;

				while(i < this.buttons.length)
				{
					this.more.insertOption(this.buttons[i]);
					i++;
				}

				this.more.updateOptions();
				this.more.updateInterface();
			}
			else
			{
				this.more.setVisibility(false);
			}
		}
	};

	/** 
	 * Create the icons to add objects to the scene.
	 *
	 * @method createObject
	 */
	SideBar.prototype.createObject = function()
	{
		var self = this;

		// Add Models
		var models = new ButtonDrawer(this);
		models.setImage(Global.FILE_PATH + "icons/models/models.png");
		this.buttons.push(models);

		// Cube
		models.addOption(Global.FILE_PATH + "icons/models/cube.png", function()
		{
			var geometry = new three.BoxBufferGeometry(1, 1, 1);
			geometry.name = "cube";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "cube";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.cube);

		// Cylinder
		models.addOption(Global.FILE_PATH + "icons/models/cylinder.png", function()
		{
			var geometry = new three.CylinderBufferGeometry(1, 1, 2, 32);
			geometry.name = "cylinder";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "cylinder";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.cylinder);

		// Sphere
		models.addOption(Global.FILE_PATH + "icons/models/sphere.png", function()
		{
			var geometry = new three.SphereBufferGeometry(1, 32, 32);
			geometry.name = "sphere";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "sphere";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.sphere);

		// Torus Knot
		models.addOption(Global.FILE_PATH + "icons/models/torusknot.png", function()
		{
			var geometry = new three.TorusKnotBufferGeometry(1, 0.4, 128, 96, 2, 3);
			geometry.name = "torusknot";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "torus knot";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.torusKnot);
		
		// Torus
		models.addOption(Global.FILE_PATH + "icons/models/torus.png", function()
		{
			var geometry = new three.TorusBufferGeometry(1, 0.5, 16, 96);
			geometry.name = "torus";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "torus";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.torus);

		// Cone
		models.addOption(Global.FILE_PATH + "icons/models/cone.png", function()
		{
			var geometry = new three.ConeBufferGeometry(1, 2, 32);
			geometry.name = "cone";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "cone";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.cone);
		
		// Plane
		models.addOption(Global.FILE_PATH + "icons/models/plane.png", function()
		{
			var geometry = new three.PlaneBufferGeometry(1, 1);
			geometry.name = "plane";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "plane";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.plane);

		// Circle
		models.addOption(Global.FILE_PATH + "icons/models/circle.png", function()
		{
			var geometry = new three.CircleBufferGeometry(1, 32);
			geometry.name = "circle";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "circle";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.circle);

		// Ring
		models.addOption(Global.FILE_PATH + "icons/models/ring.png", function()
		{
			var geometry = new three.RingBufferGeometry(1, 5, 32, 1);
			geometry.name = "ring";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "ring";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.ring);

		// Icosahedron
		models.addOption(Global.FILE_PATH + "icons/models/icosahedron.png", function()
		{
			var geometry = new three.IcosahedronBufferGeometry(1, 0);
			geometry.name = "icosahedron";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "icosahedron";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.icosahedron);

		// Tetrahedron
		models.addOption(Global.FILE_PATH + "icons/models/pyramid.png", function()
		{
			var geometry = new three.TetrahedronBufferGeometry(1, 0);
			geometry.name = "tetrahedron";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "tetrahedron";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.tetrahedron);

		// Octahedron
		models.addOption(Global.FILE_PATH + "icons/models/octahedron.png", function()
		{
			var geometry = new three.OctahedronBufferGeometry(1, 0);
			geometry.name = "octahedron";

			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "octahedron";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.octahedron);

		// Dodecahedron
		models.addOption(Global.FILE_PATH + "icons/models/dodecahedron.png", function()
		{
			var geometry = new three.DodecahedronBufferGeometry(1, 0);
			geometry.name = "dodecahedron";
			
			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "dodecahedron";
			Editor$1.addObject(model, self.editor.scene);
		}, Locale.dodecahedron);

		// Capsule
		models.addOption(Global.FILE_PATH + "icons/models/capsule.png", function()
		{
			var geometry = new CapsuleBufferGeometry(0.5, 0.5, 1.0, 32, 1, 8, 8);
			geometry.name = "capsule";
			
			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "capsule";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.capsule);

		// Rounded box
		models.addOption(Global.FILE_PATH + "icons/models/cube.png", function()
		{
			var geometry = new RoundedBoxBufferGeometry(1, 1, 1, 0.1, 8);
			geometry.name = "box";
			
			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "box";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.roundedBox);

		// Terrain
		models.addOption(Global.FILE_PATH + "icons/models/terrain.png", function()
		{
			Editor$1.addAction(new AddResourceAction(Editor$1.defaultImageTerrain, Editor$1.program, "images"));

			var geometry = new TerrainBufferGeometry(10, 10, 100, 100, 5, Editor$1.defaultImageTerrain);
			geometry.name = "terrain";
			
			var model = new Mesh(geometry, Editor$1.defaultMaterial);
			model.name = "terrain";

			Editor$1.addObject(model, self.editor.scene);
		}, Locale.terrain);

		// Parametric
		/*models.addOption(Global.FILE_PATH + "icons/models/spline.png", function()
		{
			var klein = function (v, u, optionalTarget)
			{
				var result = optionalTarget || new Vector3();

				u *= Math.PI;
				v *= 2 * Math.PI;

				u = u * 2;
				var x, y, z;
				if (u < Math.PI)
				{
					x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v);
					z = - 8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v);
				}
				else
				{
					x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI);
					z = - 8 * Math.sin(u);
				}

				y = - 2 * (1 - Math.cos(u) / 2) * Math.sin(v);

				return result.set(x, y, z);
			};

			var geometry = new ParametricGeometry(klein, 25, 25);
			var model = new Mesh(geometry, Editor.defaultMaterial);
			model.name = "parametric";
			Editor.addObject(model, self.editor.scene);
		}, Locale.parametric);*/

		models.updateOptions();

		// Text
		var text = new ButtonDrawer(this);
		text.setImage(Global.FILE_PATH + "icons/text/text.png");
		this.buttons.push(text);

		text.addOption(Global.FILE_PATH + "icons/text/textmesh.png", function()
		{
			Editor$1.addObject(new TextMesh("text", Editor$1.defaultMaterial, Editor$1.defaultFont), self.editor.scene);
		}, Locale.textMesh);

		text.addOption(Global.FILE_PATH + "icons/text/text.png", function()
		{
			var texture = new Texture(Global.FILE_PATH + "sdf/roboto-bold.png");
			var object = new TextBitmap(
			{
				font: JSON.parse(FileSystem.readFile(Global.FILE_PATH + "sdf/roboto-bold.json")),
				text: "text",
				width: 500,
				align: TextBitmap.CENTER,
				letterSpacing: 3,
				color: 0xFFFFFF
			}, texture, TextBitmap.SDF);

			Editor$1.addObject(object, self.editor.scene);
		}, Locale.textBitmap);

		text.addOption(Global.FILE_PATH + "icons/text/textcanvas.png", function()
		{
			Editor$1.addObject(new TextSprite("text"), self.editor.scene);
		}, Locale.textSprite);

		text.updateOptions();

		// Add lights
		var lights = new ButtonDrawer(this);
		lights.setImage(Global.FILE_PATH + "icons/lights/point.png");
		this.buttons.push(lights);

		// Point Light
		lights.addOption(Global.FILE_PATH + "icons/lights/point.png", function()
		{
			Editor$1.addObject(new PointLight(0x444444), self.editor.scene);
		}, Locale.pointLight);

		// Ambient Light
		lights.addOption(Global.FILE_PATH + "icons/lights/ambient.png", function()
		{
			Editor$1.addObject(new AmbientLight(0x444444), self.editor.scene);
		}, Locale.ambientLight);

		// Spot Light
		lights.addOption(Global.FILE_PATH + "icons/lights/spot.png", function()
		{
			Editor$1.addObject(new SpotLight(0x444444), self.editor.scene);
		}, Locale.spotLight);

		// Directional Light
		lights.addOption(Global.FILE_PATH + "icons/lights/directional.png", function()
		{
			Editor$1.addObject(new DirectionalLight(0x444444), self.editor.scene);
		}, Locale.directionalLight);

		// Hemisphere Light
		lights.addOption(Global.FILE_PATH + "icons/lights/hemisphere.png", function()
		{
			Editor$1.addObject(new HemisphereLight(0x444444), self.editor.scene);
		}, Locale.hemisphereLight);

		// RectArea Light
		lights.addOption(Global.FILE_PATH + "icons/lights/rectarea.png", function()
		{
			Editor$1.addObject(new RectAreaLight(0x444444, 100, 1, 1), self.editor.scene);
		}, Locale.rectAreaLight);

		// Probe
		lights.addOption(Global.FILE_PATH + "icons/misc/probe.png", function()
		{
			Editor$1.addObject(new LightProbe(), self.editor.scene);
		}, Locale.lighProbe);

		// Sky
		lights.addOption(Global.FILE_PATH + "icons/lights/sky.png", function()
		{
			Editor$1.addObject(new Sky(), self.editor.scene);
		}, Locale.sky);

		lights.updateOptions();

		// Add camera
		var cameras = new ButtonDrawer(this);
		cameras.setImage(Global.FILE_PATH + "icons/camera/camera.png");
		this.buttons.push(cameras);

		// Perspective camera
		cameras.addOption(Global.FILE_PATH + "icons/camera/prespective.png", function()
		{
			Editor$1.addObject(new PerspectiveCamera(60, 1), self.editor.scene);
		}, Locale.perspectiveCamera);

		// Orthographic camera
		cameras.addOption(Global.FILE_PATH + "icons/camera/orthographic.png", function()
		{
			Editor$1.addObject(new OrthographicCamera(3, 2, OrthographicCamera.RESIZE_HORIZONTAL), self.editor.scene);
		}, Locale.orthographicCamera);

		cameras.updateOptions();

		// Add script
		var scripts = new ButtonDrawer(this);
		scripts.setImage(Global.FILE_PATH + "icons/script/script.png");
		this.buttons.push(scripts);

		// Javascript script
		scripts.addOption(Global.FILE_PATH + "icons/script/script.png", function()
		{
			Editor$1.addObject(new Script(), self.editor.scene);
		}, "Javascript Script");

		scripts.updateOptions();

		// Effects
		var effects = new ButtonDrawer(this);
		effects.setImage(Global.FILE_PATH + "icons/misc/particles.png");
		this.buttons.push(effects);

		// Sprite
		effects.addOption(Global.FILE_PATH + "icons/misc/sprite.png", function()
		{
			Editor$1.addObject(new Sprite(Editor$1.defaultSpriteMaterial), self.editor.scene);
		}, Locale.sprite);

		// Particle emitter
		effects.addOption(Global.FILE_PATH + "icons/misc/particles.png", function()
		{
			var particle = new ParticleEmitter();
			particle.texture = Editor$1.defaultTextureParticle;
			particle.reload();
			Editor$1.addObject(particle, self.editor.scene);
		}, Locale.particleEmitter);

		// Container
		effects.addOption(Global.FILE_PATH + "icons/misc/container.png", function()
		{
			Editor$1.addObject(new Container(), self.editor.scene);
		}, Locale.container);

		// Cube Camera
		effects.addOption(Global.FILE_PATH + "icons/misc/probe.png", function()
		{
			Editor$1.addObject(new CubeCamera(), self.editor.scene);
		}, Locale.cubeCamera);

		// Audio
		effects.addOption(Global.FILE_PATH + "icons/misc/audio.png", function()
		{
			Editor$1.addObject(new AudioEmitter(Editor$1.defaultAudio), self.editor.scene);
		}, Locale.audio);

		// Positional Audio
		effects.addOption(Global.FILE_PATH + "icons/misc/audio_positional.png", function()
		{
			Editor$1.addObject(new PositionalAudio(Editor$1.defaultAudio), self.editor.scene);
		}, Locale.positionalAudio);

		// Lens flare
		effects.addOption(Global.FILE_PATH + "icons/misc/flare.png", function()
		{
			var lensFlare = new LensFlare();

			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[0], 700, 0.0);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[2], 512, 0.0);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[2], 512, 0.0);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[2], 512, 0.0);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[3], 60, 0.6);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[3], 70, 0.7);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[3], 120, 0.9);
			lensFlare.addFlare(Editor$1.defaultTextureLensFlare[3], 70, 1.0);

			Editor$1.addObject(lensFlare, self.editor.scene);
		}, Locale.lensFlare);

		if(Nunu.developmentMode())
		{
			effects.addOption(Global.FILE_PATH + "icons/platform/web.png", function()
			{
				Editor$1.addObject(new HTMLView("https:// www.techpowerup.com/"), self.editor.scene);
			}, Locale.htmlView);
		}

		effects.updateOptions();

		// Physics
		var physics = new ButtonDrawer(this);
		physics.setImage(Global.FILE_PATH + "icons/misc/physics.png");
		this.buttons.push(physics);

		// Physics box
		physics.addOption(Global.FILE_PATH + "icons/models/cube.png", function()
		{
			var object = new PhysicsObject();
			object.body.addShape(new cannon.Box(new cannon.Vec3(0.5, 0.5, 0.5)));
			object.name = "box";
			Editor$1.addObject(object, self.editor.scene);
		}, Locale.box);

		// Physics sphere
		physics.addOption(Global.FILE_PATH + "icons/models/sphere.png", function()
		{
			var object = new PhysicsObject();
			object.body.addShape(new cannon.Sphere(1.0));
			object.name = "sphere";
			Editor$1.addObject(object, self.editor.scene);
		}, Locale.sphere);

		// Physics Cylinder
		physics.addOption(Global.FILE_PATH + "icons/models/cylinder.png", function()
		{
			var object = new PhysicsObject();
			object.body.addShape(new cannon.Cylinder(1.0, 1.0, 2.0, 8));
			object.name = "cylinder";
			Editor$1.addObject(object, self.editor.scene);
		}, Locale.cylinder);

		// Physics Plane
		physics.addOption(Global.FILE_PATH + "icons/models/plane.png", function()
		{
			var object = new PhysicsObject();
			object.rotation.x = -Math.PI / 2;
			object.body.addShape(new cannon.Plane());
			object.body.type = cannon.Body.KINEMATIC;
			object.name = "ground";
			Editor$1.addObject(object, self.editor.scene);
		}, Locale.ground);

		// Physics Particle
		physics.addOption(Global.FILE_PATH + "icons/models/point.png", function()
		{
			var object = new PhysicsObject();
			object.body.addShape(new cannon.Particle());
			object.name = "particle";
			Editor$1.addObject(object, self.editor.scene);
		}, Locale.particle);

		physics.updateOptions();

		// Add device
		var controls = new ButtonDrawer(this);
		controls.setImage(Global.FILE_PATH + "icons/misc/controller.png");
		this.buttons.push(controls);

		// Orbit controls
		controls.addOption(Global.FILE_PATH + "icons/misc/orbit.png", function()
		{
			Editor$1.addObject(new OrbitControls(), self.editor.scene);
		}, Locale.orbitControls);

		// FPS controls
		controls.addOption(Global.FILE_PATH + "icons/misc/crosshair.png", function()
		{
			Editor$1.addObject(new FirstPersonControls(), self.editor.scene);
		}, Locale.firstPersonControls);

		// Leap Hand
		controls.addOption(Global.FILE_PATH + "icons/hw/leap.png", function()
		{
			Editor$1.addObject(new LeapMotion(), self.editor.scene);
		}, Locale.leapMotion);

		// Kinect Skeleton
		controls.addOption(Global.FILE_PATH + "icons/hw/kinect.png", function()
		{
			Editor$1.addObject(new KinectDevice(), self.editor.scene);
		}, Locale.microsoftKinect);

		controls.updateOptions();
	};

	/** 
	 * Wireframe helper is used to preview drawable objects.
	 * 
	 * Every line is drawn individually, usefull to analyse the geometry in detail.
	 *
	 * @class WireframeHelper
	 * @param {Object3D} object
	 * @param {number} hex Helper color in hexadecimal.
	 */
	function WireframeHelper(object, hex) 
	{
		three.Mesh.call(this, object.geometry, new three.MeshBasicMaterial(
		{
			color: (hex !== undefined) ? hex : 0xFFFFFF,
			wireframe: true
		}));

		/**
		 * Object attached to the helper
		 *
		 * @attribute object
		 * @type {Object3D}
		 */
		this.object = object;
		
		this.matrixAutoUpdate = false;
		this.update();
	}

	WireframeHelper.prototype = Object.create(three.Mesh.prototype);

	WireframeHelper.prototype.update = function()
	{
		this.geometry = this.object.geometry;
		this.matrix.copy(this.object.matrixWorld);
	};

	function SkeletonHelper(object) 
	{
		this.object = object;

		var bones = SkeletonHelper.getBoneList(object);
		var geometry = new three.BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new three.Color(0, 0, 1);
		var color2 = new three.Color(0, 1, 0);

		for(var i = 0; i < bones.length; i++)
		{
			var bone = bones[i];

			if(bone.parent && bone.parent.isBone)
			{
				vertices.push(0, 0, 0);
				vertices.push(0, 0, 0);
				colors.push(color1.r, color1.g, color1.b);
				colors.push(color2.r, color2.g, color2.b);
			}
		}

		geometry.setAttribute("position", new three.Float32BufferAttribute(vertices, 3));
		geometry.setAttribute("color", new three.Float32BufferAttribute(colors, 3));

		three.LineSegments.call(this, geometry, new three.LineBasicMaterial(
		{
			vertexColors: three.VertexColors,
			depthTest: false,
			depthWrite: false,
			transparent: false
		}));

		this.root = object;
		this.bones = bones;
		this.matrixAutoUpdate = false;

		this.update();
	}

	SkeletonHelper.prototype = Object.create(three.LineSegments.prototype);

	SkeletonHelper.getBoneList = function(object)
	{
		var boneList = [];

		if(object && object.isBone)
		{
			boneList.push(object);
		}

		for(var i = 0; i < object.children.length; i++)
		{
			boneList.push.apply(boneList, SkeletonHelper.getBoneList(object.children[i]));
		}

		return boneList;
	};

	SkeletonHelper.prototype.update = function ()
	{
		var bones = this.bones;
		var geometry = this.geometry;
		var position = geometry.getAttribute("position");

		var matrixWorldInv = new three.Matrix4();
		matrixWorldInv.getInverse(this.root.matrixWorld);

		var boneMatrix = new three.Matrix4();
		var vector = new three.Vector3();

		for(var i = 0, j = 0; i < bones.length; i++)
		{
			var bone = bones[i];
			if(bone.parent && bone.parent.isBone)
			{	
				boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
				vector.setFromMatrixPosition(boneMatrix);
				position.setXYZ(j, vector.x, vector.y, vector.z);

				boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
				vector.setFromMatrixPosition(boneMatrix);
				position.setXYZ(j + 1, vector.x, vector.y, vector.z);

				j += 2;
			}
		}

		geometry.getAttribute("position").needsUpdate = true;
	};

	/**
	 * Helper to visualizer rect aread lights.
	 *
	 * @class RectAreaLightHelper
	 */
	function RectAreaLightHelper(object) 
	{
		three.Mesh.call(this, new three.PlaneBufferGeometry(1, 1), new three.MeshBasicMaterial({side: three.DoubleSide}));

		/**
		 * Object attached to the helper
		 *
		 * @attribute object
		 * @type {Object3D}
		 */
		this.object = object;

		this.update();
	}

	RectAreaLightHelper.prototype = Object.create(three.Mesh.prototype);

	RectAreaLightHelper.prototype.update = function()
	{
		this.material.color.copy(this.object.color).multiplyScalar(this.object.intensity);

		this.object.getWorldPosition(this.position);
		this.object.getWorldQuaternion(this.quaternion);

		this.scale.set(this.object.width, this.object.height, 1);
	};

	/** 
	 * Point helper is used to preview Points objects.
	 * 
	 * @class PointsHelper
	 * @param {Points} object
	 * @param {number} hex Helper color in hexadecimal.
	 */
	function PointsHelper(object, hex)
	{
		three.Points.call(this, object.geometry, object.material.clone());

		this.material.color = new three.Color((hex !== undefined) ? hex : 0xFFFF00);
		this.material.size = object.material.size * 1.2;

		/**
		 * Object attached to the helper
		 *
		 * @attribute object
		 * @type {Object3D}
		 */
		this.object = object;

		this.matrixAutoUpdate = false;
		this.update();
	}

	PointsHelper.prototype = Object.create(three.Points.prototype);

	PointsHelper.prototype.update = function()
	{
		this.geometry = this.object.geometry;
		this.matrix.copy(this.object.matrixWorld);
	};

	/**
	 * Helper to preview physics objects on the editor.
	 *
	 * Based on code from CANNON debug shape renderer made by schteppe
	 *
	 * @class PhysicsObjectHelper
	 */
	function PhysicsObjectHelper(object, color)
	{
		three.Object3D.call(this);

		/**
		 * Object attached to the helper.
		 *
		 * @attribute object
		 * @type {Object3D}
		 */
		this.object = object;

		/**
		 * Meshes used to represent the shapes attached to the body.
		 *
		 * @attribute meshes
		 * @type {Array}
		 */
		this.meshes = [];
		this.matrixAutoUpdate = false;

		this.material = new three.MeshBasicMaterial(
		{
			color: (color !== undefined) ? color : 0x00FF00,
			wireframe: false,
			transparent: true,
			opacity: 0.5
		});
	}

	PhysicsObjectHelper.SPHERE = new three.SphereBufferGeometry(1, 32, 32);
	PhysicsObjectHelper.BOX = new three.BoxBufferGeometry(1, 1, 1);
	PhysicsObjectHelper.PLANE = new three.PlaneBufferGeometry(100, 100);
	PhysicsObjectHelper.CYLINDER = new three.CylinderBufferGeometry(1, 1, 10, 32);

	PhysicsObjectHelper.prototype = Object.create(three.Object3D.prototype);

	/**
	 * Update the helper from the physics body.
	 *
	 * @method update
	 */
	PhysicsObjectHelper.prototype.update = function()
	{
		this.matrix.copy(this.object.matrixWorld);

		var body = this.object.body;
		var index = 0;

		// Iterate all the shapes in the physics body
		for(var j = 0; j < body.shapes.length; j++)
		{
			var shape = body.shapes[j];

			this.updateMesh(index, body, shape);

			var mesh = this.meshes[index];
			if(mesh !== undefined)
			{
				var tmpVec = new cannon.Vec3();
				var tmpQuat = new cannon.Vec3();

				// Get world position
				body.quaternion.vmult(body.shapeOffsets[j], tmpVec);
				body.position.vadd(tmpVec, tmpVec);

				// Get world quaternion
				body.quaternion.mult(body.shapeOrientations[j], tmpQuat);

				// Copy to meshes
				mesh.position.copy(tmpVec);
				mesh.quaternion.copy(tmpQuat);
			}

			index++;
		}

		for(var i = index; i < this.meshes.length; i++)
		{
			var mesh = index[i];
			if(mesh)
			{
				this.remove(mesh);
			}
		}

		this.meshes.length = index;
	};

	PhysicsObjectHelper.prototype.updateMesh = function(index, body, shape)
	{
		var mesh = this.meshes[index];
		if(!this.typeMatch(mesh, shape))
		{
			if(mesh)
			{
				this.remove(mesh);
			}
			mesh = this.meshes[index] = this.createMesh(shape);
		}

		this.scaleMesh(mesh, shape);
	};

	/**
	 * Check if the mesh attahched to this helper object matches the CANNON body shape.
	 *
	 * @method typeMatch
	 * @return {boolean} True if the mesh matches the shape.
	 */
	PhysicsObjectHelper.prototype.typeMatch = function(mesh, shape)
	{
		if(!mesh)
		{
			return false;
		}

		var geometry = mesh.geometry;

		return (geometry instanceof three.SphereGeometry && shape instanceof cannon.Sphere) ||
		(geometry instanceof three.BoxGeometry && shape instanceof cannon.Box) ||
		(geometry instanceof three.PlaneGeometry && shape instanceof cannon.Plane) ||
		(geometry.id === shape.geometryId && (shape instanceof cannon.ConvexPolyhedron || shape instanceof cannon.Trimesh) || shape instanceof cannon.Heightfield);
	};

	/**
	 * Create a mesh to represent a CANNON physics shape and attach it to this helper object.
	 *
	 * @method createMesh
	 * @return {Mesh} Mesh created to represent the shape.
	 */
	PhysicsObjectHelper.prototype.createMesh = function(shape)
	{
		var material = this.material;
		var mesh = null;

		switch(shape.type)
		{
			case cannon.Shape.types.SPHERE:
				mesh = new three.Mesh(PhysicsObjectHelper.SPHERE, material);
				break;

			case cannon.Shape.types.PARTICLE:
				mesh = new three.Mesh(PhysicsObjectHelper.SPHERE, material);
				break;

			case cannon.Shape.types.BOX:
				mesh = new three.Mesh(PhysicsObjectHelper.BOX, material);
				break;

			case cannon.Shape.types.PLANE:
				mesh = new three.Mesh(PhysicsObjectHelper.PLANE, material);
				mesh.scale.set(1000, 1000, 1);
				break;

			case cannon.Shape.types.CONVEXPOLYHEDRON:
				// Create mesh
				var geo = new three.Geometry();

				// Add vertices
				for(var i = 0; i < shape.vertices.length; i++)
				{
					var v = shape.vertices[i];
					geo.vertices.push(new three.Vector3(v.x, v.y, v.z));
				}

				// Add faces
				for(var i = 0; i < shape.faces.length; i++)
				{
					var face = shape.faces[i];

					// Add triangles
					var a = face[0];
					for(var j = 1; j < face.length - 1; j++)
					{
						var b = face[j];
						var c = face[j + 1];
						geo.faces.push(new three.Face3(a, b, c));
					}
				}
				geo.computeBoundingSphere();
				geo.computeFaceNormals();
				mesh = new three.Mesh(geo, material);
				shape.geometryId = geo.id;
				break;

			case cannon.Shape.types.TRIMESH:
				var geometry = new three.Geometry();
				var v0 = new cannon.Vec3();
				var v1 = new cannon.Vec3();
				var v2 = new cannon.Vec3();
				for(var i = 0; i < shape.indices.length / 3; i++)
				{
					shape.getTriangleVertices(i, v0, v1, v2);
					geometry.vertices.push(new three.Vector3(v0.x, v0.y, v0.z), new three.Vector3(v1.x, v1.y, v1.z), new three.Vector3(v2.x, v2.y, v2.z));
					var j = geometry.vertices.length - 3;
					geometry.faces.push(new three.Face3(j, j+1, j+2));
				}
				geometry.computeBoundingSphere();
				geometry.computeFaceNormals();
				mesh = new three.Mesh(geometry, material);
				shape.geometryId = geometry.id;
				break;

			case cannon.Shape.types.HEIGHTFIELD:
				var geometry = new three.Geometry();
				var v0 = new cannon.Vec3();
				var v1 = new cannon.Vec3();
				var v2 = new cannon.Vec3();

				for(var xi = 0; xi < shape.data.length - 1; xi++)
				{
					for(var yi = 0; yi < shape.data[xi].length - 1; yi++)
					{
						for(var k = 0; k < 2; k++)
						{
							shape.getConvexTrianglePillar(xi, yi, k === 0);
							v0.copy(shape.pillarConvex.vertices[0]);
							v1.copy(shape.pillarConvex.vertices[1]);
							v2.copy(shape.pillarConvex.vertices[2]);
							v0.vadd(shape.pillarOffset, v0);
							v1.vadd(shape.pillarOffset, v1);
							v2.vadd(shape.pillarOffset, v2);
							geometry.vertices.push(new three.Vector3(v0.x, v0.y, v0.z), new three.Vector3(v1.x, v1.y, v1.z), new three.Vector3(v2.x, v2.y, v2.z));
							var i = geometry.vertices.length - 3;
							geometry.faces.push(new three.Face3(i, i + 1, i + 2));
						}
					}
				}

				geometry.computeBoundingSphere();
				geometry.computeFaceNormals();
				mesh = new three.Mesh(geometry, material);
				shape.geometryId = geometry.id;
				break;
		}

		if(mesh !== null)
		{
			this.add(mesh);
		}

		return mesh;
	};

	/**
	 * Set to correct scale of the helper mesh based on the shape type and size configuration.
	 *
	 * @method scaleMesh
	 * @param {Mesh} mesh Mesh to be changed.
	 * @param {Shape} shape Shape to analyse and extract scale from.
	 */
	PhysicsObjectHelper.prototype.scaleMesh = function(mesh, shape)
	{
		var type = shape.type;

		if(type === cannon.Shape.types.SPHERE)
		{
			var radius = shape.radius;
			mesh.scale.set(radius, radius, radius);
		}
		else if(type === cannon.Shape.types.PARTICLE)
		{
			mesh.scale.set(0.1, 0.1, 0.1);
		}
		else if(type === cannon.Shape.types.BOX)
		{
			mesh.scale.copy(shape.halfExtents);
			mesh.scale.multiplyScalar(2);
		}
		else if(type === cannon.Shape.types.CONVEXPOLYHEDRON)
		{
			mesh.scale.set(1, 1, 1);
		}
		else if(type === cannon.Shape.types.TRIMESH)
		{
			mesh.scale.copy(shape.scale);
		}
		else if(type === cannon.Shape.types.HEIGHTFIELD)
		{
			mesh.scale.set(1, 1, 1);
		}
	};

	/** 
	 * Object icon helper is used to display the icon of an object.
	 * 
	 * @class ObjectIconHelper
	 * @param {Object3D} object
	 * @param {String) icon Icon URL.
	 */
	function ObjectIconHelper(object, icon)
	{
		three.Sprite.call(this, ObjectIconHelper.getMaterial(icon));

		/**
		 * Object attached to the helper
		 *
		 * @attribute object
		 * @type {Object3D}
		 */
		this.object = object;

		/**
		 * Size of the helper.
		 *
		 * @attribute size
		 * @type {number}
		 */
		this.size = 0.1;
		
		this.matrixAutoUpdate = false;
	}

	ObjectIconHelper.prototype = Object.create(three.Sprite.prototype);

	/**
	 * Cache of icon helper materials.
	 *
	 * @static
	 * @attribute MATERIALS
	 * @type {Map}
	 */
	ObjectIconHelper.MATERIALS = new Map();

	/**
	 * Get the sprite material for a icon url.
	 *
	 * @static
	 * @method getMaterial
	 * @param {string} icon Icon URL.
	 */
	ObjectIconHelper.getMaterial = function(icon)
	{
		if(ObjectIconHelper.MATERIALS.has(icon))
		{
			return ObjectIconHelper.MATERIALS.get(icon);
		}

		var element = document.createElement("img");
		var texture = new three.Texture(element);
		var material = new three.SpriteMaterial(
		{
			map: texture,
			transparent: true,
			depthTest: false,
			depthWrite: false,
			sizeAttenuation: false,
			alphaTest: 0.2
		});
		
		material.ratio = 1.0;

		element.onload = function()
		{
			material.ratio = this.naturalWidth / this.naturalHeight;
			texture.needsUpdate = true;	
		};
		element.src = icon;

		ObjectIconHelper.MATERIALS.set(icon, material);

		return material;
	};

	ObjectIconHelper.prototype.update = function()
	{
		// Position
		this.matrix.elements[12] = this.object.matrixWorld.elements[12];
		this.matrix.elements[13] = this.object.matrixWorld.elements[13];
		this.matrix.elements[14] = this.object.matrixWorld.elements[14];

		// Scale
		this.matrix.elements[0] = this.size;
		this.matrix.elements[5] = this.size / this.material.ratio;
		this.matrix.elements[10] = this.size;

	};

	/** 
	 * Line helper is used to preview Line objects.
	 * 
	 * @class LineHelper
	 * @param {Line} object
	 * @param {number} hex Helper color in hexadecimal.
	 */
	function LineHelper(object, hex)
	{
		three.Line.call(this, object.geometry, object.material.clone());

		this.material.color = new three.Color((hex !== undefined) ? hex : 0xFFFF00);
		
		/**
		 * Object attached to the helper
		 *
		 * @attribute object
		 * @type {Object3D}
		 */
		this.object = object;
		
		this.matrixAutoUpdate = false;
		this.update();
	}

	LineHelper.prototype = Object.create(three.Line.prototype);

	LineHelper.prototype.update = function()
	{
		this.geometry = this.object.geometry;
		this.matrix.copy(this.object.matrixWorld);
	};

	function LightProbeHelper(lightProbe, size)
	{
		this.lightProbe = lightProbe;
		this.size = size;

		var material = new three.ShaderMaterial({

			type: 'LightProbeHelperMaterial',

			uniforms: {
				sh: {value: this.lightProbe.sh.coefficients}, // by reference
				intensity: {value: this.lightProbe.intensity}
			},

			vertexShader: [
				'varying vec3 vNormal;',
				'void main() {',
				'	vNormal = normalize(normalMatrix * normal);',
				'	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
				'}',
			].join('\n'),

			fragmentShader: [
				'#define RECIPROCAL_PI 0.318309886',
				'vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {',
				'	// matrix is assumed to be orthogonal',
				'	return normalize((vec4(normal, 0.0) * matrix).xyz);',
				'}',

				'// source: https:// graphics.stanford.edu/papers/envmap/envmap.pdf',
				'vec3 shGetIrradianceAt(in vec3 normal, in vec3 shCoefficients[9]) {',

				'	// normal is assumed to have unit length',
				'	float x = normal.x, y = normal.y, z = normal.z;',

				'	// band 0',
				'	vec3 result = shCoefficients[0] * 0.886227;',

				'	// band 1',
				'	result += shCoefficients[1] * 2.0 * 0.511664 * y;',
				'	result += shCoefficients[2] * 2.0 * 0.511664 * z;',
				'	result += shCoefficients[3] * 2.0 * 0.511664 * x;',

				'	// band 2',
				'	result += shCoefficients[4] * 2.0 * 0.429043 * x * y;',
				'	result += shCoefficients[5] * 2.0 * 0.429043 * y * z;',
				'	result += shCoefficients[6] * (0.743125 * z * z - 0.247708);',
				'	result += shCoefficients[7] * 2.0 * 0.429043 * x * z;',
				'	result += shCoefficients[8] * 0.429043 * (x * x - y * y);',

				'	return result;',

				'}',

				'uniform vec3 sh[9]; // sh coefficients',
				'uniform float intensity; // light probe intensity',
				'varying vec3 vNormal;',
				'void main() {',
				'	vec3 normal = normalize(vNormal);',
				'	vec3 worldNormal = inverseTransformDirection(normal, viewMatrix);',
				'	vec3 irradiance = shGetIrradianceAt(worldNormal, sh);',
				'	vec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;',
				'	gl_FragColor = linearToOutputTexel(vec4(outgoingLight, 1.0));',
				'}'

			].join('\n')
		});

		var geometry = new three.SphereBufferGeometry(1, 32, 16);

		three.Mesh.call(this, geometry, material);

		this.onBeforeRender();

	}

	LightProbeHelper.prototype = Object.create(three.Mesh.prototype);
	LightProbeHelper.prototype.constructor = LightProbeHelper;

	LightProbeHelper.prototype.dispose = function ()
	{
		this.geometry.dispose();
		this.material.dispose();
	};

	LightProbeHelper.prototype.onBeforeRender = function()
	{
		this.position.copy(this.lightProbe.position);
		this.scale.set(1, 1, 1).multiplyScalar(this.size);
		this.material.uniforms.intensity.value = this.lightProbe.intensity;
	};

	/**
	 * Grid helper is used to visualize a grid in the editor.
	 *
	 * Size, spacing and color of the grid can be costumized.
	 *
	 * @class GridHelper
	 * @param size {number} Total size of the grid.
	 * @param spacing {number} Spacing between lines.
	 * @param color {number} Hex color of the grid lines.
	 */
	function GridHelper(size, spacing, color)
	{
		this.size = (size !== undefined) ? size : 100;
		this.spacing = (spacing !== undefined) ? spacing : 1;

		three.LineSegments.call(this, new three.BufferGeometry(), new three.LineBasicMaterial(
		{
			color: (color !== undefined) ? color : 0x888888,
			depthWrite: false,
			transparent: true,
			opacity: 0.5
		}));

		this.update();
	}
	GridHelper.prototype = Object.create(three.LineSegments.prototype);

	GridHelper.prototype.setSize = function(size)
	{
		this.size = size;
	};

	GridHelper.prototype.setSpacing = function(spacing)
	{
		this.spacing = spacing;
	};

	/**
	 * Update the geometry of the grid.
	 *
	 * @method update
	 */
	GridHelper.prototype.update = function()
	{
		var geometry = this.geometry;
		geometry.deleteAttribute("position");

		var divisions = Math.round(this.size / this.spacing) * 2;
		var step = this.size * 2 / divisions;
		var vertices = [];

		for(var i = 0, k = -this.size; i <= divisions; i ++, k += step)
		{
			vertices.push(-this.size, 0, k, this.size, 0, k);
			vertices.push(k, 0, -this.size, k, 0, this.size);
		}

		geometry.setAttribute("position", new three.Float32BufferAttribute(vertices, 3));
	};

	/**
	 * A editor controls objects is used to control the camera inside of the editor.
	 *
	 * @class EditorControls
	 * @extends {Group}
	 */
	function EditorControls()
	{
		three.Group.call(this);

		/**
		 * Camera object attached to this controls.
		 *
		 * @property camera
		 * @type {Object3D}
		 */
		this.camera = null;
	}

	EditorControls.prototype = Object.create(three.Group.prototype);

	/**
	 * Attach a camera to this controls object.
	 *
	 * @method attach
	 * @param {Camera} camera
	 */
	EditorControls.prototype.attach = function(camera)
	{
		while(this.children.length > 0)
		{
			this.remove(this.children[0]);
		}
		this.add(camera);

		this.camera = camera;
		this.updateControls();
	};

	/**
	 * Reset the controls to its original position.
	 * 
	 * @method reset
	 */
	EditorControls.prototype.reset = function(){};

	/** 
	 * Focus camera on a object.
	 * 
	 * @method focusObject
	 * @param {Object3D} object Object to point camera at.
	 */
	EditorControls.prototype.focusObject = function(object){};

	/** 
	 * Set controls orientation, using orientation code form OrientationCube 
	 *
	 * @method setOrientation
	 */
	EditorControls.prototype.setOrientation = function(orientation){};

	/**
	 * Update the orbit controls position, the keyboard movement should be optional.
	 * 
	 * @method update
	 * @param {Mouse} mouse
	 * @param {Keyboard} keyboard
	 * @param {number} delta Time passed after from the last update.
	 */
	EditorControls.prototype.update = function(mouse, keyboard, delta){};

	/**
	 * Update controls position and rotation.
	 *
	 * Should be called if some of its properties are changed manually.
	 * 
	 * @method updateControls
	 */
	EditorControls.prototype.updateControls = function(){};

	/**
	 * Orbit controls can be used to navigate the world using a imaginary central point as reference.
	 *
	 * The camera orbits around that central point always looking towards it, and the distance to the point can be changes.
	 *
	 * @class EditorOrbitControls
	 * @extends {EditorControls}
	 */
	function EditorOrbitControls()
	{
		EditorControls.call(this);

		/**
		 * Distance to the center of the orbit.
		 *
		 * @property distance
		 * @type {number}
		 */
		this.distance = 10;

		/**
		 * Central point of the orbit.
		 *
		 * @property center
		 * @type {Vector3}
		 */
		this.center = new three.Vector3();

		/**
		 * Orientation of the camera.
		 *
		 * X is the horizontal orientation and Y the vertical orientation.
		 *
		 * @property orientation
		 * @type {Vector2}
		 */	 
		this.orientation = new three.Vector2();

		/**
		 * Maximum Distance allowed.
		 *
		 * @property maxDistance
		 * @type {number}
		 */
		this.maxDistance = Number.MAX_SAFE_INTEGER;

		/**
		 * Minimum distance allowed.
		 *
		 * @property minDistance
		 * @type {number}
		 */
		this.minDistance = 1e-10;
		
		/**
		 * Maximum angle allowed in the y (vertical) orientation.
		 *
		 * @property limitUp
		 * @type {number}
		 */
		this.limitUp = 1.57;

		/**
		 * Minimum angle allowed in the y (vertical) orientation.
		 *
		 * @property limitDown
		 * @type {number}
		 */
		this.limitDown = -1.57;
		
		/**
		 * Indicates if the orbit controls needed an update on the last update.
		 *
		 * The variable is reset on each update call.
		 *
		 * @property needsUpdate
		 * @type {boolean}
		 */
		this.needsUpdate = false;

		/**
		 * Enables smooth orbit movement.
		 *
		 * @property smooth
		 * @type {boolean}
		 */	
		this.smooth = false;

		/**
		 * Orbit speed friction, higher value allow the orbit to retain more speed.
		 *
		 * Only used when smooth is set true.
		 *
		 * @property friction
		 * @type {number}
		 */	
		this.friction = 0.8;

		/**
		 * Obit movement speed.
		 *
		 * Only used when smooth is set true.
		 *
		 * @property speed
		 * @type {number}
		 */	
		this.speed = 0.3;
		this.speedDistance = 0;
		this.speedCenter = new three.Vector3(0, 0, 0);
		this.speedOrientation = new three.Vector2(0, 0);

		this.tempVector = new three.Vector3(0, 0, 0);
		this.tempMatrix = new three.Matrix4();

		this.reset();
		this.updateControls();
	}

	EditorOrbitControls.UP = new three.Vector3(0, 1, 0);

	EditorOrbitControls.prototype = Object.create(EditorControls.prototype);

	EditorOrbitControls.prototype.reset = function()
	{
		this.distance = 10;
		this.center.set(0, 0, 0);
		this.orientation.set(-0.4, 0.4);
		this.updateControls();
	};

	EditorOrbitControls.prototype.focusObject = function(object)
	{
		var box = ObjectUtils.calculateBoundingBox(object);
		
		if(box !== null)
		{
			box.applyMatrix4(object.matrixWorld);
			box.getCenter(this.center);

			var size = box.getSize(this.tempVector).length();

			if(this.camera instanceof three.PerspectiveCamera)
			{
				this.distance = (size / 2) / three.Math.tan(three.Math.DEG2RAD * 0.5 * this.camera.fov);
			}
			else
			{
				this.distance = size;
			}

			this.updateControls();
		}
		else
		{
			object.getWorldPosition(this.center);
			this.distance = this.center.y + 1.0;
			this.updateControls();
		}
	};

	EditorOrbitControls.prototype.setOrientation = function(code)
	{
		if(code === OrientationCube.Z_POS)
		{
			this.orientation.set(three.Math.PI / 2, 0);
		}
		else if(code === OrientationCube.Z_NEG)
		{
			this.orientation.set(-three.Math.PI / 2, 0);
		}
		else if(code === OrientationCube.X_POS)
		{
			this.orientation.set(0, 0);
		}
		else if(code === OrientationCube.X_NEG)
		{
			this.orientation.set(three.Math.PI, 0);
		}
		else if(code === OrientationCube.Y_POS)
		{
			this.orientation.set(three.Math.PI, 1.57);
		}
		else if(code === OrientationCube.Y_NEG)
		{
			this.orientation.set(three.Math.PI, -1.57);
		}

		this.updateControls();
	};

	EditorOrbitControls.prototype.update = function(mouse, keyboard)
	{
		this.needsUpdate = false;

		if(mouse.buttonPressed(Mouse.LEFT))
		{
			if(this.smooth === true)
			{
				this.speedOrientation.y += this.speed * Editor$1.settings.editor.mouseLookSensitivity * (Editor$1.settings.editor.invertNavigation ? mouse.delta.y : -mouse.delta.y);
				this.speedOrientation.x -= this.speed * Editor$1.settings.editor.mouseLookSensitivity * mouse.delta.x;
			}
			else
			{
				this.orientation.y += Editor$1.settings.editor.mouseLookSensitivity * (Editor$1.settings.editor.invertNavigation ? mouse.delta.y : -mouse.delta.y);
				this.orientation.x -= Editor$1.settings.editor.mouseLookSensitivity * mouse.delta.x;
			}

			this.needsUpdate = true;
		}

		if(mouse.buttonPressed(Mouse.MIDDLE))
		{
			if(this.smooth === true)
			{
				this.speedCenter.y += this.speed * Editor$1.settings.editor.mouseLookSensitivity * mouse.delta.y * this.distance;
			}
			else
			{
				this.center.y += mouse.delta.y * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
			}
		
			this.needsUpdate = true;
		}

		if(mouse.buttonPressed(Mouse.RIGHT))
		{
			var direction = this.getWorldDirection(this.tempVector);
			var up = direction.y > 0;
			direction.y = 0;
			direction.normalize();

			if(this.smooth === true)
			{
				var y = this.speed * mouse.delta.y * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
				this.speedCenter.x += up ? (-direction.x * y) : (direction.x * y);
				this.speedCenter.z += up ? (-direction.z * y) : (direction.z * y);
				
				direction.applyAxisAngle(OrbitControls.UP, three.Math.PI/2);

				var x = this.speed * mouse.delta.x * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
				this.speedCenter.x -= direction.x * x;
				this.speedCenter.z -= direction.z * x;
			}
			else
			{
				var y = mouse.delta.y * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
				this.center.x += up ? (-direction.x * y) : (direction.x * y);
				this.center.z += up ? (-direction.z * y) : (direction.z * y);
				
				direction.applyAxisAngle(EditorOrbitControls.UP, three.Math.PI/2);

				var x = mouse.delta.x * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
				this.center.x -= direction.x * x;
				this.center.z -= direction.z * x;
			}

			this.needsUpdate = true;
		}

		if(mouse.wheel !== 0)
		{
			if(this.smooth === true)
			{
				this.speedDistance += this.speed * mouse.wheel * this.distance * Editor$1.settings.editor.mouseWheelSensitivity;
			}
			else
			{
				this.distance += mouse.wheel * this.distance * Editor$1.settings.editor.mouseWheelSensitivity;
			}
		
			this.needsUpdate = true;
		}
		
		// Keyboard movement
		if(Editor$1.settings.editor.keyboardNavigation && this.keyboardMovement(keyboard))
		{
			this.needsUpdate = true;
		}

		// If smooth always update 
		if(this.smooth === true)
		{
			this.distance += this.speedDistance;
			this.center.add(this.speedCenter);
			this.orientation.add(this.speedOrientation);

			this.applyLimits();

			this.speedDistance *= this.friction;
			this.speedOrientation.multiplyScalar(this.friction);
			this.speedCenter.multiplyScalar(this.friction);

			this.updateControls();
			return;
		}

		if(this.needsUpdate === true)
		{
			this.updateControls();
		}
	};

	OrbitControls.prototype.keyboardMovement = function(keyboard)
	{
		if(keyboard === undefined)
		{
			return false;
		}

		var needsUpdate = false;

		if(keyboard.keyPressed(Keyboard.S))
		{
			var direction = this.getWorldDirection(this.tempVector);
			direction.y = 0;
			direction.normalize();

			this.center.x += direction.x * Editor$1.settings.editor.keyboardNavigationSpeed;
			this.center.z += direction.z * Editor$1.settings.editor.keyboardNavigationSpeed;
			needsUpdate = true;
		}
		if(keyboard.keyPressed(Keyboard.W))
		{
			var direction = this.getWorldDirection(this.tempVector);
			direction.y = 0;
			direction.normalize();

			this.center.x -= direction.x * Editor$1.settings.editor.keyboardNavigationSpeed;
			this.center.z -= direction.z * Editor$1.settings.editor.keyboardNavigationSpeed;
			needsUpdate = true;
		}
		if(keyboard.keyPressed(Keyboard.A))
		{
			var direction = this.getWorldDirection(this.tempVector);
			direction.y = 0;
			direction.normalize();
			direction.applyAxisAngle(EditorOrbitControls.UP, 1.57);

			this.center.x -= direction.x * Editor$1.settings.editor.keyboardNavigationSpeed;
			this.center.z -= direction.z * Editor$1.settings.editor.keyboardNavigationSpeed;
			needsUpdate = true;
		}
		if(keyboard.keyPressed(Keyboard.D))
		{
			var direction = this.getWorldDirection(this.tempVector);
			direction.y = 0;
			direction.normalize();
			direction.applyAxisAngle(EditorOrbitControls.UP, 1.57);

			this.center.x += direction.x * Editor$1.settings.editor.keyboardNavigationSpeed;
			this.center.z += direction.z * Editor$1.settings.editor.keyboardNavigationSpeed;
			needsUpdate = true;
		}

		return needsUpdate;
	};

	EditorOrbitControls.prototype.applyLimits = function()
	{
		if(this.orientation.y < this.limitDown)
		{
			this.orientation.y = this.limitDown;
		}
		else if(this.orientation.y > this.limitUp)
		{
			this.orientation.y = this.limitUp;
		}

		if(this.distance < this.minDistance)
		{
			this.distance = this.minDistance;
		}
		else if(this.distance > this.maxDistance)
		{
			this.distance = this.maxDistance;
		}
	};

	EditorOrbitControls.prototype.updateControls = function()
	{
		this.applyLimits();

		var cos = this.distance * three.Math.cos(this.orientation.y);
		this.position.set(three.Math.cos(this.orientation.x) * cos, this.distance * three.Math.sin(this.orientation.y), three.Math.sin(this.orientation.x) * cos);
		this.position.add(this.center);

		this.tempMatrix.lookAt(this.position, this.center, EditorOrbitControls.UP);
		this.quaternion.setFromRotationMatrix(this.tempMatrix);

		this.updateMatrixWorld(true);

		if(this.camera instanceof OrthographicCamera)
		{
			this.camera.size = this.distance;
			this.camera.updateProjectionMatrix();
		}
	};

	/**
	 * The planar controls are used to control 2D movement, fixed to one camera orientation.
	 *
	 * @class PlanarControls
	 * @extends {OrbitControls}
	 * @param {number} mode Mode indicates the orientation to be locked.
	 */
	function EditorPlanarControls(mode)
	{
		EditorOrbitControls.call(this);

		this.setMode(mode !== undefined ? mode : Settings.PLANAR_LEFT);
	}

	EditorPlanarControls.prototype = Object.create(EditorOrbitControls.prototype);

	EditorPlanarControls.prototype.setOrientation = function(code){};

	EditorPlanarControls.prototype.setMode = function(mode)
	{
		this.mode = mode;

		if(mode === Settings.PLANAR_FRONT)
		{
			this.orientation.set(Math.PI / 2, 0);
		}
		else if(mode === Settings.PLANAR_BACK)
		{
			this.orientation.set(-Math.PI / 2, 0);
		}
		else if(mode === Settings.PLANAR_LEFT)
		{
			this.orientation.set(0, 0);
		}
		else if(mode === Settings.PLANAR_RIGHT)
		{
			this.orientation.set(Math.PI, 0);
		}
		else if(mode === Settings.PLANAR_TOP)
		{
			this.orientation.set(Math.PI, 1.57);
		}
		else if(mode === Settings.PLANAR_BOTTOM)
		{
			this.orientation.set(Math.PI, -1.57);
		}

		this.updateControls();
	};

	EditorPlanarControls.prototype.reset = function()
	{
		this.distance = 10;
		this.center.set(0, 0, 0);
		this.updateControls();
	};

	EditorPlanarControls.prototype.update = function(mouse, keyboard)
	{
		var needsUpdate = false;

		if(mouse.buttonPressed(Mouse.RIGHT))
		{
			var direction = this.getWorldDirection(this.tempVector);
			var up = direction.y > 0;
			direction.y = 0;
			direction.normalize();

			if(this.mode === Settings.PLANAR_TOP || this.mode === Settings.PLANAR_BOTTOM)
			{
				var y = mouse.delta.y * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
				this.center.x += up ? (-direction.x * y) : (direction.x * y);
				this.center.z += up ? (-direction.z * y) : (direction.z * y);
			}
			else
			{
				this.center.y += mouse.delta.y * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
			}

			direction.applyAxisAngle(EditorOrbitControls.UP, 1.57);

			var x = mouse.delta.x * Editor$1.settings.editor.mouseLookSensitivity * this.distance;
			this.center.x -= direction.x * x;
			this.center.z -= direction.z * x;

			needsUpdate = true;
		}

		if(mouse.wheel !== 0)
		{
			this.distance += mouse.wheel * Editor$1.settings.editor.mouseWheelSensitivity * this.distance;
			needsUpdate = true;
		}
		
		/*
		// WASD movement
		if(Editor.settings.editor.keyboardNavigation)
		{
			if(keyboard.keyPressed(Keyboard.W))
			{
				var direction = this.getWorldDirection(this.tempVector);
				direction.y = 0;
				direction.normalize();

				this.center.x -= direction.x * Editor.settings.editor.keyboardNavigationSpeed;
				this.center.z -= direction.z * Editor.settings.editor.keyboardNavigationSpeed;
				needsUpdate = true;
			}
			if(keyboard.keyPressed(Keyboard.A))
			{
				var direction = this.getWorldDirection(this.tempVector);
				direction.y = 0;
				direction.normalize();
				direction.applyAxisAngle(EditorOrbitControls.UP, 1.57);

				this.center.x -= direction.x * Editor.settings.editor.keyboardNavigationSpeed;
				this.center.z -= direction.z * Editor.settings.editor.keyboardNavigationSpeed;
				needsUpdate = true;
			}
			if(keyboard.keyPressed(Keyboard.S))
			{
				var direction = this.getWorldDirection(this.tempVector);
				direction.y = 0;
				direction.normalize();

				this.center.x += direction.x * Editor.settings.editor.keyboardNavigationSpeed;
				this.center.z += direction.z * Editor.settings.editor.keyboardNavigationSpeed;
				needsUpdate = true;
			}
			if(keyboard.keyPressed(Keyboard.D))
			{
				var direction = this.getWorldDirection(this.tempVector);
				direction.y = 0;
				direction.normalize();
				direction.applyAxisAngle(EditorOrbitControls.UP, 1.57);

				this.center.x += direction.x * Editor.settings.editor.keyboardNavigationSpeed;
				this.center.z += direction.z * Editor.settings.editor.keyboardNavigationSpeed;
				needsUpdate = true;
			}
		}
		*/

		if(needsUpdate === true)
		{
			this.updateControls();
		}
	};

	/**
	 * Free controls can be used to navigate the world in a first person like way.
	 *
	 * The mouse can be used to look around or control the movement.
	 *
	 * @class EditorFreeControls
	 * @extends {EditorControls}
	 */
	function EditorFreeControls()
	{
		EditorControls.call(this);

		/**
		 * Orientation of the camera.
		 *
		 * X is the horizontal orientation and Y the vertical orientation.
		 *
		 * @property orientation
		 * @type {Vector2}
		 */	 
		this.orientation = new three.Vector2();

		this.camera = null;

		/**
		 * Indicates if the orbit controls needed an update on the last update.
		 *
		 * The variable is reset on each update call.
		 *
		 * @property needsUpdate
		 * @type {boolean}
		 */
		this.needsUpdate = false;

		this.temp = new three.Vector3();

		this.reset();
		this.updateControls();
	}

	EditorFreeControls.prototype = Object.create(EditorControls.prototype);

	EditorFreeControls.ZERO = new three.Vector3(0, 0, 0);

	EditorFreeControls.prototype.reset = function()
	{
		this.orientation.set(0.5, 0.5);
		this.position.set(5, 4.8, 7.4);
		this.updateControls();
	};

	EditorFreeControls.prototype.focusObject = function(object)
	{
		var box = ObjectUtils.calculateBoundingBox(object);
		box.applyMatrix4(object.matrixWorld);

		var size = box.getSize(new three.Vector3()).length();
		var distance = this.getWorldPosition(new three.Vector3()).distanceTo(object.getWorldPosition(new three.Vector3()));

		var direction = object.position.clone();
		direction.sub(this.position);
		direction.normalize();
		direction.multiplyScalar(distance - size);
		
		this.position.add(direction);
		this.updateControls();
	};

	EditorFreeControls.prototype.setOrientation = function(code)
	{
		if(code === OrientationCube.Z_POS)
		{
			this.orientation.set(0, 0);
		}
		else if(code === OrientationCube.Z_NEG)
		{
			this.orientation.set(Math.PI, 0);
		}
		else if(code === OrientationCube.X_POS)
		{
			this.orientation.set(Math.PI / 2, 0);
		}
		else if(code === OrientationCube.X_NEG)
		{
			this.orientation.set(-Math.PI / 2, 0);
		}
		else if(code === OrientationCube.Y_POS)
		{
			this.orientation.set(Math.PI, +1.57);
		}
		else if(code === OrientationCube.Y_NEG)
		{
			this.orientation.set(Math.PI, -1.57);
		}

		this.updateControls();
	};

	EditorFreeControls.prototype.update = function(mouse, keyboard)
	{
		this.needsUpdate = false;

		// Look camera
		if(mouse.buttonPressed(Mouse.LEFT))
		{
			this.orientation.y -= Editor$1.settings.editor.mouseLookSensitivity * (Editor$1.settings.editor.invertNavigation ? mouse.delta.y : -mouse.delta.y);
			this.orientation.x -= Editor$1.settings.editor.mouseLookSensitivity * mouse.delta.x;

			// Limit Vertical Rotation to 90 degrees
			if(this.orientation.y < -1.57)
			{
				this.orientation.y = -1.57;
			}
			else if(this.orientation.y > 1.57)
			{
				this.orientation.y = 1.57;
			}

			this.needsUpdate = true;
		}

		// Move Camera on X and Z
		if(mouse.buttonPressed(Mouse.RIGHT))
		{
			// Move speed
			var speed = this.position.distanceTo(EditorFreeControls.ZERO) * Editor$1.settings.editor.mouseMoveSpeed;
			if(speed < 0.01)
			{
				speed = 0.01;
			}

			// Move Camera Front and Back
			var angleCos = Math.cos(this.orientation.x);
			var angleSin = Math.sin(this.orientation.x);
			this.position.z -= mouse.delta.y * speed * angleCos;
			this.position.x -= mouse.delta.y * speed * angleSin;

			// Move Camera Lateral
			var angleCos = Math.cos(this.orientation.x + MathUtils.PID2);
			var angleSin = Math.sin(this.orientation.x + MathUtils.PID2);
			this.position.z -= mouse.delta.x * speed * angleCos;
			this.position.x -= mouse.delta.x * speed * angleSin;

			this.needsUpdate = true;
		}
		
		// Move Camera on Y
		if(mouse.buttonPressed(Mouse.MIDDLE))
		{
			this.position.y += mouse.delta.y * Editor$1.settings.editor.mouseMoveSpeed * 100;

			this.needsUpdate = true;
		}

		// Move in camera direction using mouse scroll
		if(mouse.wheel !== 0)
		{
			// Move speed
			var speed = mouse.wheel * this.position.distanceTo(EditorFreeControls.ZERO) * Editor$1.settings.editor.mouseWheelSensitivity;

			// Limit zoom speed
			if(speed < 0 && speed > -0.02)
			{
				speed = -0.02;
			}
			else if(speed > 0 && speed < 0.02)
			{
				speed = 0.02;
			}

			// Move camera
			var direction = this.getWorldDirection(this.temp);
			direction.multiplyScalar(speed);
			this.position.add(direction);

			this.needsUpdate = true;
		}

		// WASD movement
		if(Editor$1.settings.editor.keyboardNavigation)
		{
			if(keyboard.keyPressed(Keyboard.S))
			{
				var direction = this.getWorldDirection(this.temp);
				direction.multiplyScalar(Editor$1.settings.editor.keyboardNavigationSpeed);
				this.position.add(direction);
				this.needsUpdate = true;
			}
			if(keyboard.keyPressed(Keyboard.W))
			{
				var direction = this.getWorldDirection(this.temp);
				direction.multiplyScalar(Editor$1.settings.editor.keyboardNavigationSpeed);
				this.position.sub(direction);
				this.needsUpdate = true;
			}
			if(keyboard.keyPressed(Keyboard.D))
			{
				this.temp.set(Math.sin(this.orientation.x - 1.57), 0, Math.cos(this.orientation.x - 1.57));
				this.temp.normalize();
				this.temp.multiplyScalar(Editor$1.settings.editor.keyboardNavigationSpeed);
				this.position.sub(this.temp);
				this.needsUpdate = true;
			}
			if(keyboard.keyPressed(Keyboard.A))
			{
				this.temp.set(Math.sin(this.orientation.x + 1.57), 0, Math.cos(this.orientation.x + 1.57));
				this.temp.normalize();
				this.temp.multiplyScalar(Editor$1.settings.editor.keyboardNavigationSpeed);
				this.position.sub(this.temp);
				this.needsUpdate = true;
			}
		}

		if(this.needsUpdate)
		{
			this.updateControls();
		}
	};

	EditorFreeControls.prototype.updateControls = function()
	{
		var cos = Math.cos(this.orientation.y);
		this.temp.set(Math.sin(this.orientation.x)*cos, Math.sin(this.orientation.y), Math.cos(this.orientation.x)*cos);
		this.temp.add(this.position);

		this.lookAt(this.temp);

		this.updateMatrixWorld(true);
	};

	/**
	 * The drag buffer is a global object used to store and get object being dragged.
	 *
	 * Objects are stored in an array and are indetified with a UUID.
	 *
	 * @static
	 * @class DragBuffer
	 */
	var DragBuffer = {};

	/**
	 * Object drag buffer, stores objects being dragged.
	 *
	 * @attribute buffer
	 */
	DragBuffer.buffer = [];

	/** 
	 * Push elemento to drag buffer.
	 *
	 * Checks if element dont exist on drag buffer before inserting.
	 *
	 * @method push
	 */
	DragBuffer.push = function(obj)
	{
		if(DragBuffer.buffer.indexOf(obj) === -1)
		{
			DragBuffer.buffer.push(obj);
		}
	};

	/** 
	 * Get element from drag buffer using its identifier.
	 *
	 * @method pop
	 * @return {Object} Object indentfied by uuid, if not found return null.
	 */
	DragBuffer.pop = function(uuid)
	{
		for(var i = 0; i < DragBuffer.buffer.length; i++)
		{
			if(DragBuffer.buffer[i].uuid === uuid)
			{
				var obj = DragBuffer.buffer[i];
				DragBuffer.buffer.splice(i, 1);
				return obj;
			}
		}

		return null;
	};

	/** 
	 * Get element from drag buffer without removing it.
	 *
	 * @method get
	 * @return {Object} Object indentfied by uuid, if not found return null.
	 */
	DragBuffer.get = function(uuid)
	{
		for(var i = 0; i < DragBuffer.buffer.length; i++)
		{
			if(DragBuffer.buffer[i].uuid === uuid)
			{
				return DragBuffer.buffer[i];
			}
		}
		
		return null;
	};

	/**
	 * Tab button is used to navigate trough tabs.
	 *
	 * @class TabButton
	 * @extends {Component}
	 * @param {Component} parent
	 * @param {TabComponent} tab
	 */
	function TabButton(parent, tab)
	{
		Component.call(this, parent, "div");

		var self = this;

		this.element.draggable = true;
		this.element.style.cursor = "pointer";
		this.element.style.boxSizing = "border-box";
		this.element.style.backgroundColor = "var(--bar-color)";

		/**
		 * Pointer to the tab element related with this button.
		 *
		 * @property tab
		 * @type {TabComponent}
		 */
		this.tab = tab;

		// Icon
		this.icon = document.createElement("img");
		this.icon.style.pointerEvents = "none";
		this.icon.style.position = "absolute";
		this.icon.src = tab.icon;
		this.element.appendChild(this.icon);

		// Text
		this.text = document.createElement("div");
		this.text.style.position = "absolute";
		this.text.style.overflow = "hidden";
		this.text.style.textAlign = "center";
		this.text.style.pointerEvents = "none";
		this.text.style.textOverflow = "ellipsis";
		this.text.style.whiteSpace = "nowrap";
		this.text.style.color = "var(--color-light)";
		this.element.appendChild(this.text);

		// Title
		this.title = document.createTextNode(tab.title);
		this.text.appendChild(this.title);

		// Close button
		this.close = document.createElement("img");
		this.close.draggable = false;
		this.close.style.position = "absolute";
		this.close.style.opacity = 0.5;
		this.close.style.display = (tab.closeable) ? "block" : "none";
		this.close.src = Global.FILE_PATH + "icons/misc/close.png";
		this.element.appendChild(this.close);

		this.close.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};

		this.close.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};

		this.close.onclick = function()
		{
			self.tab.close();
		};


		// Drag state
		var dragState = TabButton.NONE;

		// Drag control
		this.element.ondragstart = function(event)
		{
			event.dataTransfer.setData("tab", self.tab.index);
			dragState = TabButton.NONE;
		};

		// Drag drop
		this.element.ondrop = function(event)
		{
			event.preventDefault();
			this.style.borderLeft = null;
			this.style.borderRight = null;
			this.style.borderBottom = null;
			this.style.borderTop = null;

			var index = event.dataTransfer.getData("tab");
			if(index !== "")
			{
				index = parseInt(index);

				if(index !== self.tab.index)
				{	
					// Before
					if(dragState === TabButton.PREVIOUS)
					{
						self.tab.container.moveTabIndex(index, index < self.tab.index ? self.tab.index - 1 : self.tab.index);
					}
					// After
					else if(dragState === TabButton.NEXT)
					{
						self.tab.container.moveTabIndex(index, index < self.tab.index ? self.tab.index : self.tab.index + 1);
					}
				}
			}
		};

		// Drag over
		this.element.ondragover = function(event)
		{
			if(self.tab.container.placement === TabGroup.TOP || self.tab.container.placement === TabGroup.BOTTOM)
			{
				if(event.layerX > self.size.x * 0.8 || event.target !== this)
				{
					if(dragState !== TabButton.NEXT)
					{
						dragState = TabButton.NEXT;
						this.style.borderLeft = null;
						this.style.borderRight = "thick solid #999999";
					}
				}
				else if(event.layerX < self.size.x * 0.2)
				{
					if(dragState !== TabButton.PREVIOUS)
					{
						dragState = TabButton.PREVIOUS;
						this.style.borderRight = null;
						this.style.borderLeft = "thick solid #999999";
					}
				}
				else
				{
					if(dragState !== TabButton.NONE	)
					{
						dragState = TabButton.NONE;
						this.style.borderLeft = null;
						this.style.borderRight = null;
					}
				}
			}
			else
			{
				if(event.layerY > self.size.y * 0.7 || event.target !== this)
				{
					if(dragState !== TabButton.NEXT)
					{
						dragState = TabButton.NEXT;
						this.style.borderTop = null;
						this.style.borderBottom = "solid #999999";
					}
				}
				else if(event.layerY < self.size.y * 0.3)
				{
					if(dragState !== TabButton.PREVIOUS)
					{
						dragState = TabButton.PREVIOUS;
						this.style.borderBottom = null;
						this.style.borderTop = "solid #999999";
					}
				}
				else
				{
					if(dragState !== TabButton.NONE	)
					{
						dragState = TabButton.NONE;
						this.style.borderBottom = null;
						this.style.borderTop = null;
					}
				}
			}
		};

		// Drag end
		this.element.ondragend = function(event)
		{
			event.preventDefault();
			
			dragState = TabButton.NONE;
			this.style.borderLeft = null;
			this.style.borderRight = null;
			this.style.borderBottom = null;
			this.style.borderTop = null;
		};

		// Drag leave
		this.element.ondragleave = function(event)
		{
			event.preventDefault();
			
			dragState = TabButton.NONE;
			this.style.borderLeft = null;
			this.style.borderRight = null;
			this.style.borderBottom = null;
			this.style.borderTop = null;
		};

		this.element.onmousedown = function(event)
		{
			var button = event.which - 1;

			// Select tab
			if(button === Mouse.LEFT)
			{
				self.tab.container.selectTab(self.tab);
			}
			// Close tab
			else if(tab.closeable && button === Mouse.MIDDLE)
			{
				self.tab.container.removeTab(self.tab);
			}
		};

		this.element.onmouseenter = function()
		{
			this.style.backgroundColor = "var(--button-over-color)";
		};

		this.element.onmouseleave = function()
		{
			if(tab.isSelected())
			{
				this.style.backgroundColor = "var(--button-over-color)";
			}
			else
			{
				this.style.backgroundColor = "var(--bar-color)";
			}
		};
	}

	TabButton.prototype = Object.create(Component.prototype);

	TabButton.NONE = 0;
	TabButton.PREVIOUS = 1;
	TabButton.NEXT = 2;

	/**
	 * Set the tab icon image.
	 *
	 * @method setIcon
	 * @param {string} icon URL of the icon image.
	 */
	TabButton.prototype.setIcon = function(icon)
	{
		this.tab.icon = icon;
		this.icon.src = icon;
	};

	/**
	 * Set text to be displayed in the button as its name.
	 *
	 * @method setName
	 * @param {string} text
	 */
	TabButton.prototype.setName = function(text)
	{
		this.tab.title = text;
		this.title.data = text;
	};

	// Update selected state of the button
	TabButton.prototype.updateSelection = function()
	{
		this.element.style.backgroundColor = this.tab.isSelected() ? "var(--button-over-color)" : "var(--bar-color)";
	};

	TabButton.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);
		
		// Icon
		this.icon.style.top = (this.size.y * 0.2) + "px";
		this.icon.style.left = (this.size.y * 0.2) + "px";
		this.icon.style.width = (this.size.y * 0.6) + "px";
		this.icon.style.height = (this.size.y * 0.6) + "px";

		// Text
		this.text.style.left = this.size.y + "px";
		this.text.style.top = ((this.size.y - 12) / 2) + "px";
		this.text.style.width = (this.size.x - 2 * this.size.y) + "px";
		this.text.style.height = this.size.y + "px";

		// Close
		if(this.tab.closeable === true)
		{
			this.close.style.width = (this.size.y * 0.4) + "px";
			this.close.style.height = (this.size.y * 0.4) + "px";
			this.close.style.top = (this.size.y * 0.3) + "px";
			this.close.style.right = (this.size.y * 0.3) + "px";
			this.close.style.display = "block";
		}
		else
		{
			this.close.style.display = "none";
		}

		this.updateSelection();
	};

	/**
	 * DOM division element container.
	 * 
	 * @class Division
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function Division(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";
	}

	Division.prototype = Object.create(Component.prototype);

	/**
	 * A tab group contains and manages tab elements.
	 *
	 * The group is also responsible for creating and managing the lifecycle of its tab elements.
	 * 
	 * @class TabGroup
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function TabGroup(parent, placement)
	{
		Component.call(this, parent, "div");

		var self = this;

		this.element.style.overflow = "visible";
		this.element.style.backgroundColor = "var(--panel-color)";

		this.preventDragEvents();
		
		// Buttons
		this.buttons = new Division(this);
		this.buttons.element.style.backgroundColor = "var(--bar-color)";
		this.buttons.element.ondrop = function(event)
		{
			event.preventDefault();

			var uuid = event.dataTransfer.getData("uuid");
			var tab = DragBuffer.get(uuid);

			if(tab instanceof TabComponent)
			{
				self.attachTab(tab);
				DragBuffer.pop(uuid);
			}
		};

		// Tab
		this.tab = new Division(this);

		/**
		 * Division used to display a message indicating that the tab is empty.
		 *
		 * @property empty
		 * @type {Component}
		 */
		this.empty = document.createElement("div");
		this.empty.style.position = "absolute";
		this.empty.style.textAlign = "center";
		this.empty.style.display = "none";
		this.empty.style.width = "100%";
		this.empty.style.height = "100%";
		this.empty.style.flexDirection = "column";
		this.empty.style.justifyContent = "center";
		this.empty.style.pointerEvents = "none";
		this.empty.appendChild(document.createTextNode(Locale.openTabToEditContent));
		this.element.appendChild(this.empty);

		/**
		 * Tab that is currently selected.
		 *
		 * @property selected
		 * @type {TabComponent}
		 */
		this.selected = null;
		
		/**
		 * Base size of the buttons in this group.
		 * 
		 * Size may be ajusted to fit the available space.
		 *
		 * @property buttonSize
		 * @type {Vector2}
		 */
		this.buttonSize = new three.Vector2(150, 22);

		/**
		 * Tab buttons placement.
		 *
		 * @property placement
		 * @type {number}
		 */
		this.placement = placement !== undefined ? placement : TabGroup.TOP;
		this.setPlacement(this.placement);

		/**
		 * Tab elements attache to this group.
		 * 
		 * @type {Array}
		 */
		this.options = [];

		/**
		 * Indicates if the tab is currently on focus.
		 *
		 * @property focused
		 * @type {boolean}
		 */
		this.focused = false;

		this.element.onmouseenter = function()
		{
			self.focused = true;
		};
		this.element.onmouseleave = function()
		{
			self.focused = false;
		};
	}

	TabGroup.TOP = 0;
	TabGroup.BOTTOM = 1;
	TabGroup.LEFT = 2;
	TabGroup.RIGHT = 3;

	TabGroup.prototype = Object.create(Component.prototype);

	/**
	 * Update all tabs object data.
	 *
	 * @method updateMetadata
	 */
	TabGroup.prototype.updateMetadata = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].updateMetadata();
		}
	};

	/**
	 * Update all tab object views.
	 *
	 * @method updateMetadata
	 */
	TabGroup.prototype.updateObjectsView = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].updateObjectsView();
		}
	};

	/**
	 * Attach tab to this group and remove it from the original group.
	 *
	 * @method attachTab
	 * @param {TabComponent} tab Tab to be moved.
	 * @param {number} insertIndex Index where to place the tab.
	 */
	TabGroup.prototype.attachTab = function(tab, insertIndex)
	{	
		// Remove from old group
		tab.container.removeTab(tab.index, true);
		
		// Attach to this group
		tab.container = this;
		tab.button.attachTo(this.buttons);
		tab.attachTo(this.tab);
		
		// Add to options
		if(insertIndex !== undefined)
		{
			tab.index = insertIndex;
			this.options.splice(insertIndex, 0, tab);
		}
		else
		{
			tab.index = this.options.length;
			this.options.push(tab);
		}

		// Select the tab if none selected
		if(this.selected === null)
		{
			this.selectTab(tab);
		}
		
		this.updateOptionIndex();
		this.updateInterface();

		return tab;
	};

	/**
	 * Move tab from position to another.
	 *
	 * @method moveTabIndex
	 * @param {number} origin Origin index.
	 * @param {number} destination Destination index.
	 */
	TabGroup.prototype.moveTabIndex = function(origin, destination)
	{
		var button = this.options[origin];

		this.options.splice(origin, 1);
		this.options.splice(destination, 0, button);

		this.updateOptionIndex();
		this.updateInterface();
	};

	TabGroup.prototype.updateSelection = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].updateSelection();
		}
	};

	TabGroup.prototype.updateSettings = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].updateSettings();
		}
	};

	/**
	 * Get the currently active tab of the group.
	 *
	 * @method getActiveTab
	 */
	TabGroup.prototype.getActiveTab = function()
	{
		if(this.selected !== null)
		{
			return this.selected;
		}

		return null;
	};

	/**
	 * Close actual tab if its closeable.
	 *
	 * @method closeActual
	 */
	TabGroup.prototype.closeActual = function()
	{
		if(this.selected !== null && this.selected.closeable)
		{
			this.selected.deactivate();
			this.removeTab(this.selected);
		}
	};

	/** 
	 * Select tab to set active on this group.
	 *
	 * If not valid tab is selected the actual selection will be cleared.
	 *
	 * @method selectTab
	 * @param {TabComponent} tab TabComponent to be selected or index in the tab array.
	 */
	TabGroup.prototype.selectTab = function(tab)
	{
		if(this.selected !== null)
		{
			this.selected.deactivate();
		}

		// Tab as a TabComponent object
		if(tab instanceof TabComponent)
		{
			this.selected = tab;
			this.selected.activate();
		}
		// Tab as a index
		else if(typeof tab === "number" && tab > -1 && tab < this.options.length)
		{
			this.selected = this.options[tab];
			this.selected.activate();
		}
		else
		{
			this.selected = null;
		}

		this.empty.style.display = this.selected === null ? "flex" : "none";
		this.updateInterface();
	};

	/**
	 * Select next tab.
	 *
	 * @method selectNextTab
	 */
	TabGroup.prototype.selectNextTab = function()
	{
		if(this.options.length > 0)
		{
			this.selectTab((this.selected.index + 1) % this.options.length);
		}
	};

	/**
	 * Select previous tab.
	 *
	 * @method selectPreviousTab
	 */
	TabGroup.prototype.selectPreviousTab = function()
	{
		if(this.options.length > 0)
		{
			if(this.selected.index === 0)
			{
				this.selectTab(this.options.length - 1);
			}
			else
			{
				this.selectTab(this.selected.index - 1);
			}
		}
	};

	/**
	 * Add new option to tab group.
	 *
	 * @method addtab
	 */
	TabGroup.prototype.addTab = function(TabConstructor, closeable)
	{
		var tab = new TabConstructor(this.tab, closeable, this, this.options.length);
		tab.button = new TabButton(this.buttons, tab);
		this.options.push(tab);
		
		if(this.selected === null || this.options.length === 1)
		{
			this.selectTab(tab);
		}
		else
		{
			this.updateInterface();
		}

		return tab;
	};

	/**
	 * Get tab from tab type and attached object is there is any.
	 *
	 * @method getTab
	 * @param {Constructor} type Type of tab to look for.
	 * @param {Object} object Object attached to the tab.
	 */
	TabGroup.prototype.getTab = function(type, object)
	{
		for(var i = 0; i < this.options.length; i++)
		{
			if(this.options[i] instanceof type)
			{
				if(object === undefined || this.options[i].isAttached(object))
				{
					return this.options[i];
				}
			}
		}

		return null;
	};

	/**
	 * Remove tab from group.
	 *
	 * @method removeTab
	 * @param {number} index Index of tab to look for.
	 * @param {boolean} dontDestroy If true the element is not destroyed.
	 */
	TabGroup.prototype.removeTab = function(index, dontDestroy)
	{	
		// If index is an object get the actual index
		if(typeof index === "object")
		{
			index = this.options.indexOf(index);
		}

		// Check if the index is in range
		if(index > -1 && index < this.options.length)
		{
			var tab = this.options[index];

			if(dontDestroy !== true)
			{
				tab.destroy();
			}

			this.options.splice(index, 1);
			this.updateOptionIndex();

			// Select option
			if(this.selected === tab)
			{
				if(this.options.length > 0)
				{
					this.selectTab(index !== 0 ? index - 1 : 0);
				}
				else
				{
					this.selectTab(null);
				}
			}
			else 
			{
				this.selectTab(null);
			}

			return tab;
		}

		return null;
	};

	/**
	 * Remove all closable tabs from the group.
	 *
	 * @method clear
	 * @param {boolean} forceAll Remove also the not closable tabs.
	 */
	TabGroup.prototype.clear = function(forceAll)
	{
		if(forceAll === true)
		{
			while(this.options.length > 0)
			{
				this.options.pop().destroy();
			}

			this.selectTab(null);
		}
		else
		{
			var i = 0;
			while(i < this.options.length)
			{
				if(this.options[i].closeable)
				{
					this.options[i].destroy();
					this.options.splice(i, 1);
				}
				else
				{
					i++;
				}
			}

			// Check is selected tab is still available
			var index = this.options.indexOf(this.selected);
			if(index === -1 && this.options.length > 0)
			{
				this.selectTab(0);
			}
		}
	};

	/**
	 * Update index variable stored in the tabs.
	 *
	 * @method updateOptionIndex
	 */
	TabGroup.prototype.updateOptionIndex = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].index = i;
		}
	};

	/**
	 * Set the tab group buttons placement.
	 *
	 * @method setPlacement
	 * @param {number} placement
	 */
	TabGroup.prototype.setPlacement = function(placement)
	{
		this.placement = placement;
	};

	TabGroup.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		var tabSize = this.size.clone();
		var buttonSize = this.buttonSize.clone();
		var offset = this.buttonSize.clone();

		// Calculate size of the buttons and offset
		if(this.placement === TabGroup.TOP || this.placement === TabGroup.BOTTOM)
		{
			if(buttonSize.x * this.options.length > this.size.x)
			{
				buttonSize.x = this.size.x / this.options.length;
				offset.x = buttonSize.x;
			}
			tabSize.y -= this.buttonSize.y;
			offset.y = 0;
		}
		else if(this.placement === TabGroup.LEFT || this.placement === TabGroup.RIGHT)
		{
			if(buttonSize.y * this.options.length > this.size.y)
			{
				buttonSize.y = this.size.y / this.options.length;
				offset.y = buttonSize.y;
			}
			tabSize.x -= this.buttonSize.x;
			offset.x = 0;
		}
		
		// Update tab and buttons
		for(var i = 0; i < this.options.length; i++)
		{
			var tab = this.options[i];
			tab.visible = this.selected === tab;
			tab.size.copy(tabSize);
			tab.updateInterface();

			var button = tab.button;
			button.size.copy(buttonSize);
			button.position.copy(offset);
			button.position.multiplyScalar(i);
			button.updateInterface();
		}

		this.tab.size.copy(tabSize);
		this.tab.updateSize();

		// Position buttons and tab division
		if(this.placement === TabGroup.TOP)
		{	
			this.buttons.position.set(0, 0);
			this.buttons.updatePosition();
			this.buttons.size.set(this.size.x, this.buttonSize.y);
			this.buttons.updateSize();

			this.tab.position.set(0, this.buttonSize.y);
			this.tab.updatePosition();
		}
		else if(this.placement === TabGroup.BOTTOM)
		{
			this.buttons.position.set(0, this.size.y - this.buttonSize.y);
			this.buttons.updatePosition();
			this.buttons.size.set(this.size.x, this.buttonSize.y);
			this.buttons.updateSize();

			this.tab.position.set(0, 0);
			this.tab.updatePosition();
		}
		else if(this.placement === TabGroup.LEFT)
		{
			this.buttons.position.set(0, 0);
			this.buttons.updatePosition();
			this.buttons.size.set(this.buttonSize.x, this.size.y);
			this.buttons.updateSize();
			
			this.tab.position.set(this.buttonSize.x, 0);
			this.tab.updatePosition();
		}
		else if(this.placement === TabGroup.RIGHT)
		{
			this.buttons.position.set(this.size.x - this.buttonSize.x, 0);
			this.buttons.updatePosition();
			this.buttons.size.set(this.buttonSize.x, this.size.y);
			this.buttons.updateSize();

			this.tab.position.set(0, 0);
			this.tab.updatePosition();
		}
	};

	/**
	 * Dual container is used to place two components.
	 *
	 * The component can be resized, using a resizable bar that can be vertical or horizontal.
	 *
	 * @class DualContainer
	 */
	function DualContainer(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "hidden";
		this.element.style.backgroundColor = "var(--panel-color)";

		// Container A
		this.elementA = null;

		// Container B
		this.elementB = null;

		// Resize tab
		this.resizeTab = document.createElement("div");
		this.resizeTab.style.position = "absolute";
		this.resizeTab.style.cursor = "e-resize";
		this.resizeTab.style.backgroundColor = "var(--bar-color)";
		this.element.appendChild(this.resizeTab);

		// Resize Tab
		this.tabPosition = 0.5;
		this.tabPositionMax = 0.95;
		this.tabPositionMin = 0.05;
		this.tabSize = 5;
		this.orientation = DualContainer.HORIZONTAL;

		var self = this;

		// Tab mouse down
		this.resizeTab.onmousedown = function(event)
		{
			self.manager.create();
		};

		// Tab resize event manager
		this.manager = new EventManager();
		this.manager.add(window, "mousemove", function(event)
		{
			if(self.orientation === DualContainer.HORIZONTAL)
			{	
				self.tabPosition += event.movementX / self.size.x;
			}
			else if(self.orientation === DualContainer.VERTICAL)
			{
				self.tabPosition += event.movementY / self.size.y;
			}

			// Limit tab position
			if(self.tabPosition > self.tabPositionMax)
			{
				self.tabPosition = self.tabPositionMax;
			}
			else if(self.tabPosition < self.tabPositionMin)
			{
				self.tabPosition = self.tabPositionMin;
			}

			self.updateInterface();
		});

		this.manager.add(window, "mouseup", function(event)
		{
			self.manager.destroy();
		});
	}

	DualContainer.HORIZONTAL = 0;
	DualContainer.VERTICAL = 1;

	DualContainer.prototype = Object.create(Component.prototype);

	DualContainer.prototype.attach = function(element)
	{
		if(this.elementA === null)
		{
			this.attachA(element);
			return;
		}
		
		if(this.elementB === null)
		{
			this.attachB(element);
			return;
		}
		
		console.warn("nunuStudio: Cannot attach more elements.");
	};

	DualContainer.prototype.attachA = function(element)
	{
		this.elementA = element;
		this.elementA.attachTo(this);
	};

	DualContainer.prototype.attachB = function(element)
	{
		this.elementB = element;
		this.elementB.attachTo(this);
	};

	DualContainer.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		if(this.elementA === null || this.elementB === null)
		{
			console.log("nunuStudio: Dual container elements are null", this, this.elementA, this.elementB);
			return;
		}

		if(this.orientation === DualContainer.HORIZONTAL)
		{
			var tabPositionAbs = this.tabPosition * this.size.x;

			this.elementA.position.set(0, 0);
			this.elementA.size.set(tabPositionAbs, this.size.y);
			this.elementA.updateInterface();

			this.elementB.size.set(this.size.x - tabPositionAbs - this.tabSize, this.size.y);
			this.elementB.position.set(this.elementA.size.x + this.tabSize, 0);
			this.elementB.updateInterface();

			this.resizeTab.style.cursor = "e-resize";
			this.resizeTab.style.top = "0px";
			this.resizeTab.style.left = this.elementA.size.x + "px";
			this.resizeTab.style.width = this.tabSize + "px";
			this.resizeTab.style.height = this.size.y + "px";
		}
		else if(this.orientation === DualContainer.VERTICAL)
		{
			var tabPositionAbs = this.tabPosition * this.size.y;
			
			this.elementA.position.set(0, 0);
			this.elementA.size.set(this.size.x, tabPositionAbs);
			this.elementA.updateInterface();
			
			this.elementB.size.set(this.size.x, this.size.y - tabPositionAbs - this.tabSize);
			this.elementB.position.set(0, this.elementA.size.y + this.tabSize);
			this.elementB.updateInterface();

			this.resizeTab.style.cursor = "n-resize";
			this.resizeTab.style.top = this.elementA.size.y + "px";
			this.resizeTab.style.left = "0px";
			this.resizeTab.style.width = this.size.x + "px";
			this.resizeTab.style.height = this.tabSize + "px";
		}
	};

	/**
	 * Tab dual container is a dual container with tabgroups.
	 *
	 * @class TabDualContainer
	 * @extends {Element, TabDual}
	 */
	function TabDualContainer(parent)
	{
		DualContainer.call(this, parent);

		this.element.style.overflow = "visible";
	}

	TabDualContainer.prototype = Object.create(DualContainer.prototype);

	/**
	 * Update all tabs object data.
	 *
	 * @method updateMetadata
	 */
	TabDualContainer.prototype.updateMetadata = function()
	{
		this.elementA.updateMetadata();
		this.elementB.updateMetadata();
	};

	/**
	 * Update all tab object views.
	 *
	 * @method updateObjectsView
	 */
	TabDualContainer.prototype.updateObjectsView = function()
	{
		this.elementA.updateObjectsView();
		this.elementB.updateObjectsView();
	};

	/**
	 * Update all tab object selection status.
	 * 
	 * Should be called after object selection changes.
	 *
	 * @method updateSelection
	 */
	TabDualContainer.prototype.updateSelection = function()
	{
		this.elementA.updateSelection();
		this.elementB.updateSelection();
	};

	/**
	 * Update all tab settings.
	 *
	 * Should be called after editor settings are changed.
	 *
	 * @method updateSettings
	 */
	TabDualContainer.prototype.updateSettings = function()
	{
		this.elementA.updateSettings();
		this.elementB.updateSettings();
	};

	/**
	 * Get an array with all the tabs currently active.
	 *
	 * @method getActiveTab
	 * @return {Array} Active tabs.
	 */
	TabDualContainer.prototype.getActiveTab = function()
	{
		var active = [];

		if(this.elementA instanceof TabGroup)
		{
			var tab = this.elementA.getActiveTab();
			if(tab !== null)
			{
				active.push(tab);
			}
		}
		else
		{
			active = active.concat(this.elementA.getActiveTab());
		}

		if(this.elementB instanceof TabGroup)
		{
			var tab = this.elementB.getActiveTab();
			if(tab !== null)
			{
				active.push(tab);
			}
			this.elementA.getActiveTab();
		}
		else
		{
			active = active.concat(this.elementB.getActiveTab());
		}

		return active;
	};

	/**
	 * Close the tab that is currently being shown if it is closeable.
	 *
	 * @method closeActual
	 */
	TabDualContainer.prototype.closeActual = function()
	{
		if(!(this.elementA instanceof TabGroup) || this.elementA.focused)
		{
			this.elementA.closeActual();
		}

		if(!(this.elementB instanceof TabGroup) || this.elementB.focused)
		{
			this.elementB.closeActual();
		}
	};

	/**
	 * Select a specific tab from the container tab tree.
	 *
	 * @method selectTab
	 * @param {TabComponent} tab Tab to select.
	 */
	TabDualContainer.prototype.selectTab = function(tab)
	{
		this.elementA.selectTab(tab);
		this.elementB.selectTab(tab);
	};

	/**
	 * Select next tab from the currently focused tab group.
	 *
	 * @method selectNextTab
	 */
	TabDualContainer.prototype.selectNextTab = function()
	{
		if(!(this.elementA instanceof TabGroup) || this.elementA.focused)
		{
			this.elementA.selectNextTab();
		}

		if(!(this.elementB instanceof TabGroup) || this.elementB.focused)
		{
			this.elementB.selectNextTab();
		}
	};

	/**
	 * Select previous tab from the currently focused tab group.
	 *
	 * @method selectPreviousTab
	 */
	TabDualContainer.prototype.selectPreviousTab = function()
	{
		if(!(this.elementA instanceof TabGroup) || this.elementA.focused)
		{
			this.elementA.selectPreviousTab();
		}

		if(!(this.elementB instanceof TabGroup) || this.elementB.focused)
		{
			this.elementB.selectPreviousTab();
		}
	};

	/**
	 * Add new option to tab group.
	 *
	 * Prefer the tab group stored on the elementA.
	 *
	 * @method addTab
	 * @param {Constructor} TabConstructor Constructor if the TabComponent to be added to the container.
	 * @param {boolean} closeable Indicates if the tab can be closed.
	 */
	TabDualContainer.prototype.addTab = function(TabConstructor, closeable)
	{
		var tab = this.elementA.addTab(TabConstructor, closeable);
		if(tab === null)
		{
			tab = this.elementB.addTab(TabConstructor, closeable);
		}

		return tab;
	};

	/**
	 * Get tab from tab type and attached object is there is any.
	 *
	 * @param {Constructor} type Type of the tab to look for.
	 * @param {Object} object Object attached to the tab.
	 * @return TabComponent The tab from the type specified that has the object attached to it.
	 */
	TabDualContainer.prototype.getTab = function(type, object)
	{
		var tab = this.elementA.getTab(type, object);
		
		if(tab === null)
		{
			tab = this.elementB.getTab(type, object);
		}

		return tab;
	};

	/**
	 * Remove all tabs from the container.
	 * 
	 * @method clear
	 */
	TabDualContainer.prototype.clear = function(forceAll)
	{
		this.elementA.clear(forceAll);
		this.elementB.clear(forceAll);
	};

	/**
	 * Tab button is used to navigate trough tabs.
	 *
	 * The split version of the tab button is intended to be used alongside splitable tab groups.
	 * 
	 * @class TabButtonSplit
	 * @extends {Component}
	 * @param {Component} parent
	 * @param {TabComponent} tab
	 */
	function TabButtonSplit(parent, tab)
	{
		Component.call(this, parent, "div");

		var self = this;

		this.element.draggable = true;
		this.element.style.cursor = "pointer";
		this.element.style.boxSizing = "border-box";
		this.element.style.backgroundColor = "var(--bar-color)";

		// Tab
		this.tab = tab;

		// Icon
		this.icon = document.createElement("img");
		this.icon.style.pointerEvents = "none";
		this.icon.style.position = "absolute";
		this.icon.src = tab.icon;
		this.element.appendChild(this.icon);

		// Text
		this.text = document.createElement("div");
		this.text.style.position = "absolute";
		this.text.style.overflow = "hidden";
		this.text.style.textAlign = "center";
		this.text.style.pointerEvents = "none";
		this.text.style.textOverflow = "ellipsis";
		this.text.style.whiteSpace = "nowrap";
		this.text.style.color = "var(--color-light)";
		this.element.appendChild(this.text);

		// Title
		this.title = document.createTextNode(tab.title);
		this.text.appendChild(this.title);

		// Close button
		this.close = document.createElement("img");
		this.close.draggable = false;
		this.close.style.position = "absolute";
		this.close.style.opacity = 0.5;
		this.close.style.display = (tab.closeable) ? "block" : "none";
		this.close.src = Global.FILE_PATH + "icons/misc/close.png";
		this.element.appendChild(this.close);

		this.close.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};

		this.close.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};

		this.close.onclick = function()
		{
			self.tab.close();
		};
		
		// Drag state
		var dragState = TabButtonSplit.NONE;

		// Drag control
		this.element.ondragstart = function(event)
		{
			event.dataTransfer.setData("uuid", self.tab.uuid);
			DragBuffer.push(self.tab);

			event.dataTransfer.setData("tab", self.tab.index);
			dragState = TabButtonSplit.NONE;
		};

		// Drag drop
		this.element.ondrop = function(event)
		{
			event.preventDefault();
			this.style.borderLeft = null;
			this.style.borderRight = null;
			this.style.borderBottom = null;
			this.style.borderTop = null;

			var uuid = event.dataTransfer.getData("uuid");
			var tab = DragBuffer.get(uuid);

			if(tab instanceof TabComponent)
			{
				// In the same container
				if(tab.container === self.tab.container)
				{
					var index = event.dataTransfer.getData("tab");
					index = parseInt(index);

					if(index !== self.tab.index)
					{	
						// Before
						if(dragState === TabButtonSplit.PREVIOUS)
						{
							self.tab.container.moveTabIndex(index, index < self.tab.index ? self.tab.index - 1 : self.tab.index);
						}
						// After
						else if(dragState === TabButtonSplit.NEXT)
						{
							self.tab.container.moveTabIndex(index, index < self.tab.index ? self.tab.index : self.tab.index + 1);
						}
						
						DragBuffer.pop(uuid);
					}
				}
				// From another container
				else
				{
					// Before
					if(dragState === TabButtonSplit.PREVIOUS)
					{
						self.tab.container.attachTab(tab, self.tab.index);
					}
					// After
					else if(dragState === TabButtonSplit.NEXT)
					{
						self.tab.container.attachTab(tab, self.tab.index + 1);
					}
					
					DragBuffer.pop(uuid);
				}
			}
		};

		// Drag over
		this.element.ondragover = function(event)
		{
			if(self.tab.container.placement === TabGroup.TOP || self.tab.container.placement === TabGroup.BOTTOM)
			{	
				if(event.layerX > self.size.x * 0.8 || event.target !== this)
				{
					if(dragState !== TabButtonSplit.NEXT)
					{
						dragState = TabButtonSplit.NEXT;
						this.style.borderLeft = null;
						this.style.borderRight = "thick solid #999999";
					}
				}
				else if(event.layerX < self.size.x * 0.2)
				{
					if(dragState !== TabButtonSplit.PREVIOUS)
					{
						dragState = TabButtonSplit.PREVIOUS;
						this.style.borderRight = null;
						this.style.borderLeft = "thick solid #999999";
					}
				}
				else
				{
					if(dragState !== TabButtonSplit.NONE)
					{
						dragState = TabButtonSplit.NONE;
						this.style.borderLeft = null;
						this.style.borderRight = null;
					}
				}
			}
			else
			{
				if(event.layerY > self.size.y * 0.7 || event.target !== this)
				{
					if(dragState !== TabButtonSplit.NEXT)
					{
						dragState = TabButtonSplit.NEXT;
						this.style.borderTop = null;
						this.style.borderBottom = "solid #999999";
					}
				}
				else if(event.layerY < self.size.y * 0.3)
				{
					if(dragState !== TabButtonSplit.PREVIOUS)
					{
						dragState = TabButtonSplit.PREVIOUS;
						this.style.borderBottom = null;
						this.style.borderTop = "solid #999999";
					}
				}
				else
				{
					if(dragState !== TabButtonSplit.NONE)
					{
						dragState = TabButtonSplit.NONE;
						this.style.borderBottom = null;
						this.style.borderTop = null;
					}
				}
			}
		};

		// Drag end
		this.element.ondragend = function(event)
		{
			event.preventDefault();
			
			DragBuffer.pop(self.tab.uuid);

			dragState = TabButtonSplit.NONE;
			this.style.borderLeft = null;
			this.style.borderRight = null;
			this.style.borderBottom = null;
			this.style.borderTop = null;
		};

		// Drag leave
		this.element.ondragleave = function(event)
		{
			event.preventDefault();
			
			dragState = TabButtonSplit.NONE;
			this.style.borderLeft = null;
			this.style.borderRight = null;
			this.style.borderBottom = null;
			this.style.borderTop = null;
		};

		// Mouse down
		this.element.onmousedown = function(event)
		{
			var button = event.which - 1;

			// Select tab
			if(button === Mouse.LEFT)
			{
				self.tab.container.selectTab(self.tab);
			}
			// Close tab
			else if(tab.closeable && button === Mouse.MIDDLE)
			{
				self.tab.container.removeTab(self.tab);
			}
		};

		// Mouse enter
		this.element.onmouseenter = function()
		{
			this.style.backgroundColor = "var(--button-over-color)";
		};

		// Mouse leave
		this.element.onmouseleave = function()
		{
			if(tab.isSelected())
			{
				this.style.backgroundColor = "var(--button-over-color)";
			}
			else
			{
				this.style.backgroundColor = "var(--bar-color)";
			}
		};
	}

	TabButtonSplit.prototype = Object.create(Component.prototype);

	TabButtonSplit.NONE = 0;
	TabButtonSplit.PREVIOUS = 1;
	TabButtonSplit.NEXT = 2;

	/**
	 * Set the tab icon image.
	 *
	 * @method setIcon
	 * @param {string} icon URL of the icon image.
	 */
	TabButtonSplit.prototype.setIcon = function(icon)
	{
		this.tab.icon = icon;
		this.icon.src = icon;
	};

	/**
	 * Set text to be displayed in the button as its name.
	 *
	 * @method setName
	 * @param {string} text
	 */
	TabButtonSplit.prototype.setName = function(text)
	{
		this.tab.title = text;
		this.title.data = text;
	};

	TabButtonSplit.prototype.updateSelection = function()
	{
		this.element.style.backgroundColor = this.tab.isSelected() ? "var(--button-over-color)" : "var(--bar-color)";
	};

	TabButtonSplit.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);
		
		// Icon
		this.icon.style.top = (this.size.y * 0.2) + "px";
		this.icon.style.left = (this.size.y * 0.2) + "px";
		this.icon.style.width = (this.size.y * 0.6) + "px";
		this.icon.style.height = (this.size.y * 0.6) + "px";

		// Text
		this.text.style.left = this.size.y + "px";
		this.text.style.top = ((this.size.y - 12) / 2) + "px";
		this.text.style.width = (this.size.x - 2 * this.size.y) + "px";
		this.text.style.height = this.size.y + "px";

		// Close
		if(this.tab.closeable === true)
		{
			this.close.style.width = (this.size.y * 0.4) + "px";
			this.close.style.height = (this.size.y * 0.4) + "px";
			this.close.style.top = (this.size.y * 0.3) + "px";
			this.close.style.right = (this.size.y * 0.3) + "px";
			this.close.style.display = "block";
		}
		else
		{
			this.close.style.display = "none";
		}

		this.updateSelection();
	};

	/**
	 * A tab group contains and manages tab elements.
	 *
	 * A splitable tab group can be splited into two tab group allowing a more flexible interface organization during runtime.
	 * 
	 * @class TabGroupSplit
	 * @extends {TabGroup}
	 * @param {Component} parent Parent element.
	 */
	function TabGroupSplit(parent, placement)
	{
		TabGroup.call(this, parent, placement);

		var self = this;

		/**
		 * Border where another another tabs can be dragged to for this tab to be spplited.
		 *
		 * @property dragBorder
		 * @type {number}
		 */
		this.dragBorder = 0.2;

		/**
		 * If true the group can be split in two.
		 *
		 * @property canSplit
		 * @type {boolean}
		 */
		this.canSplit = true;

		/**
		 * If true the group can be collapsed.
		 *
		 * @property canCollapse
		 * @type {boolean}
		 */
		this.canCollapse = true;

		/**
		 * DOM element to be displayed when a tab is dragged over.
		 *
		 * @property tabArea
		 * @type {Component}
		 */
		this.tabArea = document.createElement("div");
		this.tabArea.style.zIndex = "1000";
		this.tabArea.style.position = "absolute";
		this.tabArea.style.backgroundColor = "var(--color-black-alpha-20)";
		this.tabArea.style.pointerEvents = "none";

		// Drag drop
		this.tab.element.ondrop = function(event)
		{
			event.preventDefault();

			var uuid = event.dataTransfer.getData("uuid");
			var tab = DragBuffer.get(uuid);

			if(tab instanceof TabComponent)
			{
				var position = DOMUtils.getPosition(self.element);
				var x = event.clientX - position.x;
				var y = event.clientY - position.y;

				// Left
				if(x < self.size.x * self.dragBorder)
				{
					self.split(TabGroup.LEFT).attachTab(tab);
				}
				// Right
				else if(x > self.size.x * (1 - self.dragBorder))
				{
					self.split(TabGroup.RIGHT).attachTab(tab);
				}
				// Top
				else if(y < self.size.y * self.dragBorder)
				{
					self.split(TabGroup.TOP).attachTab(tab);
				}
				// Bottom
				else if(y > self.size.y * (1 - self.dragBorder))
				{
					self.split(TabGroup.BOTTOM).attachTab(tab);
				}
				else
				{
					self.attachTab(tab);
				}

				DragBuffer.pop(uuid);
			}

			if(self.tab.element.contains(self.tabArea))
			{
				self.tab.element.removeChild(self.tabArea);
			}
		};

		// Drag over
		this.tab.element.ondragover = function(event)
		{
			event.preventDefault();

			if(!(DragBuffer.buffer[0] instanceof TabComponent))
			{
				return;
			}

			var position = DOMUtils.getPosition(self.element);
			var x = event.clientX - position.x;
			var y = event.clientY - position.y;

			// Left
			if(x < self.size.x * self.dragBorder)
			{
				self.tabArea.style.right = null;
				self.tabArea.style.bottom = null;
				self.tabArea.style.top = "0px";
				self.tabArea.style.left = "0px";
				self.tabArea.style.width = "50%";
				self.tabArea.style.height = "100%";

				if(!self.tab.element.contains(self.tabArea))
				{
					self.tab.element.appendChild(self.tabArea);
				}
			}
			// Right
			else if(x > self.size.x * (1 - self.dragBorder))
			{
				self.tabArea.style.left = null;
				self.tabArea.style.bottom = null;
				self.tabArea.style.top = "0px";
				self.tabArea.style.right = "0px";
				self.tabArea.style.width = "50%";
				self.tabArea.style.height = "100%";

				if(!self.tab.element.contains(self.tabArea))
				{
					self.tab.element.appendChild(self.tabArea);
				}
			}
			// Top
			else if(y < self.size.y * self.dragBorder)
			{
				self.tabArea.style.right = null;
				self.tabArea.style.bottom = null;
				self.tabArea.style.top = "0px";
				self.tabArea.style.left = "0px";
				self.tabArea.style.width = "100%";
				self.tabArea.style.height = "50%";

				if(!self.tab.element.contains(self.tabArea))
				{
					self.tab.element.appendChild(self.tabArea);
				}
			}
			// Bottom
			else if(y > self.size.y * (1 - self.dragBorder))
			{
				self.tabArea.style.top = null;
				self.tabArea.style.right = null;
				self.tabArea.style.bottom = "0px";
				self.tabArea.style.left = "0px";
				self.tabArea.style.width = "100%";
				self.tabArea.style.height = "50%";

				if(!self.tab.element.contains(self.tabArea))
				{
					self.tab.element.appendChild(self.tabArea);
				}
			}
			else
			{
				if(self.tab.element.contains(self.tabArea))
				{
					self.tab.element.removeChild(self.tabArea);
				}
			}
		};

		// Drag leave
		this.tab.element.ondragleave = function(event)
		{
			event.preventDefault();

			if(self.tab.element.contains(self.tabArea))
			{
				self.tab.element.removeChild(self.tabArea);
			}
		};
	}

	TabGroupSplit.prototype = Object.create(TabGroup.prototype);

	/**
	 * Split this tab group into two new tab groups.
	 *
	 * @method split
	 * @param {number} direction Direction where to insert the new tab.
	 * @return {TabGroupSplit} The new created tab group.
	 */
	TabGroupSplit.prototype.split = function(direction)
	{
		if(this.canSplit)
		{
			if(direction === undefined)
			{
				direction = TabGroup.RIGHT;
			}

			var container = new TabDualContainer();
			var parent = this.parent;
			var group = new TabGroupSplit(container, this.placement);

			if(direction === TabGroup.RIGHT)
			{
				container.orientation = DualContainer.HORIZONTAL;
				container.attach(this);
				container.attach(group);
			}
			else if(direction === TabGroup.LEFT)
			{
				container.orientation = DualContainer.HORIZONTAL;
				container.attach(group);
				container.attach(this);
			}
			else if(direction === TabGroup.BOTTOM)
			{
				container.orientation = DualContainer.VERTICAL;
				container.attach(this);
				container.attach(group);
			}
			else if(direction === TabGroup.TOP)
			{
				container.orientation = DualContainer.VERTICAL;
				container.attach(group);
				container.attach(this);
			}
			
			if(parent instanceof TabContainer)
			{
				parent.attach(container);
				parent.updateSize();
			}
			else if(parent instanceof DualContainer)
			{
				if(parent.elementA === this)
				{
					parent.attachA(container);
					parent.updateSize();
				}
				else if(parent.elementB === this)
				{
					parent.attachB(container);
					parent.updateSize();
				}
			}

			return group;
		}
		else
		{
			console.warn("nunuStudio: Tab is not splitable.");
		}
	};

	/**
	 * If the tab is in a split container, move all the tabs to the other tabgroup in the container and close this group.
	 *
	 * @method collapse
	 */ 
	TabGroupSplit.prototype.collapse = function()
	{
		if(this.canCollapse)
		{
			if(this.parent instanceof DualContainer)
			{
				var parent = this.parent.parent;
				var group = this.parent.elementA === this ? this.parent.elementB : this.parent.elementA;

				// Dual container
				if(parent instanceof DualContainer)
				{
					if(parent.elementA === this.parent)
					{
						this.parent.destroy();
						this.destroy();
						parent.attachA(group);
					}
					else if(parent.elementB === this.parent)
					{
						this.parent.destroy();
						this.destroy();
						parent.attachB(group);
					}
				}
				// Tab container
				else
				{
					this.parent.destroy();
					this.destroy();
					parent.attach(group);
				}
				
				parent.updateSize();
			}
			else
			{
				console.warn("nunuStudio: Tab cannot be collapsed (parent is not a dual container).");
			}
		}
		else
		{
			console.warn("nunuStudio: Tab is not collapsable.");
		}
	};

	/**
	 * Attach tab to this group and remove it from the original group.
	 *
	 * @method attachTab
	 * @param {TabComponent} tab Tab to be moved.
	 * @param {number} insertIndex Index where to place the tab.
	 */
	TabGroupSplit.prototype.attachTab = function(tab, insertIndex)
	{	
		var container = tab.container;
		var tab = TabGroup.prototype.attachTab.call(this, tab, insertIndex);

		if(container.options.length === 0)
		{
			container.collapse();
		}

		return tab;
	};

	TabGroupSplit.prototype.removeTab = function(index, dontDestroy)
	{
		TabGroup.prototype.removeTab.call(this, index, dontDestroy);

		if(this.options.length === 0 && dontDestroy !== true)
		{
			this.collapse();
		}
	};

	TabGroupSplit.prototype.addTab = function(TabConstructor, closeable)
	{
		var tab = new TabConstructor(this.tab, closeable, this, this.options.length);
		tab.button = new TabButtonSplit(this.buttons, tab);
		tab.updateInterface();

		this.options.push(tab);

		if(this.selected === null || this.options.length === 1)
		{
			this.selectTab(tab);
		}
		else
		{
			this.updateInterface();
		}
		
		return tab;
	};

	/**
	 * Tab container is the root for a tree of tab groups.
	 *
	 * The container keeps track of all groups that may be splited into multiple groups.
	 *
	 * @class TabContainer
	 * @extends {Component}
	 */
	function TabContainer(parent)
	{
		Component.call(this, parent, "div");
		
		this.group = null;
	}

	TabContainer.prototype = Object.create(Component.prototype);

	/**
	 * Split this tab group into two new tab groups.
	 *
	 * @method split
	 * @param {number} direction Direction where to insert the new tab.
	 * @return {TabGroupSplit} The new created tab group.
	 */
	TabContainer.prototype.split = function(direction)
	{
		return this.group.split(direction);
	};

	TabContainer.prototype.attach = function(element)
	{
		this.group = element;
		this.group.attachTo(this);
	};

	TabContainer.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		if(this.group !== null)
		{
			this.group.position.set(0, 0);
			this.group.size.copy(this.size);
			this.group.updateInterface();
		}
	};

	/**
	 * Update all tabs object data.
	 *
	 * @method updateMetadata
	 */
	TabContainer.prototype.updateMetadata = function()
	{
		this.group.updateMetadata();
	};

	/**
	 * Update all tab object views.
	 *
	 * @method updateObjectsView
	 */
	TabContainer.prototype.updateObjectsView = function()
	{
		this.group.updateObjectsView();
	};

	/**
	 * Update all tab object selection status.
	 * 
	 * Should be called after object selection changes.
	 *
	 * @method updateSelection
	 */
	TabContainer.prototype.updateSelection = function()
	{
		this.group.updateSelection();
	};

	/**
	 * Update all tab settings.
	 *
	 * Should be called after editor settings are changed.
	 *
	 * @method updateSettings
	 */
	TabContainer.prototype.updateSettings = function()
	{
		this.group.updateSettings();
	};

	/**
	 * Get an array with all the tabs currently active.
	 *
	 * @method getActiveTab
	 * @return {Array} Active tabs.
	 */
	TabContainer.prototype.getActiveTab = function()
	{
		var active = [];

		if(this.group instanceof TabGroup)
		{
			var tab = this.group.getActiveTab();
			if(tab !== null)
			{
				active.push(tab);
			}
		}
		else
		{
			active = active.concat(this.group.getActiveTab());
		}

		return this.group.getActiveTab();
	};

	/**
	 * Close the tab that is currently being shown if it is closeable.
	 *
	 * @method closeActual
	 */
	TabContainer.prototype.closeActual = function()
	{
		this.group.closeActual();
	};

	/**
	 * Select a specific tab from the container tab tree.
	 *
	 * @method selectTab
	 * @param {TabComponent} tab Tab to select.
	 */
	TabContainer.prototype.selectTab = function(tab)
	{
		this.group.selectTab(tab);
	};

	/**
	 * Select next tab from the currently focused tab group.
	 *
	 * @method selectNextTab
	 */
	TabContainer.prototype.selectNextTab = function()
	{
		this.group.selectNextTab();
	};

	/**
	 * Select previous tab from the currently focused tab group.
	 *
	 * @method selectPreviousTab
	 */
	TabContainer.prototype.selectPreviousTab = function()
	{
		this.group.selectPreviousTab();
	};

	/**
	 * Add new tab to the tab container.
	 * 
	 * @method addTab
	 * @param {Constructor} TabConstructor Constructor if the TabComponent to be added to the container.
	 * @param {boolean} closeable Indicates if the tab can be closed.
	 */
	TabContainer.prototype.addTab = function(TabConstructor, closeable)
	{
		return this.group.addTab(TabConstructor, closeable);
	};

	/**
	 * Get tab from tab type and attached object is there is any.
	 *
	 * @param {Constructor} type Type of the tab to look for.
	 * @param {Object} object Object attached to the tab.
	 * @return TabComponent The tab from the type specified that has the object attached to it.
	 */
	TabContainer.prototype.getTab = function(type, object)
	{
		return this.group.getTab(type, object);
	};

	/**
	 * Remove all tabs from the container.
	 * 
	 * @method clear
	 */
	TabContainer.prototype.clear = function(forceAll)
	{
		this.group.clear();
	};

	/**
	 * Tab element is used to create tabbed elements.
	 *
	 * These are used to implement the main components of the interface (editors, menus, etc).
	 *
	 * @class TabComponent
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 * @param {boolean} closeable If false the tab cannot be closed.
	 * @param {TabContainer} container Container for this tab.
	 * @param {number} index Index of the tab.
	 * @param {string} title Title of the tab.
	 * @param {string} icon Icon of the tab.
	 */
	function TabComponent(parent, closeable, container, index, title, icon)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";
		this.element.style.backgroundColor = "var(--panel-color)";
		this.preventDragEvents();

		/**
		 * Pointer to the group where this tab is.
		 *
		 * @property container
		 * @type {TabGroup}
		 */
		this.container = container;

		/**
		 * UUID of this tab.
		 *
		 * @property uuid
		 * @type {string}
		 */
		this.uuid = three.Math.generateUUID();

		/**
		 * Index of the tab inside of the container
		 *
		 * @property index
		 * @type {number}
		 */
		this.index = index;

		/**
		 * Pointer to the button associated with this tab.
		 *
		 * @property container
		 * @type {TabButton}
		 */
		this.button = null;

		// Meta
		this.closeable = closeable;
		this.title = title;
		this.icon = icon;

		/**
		 * Indicates if the tab is currently active (on display).
		 *
		 * @property active
		 * @type {boolean}
		 */
		this.active = false;
	}

	TabComponent.prototype = Object.create(Component.prototype);

	/**
	 * Update tab metadata (name, icon, ...)
	 * 
	 * Called after applying changes to object.
	 * 
	 * Called for every tab.
	 *
	 * @method updateMetadata
	 */
	TabComponent.prototype.updateMetadata = function(){};

	/**
	 * Update tab settings.
	 * 
	 * Called after settings of the editor are changed.
	 * 
	 * Called for every tab.
	 *
	 * @method updateSettings
	 */
	TabComponent.prototype.updateSettings = function(){};

	/**
	 * Update tab values of the gui for the object attached.
	 * 
	 * Called when properties of objects are changed.
	 * 
	 * Called only for active tabs.
	 *
	 * @method updateValues
	 */
	TabComponent.prototype.updateValues = function(){};

	/**
	 * Update tab object view.
	 * 
	 * Called when objects are added, removed, etc.
	 * 
	 * Called only for active tabs.
	 *
	 * @method updateObjectsView
	 */
	TabComponent.prototype.updateObjectsView = function(){};

	/**
	 * Update tab after object selection changed.
	 * 
	 * Called after a new object was selected.
	 * 
	 * Called only for active tabs.
	 *
	 * @method updateSelection
	 */
	TabComponent.prototype.updateSelection = function(){};

	/**
	 * Activate tab.
	 * 
	 * Called when a tab becomes active (visible).
	 *
	 * @method activate
	 */
	TabComponent.prototype.activate = function()
	{
		if(this.active === true)
		{
			this.deactivate();
		}
		
		// TODO <IF TAB NEEDS UPDATE IT SHOULD TAKE CARE OF IT>
		if(this.update !== undefined)
		{
			var self = this;

			var update = function()
			{
				self.update();

				if(self.active === true)
				{
					requestAnimationFrame(update);
				}
			};

			requestAnimationFrame(update);
		}

		this.active = true;
	};

	/**
	 * Deactivate tab.
	 * 
	 * Called when a tab is deactivated or closed.
	 *
	 * @method deactivate
	 */
	TabComponent.prototype.deactivate = function()
	{
		this.active = false;
	};

	/**
	 * Generic method to attach object to a tab.
	 *
	 * Attached object can be edited using the tab.
	 *
	 * @method attach
	 * @param {Object} object
	 */
	TabComponent.prototype.attach = function(object){};

	/**
	 * Check if an object or resource is attached to the tab.
	 * 
	 * Called to check if a tab needs to be closed after changes to objects.
	 *
	 * @method isAttached
	 */
	TabComponent.prototype.isAttached = function(object)
	{
		return false;
	};

	/**
	 * Close the tab element and remove is from the container.
	 * 
	 * @method close
	 */
	TabComponent.prototype.close = function()
	{
		this.container.removeTab(this);
	};

	/**
	 * Select this tab.
	 * 
	 * @method select
	 */
	TabComponent.prototype.select = function()
	{
		this.container.selectTab(this);
	};

	/**
	 * Check if tab is selected
	 *
	 * @method isSelected
	 * @return {boolean} True if the tab is selected in the container.
	 */
	TabComponent.prototype.isSelected = function()
	{
		return this === this.container.selected;
	};

	/**
	 * Set icon of the button attached to this tab.
	 *
	 * The button should have a .setIcon(url) method.
	 *
	 * @method setIcon
	 * @param {string} icon URL of the icon.
	 */
	TabComponent.prototype.setIcon = function(icon)
	{
		this.icon = icon;
		this.button.setIcon(icon);
	};

	/**
	 * Set text in the button.
	 *
	 * The button should have a .setName(text) method.
	 *
	 * @method setName
	 * @param {string} text
	 */
	TabComponent.prototype.setName = function(text)
	{
		this.title = text;
		this.button.setName(text);
	};

	TabComponent.prototype.destroy = function()
	{
		Component.prototype.destroy.call(this);
		
		if(this.button !== null)
		{
			this.button.destroy();
		}
	};

	/**
	 * CSS 3D element drawn as a billboard.
	 *
	 * Always faces the screen orientation (does not rotate).
	 *
	 * @class CSS3DSprite
	 * @extends {CSS3DObject}
	 * @param {Component} element DOM element encapsulated in the object container.
	 */
	function CSS3DSprite(element)
	{
		CSS3DObject.call(this, element);
	}

	CSS3DSprite.prototype = Object.create(CSS3DObject.prototype);
	CSS3DSprite.prototype.constructor = CSS3DSprite;
	CSS3DSprite.prototype.isCSS3DSprite = true;

	/**
	 * 3D renderer using DOM elements.
	 *
	 * Applies the threejs transformation hierarchy to the DOM element using CSS3D.
	 *
	 * Only renders CSS specific objects, the output of the renderer is not combined with the WebGL output. Everything is renderer of top.
	 *
	 * Based on the three.js adaptation (mrdoob, yomotsu) of http:// www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
	 * 
	 * @class CSS3DRenderer
	 * @param {Component} domElement DOM division to place rendered objects.
	 */
	function CSS3DRenderer(domElement)
	{
		/**
		 * Size of the renderer viewport.
		 *
		 * @attribute size
		 * @type {Vector2}
		 */
		this.size = new three.Vector2(2, 2);

		/**
		 * Size of the renderer viewport.
		 *
		 * @attribute size
		 * @type {Vector2}
		 */
		this.halfSize = new three.Vector2(1, 1);

		/**
		 * Temporary matrix object.
		 *
		 * @attribute matrix
		 * @type {Matrix4}
		 */
		this.matrix = new three.Matrix4();

		/**
		 * Object cache, used to store the rendered objects state.
		 *
		 * @attribute cache
		 * @type {Object}
		 */
		this.cache =
		{
			camera: {fov: 0, style: ""},
			objects: new WeakMap()
		};

		/**
		 * Main DOM element used for the renderer.
		 *
		 * @attribute domElement
		 * @type {Element}
		 */
		this.domElement = domElement !== undefined ? domElement : document.createElement("div");
		this.domElement.style.overflow = "hidden";
		this.domElement.style.pointerEvents = "none";

		/**
		 * Camera projected DOM element.
		 *
		 * @attribute domElement
		 * @type {Element}
		 */
		this.cameraElement = document.createElement("div");
		this.cameraElement.style.WebkitTransformStyle = "preserve-3d";
		this.cameraElement.style.transformStyle = "preserve-3d";
		this.domElement.appendChild(this.cameraElement);
	}
	/**
	 * Get the size of the renderer.
	 *
	 * @method getSize
	 */
	CSS3DRenderer.prototype.getSize = function()
	{
		return {width: this.size.x, height: this.size.y};
	};

	/**
	 * Set the size of the renderer.
	 *
	 * The size is also applie to the internal DOM division.
	 *
	 * @method setSize
	 * @param {number} width
	 * @param {number} height
	 */
	CSS3DRenderer.prototype.setSize = function(width, height)
	{
		this.size.set(width, height);
		this.halfSize.set(width / 2, height / 2);

		this.domElement.style.width = width + "px";
		this.domElement.style.height = height + "px";
		this.cameraElement.style.width = width + "px";
		this.cameraElement.style.height = height + "px";
	};

	/**
	 * Render the CSS object of a scene using a camera.
	 *
	 * @method render
	 * @param {Scene} scene Scene to be rendered.
	 * @param {Camera} camera Camera used to render the scene.
	 */
	CSS3DRenderer.prototype.render = function(scene, camera)
	{
		// Get the camera transform as a css 3D string
		function getCameraCSSMatrix(matrix)
		{
			var elements = matrix.elements;

			return "matrix3d(" +
				elements[0] + "," +
				(-elements[1]) + "," +
				elements[2] + "," +
				elements[3] + "," +
				elements[4] + "," +
				(-elements[5]) + "," +
				elements[6] + "," +
				elements[7] + "," +
				elements[8] + "," +
				(-elements[9]) + "," +
				elements[10] + "," +
				elements[11] + "," +
				elements[12] + "," +
				(-elements[13]) + "," +
				elements[14] + "," +
				elements[15] +
			")";
		}

		// Get the object transform as a css 3D string
		function getObjectCSSMatrix(matrix, cameraCSSMatrix)
		{
			var elements = matrix.elements;
			
			return "translate(-50%,-50%)matrix3d(" +
				elements[0] + "," +
				elements[1] + "," +
				elements[2] + "," +
				elements[3] + "," +
				(-elements[4]) + "," +
				(-elements[5]) + "," +
				(-elements[6]) + "," +
				(-elements[7]) + "," +
				elements[8] + "," +
				elements[9] + "," +
				elements[10] + "," +
				elements[11] + "," +
				elements[12] + "," +
				elements[13] + "," +
				elements[14] + "," +
				elements[15] +
			")";
		}

		var self = this;

		// Auxiliar method to render a single object
		function renderObject(object, camera, cameraCSSMatrix)
		{
			// Render only CSS objects
			if(object.isCSS3DObject === true)
			{
				// Store the css transformation style value
				var style;

				// Remove rotation from the transformation matrix for Sprites
				if(object.isCSS3DSprite === true)
				{
					matrix.copy(camera.matrixWorldInverse);
					matrix.transpose();
					matrix.copyPosition(object.matrixWorld);
					matrix.scale(object.scale);

					matrix.elements[3] = 0;
					matrix.elements[7] = 0;
					matrix.elements[11] = 0;
					matrix.elements[15] = 1;

					style = getObjectCSSMatrix(matrix);
				}
				else
				{
					style = getObjectCSSMatrix(object.matrixWorld);
				}

				var element = object.element;
				var cachedObject = self.cache.objects.get(object);

				// Add the DOM element to the cache
				if(cachedObject === undefined || cachedObject.style !== style)
				{
					element.style.WebkitTransform = style;
					element.style.transform = style;
					self.cache.objects.set(object, {style: style});
				}

				// If the DOM element does not have a parend add to the cameraElement division
				if(element.parentNode !== self.cameraElement)
				{
					self.cameraElement.appendChild(element);
				}
			}

			// Render children object
			for(var i = 0, l = object.children.length; i < l; i++)
			{
				renderObject(object.children[i], camera);
			}
		}

		// Get the effective camera fov from the projection matrix
		var fov = camera.projectionMatrix.elements[5] * this.halfSize.y;

		// If the camera fov is diferrent from the cached one ajust values.
		if(this.cache.camera.fov !== fov)
		{
			if(camera.isPerspectiveCamera)
			{
				this.domElement.style.WebkitPerspective = fov + "px";
				this.domElement.style.perspective = fov + "px";
			}

			this.cache.camera.fov = fov;
		}

		// Update the scene world matrix
		scene.updateMatrixWorld();

		// Update the camera world matrix
		if(camera.parent === null)
		{
			camera.updateMatrixWorld();
		}

		var cameraCSSMatrix;

		// Orthographic camera matrix
		if(camera.isOrthographicCamera)
		{
			var tx = -(camera.right + camera.left) / 2;
			var ty = (camera.top + camera.bottom) / 2;

			cameraCSSMatrix = "scale(" + fov + ")" + "translate(" + tx + "px," + ty + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
		}
		// Perpective camera matrix
		else
		{
			cameraCSSMatrix = "translateZ(" + fov + "px)" + getCameraCSSMatrix(camera.matrixWorldInverse);
		}

		var style = cameraCSSMatrix + "translate(" + this.halfSize.x + "px," + this.halfSize.y + "px)";

		// If the style is diferent from cache ajust style
		if(this.cache.camera.style !== style)
		{
			this.cameraElement.style.WebkitTransform = style;
			this.cameraElement.style.transform = style;
			this.cache.camera.style = style;
		}

		// Render scene recursively
		renderObject(scene, camera);
	};

	/**
	 * A canvas element that also contains a thee.js webgl renderer object.
	 *
	 * The renderer is automatically updated to match the canvas size, it also handles the device pixel ratio.
	 *
	 * @class RendererCanvas
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 * @param {boolean} alpha If true the background is transparent.
	 */
	function RendererCanvas(parent, options, useCSSRenderer)
	{
		Component.call(this, parent, "div");

		this.element.style.backgroundColor = "var(--color-black)";
		
		/** 
		 * List os parameters to be passed to the WebGLrenderer.
		 *
		 * @attribute options
		 * @type {Object}
		 */
		this.options = options !== undefined ? options : new RendererConfiguration();

		/**
		 * On resize callback, called every time the container is updated.
		 *
		 * @attribute onResize
		 * @type {Function}
		 */
		this.onResize = null;

		/**
		 * Indicates if a CSS renderer should be created alongside the WebGL renderer.
		 *
		 * @attribute useCSSRenderer
		 * @type {boolean}
		 */
		this.useCSSRenderer = useCSSRenderer !== undefined ? useCSSRenderer : true;

		/**
		 * CSS renderer used alongside.
		 *
		 * @attribute cssRenderer
		 * @type {CSS3DObject}
		 */
		this.cssRenderer = null;

		/**
		 * Overlay division used to place the css rendered DOM objects.
		 *
		 * @attribute cssDivision
		 * @type {Component}
		 */
		this.cssDivision = null;

		/**
		 * Rendering resolution accouting for the device pixel ratio.
		 *
		 * @attribute resolution
		 * @type {Vector2}
		 */
		this.resolution = new three.Vector2();

		/**
		 * Method called when the canvas is reset, might need to be used to replace canvas related events.
		 *
		 * Receives the RendererCanvas object as argument.
		 *
		 * @attribute onCanvasReset
		 * @type {Function}
		 */
		this.onCanvasReset = null;

		/**
		 * Canvas DOM element.
		 * 
		 * @attribute canvas
		 * @type {Component}
		 */
		this.canvas = null;
		this.resetCanvas();

		/**
		 * three.js WebGl renderer.
		 *
		 * @attribute renderer
		 * @type {WebGlRenderer}
		 */
		this.renderer = null;
		this.createRenderer();
	}

	RendererCanvas.prototype = Object.create(Component.prototype);

	/**
	 * Set on resize callback, can be usefull to update cameras and other screen space dependent objects.
	 * 
	 * The callback receives the width and height of the rendering canvas.
	 * 
	 * @method setOnResize
	 * @param {Function} callback
	 */
	RendererCanvas.prototype.setOnResize = function(callback)
	{
		this.onResize = callback;
	};

	/**
	 * Reset the canvas DOM element.
	 * 
	 * Removes the current canvas and creates a new one.
	 * 
	 * @method resetCanvas
	 */
	RendererCanvas.prototype.resetCanvas = function()
	{
		if(this.element.contains(this.canvas))
		{
			this.element.removeChild(this.canvas);
		}

		this.canvas = document.createElement("canvas");
		this.canvas.style.position = "absolute";
		this.canvas.style.display = "block";
		this.canvas.style.top = "0px";
		this.canvas.style.left = "0px";

		if(this.element.children.length === 0)
		{
			this.element.appendChild(this.canvas);
		}
		else
		{
			this.element.insertBefore(this.canvas, this.element.firstChild);
		}

		if(this.element.contains(this.cssDivision))
		{
			this.element.removeChild(this.cssDivision);
		}

		if(this.useCSSRenderer)
		{
			this.cssDivision = document.createElement("div");
			this.cssDivision.style.position = "absolute";
			this.cssDivision.style.display = "block";
			this.cssDivision.style.top = "0px";
			this.cssDivision.style.left = "0px";
			this.element.appendChild(this.cssDivision);
		}

		this.resizeCanvas();

		if(this.onCanvasReset !== null)
		{
			this.onCanvasReset(this);
		}
	};

	/**
	 * Creates a new threejs WebGL renderer.
	 * 
	 * The renderer is created with the options specified on the object, always uses the canvas attached to the component.
	 *
	 * The user has to ensure that the old context was disposed before creating a new renderer.
	 * 
	 * @method createRenderer
	 */
	RendererCanvas.prototype.createRenderer = function()
	{
		// Create renderer
		this.renderer = this.options.createRenderer(this.canvas);

		// CSS Renderer
		if(this.useCSSRenderer)
		{
			this.cssRenderer = new CSS3DRenderer(this.cssDivision);
		}
	};

	/**
	 * Get blob with data present on this rendering canvas.
	 *
	 * If the preserveDrawingBuffer is set to false.
	 *
	 * @method getBlob
	 * @param {Function} onLoad Blob load callback.
	 * @param {string} encoding Image encoding.
	 * @param {number} quality Quality of the JPEG encoding is used.
	 */
	RendererCanvas.prototype.getBlob = function(onLoad, encoding, quality)
	{
		this.canvas.toBlob(onLoad, encoding !== undefined ? encoding : "image/jpeg", quality !== undefined ? quality : 0.7);
	};

	/**
	 * Create a new fresh context for this renderer.
	 *
	 * Deletes the canvas and creates a new one.
	 *
	 * This may be usefull to change some configurations in the renderer.
	 * 
	 * @method reloadContext
	 */
	RendererCanvas.prototype.reloadContext = function()
	{
		this.forceContextLoss();
		this.resetCanvas();
		this.createRenderer();
		this.updateSize();
	};

	/**
	 * Force the current renderer to loose context.
	 * 
	 * This is achieved by using the WEBGL_lose_context extension and may not be supported by all browsers.
	 * 
	 * @method forceContextLoss
	 */
	RendererCanvas.prototype.forceContextLoss = function()
	{
		try
		{
			if(this.renderer !== null)
			{
				this.renderer.dispose();
				this.renderer.forceContextLoss();
				this.renderer = null;
			}
		}
		catch(e)
		{
			this.renderer = null;
			console.log("nunuStudio: Failed to destroy WebGL context.");
		}
	};

	/**
	 * Resize the canvas to match the parent size and consider the device pixel ratio.
	 *
	 * @method resizeCanvas
	 */
	RendererCanvas.prototype.resizeCanvas = function()
	{
		this.resolution.copy(this.size);
		this.resolution.multiplyScalar(Editor$1.getPixelRatio());

		this.canvas.width = this.resolution.x;
		this.canvas.height = this.resolution.y;
		this.canvas.style.width = this.size.x + "px";
		this.canvas.style.height = this.size.y + "px";

		if(this.useCSSRenderer)
		{
			this.cssDivision.style.width = this.size.x + "px";
			this.cssDivision.style.height = this.size.y + "px";
		}

		if(this.onResize !== null)
		{
			this.onResize(this.resolution.x, this.resolution.y);
		}
	};

	RendererCanvas.prototype.destroy = function()
	{
		Component.prototype.destroy.call(this);

		this.forceContextLoss();
	};

	RendererCanvas.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		this.resizeCanvas();

		if(this.renderer !== null)
		{
			this.renderer.setSize(this.resolution.x, this.resolution.y, false);
		}

		if(this.useCSSRenderer)
		{
			this.cssRenderer.setSize(this.size.x, this.size.y);
		}
	};

	function DropdownList(parent)
	{
		Component.call(this, parent, "div");

		// Select
		this.select = document.createElement("select");
		this.select.style.backgroundColor = "var(--box-color)";
		this.select.style.color = "var(--color-light)";
		this.select.style.left = "0px";
		this.select.style.top = "0px";
		this.select.style.textIndent = "5px";
		this.select.style.borderStyle = "none";
		this.select.style.boxSizing = "border-box";
		this.select.style.borderRadius = "4px";
		this.select.style.outline = "none";
		this.select.style.cursor = "pointer";
		this.select.style.MozAppearance = "textfield";
		this.select.style.webkitAppearance = "caret";
		this.select.style.appearance = "textfield";
		this.element.appendChild(this.select);

		// Arrow
		this.arrow = document.createElement("img");
		this.arrow.style.display = "block";
		this.arrow.style.position = "absolute";
		this.arrow.style.pointerEvents = "none";
		this.arrow.style.right = "6px";
		this.arrow.style.width = "10px";
		this.arrow.style.height = "10px";
		this.arrow.src = Global.FILE_PATH + "icons/misc/arrow_down.png";
		this.element.appendChild(this.arrow);

		// Attributes
		this.values = [];
	}

	DropdownList.prototype = Object.create(Component.prototype);

	/**
	 * Set the disabled state of the element.
	 *
	 * @method setDisabled
	 * @param {boolean} disabled
	 */
	DropdownList.prototype.setDisabled = function(value)
	{
		this.select.disabled = value;
	};

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	DropdownList.prototype.setOnChange = function(onChange)
	{
		this.select.onchange = onChange;
	};

	/**
	 * Add option to the dropdown list.
	 *
	 * @method addValue
	 * @param {string} text Label of the option.
	 * @param {Object} value Value of the option.
	 */
	DropdownList.prototype.addValue = function(text, value)
	{
		var option = document.createElement("option");
		option.appendChild(document.createTextNode(text));
		this.values.push(value);
		this.select.appendChild(option);
	};

	/**
	 * Remove all element from dropdown
	 *
	 * @method clearValues
	 */
	DropdownList.prototype.clearValues = function()
	{
		this.values = [];
		for(var i = 0; i < this.select.children.length; i++)
		{
			this.select.removeChild(this.select.children[i]);
		}
	};

	/**
	 * Get value stored in the input element.
	 *
	 * @method setValue
	 * @return {Object} Value stored in the input element.
	 */
	DropdownList.prototype.getValue = function()
	{
		if(this.select.selectedIndex > -1)
		{
			return this.values[this.select.selectedIndex];
		}
		return null;
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setValue
	 * @param {Object} value
	 */
	DropdownList.prototype.setValue = function(value)
	{
		// Get value index
		for(var i = 0; i < this.values.length; i++)
		{
			if(this.values[i] === value)
			{
				this.select.selectedIndex = i;
				break;
			}
		}

		// If value not found set selectedIndex to -1
		if(i === this.values.length)
		{
			this.select.selectedIndex = -1;
		}
	};

	// Get dropdownlist selected index
	DropdownList.prototype.getSelectedIndex = function()
	{
		return this.select.selectedIndex;
	};

	// Set dropdownlist selected index
	DropdownList.prototype.setSelectedIndex = function(index)
	{
		this.select.selectedIndex = index;
	};

	DropdownList.prototype.updateVisibility = function()
	{
		this.element.style.visibility = this.visible ? "visible" : "hidden";
	};

	DropdownList.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		this.select.style.width = this.size.x + "px";
		this.select.style.height = this.size.y + "px";

		this.arrow.style.top = ((this.size.y - 10) / 2) + "px";
	};

	/** 
	 * The scene editor is the core of the nunuStudio editor.
	 *
	 * It is used to edit the scenes and apply changes to the objects using helper objects.
	 *
	 * @class SceneEditor
	 * @extends {TabComponent}
	 */
	function SceneEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.scene, Global.FILE_PATH + "icons/misc/scene.png");

		var self = this;

		/**
		 * Rendering canvas element where the scene is presented.
		 *
		 * @attribute canvas
		 * @type {RendererCanvas}
		 */
		this.canvas = new RendererCanvas(this, Editor$1.getRendererConfig());
		this.canvas.resetCanvas = function()
		{
			RendererCanvas.prototype.resetCanvas.call(this);

			self.transform.setCanvas(this.canvas);
			self.mouse.setCanvas(this.canvas);

			this.canvas.ondragover = Component.preventDefault;
			this.canvas.ondrop = function(event)
			{
				event.preventDefault();

				var uuid = event.dataTransfer.getData("uuid");
				var draggedObject = DragBuffer.get(uuid);

				var canvas = this;
				var rect = canvas.getBoundingClientRect();

				var position = new three.Vector2(event.clientX - rect.left, event.clientY - rect.top);
				var normalized = new three.Vector2(position.x / self.canvas.size.x * 2.0 - 1.0, -2.0 * position.y / self.canvas.size.y + 1.0);
				self.raycaster.setFromCamera(normalized, self.camera);

				var intersections = self.raycaster.intersectObjects(self.scene.children, true);

				// Auxiliar method to copy details from a object to a destination
				function copyDetails(destination, object)
				{
					destination.name = object.name;
					destination.visible = object.visible;
					destination.castShadow = object.castShadow;
					destination.receiveShadow = object.receiveShadow;
					destination.frustumCulled = object.frustumCulled;
					destination.renderOrder = object.renderOrder;
					destination.matrixAutoUpdate = object.matrixAutoUpdate;
					destination.position.copy(object.position);
					destination.scale.copy(object.scale);
					destination.quaternion.copy(object.quaternion);
				}

				// Auxiliar method to attach textures to objects
				function attachTexture(texture, object)
				{
					var material = null;
					if(object instanceof three.Mesh || object instanceof three.SkinnedMesh)
					{
						material = new three.MeshStandardMaterial({map:texture, color:0xFFFFFF, roughness: 0.6, metalness: 0.2});
						material.name = texture.name;
					}
					else if(object instanceof three.Line)
					{
						material = new three.LineBasicMaterial({color:0xFFFFFF});
						material.name = texture.name;
					}
					else if(object instanceof three.Points)
					{
						material = new three.PointsMaterial({map:texture, color:0xFFFFFF});
						material.name = texture.name;
					}
					else if(object instanceof three.Sprite)
					{
						material = new three.SpriteMaterial({map:texture, color:0xFFFFFF});
						material.name = texture.name;
					}

					Editor$1.addAction(new ActionBundle(
					[
						new AddResourceAction(material, Editor$1.program, "materials"), 
						new ChangeAction(object, "material", material)
					]));
				}

				// Dragged file
				if(event.dataTransfer.files.length > 0)
				{
					var files = event.dataTransfer.files;

					for(var i = 0; i < files.length; i++)
					{
						var file = files[i];

						// Check if mouse intersects and object
						if(intersections.length > 0)
						{
							var name = FileSystem.getFileName(file.name);
							var object = intersections[0].object;

							// Image
							if(Image.fileIsImage(file))
							{
								Loaders.loadTexture(file, function(texture)
								{
									attachTexture(texture ,object);
								});
							}
							// Video
							else if(Video.fileIsVideo(file))
							{
								Loaders.loadVideoTexture(file, function(texture)
								{
									attachTexture(texture ,object);
								});
							}
							// Font
							else if(Font.fileIsFont(file))
							{
								if(object.font !== undefined)
								{
									Loaders.loadFont(file, function(font)
									{
										object.setFont(font);
									});
								}
							}
						}
						
						// Model
						if(Model.fileIsModel(file))
						{
							Loaders.loadModel(file);
						}
					}
				}
				// Dragged resource
				else if(draggedObject !== null)
				{
					// Object intersected
					if(intersections.length > 0)
					{
						var object = intersections[0].object;

						// Material
						if(draggedObject instanceof three.Material)
						{
							// Sprite material
							if(draggedObject instanceof three.SpriteMaterial)
							{
								if(object instanceof three.Sprite)
								{
									Editor$1.addAction(new ChangeAction(object, "material", draggedObject));
								}
							}
							// Points material
							else if(draggedObject instanceof three.PointsMaterial)
							{
								if(object instanceof three.Points)
								{
									Editor$1.addAction(new ChangeAction(object, "material", draggedObject));
								}
								else if(object.geometry !== undefined)
								{
									var newObject = new three.Points(object.geometry, draggedObject);
									copyDetails(newObject, object);
									Editor$1.addAction(new SwapAction(object, newObject, true));
								}
							}
							// Line material
							else if(draggedObject instanceof three.LineBasicMaterial)
							{
								if(object instanceof three.Line)
								{
									Editor$1.addAction(new ChangeAction(object, "material", draggedObject));
								}
								else if(object.geometry !== undefined)
								{
									var newObject = new three.Line(object.geometry, draggedObject);
									copyDetails(newObject, object);
									Editor$1.addAction(new SwapAction(object, newObject, true));
								}
							}
							// Shader material
							else if(draggedObject instanceof three.ShaderMaterial)
							{
								if(object.material !== undefined)
								{
									Editor$1.addAction(new ChangeAction(object, "material", draggedObject));
								}
							}
							// Mesh material
							else
							{
								if(object instanceof three.Mesh)
								{
									Editor$1.addAction(new ChangeAction(object, "material", draggedObject));
								}
								else if(object.geometry !== undefined)
								{
									var newObject = new three.Mesh(object.geometry, draggedObject);
									copyDetails(newObject, object);
									Editor$1.addAction(new SwapAction(object, newObject, true));
								}
							}
						}
						// Cubemap
						else if(draggedObject.isCubeTexture === true)
						{
							if(object.material instanceof three.Material)
							{
								Editor$1.addAction(new ChangeAction(object.material, "envMap", draggedObject));
								self.canvas.reloadContext();
							}
						}
						// Texture
						else if(draggedObject instanceof three.Texture)
						{
							attachTexture(draggedObject, object);
						}
						// Image
						else if(draggedObject instanceof Image)
						{
							attachTexture(new three.Texture(draggedObject), object);
						}
						// Video
						else if(draggedObject instanceof Video)
						{
							attachTexture(new VideoTexture(draggedObject), object);
						}
						// Font
						else if(draggedObject instanceof Font)
						{
							if(object.font !== undefined)
							{
								object.setFont(draggedObject);
								Editor$1.updateObjectsViewsGUI();
							}
						}
						// Geometry
						else if(draggedObject instanceof three.Geometry || draggedObject instanceof three.BufferGeometry)
						{
							if(object instanceof three.Mesh || object instanceof three.Points || object instanceof three.Line)
							{
								Editor$1.addAction(new ChangeAction(object, "geometry", draggedObject));
							}
						}
					}

					// Create audio emitter
					if(draggedObject instanceof Audio)
					{
						var audio = new AudioEmitter(draggedObject);
						audio.name = draggedObject.name;
						Editor$1.addObject(audio);
					}
				}
			};
		};

		/**
		 * Keyboard input object.
		 *
		 * @attribute keyboard
		 * @type {Keyboard}
		 */
		this.keyboard = new Keyboard();

		/** 
		 * Mouse input object
		 *
		 * It is attached to the window object to capture movement outside of the tab division.
		 *
		 * @attribute mouse
		 * @type {Mouse}
		 */
		this.mouse = new Mouse(window, true);

		/** 
		 * Raycaster object used for object picking.
		 *
		 * @attribute raycaster
		 * @type {Raycaster}
		 */
		this.raycaster = new three.Raycaster();

		/**
		 * Normalized mouse coordinates for raycasting.
		 *
		 * @attribute normalized
		 * @type {Vector2}
		 */
		this.normalized = new three.Vector2();

		/**
		 * Scene being edited in this tab.
		 *
		 * Can also be a regular 3D object.
		 *
		 * @attribute scene
		 * @type {Object3D}
		 */
		this.scene = null;

		/** 
		 * The tool bar contains the selector for the transform tools and object placing icons.
		 *
		 * @attribute sideBar
		 * @type {SideBar}
		 */
		this.sideBar = new SideBar(this);
		
		/**
		 * Camera orientation cube.
		 *
		 * Used to preview the orientation of the editor camera.
		 *
		 * @attribute orientation
		 * @type {OrientationCube}
		 */
		this.orientation = new OrientationCube();

		/**
		 * Helper scene stored the object and editor preview objects.
		 *
		 * @attribute helperScene
		 * @type {Scene}
		 */
		this.helperScene = new three.Scene();
		this.helperScene.matrixAutoUpdate = false;

		/**
		 * Grid helper configured to match editor settings.
		 *
		 * @attribute gridHelper
		 * @type {GridHelper}
		 */
		this.gridHelper = new GridHelper(Editor$1.settings.editor.gridSize, Editor$1.settings.editor.gridSpacing, 0x888888);
		this.gridHelper.visible = Editor$1.settings.editor.gridEnabled;
		this.helperScene.add(this.gridHelper);

		/**
		 * Axes helper configured to match editor settings.
		 *
		 * @attribute axisHelper
		 * @type {AxesHelper}
		 */
		this.axisHelper = new three.AxesHelper(Editor$1.settings.editor.gridSize);
		this.axisHelper.material.depthWrite = false;
		this.axisHelper.material.transparent = true;
		this.axisHelper.material.opacity = 1.0;
		this.axisHelper.visible = Editor$1.settings.editor.axisEnabled;
		this.helperScene.add(this.axisHelper);

		/**
		 * Object helper container.
		 *
		 * @attribute objectHelper
		 * @type {Group}
		 */
		this.objectHelper = new three.Group();
		this.objectHelper.matrixAutoUpdate = true;
		this.helperScene.add(this.objectHelper);

		/**
		 * Group where the object manipulation tools are drawn
		 *
		 * @attribute toolScene
		 * @type {Scene}
		 */
		this.toolScene = new three.Scene();
		this.toolScene.matrixAutoUpdate = false;

		/**
		 * Editor manipulation mode.
		 *
		 * @attribute mode
		 * @type {number}
		 */
		this.mode = SceneEditor.SELECT;

		/** 
		 * Transform controls tool.
		 *
		 * @attribute transform
		 * @type {TransformControls}
		 */
		this.transform = new TransformControls(this.camera, null, this.mouse);
		this.transform.visible = false;
		this.toolScene.add(this.transform);

		/**
		 * Camera object used to visualize the scene.
		 *
		 * This object is attached to the scene as the defaultCamera, allowing it to be used for runtime when there is no default camera.
		 *
		 * Can be a an OrthographicCamera or PerspectiveCamera dependeing on the cameraMode value.
		 *
		 * @attribute camera
		 * @type {Camera}
		 */
		this.camera = null;
		
		/** 
		 * Camera controls object used to manipulate the camera position.
		 *
		 * Can be EditorFreeControls, EditorOrbitControls or EditorPlanarControls.
		 *
		 * @attribute controls
		 * @type {Group}
		 */
		this.controls = null;
		this.controlsMode = -1;
		this.setCameraMode(SceneEditor.PERSPECTIVE);

		/**
		 * Transformation controls mode can be local or world.
		 *
		 * @attribute transformationSpace
		 * @type {DropdownList}
		 */
		this.transformationSpace = new DropdownList(this);
		this.transformationSpace.size.set(60, 30);
		this.transformationSpace.position.set(145, 5);
		this.transformationSpace.updatePosition(Component.BOTTOM_RIGHT);
		this.transformationSpace.updateSize();
		this.transformationSpace.addValue(Locale.local, TransformControls.LOCAL);
		this.transformationSpace.addValue(Locale.world, TransformControls.WORLD);
		this.transformationSpace.element.style.opacity = 0.5;
		this.transformationSpace.setOnChange(function()
		{
			var space = self.transformationSpace.getValue();
			Editor$1.settings.editor.transformationSpace = space;
			self.transform.space = space;
		});
		this.transformationSpace.element.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};
		this.transformationSpace.element.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};

		/**
		 * Dropdown to select the world navigation mode to use.
		 *
		 * @attribute navigation
		 * @type {DropdownList}
		 */
		this.navigation = new DropdownList(this);
		this.navigation.setAltText(Locale.cameraNavigation);
		this.navigation.size.set(100, 30);
		this.navigation.position.set(40, 5);
		this.navigation.updatePosition(Component.BOTTOM_RIGHT);
		this.navigation.updateSize();
		this.navigation.addValue(Locale.firstPerson, Settings.FIRST_PERSON);
		this.navigation.addValue(Locale.orbit, Settings.ORBIT);
		this.navigation.addValue(Locale.left, Settings.PLANAR_LEFT);
		this.navigation.addValue(Locale.right, Settings.PLANAR_RIGHT);
		this.navigation.addValue(Locale.front, Settings.PLANAR_FRONT);
		this.navigation.addValue(Locale.back, Settings.PLANAR_BACK);
		this.navigation.addValue(Locale.top, Settings.PLANAR_TOP);
		this.navigation.addValue(Locale.bottom, Settings.PLANAR_BOTTOM);
		this.navigation.element.style.opacity = 0.5;
		this.navigation.setOnChange(function()
		{
			Editor$1.settings.editor.navigation = self.navigation.getValue();
			self.updateCameraControls(Editor$1.settings.editor.navigation);
		});
		this.navigation.element.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};
		this.navigation.element.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};

		/**
		 * Button to toggle snap to grid functionality
		 *
		 * @method snapGridButton
		 * @type {ButtonIcon}
		 */
		this.snapGridButton = new ButtonIcon(this);
		this.snapGridButton.position.set(5, 40);
		this.snapGridButton.size.set(30, 30);
		this.snapGridButton.setImage(Global.FILE_PATH + "icons/misc/" + (Editor$1.settings.editor.snap ? "grid" : "freemove") + ".png");
		this.snapGridButton.setAltText(Locale.toggleSnapToGrid);
		this.snapGridButton.setImageScale(0.8, 0.8);
		this.snapGridButton.updateSize();
		this.snapGridButton.updatePosition(Component.BOTTOM_RIGHT);
		this.snapGridButton.element.style.backgroundColor = "var(--panel-color)";
		this.snapGridButton.element.style.borderRadius = "5px";
		this.snapGridButton.element.style.opacity = 0.5;
		this.snapGridButton.element.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};
		this.snapGridButton.element.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};
		this.snapGridButton.setOnClick(function()
		{
			Editor$1.settings.editor.snap = !Editor$1.settings.editor.snap;
			self.transform.snap = Editor$1.settings.editor.snap;

			self.snapGridButton.setImage(Global.FILE_PATH + "icons/misc/" + (Editor$1.settings.editor.snap ? "grid" : "freemove") + ".png");
		});

		/**
		 * Button to toggle the camera mode between ORTHOGRAPHIC and PERSPECTIVE.
		 *
		 * @method cameraButton
		 * @type {ButtonIcon}
		 */
		this.cameraButton = new ButtonIcon(this);
		this.cameraButton.position.set(5, 5);
		this.cameraButton.size.set(30, 30);
		this.cameraButton.setImage(Global.FILE_PATH + "icons/misc/3d.png");
		this.cameraButton.setAltText(Locale.cameraMode);
		this.cameraButton.setImageScale(0.8, 0.8);
		this.cameraButton.updateSize();
		this.cameraButton.updatePosition(Component.BOTTOM_RIGHT);
		this.cameraButton.element.style.backgroundColor = "var(--panel-color)";
		this.cameraButton.element.style.borderRadius = "5px";
		this.cameraButton.element.style.opacity = 0.5;
		this.cameraButton.element.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};
		this.cameraButton.element.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};
		this.cameraButton.setOnClick(function()
		{
			self.setCameraMode();

			if(self.cameraMode === SceneEditor.ORTHOGRAPHIC)
			{
				self.cameraButton.setImage(Global.FILE_PATH + "icons/misc/2d.png");
			}
			else if(self.cameraMode === SceneEditor.PERSPECTIVE)
			{
				self.cameraButton.setImage(Global.FILE_PATH + "icons/misc/3d.png");
			}
		});

		/**
		 * The editor tool bar is used to select tool used to manipulate objects.
		 *
		 * @attribute toolBar
		 * @type {ToolBar}
		 */
		this.toolBar = new ToolBar(this);
		this.toolBar.setMode(Component.BOTTOM_LEFT);

		/**
		 * Event manager to handley keyboard shortcuts.
		 *
		 * @attribute manager
		 * @type {EventManager}
		 */
		this.manager = new EventManager();
		this.manager.add(document.body, "keydown", function(event)
		{
			var key = event.keyCode;

			if(event.ctrlKey)
			{
				if(self.container.focused)
				{
					if(key === Keyboard.NUM1)
					{
						self.selectTool(SceneEditor.SELECT);
					}
					else if(key === Keyboard.NUM2)
					{
						self.selectTool(SceneEditor.MOVE);
					}
					else if(key === Keyboard.NUM3)
					{
						self.selectTool(SceneEditor.SCALE);
					}
					else if(key === Keyboard.NUM4)
					{
						self.selectTool(SceneEditor.ROTATE);
					}
					else if(key === Keyboard.F)
					{
						self.focusObject();
					}
					else if(key === Keyboard.C)
					{
						Editor$1.copyObject();
					}
					else if(key === Keyboard.V)
					{
						Editor$1.pasteObject();
					}
					else if(key === Keyboard.X)
					{
						Editor$1.cutObject();
					}
				}
			}
		});

		this.canvas.resetCanvas();
	}

	SceneEditor.ORTHOGRAPHIC = 20;
	SceneEditor.PERSPECTIVE = 21;

	SceneEditor.SELECT = 0;
	SceneEditor.MOVE = 100;
	SceneEditor.SCALE = 101;
	SceneEditor.ROTATE = 102;

	SceneEditor.prototype = Object.create(TabComponent.prototype);

	SceneEditor.prototype.createRenderer = RendererCanvas.prototype.createRenderer;
	SceneEditor.prototype.reloadContext = RendererCanvas.prototype.reloadContext;
	SceneEditor.prototype.forceContextLoss = RendererCanvas.prototype.forceContextLoss;

	SceneEditor.prototype.updateMetadata = function()
	{
		if(this.scene !== null)
		{
			this.setName(this.scene.name);

			// Check if object has a parent
			if(this.scene.parent === null)
			{
				this.close();
				return;
			}

			// Check if object exists in parent
			var children = this.scene.parent.children;
			for(var i = 0; i < children.length; i++)
			{
				if(this.scene.uuid === children[i].uuid)
				{
					return;
				}
			}

			// If not found close tab
			if(i >= children.length)
			{
				this.close();
			}
		}
	};

	SceneEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);

		this.canvas.createRenderer();
		this.updateSettings();

		this.mouse.setLock(false);

		this.mouse.create();
		this.manager.create();

		this.selectTool(SceneEditor.SELECT);
	};

	SceneEditor.prototype.deactivate = function()
	{
		TabComponent.prototype.deactivate.call(this);

		this.mouse.dispose();
		this.manager.destroy();
	};

	/**
	 * Update camera controller object.
	 * 
	 * Select a new controls object based on the mode passed as argument and attach the editor camera to it.
	 *
	 * @method updateCameraControls
	 * @param {number} mode Camera mode.
	 */
	SceneEditor.prototype.updateCameraControls = function(mode)
	{
		if(this.controlsMode === mode)
		{
			return;
		}
		
		this.controlsMode = mode;

		if(mode === Settings.FIRST_PERSON)
		{
			this.controls = new EditorFreeControls();
		}
		else if(mode === Settings.ORBIT)
		{
			this.controls = new EditorOrbitControls();
		}
		else
		{
			this.controls = new EditorPlanarControls(mode);
		}

		this.controls.attach(this.camera);
	};

	SceneEditor.prototype.updateSettings = function()
	{
		// Grid
		this.gridHelper.visible = Editor$1.settings.editor.gridEnabled;
		this.gridHelper.setSize(Editor$1.settings.editor.gridSize);
		this.gridHelper.setSpacing(Editor$1.settings.editor.gridSpacing);
		this.gridHelper.update();

		// Axis
		this.axisHelper.visible = Editor$1.settings.editor.axisEnabled;

		// Orientation
		var size = Editor$1.settings.editor.cameraRotationCubeSize;
		this.orientation.viewport.size.set(size, size);

		// Controls
		this.navigation.setValue(Editor$1.settings.editor.navigation);
		this.updateCameraControls(Editor$1.settings.editor.navigation);

		// Tool
		this.transformationSpace.setValue(Editor$1.settings.editor.transformationSpace);
		this.transform.space = Editor$1.settings.editor.transformationSpace;
		this.transform.snap = Editor$1.settings.editor.snap;
		this.transform.translationSnap = Editor$1.settings.editor.gridSpacing;
		this.transform.rotationSnap = Editor$1.settings.editor.snapAngle;
	};

	SceneEditor.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);

		this.mouse.dispose();
		this.keyboard.dispose();
		this.transform.dispose();

		this.mouse.setLock(false);

		this.canvas.forceContextLoss();
	};

	SceneEditor.prototype.attach = function(scene)
	{
		this.scene = scene;
		this.updateMetadata();

		if(this.camera !== null)
		{
			this.scene.defaultCamera = this.camera;
		}
	};

	/**
	 * Check if a scene or object is attached to the editor.
	 *
	 * @method isAttached
	 * @param {Object3D} scene
	 */
	SceneEditor.prototype.isAttached = function(scene)
	{
		return this.scene === scene;
	};

	/**
	 * Focus the first currently selected object, if there is one.
	 *
	 * @method focusObject
	 */
	SceneEditor.prototype.focusObject = function()
	{
		if(Editor$1.selection.length > 0 && Editor$1.selection[0].isObject3D === true)
		{
			this.controls.focusObject(Editor$1.selection[0]);
		}
		else
		{
			Editor$1.alert(Locale.selectObjectFirst);
		}
	};

	/**
	 * Update scene editor logic.
	 *
	 * @method update
	 */
	SceneEditor.prototype.update = function()
	{
		this.mouse.update();
		this.keyboard.update();

		var isEditingObject = this.transform.update();

		// Check if mouse is inside canvas
		if(this.mouse.insideCanvas())
		{
			// Update selection
			if(this.mode === SceneEditor.SELECT)
			{
				if(this.mouse.buttonJustPressed(Mouse.LEFT))
				{
					this.selectObjectWithMouse();
				}
			}
			else
			{
				// If mouse double clicked select object
				if(this.mouse.buttonDoubleClicked(Mouse.LEFT))
				{
					this.selectObjectWithMouse();
				}	
			}

			// Lock mouse when camera is moving
			if(Editor$1.settings.editor.lockMouse && Nunu.runningOnDesktop())
			{
				if(!isEditingObject && (this.mouse.buttonJustPressed(Mouse.LEFT) || this.mouse.buttonJustPressed(Mouse.RIGHT) || this.mouse.buttonJustPressed(Mouse.MIDDLE)))
				{
					this.mouse.setLock(true);
				}
				else if(this.mouse.buttonJustReleased(Mouse.LEFT) || this.mouse.buttonJustReleased(Mouse.RIGHT) || this.mouse.buttonJustReleased(Mouse.MIDDLE))
				{
					this.mouse.setLock(false);
				}
			}

			if(isEditingObject)
			{
				Editor$1.gui.inspector.updateValues();
			}
			else
			{
				// Update controls
				this.controls.update(this.mouse, this.keyboard);

				// Update grid helper position
				this.gridHelper.position.x = this.controls.position.x - (this.controls.position.x % Editor$1.settings.editor.gridSpacing);
				this.gridHelper.position.z = this.controls.position.z - (this.controls.position.z % Editor$1.settings.editor.gridSpacing);
			}
		}

		// If has objects selected
		if(Editor$1.hasObjectSelected())
		{
			// Update object transformation matrix
			for(var i = 0; i < Editor$1.selection.length; i++)
			{
				if(Editor$1.selection[i].matrixAutoUpdate === false)
				{
					Editor$1.selection[i].updateMatrix();
				}
			}
			
			// Update object helper
			this.objectHelper.traverse(function(children)
			{
				children.update();	
			});
		}

		this.render();

	};

	/**
	 * Render all the editor scenes to the canvas using the renderer.
	 *
	 * Draws the attached scene/object after that it renders the helpers and tool scenes, the overlay orientation cube and then the camera previews.
	 * 
	 * @method render
	 */
	SceneEditor.prototype.render = function()
	{
		if(this.canvas.renderer === null)
		{
			console.warn("nunuStudio: SceneEditor renderer is null.", this);
			return;
		}

		var width = this.canvas.resolution.x;
		var height = this.canvas.resolution.y;
		var canvas = this.canvas.canvas;
		var renderer = this.canvas.renderer;

		renderer.autoClear = false;
		renderer.setViewport(0, 0, width, height);
		renderer.setScissor(0, 0, width, height);

		// Clear with scene background
		renderer.setClearColor(this.scene.background);
		renderer.clear(true, true, true);

		// Render scene
		renderer.render(this.scene, this.camera);

		if(this.canvas.cssRenderer !== null)
		{
			this.canvas.cssRenderer.render(this.scene, this.camera);
		}

		renderer.render(this.helperScene, this.camera);
		renderer.render(this.toolScene, this.camera);

		// Draw camera cube
		if(Editor$1.settings.editor.cameraRotationCube)
		{
			var code = this.orientation.raycast(this.mouse, canvas);
			
			if(code !== null && (this.mouse.buttonDoubleClicked(Mouse.LEFT) || this.mouse.buttonJustPressed(Mouse.MIDDLE)))
			{
				this.controls.setOrientation(code);
			}

			renderer.clear(false, true, false);
			this.orientation.updateRotation(this.controls);
			this.orientation.render(renderer, canvas);
		}

		// Camera preview
		if(Editor$1.settings.editor.cameraPreviewEnabled)
		{
			renderer.setScissorTest(true);

			var previewRatio = 16.0 / 9.0;

			var viewport = new Viewport();
			viewport.width = width;
			viewport.height = height;
			viewport.offset = new three.Vector2(10, 10);
			viewport.size = new three.Vector2(Editor$1.settings.editor.cameraPreviewSize * previewRatio, Editor$1.settings.editor.cameraPreviewSize);
			viewport.anchor = Editor$1.settings.editor.cameraPreviewPosition;
			viewport.mode = Viewport.ABSOLUTE;
			viewport.update();
			viewport.enable(renderer);

			// Preview camera
			if(Editor$1.selection[0] instanceof PerspectiveCamera || Editor$1.selection[0] instanceof OrthographicCamera)
			{
				renderer.clear(true, true, true);

				var camera = Editor$1.selection[0];
				camera.resize(width, height, viewport);
				camera.setupRenderer(renderer);
				camera.render(renderer, this.scene);
			}
			// Preview cube camera
			else if(Editor$1.selection[0] instanceof CubeCamera)
			{
				var cameras = Editor$1.selection[0].cameras;
				var self = this;

				function renderCamera(index, x, y, w, h)
				{
					renderer.setViewport(x, y, w, h);
					renderer.setScissor(x, y, w, h);
					renderer.clear(true, true, true);

					cameras[index].updateMatrixWorld();
					cameras[index].render(renderer, self.scene);
				}

				// Change viewport to 4:3 ratio
				viewport.size = new three.Vector2(Editor$1.settings.editor.cameraPreviewSize * (4.0 / 3.0), Editor$1.settings.editor.cameraPreviewSize);			viewport.update();

				var size = viewport.viewport.w / 3;
				var x = viewport.viewport.x;
				var y = viewport.viewport.y;

				renderCamera(CubeTexture.LEFT, x, y + size, size, size);
				renderCamera(CubeTexture.FRONT, x + size, y + size, size, size);
				renderCamera(CubeTexture.RIGHT, x + size * 2, y + size, size, size);
				renderCamera(CubeTexture.BACK, x + size * 3, y + size, size, size);
				renderCamera(CubeTexture.TOP, x + size, y, size, size);
				renderCamera(CubeTexture.BOTTOM, x + size, y + size * 2, size, size);
			}
			// Preview all cameras in use
			else if(this.scene.cameras !== undefined && this.scene.cameras.length > 0)
			{
				renderer.clear(true, true, true);

				for(var i = 0; i < this.scene.cameras.length; i++)
				{
					var camera = this.scene.cameras[i];
					camera.resize(width, height, viewport);
					camera.setupRenderer(renderer);
					camera.render(renderer, this.scene);
				}
			}
		}

		renderer.setScissorTest(false);
	};

	/**
	 * Update raycaster position from editor mouse position.
	 *
	 * @method updateRaycasterFromMouse
	 */
	SceneEditor.prototype.updateRaycasterFromMouse = function()
	{
		this.normalized.set((this.mouse.position.x / this.canvas.size.x) * 2 - 1, -(this.mouse.position.y / this.canvas.size.y) * 2 + 1);
		this.raycaster.setFromCamera(this.normalized, this.camera);
	};

	/**
	 * Select objects mouse based on the mouse position.
	 *
	 * @method selectObjectWithMouse
	 */
	SceneEditor.prototype.selectObjectWithMouse = function()
	{
		this.updateRaycasterFromMouse();

		var intersects = this.raycaster.intersectObjects(this.scene.children, true);

		if(intersects.length > 0)
		{	
			if(this.keyboard.keyPressed(Keyboard.CTRL))
			{	
				if(Editor$1.isSelected(intersects[0].object))
				{
					Editor$1.unselectObject(intersects[0].object);
				}
				else
				{
					Editor$1.addToSelection(intersects[0].object);
				}
			}
			else
			{
				Editor$1.selectObject(intersects[0].object);
			}
		}
	};

	/**
	 * Update raycaster with new x and y positions (normalized -1 to 1).
	 *
	 * @method updateRaycaster
	 * @param {number} x
	 * @param {number} y
	 */
	SceneEditor.prototype.updateRaycaster = function(x, y)
	{
		this.normalized.set(x, y);
		this.raycaster.setFromCamera(this.normalized, this.camera);
	};

	/**
	 * Set the editor camera projection mode (ortographic or perspective).
	 *
	 * @method setCameraMode
	 * @param {number} mode
	 */
	SceneEditor.prototype.setCameraMode = function(mode)
	{
		if(mode === this.cameraMode)
		{
			return;
		}

		if(mode === undefined)
		{
			mode = (this.cameraMode === SceneEditor.PERSPECTIVE) ? SceneEditor.ORTHOGRAPHIC : SceneEditor.PERSPECTIVE;
		}
		
		this.cameraMode = mode;

		var aspect = (this.canvas !== null) ? (this.canvas.size.x / this.canvas.size.y) : 1.0;

		if(this.cameraMode === SceneEditor.ORTHOGRAPHIC)
		{
			this.camera = new OrthographicCamera(10, aspect, OrthographicCamera.RESIZE_HORIZONTAL);
		}
		else if(this.cameraMode === SceneEditor.PERSPECTIVE)
		{
			this.camera = new PerspectiveCamera(60, aspect);
		}

		if(this.scene !== null)
		{
			this.scene.defaultCamera = this.camera;
		}

		this.transform.camera = this.camera;

		if(this.controls !== null)
		{
			this.controls.attach(this.camera);
			this.controls.reset();
		}
	};

	/**
	 * Select transform tool, possible values are:
	 * - SceneEditor.MOVE
	 * - SceneEditor.SCALE
	 * - SceneEditor.ROTATE
	 *
	 * @param selectTool
	 * @param {number} tool Tool to select.
	 */
	SceneEditor.prototype.selectTool = function(tool)
	{	
		if(tool !== undefined)
		{
			this.mode = tool;
		}

		if(this.mode === SceneEditor.MOVE)
		{
			this.transform.setMode(TransformControls.TRANSLATE);
			this.transform.space = Editor$1.settings.editor.transformationSpace;
		}
		else if(this.mode === SceneEditor.SCALE)
		{
			this.transform.setMode(TransformControls.SCALE);
		}
		else if(this.mode === SceneEditor.ROTATE)
		{
			this.transform.setMode(TransformControls.ROTATE);
			this.transform.space = Editor$1.settings.editor.transformationSpace;
		}
		else if(this.mode === SceneEditor.SELECT)
		{
			this.transform.setMode(TransformControls.NONE);
		}

		this.toolBar.selectTool(tool);
	};

	/**
	 * Update the selection status of the tab.
	 *
	 * Select the adequate helper to debug selected objects and attach the objects to the transform tools.
	 *
	 * @method updateSelection
	 */
	SceneEditor.prototype.updateSelection = function()
	{
		// Filter Object3D objects only (to exclude resources)
		var selectedObjects = [];
		for(var i = 0; i < Editor$1.selection.length; i++)
		{
			if(Editor$1.selection[i].isObject3D === true)
			{
				selectedObjects.push(Editor$1.selection[i]);
			}
		}

		this.transform.attach(selectedObjects);
		this.objectHelper.removeAll();

		for(var i = 0; i < selectedObjects.length; i++)
		{
			var object = selectedObjects[i];

			// Camera
			if(object instanceof three.Camera)
			{
				this.objectHelper.add(new three.CameraHelper(object));
				this.objectHelper.add(new ObjectIconHelper(object, Global.FILE_PATH + "icons/camera/camera.png"));
			}
			// Light
			else if(object instanceof three.Light)
			{
				// Directional light
				if(object instanceof three.DirectionalLight)
				{
					this.objectHelper.add(new three.DirectionalLightHelper(object, 1));
				}
				// Light probe
				else if(object instanceof three.LightProbe)
				{
					this.objectHelper.add(new LightProbeHelper(object, 2));
				}
				// Point light
				else if(object instanceof three.PointLight)
				{
					this.objectHelper.add(new three.PointLightHelper(object, 1));
				}
				// RectArea light
				else if(object instanceof three.RectAreaLight)
				{
					this.objectHelper.add(new RectAreaLightHelper(object));
				}
				// Spot light
				else if(object instanceof three.SpotLight)
				{
					this.objectHelper.add(new three.SpotLightHelper(object));
				}
				// Hemisphere light
				else if(object instanceof three.HemisphereLight)
				{
					this.objectHelper.add(new three.HemisphereLightHelper(object, 1));
				}
				// Ambient light
				else
				{
					this.objectHelper.add(new ObjectIconHelper(object, ObjectIcons.get(object.type)));
				}
			}
			// Physics
			else if(object instanceof PhysicsObject)
			{
				this.objectHelper.add(new PhysicsObjectHelper(object));
			}
			// LensFlare
			else if(object instanceof LensFlare)
			{
				this.objectHelper.add(new ObjectIconHelper(object, ObjectIcons.get(object.type)));
			}
			// Skinned Mesh
			else if(object instanceof three.SkinnedMesh)
			{
				this.objectHelper.add(new SkeletonHelper(object.parent));
				this.objectHelper.add(new WireframeHelper(object, 0xFFFF00));
			}
			// Bone
			else if(object instanceof three.Bone)
			{
				this.objectHelper.add(new SkeletonHelper(object.parent));
				this.objectHelper.add(new ObjectIconHelper(object, ObjectIcons.get(object.type)));
			}
			// Mesh
			else if(object instanceof three.Mesh)
			{
				this.objectHelper.add(new WireframeHelper(object, 0xFFFF00));
			}
			// Line
			else if(object instanceof three.Line)
			{
				this.objectHelper.add(new LineHelper(object, 0xFFFF00));
			}
			// Points
			else if(object instanceof three.Points)
			{
				this.objectHelper.add(new PointsHelper(object, 0xFFFF00));
			}
			// Spine animation
			else if(object instanceof SpineAnimation)
			{
				this.objectHelper.add(new ObjectIconHelper(object, ObjectIcons.get(object.type)));
			}
			// Container
			else if(object instanceof Container)
			{
				this.objectHelper.add(new three.BoxHelper(object, 0xFFFF00));
				this.objectHelper.add(new ObjectIconHelper(object, ObjectIcons.get(object.type)));
			}
			// Object 3D
			else
			{
				this.objectHelper.add(new ObjectIconHelper(object, ObjectIcons.get(object.type)));
			}
		}
	};

	SceneEditor.prototype.updateVisibility = function()
	{
		TabComponent.prototype.updateVisibility.call(this);
	};

	SceneEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.sideBar.position.set(0, 0);
		this.sideBar.size.set(40, this.size.y);
		this.sideBar.updateInterface();

		this.toolBar.position.set(this.size.x / 2 - this.toolBar.size.x / 2, 5);
		this.toolBar.updateInterface();

		var width = this.size.x - this.sideBar.size.x;
		var height = this.size.y;

		this.canvas.position.set(this.sideBar.size.x, 0);
		this.canvas.size.set(width, height);
		this.canvas.updateInterface();

		if(this.camera !== null)
		{
			this.camera.aspect = width / height;
			this.camera.updateProjectionMatrix();
		}
	};

	/**
	 * Contains an action and a callback function called when the action is applied or reverted.
	 *
	 * The callback method is called after the action has been applied.
	 *
	 * @class CallbackAction
	 * @param {Action} action Base action.
	 * @param {Function} callback Callback function.
	 */
	function CallbackAction(action, callback)
	{
		Action.call(this);

		this.action = action;
		this.callback = callback;
	}

	CallbackAction.prototype.apply = function()
	{
		this.action.apply();
		this.callback();
	};

	CallbackAction.prototype.revert = function()
	{
		this.action.revert();
		this.callback();
	};

	/**
	 * Table form element automatically organizes element into a grid like form.
	 * 
	 * @class TableForm
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function TableForm(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";
		
		/**
		 * Set if the form needs to be automatically resized.
		 *
		 * @property autoSize
		 * @type {boolean}
		 */
		this.autoSize = true;

		/**
		 * Resize the last element of the rows to fit the size of the container.
		 *
		 * @method fitElements
		 * @type {boolean}
		 */
		this.fitElements = true;

		/**
		 * Spacing between elements and rows.
		 *
		 * @property spacing
		 * @type {Vector2}
		 */
		this.spacing = new three.Vector2(5, 5);

		/**
		 * Default text width.
		 *
		 * @property defaultTextWidth
		 * @type {number}
		 */
		this.defaultTextWidth = 80;

		/**
		 * Rows of this form table.
		 *
		 * @property rows
		 * @type {Array}
		 */
		this.rows = [];
		this.rows.push([]);
	}

	TableForm.prototype = Object.create(Component.prototype);

	/**
	 * Set if the form should be automatically resized, and ajust overflow value.
	 *
	 * @method setAutoSize
	 * @param {boolean} autoSize
	 */
	TableForm.prototype.setAutoSize = function(autoSize)
	{
		this.autoSize = autoSize;
		this.element.style.overflow = autoSize ? "visible" : "auto";
	};

	/**
	 * Add a element to form (in actual row).
	 *
	 * @method add
	 */
	TableForm.prototype.add = function(element)
	{
		if(this.rows.length > 0)
		{
			this.rows[this.rows.length - 1].push(element);
			element.attachTo(this);
		}
	};

	/**
	 * Create text element.
	 *
	 * @method addText
	 */
	TableForm.prototype.addText = function(text, fit)
	{
		var element = new Text(this);
		element.setAlignment(Text.LEFT);
		element.setText(text);
		element.size.set(this.defaultTextWidth, 20);
		
		if(fit === true)
		{
			element.fitContent = true;
		}
		else
		{
			element.setOverflow(Text.ELLIPSIS);
		}

		this.add(element);

		return element;
	};

	/**
	 * Create division.
	 *
	 * @method addDivision
	 */
	TableForm.prototype.addDivision = function(x, y)
	{
		var division = new Division(this);
		division.size.set(x, y);
		this.add(division);

		return division;
	};

	/**
	 * Add new row to form.
	 *
	 * @method nextRow
	 */
	TableForm.prototype.nextRow = function()
	{
		this.rows.push([]);
	};

	/**
	 * Remove last row from form.
	 *
	 * @method removeLastRow
	 */
	TableForm.prototype.removeLastRow = function()
	{
		if(this.rows.length > 0)
		{
			var row = this.rows.pop();

			for(var i = 0; i < row.length; i++)
			{
				row[i].destroy();
			}
		}
	};

	/**
	 * Clear all elements from form.
	 *
	 * @method removeAll
	 */
	TableForm.prototype.removeAll = function()
	{
		for(var i = 0; i < this.rows.length; i++)
		{
			for(var j = 0; j < this.rows[i].length; j++)
			{
				this.rows[i][j].destroy();
			}
		}

		this.rows = [];
		this.rows.push([]);
	};

	TableForm.prototype.updateSize = function()
	{
		var x = 0, y = 0;
		var sizeX = 0;

		if(!this.autoSize)
		{
			x = this.spacing.x;
			y = this.spacing.y;
		}

		for(var i = 0; i < this.rows.length; i++)
		{
			var maxSizeY = 0;

			for(var j = 0; j < this.rows[i].length; j++)
			{
				var element = this.rows[i][j];
				
				if(element.visible)
				{
					// Resize last element
					if(this.fitElements && j === this.rows[i].length - 1)
					{
						element.size.x = this.size.x - x - 15;
					}

					element.position.set(x, y);
					element.updateInterface();

					// Size tracker
					if(element.size.y > maxSizeY)
					{
						maxSizeY = element.size.y;
					}

					x += element.size.x + this.spacing.x;
				}
			}

			// Form size x
			if(sizeX < x)
			{
				sizeX = x;
			}

			// Update position tracker
			if(x !== 0)
			{
				x = this.autoSize ? 0 : this.spacing.x;
				y += maxSizeY + this.spacing.y;
			}
		}

		if(this.autoSize)
		{
			this.size.set(sizeX, y);
		}

		Component.prototype.updateSize.call(this);
	};

	/**
	 * The vector box is used to represent Vector2, Vector3, Vector4 and Euler values.
	 *
	 * @class VectorBox
	 * @extends {Component}
	 */
	function VectorBox(parent)
	{
		Component.call(this, parent, "div");

		/**
		 * Indicates if the number box is storing a angle value.
		 *
		 * @attribute isAngle
		 * @type {boolean}
		 */
		this.isAngle = false;

		// X Text
		this.xText = document.createElement("div");
		this.xText.style.position = "absolute";
		this.xText.style.width = "15px";
		this.xText.style.textAlign = "center";
		this.xText.style.verticalAlign = "middle";
		this.xText.appendChild(document.createTextNode("X"));
		this.element.appendChild(this.xText);

		function createInput()
		{
			var input = document.createElement("input");
			input.type = "number";
			input.style.backgroundColor = "var(--box-color)";
			input.style.color = "var(--color-light)";
			input.style.borderStyle = "none";
			input.style.position = "absolute";
			input.style.boxSizing = "border-box";
			input.style.textIndent = "4px";
			input.style.borderRadius = "4px";
			input.style.outline = "none";
			input.style.MozAppearance = "textfield";
			input.style.webkitAppearance = "caret";
			input.style.appearance = "textfield";
			return input;
		}

		// X
		this.x = createInput();
		this.x.style.left = "15px";
		this.element.appendChild(this.x);

		// Y Text
		this.yText = document.createElement("div");
		this.yText.style.position = "absolute";
		this.yText.style.width = "15px";
		this.yText.style.textAlign = "center";
		this.yText.style.verticalAlign = "middle";
		this.yText.appendChild(document.createTextNode("Y"));
		this.element.appendChild(this.yText);

		// Y
		this.y = createInput();
		this.element.appendChild(this.y);

		// Z Text
		this.zText = document.createElement("div");
		this.zText.style.position = "absolute";
		this.zText.style.width = "15px";
		this.zText.style.textAlign = "center";
		this.zText.style.verticalAlign = "middle";
		this.zText.appendChild(document.createTextNode("Z"));
		this.element.appendChild(this.zText);

		// Z
		this.z = createInput();
		this.element.appendChild(this.z);

		// W Text
		this.wText = document.createElement("div");
		this.wText.style.position = "absolute";
		this.wText.style.width = "15px";
		this.wText.style.textAlign = "center";
		this.wText.style.verticalAlign = "middle";
		this.wText.appendChild(document.createTextNode("W"));
		this.element.appendChild(this.wText);

		// W
		this.w = createInput();
		this.element.appendChild(this.w);

		// Order
		this.order = "XYZ";
		this.type = VectorBox.VECTOR3;
	}

	VectorBox.VECTOR2 = 2;
	VectorBox.VECTOR3 = 3;
	VectorBox.QUATERNION = 4;

	VectorBox.prototype = Object.create(Component.prototype);

	/**
	 * Set the type of box, (type of data to use).
	 *  - VectorBox.VECTOR2
	 *  - VectorBox.VECTOR3
	 *  - VectorBox.QUATERNION
	 *
	 * @method setType
	 * @param {number} type
	 */
	VectorBox.prototype.setType = function(type)
	{
		if(this.type !== type)
		{
			this.type = type;
			this.updateInterface();
		}
	};

	/**
	 * Set the values step.
	 *
	 * @method setStep
	 * @param {number} value
	 */
	VectorBox.prototype.setStep = function(value)
	{
		var value = String(value);
		this.x.step = value;
		this.y.step = value;
		this.z.step = value;
		this.w.step = value;
	};

	/**
	 * Set the values range
	 *
	 * @method setRange
	 * @param {number} min
	 * @param {number} max
	 */
	VectorBox.prototype.setRange = function(min, max)
	{
	 	var min = String(min);
	 	var max = String(max);
		this.x.min = min;
		this.x.max = max;
		this.y.min = min;
		this.y.max = max;
		this.z.min = min;
		this.z.max = max;
		this.w.min = min;
		this.w.max = max;	
	};

	/**
	 * Get a value from the box.
	 *
	 * @method getValue
	 * @return {Object} Value stored.
	 */
	VectorBox.prototype.getValue = function()
	{
		var value = {x: parseFloat(this.x.value), y: parseFloat(this.y.value), z: parseFloat(this.z.value), w: parseFloat(this.w.value), order: this.order};

		if(this.isAngle)
		{
			value.x = UnitConverter.convert(value.x, Editor$1.settings.units.angle, "r");
			value.y = UnitConverter.convert(value.y, Editor$1.settings.units.angle, "r");
			value.z = UnitConverter.convert(value.z, Editor$1.settings.units.angle, "r");
			value.w = UnitConverter.convert(value.w, Editor$1.settings.units.angle, "r");
		}

		return value;
	};

	/**
	 * Set value to the vector box.
	 *
	 * @method setValue
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 * @param {number} w
	 * @param {Object} value Value
	 */
	VectorBox.prototype.setValue = function(x, y, z, w)
	{
		if(x.isVector2)
		{
			if(this.isAngle)
			{
				this.x.value = UnitConverter.convert(x.x, "r", Editor$1.settings.units.angle);
				this.y.value = UnitConverter.convert(x.y, "r", Editor$1.settings.units.angle);
			}
			else
			{
				this.x.value = x.x;
				this.y.value = x.y;
			}

			this.setType(VectorBox.VECTOR2);
		}
		else if(x.isVector3)
		{
			if(this.isAngle)
			{
				this.x.value = UnitConverter.convert(x.x, "r", Editor$1.settings.units.angle);
				this.y.value = UnitConverter.convert(x.y, "r", Editor$1.settings.units.angle);
				this.z.value = UnitConverter.convert(x.z, "r", Editor$1.settings.units.angle);
			}
			else
			{
				this.x.value = x.x;
				this.y.value = x.y;
				this.z.value = x.z;
			}

			this.setType(VectorBox.VECTOR3);
		}
		else if(x.isEuler)
		{
			if(this.isAngle)
			{
				this.x.value = UnitConverter.convert(x.x, "r", Editor$1.settings.units.angle);
				this.y.value = UnitConverter.convert(x.y, "r", Editor$1.settings.units.angle);
				this.z.value = UnitConverter.convert(x.z, "r", Editor$1.settings.units.angle);
			}
			else
			{
				this.x.value = x.x;
				this.y.value = x.y;
				this.z.value = x.z;
			}

			this.order = x.order;
			this.setType(VectorBox.VECTOR3);
		}
		else if(x.isQuaternion)
		{
			this.x.value = x.x;
			this.y.value = x.y;
			this.z.value = x.z;
			this.w.value = x.w;
			this.setType(VectorBox.QUATERNION);
		}
		else
		{
			if(this.isAngle)
			{
				x = UnitConverter.convert(x.x, "r", Editor$1.settings.units.angle);
				y = UnitConverter.convert(x.y, "r", Editor$1.settings.units.angle);
				z = UnitConverter.convert(x.z, "r", Editor$1.settings.units.angle);
				z = UnitConverter.convert(x.w, "r", Editor$1.settings.units.angle);
			}

			this.x.value = x;
			this.y.value = y;
			this.z.value = (z !== undefined) ? z : 0;
			this.w.value = (w !== undefined) ? w : 0;
		}
	};

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	VectorBox.prototype.setOnChange = function(onChange)
	{
		this.x.onchange = onChange;
		this.y.onchange = onChange;
		this.z.onchange = onChange;
		this.w.onchange = onChange;
	};

	VectorBox.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);
		
		var sizeX = Math.round((this.size.x - this.type * 15) / this.type);
		var sizeY = this.size.y + "px";

		this.xText.style.height = sizeY;
		this.xText.style.lineHeight = sizeY;
		this.x.style.width = sizeX + "px";

		this.yText.style.left = (15 + sizeX) + "px";
		this.yText.style.height = sizeY;
		this.yText.style.lineHeight = sizeY;
		this.y.style.left = (30 + sizeX) + "px";
		this.y.style.width = sizeX + "px";

		if(this.type >= VectorBox.VECTOR3)
		{
			this.zText.style.left = (30 + (2 * sizeX)) + "px";
			this.zText.style.height = sizeY;
			this.zText.style.lineHeight = sizeY;
			this.z.style.left = (45 + (2 * sizeX)) + "px";
			this.z.style.width = sizeX + "px";

			if(this.type === VectorBox.QUATERNION)
			{
				this.wText.style.left = (45 + (3 * sizeX)) + "px";
				this.wText.style.height = sizeY;
				this.wText.style.lineHeight = sizeY;
				this.w.style.left = (60 + (3 * sizeX)) + "px";
				this.w.style.width = sizeX + "px";

				this.zText.style.visibility = "visible";
				this.z.style.visibility = "visible";
				this.w.style.visibility = "visible";
				this.wText.style.visibility = "visible";
			}
			else
			{
				this.zText.style.visibility = "visible";
				this.z.style.visibility = "visible";
				this.w.style.visibility = "hidden";
				this.wText.style.visibility = "hidden";
			}
		}
		else
		{
			this.z.style.visibility = "hidden";
			this.zText.style.visibility = "hidden";
			this.w.style.visibility = "hidden";
			this.wText.style.visibility = "hidden";
		}
	};

	function TextureChooser(parent)
	{
		Component.call(this, parent, "div");

		// Preview
		this.preview = document.createElement("div");
		this.preview.style.cursor = "pointer";
		this.preview.style.visibility = "inherit";
		this.preview.style.position = "absolute";
		this.preview.style.top = "0px";
		this.preview.style.left = "0px";
		this.preview.style.backgroundImage = "url(\"" + Global.FILE_PATH + "alpha.png\")";
		this.preview.style.backgroundRepeat = "repeat";
		this.preview.style.backgroundSize = "120px 120px";
		this.element.appendChild(this.preview);

		// Image
		this.img = document.createElement("img");
		this.img.style.pointerEvents = "none";
		this.img.style.position = "absolute";
		this.img.style.left = "0px";
		this.img.style.top = "0px";
		this.img.style.width = "100%";
		this.img.style.height = "100%";
		this.preview.appendChild(this.img);

		// Video
		this.video = document.createElement("video");
		this.video.autoplay = true;
		this.video.loop = true;
		this.video.volume = 0.0;
		this.video.style.pointerEvents = "none";
		this.video.style.position = "absolute";
		this.video.style.left = "0px";
		this.video.style.top = "0px";
		this.video.style.width = "100%";
		this.video.style.height = "100%";
		this.preview.appendChild(this.video);

		var self = this;

		// On drop get file dropped
		this.preview.ondrop = function(event)
		{
			// File
			if(event.dataTransfer.files.length > 0)
			{
				self.loadTexture(event.dataTransfer.files[0]);
			}
			// Resource
			else
			{
				var uuid = event.dataTransfer.getData("uuid");
				var value = DragBuffer.get(uuid);

				// Texture
				if(value instanceof three.Texture && (self.acceptAll || !value.isCubeTexture))
				{
					self.setTexture(value);
				}
				// Image
				else if(value instanceof Image)
				{
					self.setTexture(new three.Texture(value));
				}
				// Video
				else if(value instanceof Video)
				{
					self.setTexture(new VideoTexture(value));
				}
				else
				{
					Editor$1.alert("Only textures, videos and images accepted");
				}
			}

			event.preventDefault();
		};

		// Onclick select image or video file
		this.preview.onclick = function()
		{
			if(self.onChange !== null)
			{
				FileSystem.chooseFile(function(files)
				{
					if(files.length > 0)
					{
						self.loadTexture(files[0]);
					}
				}, "image/*, video/*, .tga");
			}
		};

		/**
		 * On change callback function.
		 *
		 * @property onChange
		 * @type {Function}
		 */
		this.onChange = null;

		this.acceptAll = false;

		/**
		 * Texture stored in chooser.
		 *
		 * @property texture
		 * @type {Texture}
		 */
		this.texture = null;
	}

	TextureChooser.prototype = Object.create(Component.prototype);

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	TextureChooser.prototype.setOnChange = function(onChange)
	{
		this.onChange = onChange;
	};

	// Set texture value
	TextureChooser.prototype.setValue = function(texture)
	{
		if(texture instanceof three.Texture)
		{
			this.texture = texture;
			this.updatePreview();
		}
		else
		{
			this.texture = null;
		}
	};

	/**
	 * Get value stored in the input element.
	 *
	 * @method getValue
	 * @return {Object} Value stored in the input element.
	 */
	TextureChooser.prototype.getValue = function()
	{
		return this.texture;
	};

	// Set Texture
	TextureChooser.prototype.setTexture = function(texture)
	{
		this.setValue(texture);

		if(this.onChange !== null)
		{
			this.onChange();
		}
	};

	// Load texture from file
	TextureChooser.prototype.loadTexture = function(file)
	{
		var self = this;
		var onLoad = function(texture)
		{
			self.texture = texture;
			self.updatePreview();

			if(self.onChange !== null)
			{
				self.onChange();
			}
		};

		if(Image.fileIsImage(file))
		{
			Loaders.loadTexture(file, onLoad);
		}
		else if(Video.fileIsVideo(file))
		{
			Loaders.loadVideoTexture(file, onLoad);
		}
	};

	// Update texture preview
	TextureChooser.prototype.updatePreview = function()
	{
		var texture = this.texture;

		if(texture instanceof CanvasTexture)
		{
			this.video.style.display = "none";
			this.img.style.display = "block";
			this.img.src = texture.image.toDataURL();
		}
		else if(texture instanceof VideoTexture || texture instanceof WebcamTexture)
		{
			this.img.style.display = "none";
			this.video.style.display = "block";
			this.video.src = texture.image.src;
		}
		else if(texture instanceof CubeTexture)
		{
			this.video.style.display = "none";
			this.img.style.display = "block";
			this.img.src = texture.image[0].toDataURL();
		}
		else if(texture instanceof three.Texture || texture instanceof SpriteSheetTexture)
		{
			this.video.style.display = "none";
			this.img.style.display = "block";
			this.img.src = texture.image.src;
		}
		else
		{
			this.img.style.display = "none";
			this.video.style.display = "none";
		}
	};

	TextureChooser.prototype.updateVisibility = function()
	{
		this.element.style.visibility = this.visible ? "visible" : "hidden";
	};

	TextureChooser.prototype.updateSize = function()
	{
		this.preview.style.width = this.size.y + "px";
		this.preview.style.height = this.size.y + "px";

		Component.prototype.updateSize.call(this);
	};

	/**
	 * Button with text, inherits all methods available on the Text class.
	 * 
	 * Used in menu bars, panels, etc.
	 *
	 * @class ButtonText
	 * @extends {Button, Text}
	 * @param {Component} parent Parent element.
	 */
	function ButtonText(parent)
	{
		Button.call(this, parent);

		this.text = new Text(this);
	}

	ButtonText.prototype = Object.create(Button.prototype);

	ButtonText.prototype.setText = function(text)
	{
		this.text.setText(text);
	};

	ButtonText.prototype.updateSize = function()
	{
		Button.prototype.updateSize.call(this);

		this.text.size.copy(this.size);
		this.text.updateSize();
	};

	/**
	 * Button used in dropdown menus, context menus, etc.
	 * 
	 * The button has text and its possible to add a icon.
	 *
	 * @class ButtonMenu
	 * @extends {ButtonText}
	 * @param {Component} parent Parent element.
	 */
	function ButtonMenu(parent)
	{
		ButtonText.call(this, parent);

		this.text.span.style.textIndent = "25px";

		/**
		 * Icon DOM element displayed on the left side of the button.
		 *
		 * @attribute icon
		 * @type {Element}
		 */
		this.icon = null;
	}

	ButtonMenu.prototype = Object.create(ButtonText.prototype);

	/**
	 * Set button icon image URL.
	 *
	 * Creates the element if it still doesnt exist.
	 *
	 * @method setIcon
	 * @param {string} icon Image URL.
	 */
	ButtonMenu.prototype.setIcon = function(icon)
	{
		if(this.icon === null)
		{
			this.icon = document.createElement("img");
			this.icon.style.position = "absolute";
			this.icon.style.display = "block";
			this.icon.style.left = "5px";
			this.icon.style.top = "3px";
			this.icon.style.width = "12px";
			this.icon.style.height = "12px";
			this.element.appendChild(this.icon);
		}
		
		this.icon.src = icon;
	};

	/**
	 * Dropdown menu element, used to create dropdowns in menu bars and in context menus.
	 * 
	 * @class DropdownMenu
	 * @extends {Text}
	 * @param {Component} parent Parent element.
	 */
	function DropdownMenu(parent)
	{
		Text.call(this, parent);

		this.element.style.backgroundColor = "var(--bar-color)";
		this.element.style.cursor = "pointer";
		this.element.style.pointerEvents = "auto";

		this.preventDragEvents();

		/**
		 * Element, where the options are stored.
		 *
		 * This DOM element is added directly to the parent DOM element.
		 *
		 * @attribute panel
		 * @type {Component}
		 */
		this.panel = new Component(parent, "div");
		this.panel.element.style.overflow = "visible";
		this.panel.element.style.display = "none";
		this.panel.element.style.zIndex = "300";

		/**
		 * Option icon image, the element is only created when a icon is set.
		 *
		 * @attribute icon
		 * @type {Component}
		 */
		this.icon = null;

		/**
		 * Decorative arrow.
		 *
		 * @attribute arrow
		 * @type {Component}
		 */
		this.arrow = document.createElement("img");
		this.arrow.style.display = "none";
		this.arrow.style.position = "absolute";
		this.arrow.style.right = "5px";
		this.arrow.style.top = "3px";
		this.arrow.style.width = "12px";
		this.arrow.style.height = "12px";
		this.arrow.src = Global.FILE_PATH + "icons/misc/arrow_right.png";
		this.element.appendChild(this.arrow);

		/**
		 * Direction to open the dropdown.
		 *
		 * @attribute direction
		 * @type {number}
		 */
		this.direction = DropdownMenu.DOWN;
		
		/**
		 * Indicates if the dropdown menu is expanded.
		 *
		 * @attribute expanded
		 * @type {boolean}
		 */
		this.expanded = false;

		/**
		 * Size of each dropdown menu option.
		 *
		 * @attribute optionsSize
		 * @type {Vector2}
		 */
		this.optionsSize = new three.Vector2(150, 20);

		/**
		 * Options available in the dropdown.
		 *
		 * Options are stored as: {button:button, value:object, name:string}
		 *
		 * @attribute options
		 * @type {Array}
		 */
		this.options = [];

		var self = this;

		this.addEvent("mouseenter", function()
		{
			self.setExpanded(true);
			self.element.style.backgroundColor = "var(--button-over-color)";
		});

		this.addEvent("mouseleave", function()
		{
			self.setExpanded(false);
			self.element.style.backgroundColor = "var(--bar-color)";
		});
		
		this.panel.addEvent("mouseenter", function()
		{
			self.setExpanded(true);
		});

		this.panel.addEvent("mouseleave", function()
		{
			self.setExpanded(false);
		});
	}

	DropdownMenu.DOWN = 0;
	DropdownMenu.UP = 1;
	DropdownMenu.LEFT = 2;
	DropdownMenu.RIGHT = 3;

	DropdownMenu.prototype = Object.create(Text.prototype);

	/**
	 * Set location to where options should open.
	 *
	 * @method setDirection
	 */
	DropdownMenu.prototype.setDirection = function(location)
	{
		this.direction = location;
	};

	/**
	 * Show arrow.
	 *
	 * @method showArrow
	 */
	DropdownMenu.prototype.showArrow = function()
	{
		this.arrow.style.display = "block";
	};

	/**
	 * Set icon.
	 *
	 * @method setIcon
	 * @param {string} icon Image URL.
	 */
	DropdownMenu.prototype.setIcon = function(icon)
	{
		if(this.icon === null)
		{
			this.icon = document.createElement("img");
			this.icon.style.display = "block";
			this.icon.style.position = "absolute";
			this.icon.style.left = "5px";
			this.icon.style.top = "3px";
			this.icon.style.width = "12px";
			this.icon.style.height = "12px";
			this.element.appendChild(this.icon);
		}

		this.icon.src = icon;
	};

	/**
	 * Remove option from menu.
	 *
	 * @method removeOption
	 * @param {number} index
	 */
	DropdownMenu.prototype.removeOption = function(index)
	{
		if(index >= 0 && index < this.options.length)
		{
			this.options[index].destroy();
			this.options.splice(index, 1);
		}
	};

	/**
	 * Add new option to menu
	 *
	 * @method addOption
	 * @param {string} name of the option
	 * @param {Function} callback Callback function
	 * @param {string} icon Icon URL.
	 * @return {ButtonMenu} Button created for the new option.
	 */
	DropdownMenu.prototype.addOption = function(name, callback, icon)
	{
		var button = new ButtonMenu(this.panel);
		button.element.style.zIndex = "200";
		button.text.setText(name);
		button.text.setAlignment(Text.LEFT);
		button.position.set(25, 0);

		var self = this;
		button.setOnClick(function()
		{
			callback();
			self.setExpanded(false);
		});

		if(icon !== undefined)
		{
			button.setIcon(icon);
		}

		this.options.push(button);

		return button;
	};

	/**
	 * Add new menu to menu.
	 *
	 * @method addOption
	 * @param {string} name Name of the option.
	 * @param {string} icon Optional icon, image URL.
	 * @return {DropdownMenu} The new menu created.
	 */
	DropdownMenu.prototype.addMenu = function(name, icon)
	{
		var menu = new DropdownMenu(this.panel);
		menu.setText(name);
		menu.setDirection(DropdownMenu.LEFT);
		menu.showArrow();
		menu.setAlignment(Text.LEFT);
		menu.setMargin(25);
		
		if(icon !== undefined)
		{
			menu.setIcon(icon);
		}

		this.options.push(menu);

		return menu;
	};

	/** 
	 * Update expanded state, position all options in this dropdown.
	 * 
	 * @method setExpanded
	 * @param {boolean} expanded If true the menu will be expanded.
	 */
	DropdownMenu.prototype.setExpanded = function(expanded)
	{
		this.expanded = expanded;

		if(this.expanded)
		{
			this.panel.element.style.display = "block";

			if(this.direction === DropdownMenu.DOWN)
			{
				this.panel.element.style.top = (this.position.y + this.size.y) + "px";
				this.panel.element.style.left = this.position.x + "px";

				var out = DOMUtils.checkBorder(this.panel);

				if(out.y !== 0)
				{
					this.panel.element.style.top = null;
					this.panel.element.style.bottom = (this.position.y + this.size.y) + "px";
				}
				if(out.x !== 0)
				{
					this.panel.element.style.left = (this.position.x - out.x) + "px"; 
				}
			}
			else if(this.direction === DropdownMenu.UP)
			{
				this.panel.element.style.bottom = (this.position.y + this.size.y) + "px";
				this.panel.element.style.left = this.position.x + "px";

				var out = DOMUtils.checkBorder(this.panel);
				if(out.y !== 0)
				{
					this.panel.element.style.bottom = null;
					this.panel.element.style.top = (this.position.y + this.size.y) + "px";
				}
				if(out.x !== 0)
				{
					this.panel.element.style.left = (this.position.x - out.x) + "px"; 
				}
			}
			else if(this.direction === DropdownMenu.LEFT)
			{
				this.panel.element.style.top = this.position.y + "px";
				this.panel.element.style.left = (this.position.x + this.size.x) + "px";

				var out = DOMUtils.checkBorder(this.panel);
				if(out.x !== 0)
				{
					this.panel.element.style.left = (this.position.x - this.size.x) + "px"; 
				}
				if(out.y !== 0)
				{
					this.panel.element.style.top = (this.position.y - out.y) + "px";
				}
			}
			else if(this.direction === DropdownMenu.RIGHT)
			{
				this.panel.element.style.top = this.position.y + "px";
				this.panel.element.style.left = (this.position.x - this.size.x) + "px";

				var out = DOMUtils.checkBorder(this.panel);
				if(out.x !== 0)
				{
					this.panel.element.style.left = (this.position.x + this.size.x) + "px";
				}
				if(out.y !== 0)
				{
					this.panel.element.style.top = (this.position.y - out.y) + "px";
				}
			}
		}
		else
		{
			this.panel.element.style.display = "none";
		}
	};

	/**
	 * Update all options in the menu.
	 * 
	 * @method updateOptions
	 */
	DropdownMenu.prototype.updateOptions = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].size.set(this.optionsSize.x, this.optionsSize.y);
			this.options[i].position.set(0, this.optionsSize.y * i);
			this.options[i].updateInterface();
		}

		this.panel.element.style.width = this.size.x + "px";
		this.panel.element.style.height = (this.optionsSize.y * this.options.length) + "px";
	};

	DropdownMenu.prototype.destroy = function()
	{
		Text.prototype.destroy.call(this);

		this.parent.destroy();
	};

	DropdownMenu.prototype.updateSize = function()
	{
		Text.prototype.updateSize.call(this);

		this.updateOptions();
	};

	/**
	 * Context menu element.
	 * 
	 * @class ContextMenu
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function ContextMenu(parent)
	{
		Component.call(this, parent, "div");

		var self = this;

		this.element.style.overflow = "visible";
		this.element.style.zIndex = "300";
		this.element.onmouseleave = function()
		{
			self.destroy();
		};

		this.offset = new three.Vector2(20, 10);
		
		/**
		 * Options in this menu.
		 * 
		 * @attribute options
		 * @type {Array}
		 */
		this.options = [];
	}

	ContextMenu.prototype = Object.create(Component.prototype);

	/**
	 * Set the text of this context menu.
	 * 
	 * @method setText
	 * @param {string} text
	 */
	ContextMenu.prototype.setText = function(text)
	{
		this.text.setText(text);
	};

	/**
	 * Remove option from context menu.
	 *
	 * @method removeOption
	 * @param {number} index
	 */
	ContextMenu.prototype.removeOption = function(index)
	{
		if(index >= 0 && index < this.options.length)
		{
			this.options[index].destroy();
			this.options.splice(index, 1);
		}
	};

	/**
	 * Add new option to context menu
	 *
	 * @method addOption
	 * @param {string} name of the option
	 * @param {Function} callback Callback function
	 */
	ContextMenu.prototype.addOption = function(name, callback)
	{
		var button = new ButtonMenu(this);
		button.setStyle("zIndex", "10000");
		button.setText(name);
		button.text.setAlignment(Text.LEFT);
		button.position.x = 25;

		var self = this;
		button.setOnClick(function()
		{
			callback();
			self.destroy();
		});
		
		this.options.push(button);
	};

	/**
	 * Add new menu to context menu
	 *
	 * @method addOption
	 * @param {string} name of the option.
	 * @return {DropdownMenu} The new menu created.
	 */
	ContextMenu.prototype.addMenu = function(name)
	{
		var menu = new DropdownMenu(this);
		menu.setText(name);
		menu.setDirection(DropdownMenu.LEFT);
		menu.showArrow();
		menu.setAlignment(Text.LEFT);
		menu.setMargin(25);

		this.options.push(menu);

		return menu;
	};

	/**
	 * Update all options in the menu.
	 * 
	 * @method updateOptions
	 */
	ContextMenu.prototype.updateOptions = function()
	{
		for(var i = 0; i < this.options.length; i++)
		{
			this.options[i].size.copy(this.size);
			this.options[i].position.set(0, this.size.y * i);
			this.options[i].updateInterface();
		}
	};

	ContextMenu.prototype.updateSize = function()
	{
		this.element.style.width = this.size.x + "px";
		this.element.style.height = (this.size.y * this.options.length) + "px";

		this.updateOptions();
	};

	ContextMenu.prototype.updatePosition = function()
	{
		this.element.style.top = (this.position.y - this.offset.y) + "px";
		this.element.style.left = (this.position.x - this.offset.x) + "px";

		// Check if its inside window
		var out = DOMUtils.checkBorder(this.element);
		if(out.x !== 0)
		{
			this.element.style.left = (this.position.x + this.offset.x - this.size.x) + "px"; 
		}
		if(out.y !== 0)
		{
			this.element.style.top = (this.position.y - this.offset.y - out.y) + "px";
		}
	};

	/**
	 * DOM text input element.
	 * 
	 * @class TextBox
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function TextBox(parent)
	{
		Component.call(this, parent, "input");

		this.element.type = "text";
		this.element.style.backgroundColor = "var(--box-color)";
		this.element.style.color = "var(--color-light)";
		this.element.style.margin = "0";
		this.element.style.outline = "none";
		this.element.style.borderStyle = "none";
		this.element.style.boxSizing = "border-box";
		this.element.style.textIndent = "4px";
		this.element.style.borderRadius = "4px";

		var self = this;
		
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			context.addOption(Locale.copy, function()
			{
				var value = self.element.value;
				Editor$1.clipboard.set(value.slice(self.element.selectionStart, self.element.selectionEnd), "text");
			});
			context.addOption(Locale.cut, function()
			{
				var value = self.element.value;
				Editor$1.clipboard.set(value.slice(self.element.selectionStart, self.element.selectionEnd), "text");
				self.element.value = value.slice(0, self.element.selectionStart) + value.slice(self.element.selectionEnd, value.length);
			});
			context.addOption(Locale.paste, function()
			{
				var value = self.element.value;
				var paste = Editor$1.clipboard.get("text");
				if(paste !== undefined)
				{
					self.element.value = value.slice(0, self.element.selectionStart) + paste + value.slice(self.element.selectionEnd, value.length);
				}
			});
			context.addOption(Locale.selectAll, function()
			{
				console.log(self.element);
				self.element.select();
			});
			context.updateInterface();
		};
	}

	TextBox.prototype = Object.create(Component.prototype);

	/**
	 * Set font configuration to use for the text presented in this component.
	 *
	 * May also affect some types of children components. 
	 * 
	 * @method setFont
	 * @param {string} fontFamily Font family.
	 * @param {number} fontWeight Font weigth, sets how thick or thin characters in text should be displayed.
	 * @param {string} fontStyle Font style, specifies the font style for a text.
	 */
	TextBox.prototype.setFont = function(fontFamily, fontWeight, fontStyle)
	{
		this.element.style.fontFamily = fontFamily;

		if(fontWeight !== undefined)
		{
			this.element.style.fontWeight = fontWeight;
		}

		if(fontStyle !== undefined)
		{
			this.element.style.fontStyle = fontStyle;
		}
	};

	/**
	 * Set the disabled state of the element.
	 *
	 * @method setDisabled
	 * @param {boolean} disabled
	 */
	TextBox.prototype.setDisabled = function(value)
	{
		this.element.disabled = value;
	};

	/**
	 * Set oninput callback called after every letter typed into the box.
	 *
	 * Should be used only for immediate input effect, or can be used with a timeout value to prevent high CPU usage.
	 *
	 * @method setOnInput
	 * @param {Function} onInput Callback method called everytime the user types something.
	 * @param {number} timeout Time (ms) after the user stopped typing to activate the callback.
	 */
	TextBox.prototype.setOnInput = function(onInput, timeout)
	{
		if(timeout !== undefined)
		{
			var timer = null;

			this.element.oninput = function(event)
			{
				if(timer !== null)
				{
					clearTimeout(timer);
					timer = null;
				}

				timer = setTimeout(function()
				{
					onInput();
					timer = null;
				}, timeout);
			};
		}
		else
		{
			this.element.oninput = onInput;
		}
	};

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	TextBox.prototype.setOnChange = function(onChange)
	{
		this.element.onchange = onChange;
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setText
	 * @param {Object} text
	 */
	TextBox.prototype.setText = function(text)
	{
		this.element.value = text;
	};

	/**
	 * Get text stored in the input element.
	 *
	 * @method getText
	 * @return {string} Text stored in the input element.
	 */
	TextBox.prototype.getText = function()
	{
		return this.element.value;
	};

	/**
	 * Number input element.
	 * 
	 * @class NumberBox
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function NumberBox(parent)
	{
		Component.call(this, parent, "input");

		/**
		 * Indicates if the number box is storing a angle value.
		 *
		 * If the value is an angle is has to be converted to editor coordinates.
		 *
		 * @attribute isAngle
		 * @type {boolean}
		 */
		this.isAngle = false;

		this.element.type = "number";
		this.element.step = "0.1";
		this.element.style.backgroundColor = "var(--box-color)";
		this.element.style.color = "var(--color-light)";
		this.element.style.outline = "none";
		this.element.style.borderStyle = "none";
		this.element.style.boxSizing = "border-box";
		this.element.style.textIndent = "4px";
		this.element.style.borderRadius = "4px";
		this.element.style.boxShadow = "none";
		this.element.style.MozAppearance = "textfield";
		this.element.style.webkitAppearance = "caret";
		this.element.style.appearance = "textfield";
	}

	NumberBox.prototype = Object.create(Component.prototype);

	/**
	 * Set the disabled state of the element.
	 *
	 * @method setDisabled
	 * @param {boolean} disabled
	 */
	NumberBox.prototype.setDisabled = function(disabled)
	{
		this.element.disabled = disabled;
	};

	/**
	 * Set number range.
	 *
	 * @methos setRange
	 * @param {number} min
	 * @param {number} max
	 */
	NumberBox.prototype.setRange = function(min, max)
	{
		this.element.min = String(min);
		this.element.max = String(max);
	};

	/**
	 * Set number step.
	 *
	 * @method setStep
	 * @param {number} value
	 */
	NumberBox.prototype.setStep = function(value)
	{
		this.element.step = String(value);
	};

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	NumberBox.prototype.setOnChange = function(onChange)
	{
		this.element.onchange = onChange;
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setValue
	 * @param {number} value
	 */
	NumberBox.prototype.setValue = function(value)
	{
		if(this.isAngle)
		{
			value = UnitConverter.convert(value, "r", Editor$1.settings.units.angle);
		}

		this.element.value = value;
	};

	/**
	 * Get value stored in the input element.
	 *
	 * @method setValue
	 * @return {Object} Value stored in the input element.
	 */
	NumberBox.prototype.getValue = function()
	{	
		var value = Number.parseFloat(this.element.value);
		if(this.isAngle)
		{
			value = UnitConverter.convert(value, Editor$1.settings.units.angle, "r");
		}

		return value;
	};

	NumberBox.prototype.updateVisibility = function()
	{
		this.element.style.visibility = this.visible ? "visible" : "hidden";
	};

	/**
	 * The vector array box represents multiple numeric variables as a vector.
	 *
	 * @class NumberRow
	 * @extends {Component}
	 */
	function NumberRow(parent)
	{
		Component.call(this, parent, "div");

		/**
		 * Array with the values objects.
		 *
		 * Each value object is composed of {label:label, input:input}
		 *
		 * @attribute values
		 * @type {Array}
		 */
		this.values = [];

		/**
		 * Label size in px.
		 *
		 * @attribute labelSize
		 * @type {number}
		 */
		this.labelSize = 15;
	}

	NumberRow.prototype = Object.create(Component.prototype);

	/**
	 * Set the values step.
	 *
	 * @method setStep
	 * @param {number} value
	 */
	NumberRow.prototype.setStep = function(value)
	{
		var value = String(value);

		for(var i = 0; i < this.values.length; i++)
		{
			this.values[i].input.setStep(value);
		}
	};

	/**
	 * Set the values range
	 *
	 * @method setRange
	 * @param {number} min
	 * @param {number} max
	 */
	NumberRow.prototype.setRange = function(min, max)
	{
	 	var min = String(min);
	 	var max = String(max);

		for(var i = 0; i < this.values.length; i++)
		{
			this.values[i].input.setRange(min, max);
		}
	};

	/**
	 * Add value to the box
	 *
	 * @method addValue
	 * @param {string} label Label of de attribute.
	 * @return {NumberBox} The input number box created for this value.
	 */
	NumberRow.prototype.addValue = function(label)
	{
		var input = new NumberBox(this);

		var text = new Text(this);
		text.setText(label);	

		this.values.push(
		{
			label: text,
			input: input
		});

		return input;
	};

	NumberRow.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);
		
		var width = Math.round((this.size.x - this.values.length * this.labelSize) / this.values.length);
		var x = 0;
		
		for(var i = 0; i < this.values.length; i++)
		{
			var label = this.values[i].label;
			label.position.set(x, 0);
			label.size.set(this.labelSize, this.size.y);
			label.updateInterface();

			var input = this.values[i].input;
			input.position.set(x + this.labelSize, 0);
			input.size.set(width, this.size.y);
			input.updateInterface();

			x += width + this.labelSize;
		}
	};

	/**
	 * Color gradient chooser is used to select and preview a gradient of colors store in an array.
	 *
	 * @class ColorGradientChooser
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function ColorGradientChooser(parent)
	{
		Component.call(this, parent, "div");

		/**
		 * On change callback function.
		 *
		 * @property onChange
		 * @type {Function}
		 */
		this.onChange = null;

		/**
		 * Color values of the gradient.
		 *
		 * @property values
		 * @type {Array}
		 */
		this.values = [];

		/**
		 * Buttons DOM element. Buttons have a onchange, color and index properties attached to them.
		 *
		 * @property buttons
		 * @type {Array}
		 */
		this.buttons = [];

		this.element.style.overflow = "hidden";
		this.element.style.backgroundColor = "var(--panel-color)";
		this.element.style.borderStyle = "none";
		this.element.style.boxSizing = "border-box";
		this.element.style.borderRadius = "4px";
		this.element.style.zIndex = "2000";

		/**
		 * Canvas DOM element used to draw the gradient.
		 *
		 * @property canvas
		 * @type {Component}
		 */
		this.canvas = document.createElement("canvas");
		this.canvas.style.position = "absolute";
		this.canvas.style.top = "0px";
		this.canvas.style.left = "0px";
		this.canvas.style.width = "100%";
		this.canvas.style.height = "100%";
		this.element.appendChild(this.canvas);
	}

	ColorGradientChooser.prototype = Object.create(Component.prototype);

	/**
	 * Update the buttos to match new values.
	 *
	 * @method updateButtons
	 */
	ColorGradientChooser.prototype.updateButtons = function()
	{
		var self = this;

		function buttonOnChange()
		{
			var rgb = this.color.rgb;

			self.values[this.index].setRGB(rgb[0] / 255, rgb[1] / 255, rgb[2] / 255);
			self.updateValues();

			if(self.onChange !== null)
			{
				self.onChange(self.values[this.index], this.index);
			}
		}

		while(this.buttons.length > this.values.length)
		{
			this.element.removeChild(this.buttons.shift());
		}

		while(this.buttons.length < this.values.length)
		{
			var button = document.createElement("input");
			button.type = "text";
			button.style.display = "block";
			button.style.position = "absolute";
			button.style.top = "0px";
			button.style.width = "15px";
			button.style.height = "100%";
			button.style.cursor = "pointer";
			button.style.outline = "none";
			button.style.borderStyle = "none";
			button.style.boxSizing = "border-box";
			button.style.borderRadius = "2px";
			this.element.appendChild(button);

			var color = new jscolor(button);
			color.backgroundColor = "var(--box-color)";
			color.insetColor = "var(--box-color)";
			color.shadow = false;
			color.borderWidth = 0;
			color.borderRadius = 0;
			color.zIndex = 2000;

			button.onchange = buttonOnChange;
			button.color = color;
			button.index = -1;

			this.buttons.push(button);
		}

		for(var i = 0; i < this.buttons.length; i++)
		{
			this.buttons[i].index = i;
		}
	};

	/**
	 * Update the representation of the gradient.
	 *
	 * @method updateValues
	 */
	ColorGradientChooser.prototype.updateValues = function()
	{
		var context = this.canvas.getContext("2d");
		var gradient = context.createLinearGradient(0, 0, this.canvas.width, 0);

		var colorStep = 1 / (this.values.length - 1);
		var colorPercentage = 0;

		var buttonSpacing = (this.size.x - 15) / (this.buttons.length - 1);
		var buttonPosition = 0;

		for(var i = 0; i < this.values.length; i++)
		{
			gradient.addColorStop(colorPercentage, this.values[i].getStyle());

			this.buttons[i].color.fromRGB(this.values[i].r * 255, this.values[i].g * 255, this.values[i].b * 255);
			this.buttons[i].style.left = buttonPosition + "px";

			colorPercentage += colorStep;
			buttonPosition += buttonSpacing;
		}

		context.fillStyle = gradient;
		context.fillRect(0, 0, this.canvas.width, this.canvas.height);
	};

	/**
	 * Set onChange callback that receives (value, index) as arguments.
	 *
	 * @method setOnChange
	 * @param {Function} onChange OnChange callback receives value and index as arguments.
	 */
	ColorGradientChooser.prototype.setOnChange = function(onChange)
	{
		this.onChange = onChange;
	};

	/**
	 * Set an array of color values to be displayed on this gradient.
	 *
	 * @method setValue
	 * @param {Array} values
	 */
	ColorGradientChooser.prototype.setValue = function(values)
	{
		this.values = [];

		for(var i = 0; i < values.length; i++)
		{
			var color = new three.Color();
			color.copy(values[i]);
			this.values.push(color);
		}

		this.updateButtons();
		this.updateValues();
	};

	/**
	 * Get the values stored in this element.
	 *
	 * @method getValue
	 * @return {Array} Values of the gradient.
	 */
	ColorGradientChooser.prototype.getValue = function()
	{
		return this.values;
	};

	ColorGradientChooser.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);
		
		this.canvas.width = this.size.x;
		this.canvas.height = this.size.y;

		this.updateValues();
	};

	/**
	 * Particle editor is used to edit particle emitter objects visually.
	 *
	 * Allows the user to change all the parameters of the emitter.
	 */
	function ParticleEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.particle, Global.FILE_PATH + "icons/misc/particles.png");

		var self = this;

		// Canvas
		this.canvas = new RendererCanvas();
		this.canvas.setOnResize(function(x, y)
		{
			self.camera.aspect = x / y;
			self.camera.updateProjectionMatrix();
		});

		// Mouse
		this.mouse = new Mouse(window, true);
		this.mouse.setCanvas(this.canvas.element);

		// Particle preview
		this.scene = new three.Scene();
		this.scene.matrixAutoUpdate = false;
		this.scene.add(new three.GridHelper(50, 50, 0x888888));
		this.scene.add(new three.AxesHelper(50));

		// Particle
		this.particle = null;

		// Camera
		this.camera = new PerspectiveCamera(90, this.canvas.size.x / this.canvas.size.y);
		this.cameraRotation = new three.Vector2(0, 0.5);
		this.cameraDistance = 5;
		this.updateCamera();
		this.scene.add(this.camera);

		this.form = new TableForm();
		this.form.setAutoSize(false);

		// Main
		this.main = new DualContainer(this);
		this.main.tabPosition = 0.6;
		this.main.tabPositionMin = 0.05;
		this.main.tabPositionMax = 0.95;
		this.main.attachA(this.canvas);
		this.main.attachB(this.form);

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(200, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle, "name", self.name.getText()));
			Editor$1.updateObjectsViewsGUI();
		});
		this.form.add(this.name);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.texture);
		this.texture = new TextureChooser(this.form);
		this.texture.size.set(100, 100);
		this.texture.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.particle.group, "texture", self.texture.getValue()));
			self.particle.reload();
		});
		this.form.add(this.texture);
		this.form.nextRow();

		// Max particle count
		this.form.addText("Particle Count");
		this.maxParticleCount = new NumberBox(this.form);
		this.maxParticleCount.setStep(1.0);
		this.maxParticleCount.size.set(100, 18);
		this.maxParticleCount.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.group, "maxParticleCount", self.maxParticleCount.getValue()));
			self.particle.reload();
		});
		this.form.add(this.maxParticleCount);
		this.form.nextRow();

		// Blending mode
		this.form.addText(Locale.blendingMode);
		this.blending = new DropdownList(this.form);
		this.blending.size.set(100, 18);
		this.blending.addValue(Locale.none, three.NoBlending);
		this.blending.addValue(Locale.normal, three.NormalBlending);
		this.blending.addValue(Locale.additive, three.AdditiveBlending);
		this.blending.addValue(Locale.subtractive, three.SubtractiveBlending);
		this.blending.addValue(Locale.multiply, three.MultiplyBlending);
		this.blending.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.group, "blending", self.blending.getValue()));
			self.particle.reload();
		});
		this.form.add(this.blending);
		this.form.nextRow();

		// Direction (Time scale)
		this.form.addText(Locale.direction);
		this.direction = new DropdownList(this.form);
		this.direction.size.set(100, 18);
		this.direction.addValue(Locale.forward, 1);
		this.direction.addValue(Locale.backward, -1);
		this.direction.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter, "direction", self.direction.getValue()));
			self.particle.reload();
		});
		this.form.add(this.direction);
		this.form.nextRow();

		// Particle Count
		this.form.addText("Particle Rate");
		this.particleCount = new NumberBox(this.form);
		this.particleCount.size.set(50, 18);
		this.particleCount.setStep(1);
		this.particleCount.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter, "particleCount", self.particleCount.getValue()));
			self.particle.reload();
		});
		this.form.add(this.particleCount);
		this.form.nextRow();

		// Particle Duration
		this.form.addText(Locale.duration);
		this.duration = new NumberBox(this.form);
		this.duration.size.set(50, 18);
		this.duration.setRange(0, Number.MAX_SAFE_INTEGER);
		this.duration.setOnChange(function()
		{
			var duration = self.duration.getValue();
			if(duration === 0)
			{
				duration = null;
			}

			Editor$1.addAction(new ChangeAction(self.particle.emitter, "duration", duration));
			self.particle.reload();
		});
		this.form.add(this.duration);
		this.form.nextRow();

		// Emmitter type
		this.form.addText(Locale.emitterType);
		this.type = new DropdownList(this.form);
		this.type.size.set(100, 18);
		this.type.addValue(Locale.box, ParticleDistributions.BOX);
		this.type.addValue(Locale.sphere, ParticleDistributions.SPHERE);
		this.type.addValue(Locale.disc, ParticleDistributions.DISC);
		this.type.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter, "type", self.type.getValue()));
			self.particle.reload();
		});
		this.form.add(this.type);
		this.form.nextRow();

		// Max age
		this.form.addText(Locale.age);
		this.ageRow = new NumberRow(this.form);
		this.ageRow.labelSize = 20;
		this.ageRow.size.set(0, 18);

		this.maxAgeValue = this.ageRow.addValue("F");
		this.maxAgeValue.setRange(0, Number.MAX_SAFE_INTEGER);
		this.maxAgeValue.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.maxAge, "value", self.maxAgeValue.getValue()));
			self.particle.reload();
		});

		this.maxAgeSpread = this.ageRow.addValue("+/-");
		this.maxAgeSpread.setRange(0, Number.MAX_SAFE_INTEGER);
		this.maxAgeSpread.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.maxAge, "spread", self.maxAgeSpread.getValue()));
			self.particle.reload();
		});

		this.form.add(this.ageRow);
		this.form.nextRow();

		// Position
		this.form.addText(Locale.position);
		this.form.nextRow();

		this.form.addText(Locale.initial);
		this.positionValue = new VectorBox(this.form);
		this.positionValue.size.set(0, 18);
		this.positionValue.setOnChange(function()
		{
			self.particle.emitter.position.value.copy(self.positionValue.getValue());
			self.particle.reload();
		});
		this.form.add(this.positionValue);
		this.form.nextRow();

		this.form.addText(Locale.variation);
		this.positionSpread = new VectorBox(this.form);
		this.positionSpread.size.set(0, 18);
		this.positionSpread.setOnChange(function()
		{
			self.particle.emitter.position.spread.copy(self.positionSpread.getValue());
			self.particle.reload();
		});
		this.form.add(this.positionSpread);
		this.form.nextRow();

		// Velocity
		this.form.addText(Locale.velocity);
		this.form.nextRow();

		this.form.addText(Locale.initial);
		this.velocityValue = new VectorBox(this.form);
		this.velocityValue.size.set(0, 18);
		this.velocityValue.setOnChange(function()
		{
			self.particle.emitter.velocity.value.copy(self.velocityValue.getValue());
			self.particle.reload();
		});
		this.form.add(this.velocityValue);
		this.form.nextRow();

		this.form.addText(Locale.variation);
		this.velocitySpread = new VectorBox(this.form);
		this.velocitySpread.size.set(0, 18);
		this.velocitySpread.setOnChange(function()
		{
			self.particle.emitter.velocity.spread.copy(self.velocitySpread.getValue());
			self.particle.reload();
		});
		this.form.add(this.velocitySpread);
		this.form.nextRow();

		// Acceleration
		this.form.addText(Locale.acceleration);
		this.form.nextRow();

		this.form.addText(Locale.initial);
		this.accelerationValue = new VectorBox(this.form);
		this.accelerationValue.size.set(0, 18);
		this.accelerationValue.setOnChange(function()
		{
			self.particle.emitter.acceleration.value.copy(self.accelerationValue.getValue());
			self.particle.reload();
		});
		this.form.add(this.accelerationValue);
		this.form.nextRow();

		this.form.addText(Locale.variation);
		this.accelerationSpread = new VectorBox(this.form);
		this.accelerationSpread.size.set(0, 18);
		this.accelerationSpread.setOnChange(function()
		{
			self.particle.emitter.acceleration.spread.copy(self.accelerationSpread.getValue());
			self.particle.reload();
		});
		this.form.add(this.accelerationSpread);
		this.form.nextRow();

		// Wiggle
		this.form.addText(Locale.wiggle);
		this.wiggleRow = new NumberRow(this.form);
		this.wiggleRow.labelSize = 20;
		this.wiggleRow.size.set(0, 18);

		this.wiggleValue = this.wiggleRow.addValue("F");
		this.wiggleValue.setRange(0, Number.MAX_SAFE_INTEGER);
		this.wiggleValue.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.wiggle, "value", self.wiggleValue.getValue()));
			self.particle.reload();
		});

		this.wiggleSpread = this.wiggleRow.addValue("+/-");
		this.wiggleSpread.setRange(0, Number.MAX_SAFE_INTEGER);
		this.wiggleSpread.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.wiggle, "spread", self.wiggleSpread.getValue()));
			self.particle.reload();
		});

		this.form.add(this.wiggleRow);
		this.form.nextRow();
		
		// Opacity graph
		this.form.addText(Locale.opacity);
		this.opacity = new Graph(this.form);
		this.opacity.size.set(200, 120);
		this.opacity.setOnChange(function(value)
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.opacity, "value", value));
		});
		this.opacity.addGraph("spread", DOMUtils.getCSSVariable("--color-graph"));
		this.opacity.setOnChange(function(value)
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.opacity, "spread", value));
		}, "spread");
		this.form.add(this.opacity);
		this.form.nextRow();

		// Scale
		this.form.addText(Locale.scale);
		this.sizeRow = new NumberRow(this.form);
		this.sizeRow.labelSize = 35;
		this.sizeRow.size.set(0, 18);

		this.scaleMin = this.sizeRow.addValue(Locale.min);
		this.scaleMin.setOnChange(function()
		{
			var min = self.scaleMin.getValue();
			var max = self.scaleMax.getValue();
			self.scale.setRange(min, max);
		});

		this.scaleMax = this.sizeRow.addValue(Locale.max);
		this.scaleMax.setOnChange(function()
		{
			var min = self.scaleMin.getValue();
			var max = self.scaleMax.getValue();
			self.scale.setRange(min, max);
		});

		this.form.add(this.sizeRow);
		this.form.nextRow();

		// Scale graph
		this.form.addText("");
		this.scale = new Graph(this.form);
		this.scale.size.set(200, 120);
		this.scale.setOnChange(function(value)
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.size, "value", value));
		});
		this.scale.addGraph("spread", DOMUtils.getCSSVariable("--color-graph"));
		this.scale.setOnChange(function(value)
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.size, "spread", value));
		}, "spread");
		this.form.add(this.scale);
		this.form.nextRow();

		// Rotation
		this.form.addText(Locale.rotation);
		this.angleRow = new NumberRow(this.form);
		this.angleRow.labelSize = 35;
		this.angleRow.size.set(0, 18);

		this.angleMin = this.angleRow.addValue(Locale.min);
		this.angleMin.setOnChange(function()
		{
			var min = self.angleMin.getValue();
			var max = self.angleMax.getValue();
			self.angle.setRange(min, max);
		});

		this.angleMax = this.angleRow.addValue(Locale.max);
		this.angleMax.setOnChange(function()
		{
			var min = self.angleMin.getValue();
			var max = self.angleMax.getValue();
			self.angle.setRange(min, max);
		});

		this.form.add(this.angleRow);
		this.form.nextRow();

		// Rotation graph
		this.form.addText("");
		this.angle = new Graph(this.form);
		this.angle.size.set(200, 120);
		this.angle.setOnChange(function(value)
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.angle, "value", value));
		});
		this.angle.addGraph("spread", DOMUtils.getCSSVariable("--color-graph"));
		this.angle.setOnChange(function(value)
		{
			Editor$1.addAction(new ChangeAction(self.particle.emitter.angle, "spread", value));
		}, "spread");
		this.form.add(this.angle);
		this.form.nextRow();

		// Color
		this.form.addText(Locale.color);
		this.form.nextRow();

		this.form.addText(Locale.base);
		this.colorValue = new ColorGradientChooser(this.form);
		this.colorValue.size.set(190, 18);
		this.colorValue.setOnChange(function(color, index)
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.particle.emitter.color.value, index, color.clone()), function()
			{
				self.particle.reload();
			}));
		});
		this.form.add(this.colorValue);
		this.form.nextRow();
		
		this.form.addText(Locale.spread);
		this.colorSpread = new ColorGradientChooser(this.form);
		this.colorSpread.size.set(190, 18);
		this.colorSpread.setOnChange(function(color, index)
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.particle.emitter.color.spread, index, new three.Vector3(color.r, color.g, color.b)), function()
			{
				self.particle.reload();
			}));
		});
		this.form.add(this.colorSpread);
		this.form.nextRow();
	}

	ParticleEditor.prototype = Object.create(TabComponent.prototype);

	// Update object data
	ParticleEditor.prototype.updateMetadata = function()
	{
		if(this.particle !== null)
		{
			this.setName(this.particle.name);
			this.name.setText(this.particle.name);
			
			// Check if object has a parent
			if(this.particle.parent === null)
			{
				this.close();
				return;
			}

			// Check if object exists in parent
			var children = this.particle.parent.children;
			for(var i = 0; i < children.length; i++)
			{
				if(this.particle.uuid === children[i].uuid)
				{
					return;
				}
			}

			// If not found close tab
			if(i >= children.length)
			{
				this.close();
			}
		}
	};

	// Attach particle to particle editor
	ParticleEditor.prototype.attach = function(particle)
	{
		// Attach particle
		this.particle = particle;
		this.updateMetadata();
		
		// Group attributes
		this.name.setText(particle.name);
		this.texture.setValue(particle.group.texture);
		this.maxParticleCount.setValue(particle.group.maxParticleCount);
		this.blending.setValue(particle.group.blending);
		this.direction.setValue(particle.emitter.direction);

		// Emitter attributes
		this.particleCount.setValue(particle.emitter.particleCount);
		if(particle.emitter.duration !== null)
		{
			this.duration.setValue(particle.emitter.duration);
		}
		else
		{
			this.duration.setValue(0);
		}
		this.type.setValue(particle.emitter.type);
		this.maxAgeValue.setValue(particle.emitter.maxAge.value);
		this.maxAgeSpread.setValue(particle.emitter.maxAge.spread);
		this.positionValue.setValue(particle.emitter.position.value);
		this.positionSpread.setValue(particle.emitter.position.spread);
		this.velocityValue.setValue(particle.emitter.velocity.value);
		this.velocitySpread.setValue(particle.emitter.velocity.spread);
		this.accelerationValue.setValue(particle.emitter.acceleration.value);
		this.accelerationSpread.setValue(particle.emitter.acceleration.spread);
		this.wiggleValue.setValue(particle.emitter.wiggle.value);
		this.wiggleSpread.setValue(particle.emitter.wiggle.spread);

		this.opacity.setValue(particle.emitter.opacity.value);
		this.opacity.setValue(particle.emitter.opacity.spread, "spread");

		this.scale.setValue(particle.emitter.size.value);
		this.scale.setValue(particle.emitter.size.spread, "spread");
		this.scaleMin.setValue(this.scale.min);
		this.scaleMax.setValue(this.scale.max);

		this.angle.setValue(particle.emitter.angle.value);
		this.angle.setValue(particle.emitter.angle.spread, "spread");
		this.angleMin.setValue(this.angle.min);
		this.angleMax.setValue(this.angle.max);

		this.colorValue.setValue(particle.emitter.color.value);

		var colorSpread = [];
		for(var i = 0; i < 4; i++)
		{
			var color = particle.emitter.color.spread[i];
			colorSpread.push(new three.Color(color.x, color.y, color.z));
		}
		this.colorSpread.setValue(colorSpread);

		// Create runtime particle to preview particle
		this.particle.reload();
	};

	// Update camera position and rotation from variables
	ParticleEditor.prototype.updateCamera = function()
	{
		// Calculate direction vector
		var cosAngleY = Math.cos(this.cameraRotation.y);
		var position = new three.Vector3(this.cameraDistance * Math.cos(this.cameraRotation.x) * cosAngleY, this.cameraDistance * Math.sin(this.cameraRotation.y), this.cameraDistance * Math.sin(this.cameraRotation.x)*cosAngleY);
		this.camera.position.copy(position);
		this.camera.lookAt(new three.Vector3(0, 0, 0));
	};

	ParticleEditor.prototype.isAttached = function(particle)
	{
		return this.particle === particle;
	};

	ParticleEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);

		this.mouse.create();
	};

	ParticleEditor.prototype.deactivate = function()
	{
		TabComponent.prototype.deactivate.call(this);

		this.mouse.dispose();
	};

	ParticleEditor.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);
		
		this.mouse.dispose();
		this.canvas.destroy();
	};

	// Update material editor
	ParticleEditor.prototype.update = function()
	{
		this.mouse.update();

		if(this.mouse.insideCanvas())
		{
			// Move camera
			if(this.mouse.buttonPressed(Mouse.LEFT))
			{
				this.cameraRotation.x -= 0.003 * this.mouse.delta.x;
				this.cameraRotation.y -= 0.003 * this.mouse.delta.y;

				// Limit Vertical Rotation to 90 degrees
				if(this.cameraRotation.y < -1.57)
				{
					this.cameraRotation.y = -1.57;
				}
				else if(this.cameraRotation.y > 1.57)
				{
					this.cameraRotation.y = 1.57;
				}
			}

			// Camera zoom
			this.cameraDistance += this.mouse.wheel * 0.005;
			if(this.cameraDistance < 0.1)
			{
				this.cameraDistance = 0.1;
			}

			this.updateCamera();
		}
		
		this.particle.matrixWorld.getInverse(this.scene.matrixWorld);

		// Render grid and axis
		this.canvas.renderer.clear(true, true, true);
		this.canvas.renderer.render(this.scene, this.camera);
		this.canvas.renderer.render(this.particle, this.camera);
	};

	ParticleEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.main.size.copy(this.size);
		this.main.updateInterface();
	};

	/**
	 * Code editor tab element based on the codemirror code editor library.
	 *
	 * @class CodeEditor
	 * @extends {TabComponent}
	 */
	function CodeEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.codeEditor, Global.FILE_PATH + "icons/misc/code.png");

		var self = this;

		/**
		 * CodeMirror editor instance should be used to access any codemirror functionality.
		 * 
		 * @property code
		 * @type {CodeMirror}
		 */
		this.code = new CodeMirror(this.element,
		{
			value: "",
			hintOptions:
			{
				hint: CodeMirror.hint.anyword,
				completeSingle: false
			},
			gutters: ["CodeMirror-lint-markers"]
		});
		
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			var refactor = context.addMenu(Locale.refactor);
			refactor.addOption(Locale.rename, function()
			{
				self.server.rename(self.code);
			});

			refactor.addOption(Locale.select, function()
			{
				self.server.selectName(self.code);
			});

			context.addOption(Locale.search, function()
			{
				self.code.execCommand("find");
			});

			context.addOption(Locale.replace, function()
			{
				self.code.execCommand("replace");
			});

			context.addOption(Locale.replaceAll, function()
			{
				self.code.execCommand("replaceAll");
			});

			context.addOption(Locale.documentation, function()
			{
				self.server.jumpToDef(self.code);
			});

			context.addOption(Locale.copy, function()
			{
				var text = self.code.getSelection();
				if(text !== "")
				{
					Editor$1.clipboard.set(text, "text");
				}
			});
			context.addOption(Locale.cut, function()
			{
				var text = self.code.getSelection();
				if(text !== "")
				{
					Editor$1.clipboard.set(text, "text");
					self.code.replaceSelection("");
				}
			});
			context.addOption(Locale.paste, function()
			{
				self.code.replaceSelection(Editor$1.clipboard.get("text"));
			});
			context.addOption(Locale.autoIndent, function()
			{
				self.code.execCommand("indentAuto");
			});
			context.addOption(Locale.selectAll, function()
			{
				self.code.execCommand("selectAll");
			});
			context.addOption(Locale.undo, function()
			{
				self.code.execCommand("undo");
			});
			context.addOption(Locale.redo, function()
			{
				self.code.execCommand("redo");
			});
			context.updateInterface();
		};

		/**
		 * Event manager to for the resize scroll event.
		 *
		 * @property manager
		 * @type {EventManager}
		 */
		this.manager = new EventManager();
		this.manager.addScrollEvent(this.element, function(event)
		{
			if(event.ctrlKey && event.deltaY !== 0)
			{
				event.preventDefault();
				self.setFontSize(Editor$1.settings.code.fontSize - event.deltaY / 100);
			}
		});
		this.manager.create();
	}

	CodeEditor.prototype = Object.create(TabComponent.prototype);

	CodeEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);

		this.updateSettings();
	};

	CodeEditor.prototype.updateSettings = function()
	{
		this.setFontSize(Editor$1.settings.code.fontSize);

		this.code.setOption("lint", {options: Editor$1.settings.jslint});
		this.code.setOption("theme", Editor$1.settings.code.theme);
		this.code.setOption("lineNumbers", Editor$1.settings.code.lineNumbers);
		this.code.setOption("lineWrapping", Editor$1.settings.code.lineWrapping);
		this.code.setOption("keyMap", Editor$1.settings.code.keymap);
		this.code.setOption("autoCloseBrackets", Editor$1.settings.code.autoCloseBrackets);
		this.code.setOption("styleActiveLine", Editor$1.settings.code.highlightActiveLine);
		this.code.setOption("showMatchesOnScrollbar", Editor$1.settings.code.showMatchesOnScrollbar);
		this.code.setOption("dragDrop", Editor$1.settings.code.dragFiles);
		this.code.setOption("indentWithTabs", Editor$1.settings.code.indentWithTabs);
		this.code.setOption("tabSize", Editor$1.settings.code.tabSize);
		this.code.setOption("indentUnit", Editor$1.settings.code.indentUnit);
		this.code.setOption("smartIndent", Editor$1.settings.code.smartIndent);
		this.code.setOption("matchBrackets", Editor$1.settings.code.matchBrackets);
		this.code.setOption("vimMode", Editor$1.settings.code.vimMode);
	};

	/**
	 * Set code editor font size.
	 *
	 * @method setFontSize
	 * @param {number} size
	 */
	CodeEditor.prototype.setFontSize = function(size)
	{
		if(size < 5)
		{
			size = 5;
		}

		Editor$1.settings.code.fontSize = size;
		this.code.display.wrapper.style.fontSize = size + "px";
	};

	/**
	 * Get the code open in the editor.
	 *
	 * @method getText
	 * @return {string} The code in the editor.
	 */
	CodeEditor.prototype.getText = function()
	{
		return this.code.getValue();
	};

	/**
	 * Set the code open in the editor.
	 *
	 * @method getText
	 * @param {string} text Code to put in the editor.
	 */
	CodeEditor.prototype.setText = function(text)
	{
		this.code.setValue(text);
	};

	/**
	 * Set language mode (javascript, glsl, etc).
	 *
	 * @method setLanguage
	 * @param {string} mode Language mode.
	 */
	CodeEditor.prototype.setLanguage = function(mode)
	{
		this.code.setOption("mode", mode);
	};

	/**
	 * Set onchange callback.
	 *
	 * @method setOnChange
	 * @param {Function} callback
	 */
	CodeEditor.prototype.setOnChange = function(callback)
	{
		this.code.on("change", callback);
	};

	CodeEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.code.setSize(this.size.x, this.size.y);
	};

	/**
	 * The script editor is used to view and edit code of script objects.
	 *
	 * @class ScriptEditor
	 * @extends {CodeEditor}
	 */
	function ScriptEditor(parent, closeable, container, index)
	{
		CodeEditor.call(this, parent, closeable, container, index);

		var self = this;

		this.setLanguage("javascript");
		this.updateSettings();

		/**
		 * Tern server used to provide code analysis.
		 *
		 * @attribute server
		 * @type {CodeMirror.TernServer}
		 */
		this.server = new CodeMirror.TernServer(
		{
			caseInsensitive: false,
			defs: Editor$1.ternDefinitions
		});

		this.code.setOption("extraKeys",
		{
			"Ctrl-Space": function(cm){self.server.complete(cm);}
		});

		// Change
		this.code.on("change", function(cm)
		{
			if(!cm.state.focused)
			{
				return;
			}

			self.updateCode();
		});

		// Cursor activity event
		this.code.on("cursorActivity", function(cm)
		{
			self.server.updateArgHints(cm);
		});

		// Key pressed event
		this.code.on("keypress", function(cm, event)
		{
			var typed = String.fromCharCode(event.charCode);

			if(/[\w\.]/.exec(typed))
			{
				self.server.complete(cm);

				// If there is no tern sugestion suggest known words
				if(cm.state.completionActive == null || cm.state.completionActive.widget === null)
				{
					CodeMirror.commands.autocomplete(cm, null);
				}
			}
		});

		/**
		 * Scroll position
		 *
		 * @attribute scroll
		 * @type {Object}
		 */
		this.scroll = null;

		/**
		 * Script object attached to code editor.
		 *
		 * @attribute script
		 * @type {Script}
		 */
		this.script = null;
	}

	ScriptEditor.prototype = Object.create(CodeEditor.prototype);

	ScriptEditor.prototype.updateMetadata = function()
	{
		// Name
		this.setName(this.script.name);

		// Check if object has a parent
		if(this.script.parent === null)
		{
			this.close();
			return;
		}

		// Check if object exists in parent
		var children = this.script.parent.children;
		for(var i = 0; i < children.length; i++)
		{
			if(this.script.uuid === children[i].uuid)
			{
				return;
			}
		}

		// If not found close tab
		if(i >= children.length)
		{
			this.close();
		}
	};

	ScriptEditor.prototype.activate = function()
	{
		CodeEditor.prototype.activate.call(this);

		this.updateCode();
	};

	ScriptEditor.prototype.isAttached = function(script)
	{
		return this.script === script;
	};

	ScriptEditor.prototype.attach = function(script)
	{
		this.script = script;
		this.setText(script.code);
		this.updateMetadata();
	};

	/**
	 * Update the attached object script code.
	 *
	 * @method updateCode
	 */
	ScriptEditor.prototype.updateCode = function()
	{
		if(this.script !== null)
		{
			this.script.code = this.code.getValue();
		}
	};

	/**
	 * Check box input element.
	 * 
	 * @class CheckBox
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function CheckBox(parent)
	{
		Component.call(this, parent, "div");

		var self = this;

		this.element.style.display = "block";
		this.element.style.boxSizing = "border-box";
		this.element.style.cursor = "pointer";
		this.element.style.backgroundColor = "var(--box-color)";
		this.element.style.borderRadius = "4px";
		this.element.onclick = function()
		{
			self.setValue(!self.value);
			
			if(self.onChange !== null)
			{
				self.onChange(self.value);
			}
		};

		this.check = document.createElement("img");
		this.check.style.visibility = "hidden";
		this.check.style.pointerEvents = "none";
		this.check.style.position = "absolute";
		this.check.style.top = "20%";
		this.check.style.left = "20%";
		this.check.style.width = "60%";
		this.check.style.height = "60%";
		this.check.src = Global.FILE_PATH + "icons/misc/check.png";
		this.element.appendChild(this.check);

		/**
		 * Value stored in the checkbox.
		 *
		 * @property value
		 * @type {boolean}
		 */
		this.value = false;

		/**
		 * On change callback function.
		 *
		 * @property onChange
		 * @type {Function}
		 */
		this.onChange = null;

		/** 
		 * If the checkbox is disabled the value cannot be edited.
		 *
		 * @attribute disabled
		 * @type {boolean}
		 */
		this.disabled = false;
	}
	CheckBox.prototype = Object.create(Component.prototype);

	/**
	 * Set if element is disabled.
	 *
	 * When disabled the checkbox value cannot be edited.
	 *
	 * @method setDisabled
	 */
	CheckBox.prototype.setDisabled = function(value)
	{
		this.disabled = value;
		
		if(this.disabled === true)
		{
			this.element.style.cursor = "initial";
			this.element.style.pointerEvents = "none";
		}
		else
		{
			this.element.style.cursor = "pointer";
			this.element.style.pointerEvents = "auto";
		}
	};

	/**
	 * Set checkbox value.
	 * 
	 * @method setValue
	 * @param {boolean} value
	 */
	CheckBox.prototype.setValue = function(value)
	{
		this.value = value;
		this.check.style.visibility = this.value ? "visible" : "hidden";
	};

	/**
	 * Get checkbox value.
	 * 
	 * @method getValue
	 * @return {boolean} Value from the element.
	 */
	CheckBox.prototype.getValue = function()
	{
		return this.value;
	};

	/**
	 * Set onchange callback.
	 * 
	 * @method setOnChange
	 * @param {Function} callback
	 */
	CheckBox.prototype.setOnChange = function(callback)
	{
		this.onChange = callback;
	};

	CheckBox.prototype.updateVisibility = function()
	{
		this.element.style.visibility = this.visible ? "visible" : "hidden";
	};

	CheckBox.prototype.updateSize = function()
	{
		this.element.style.width = this.size.y + "px";
		this.element.style.height = this.size.y + "px";
	};

	function PassNode(parent, name)
	{
		TableForm.call(this, parent);

		this.element.style.overflow = "hidden"; 
		
		this.defaultTextWidth = 60;
		this.position.set(10, 5);
		this.spacing.set(5, 5);

		// Pass
		this.pass = null;
		this.composer = null;
		this.editor = null;

		// Render pass
		this.addText(name !== undefined ? name : "Pass Node");
		this.nextRow();

		var self = this;

		// Enabled
		this.addText(Locale.enabled);
		this.enabled = new CheckBox(this);
		this.enabled.size.set(18, 18);
		this.enabled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.pass, "enabled", self.enabled.getValue()));
		});
		this.add(this.enabled);
		this.nextRow();

		// Clear
		this.addText(Locale.clear);
		this.clear = new CheckBox(this);
		this.clear.size.set(18, 18);
		this.clear.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.pass, "clear", self.clear.getValue()));
		});
		this.add(this.clear);
		this.nextRow();

		// Render to screen
		this.addText("Output");
		this.renderToScreen = new CheckBox(this);
		this.renderToScreen.size.set(18, 18);
		this.renderToScreen.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.pass, "renderToScreen", self.renderToScreen.getValue()));
		});
		this.add(this.renderToScreen);
		this.nextRow();

		// Up
		this.up = new ButtonText(this);
		this.up.size.set(50, 18);
		this.up.setText("Up");
		this.up.setOnClick(function()
		{
			self.composer.moveBack(self.pass);
			self.editor.updatePostNodes();
		});

		// Down
		this.down = new ButtonText(this);
		this.down.size.set(50, 18);
		this.down.setText("Down");
		this.down.setOnClick(function()
		{
			self.composer.moveForward(self.pass);
			self.editor.updatePostNodes();
		});

		// Delete
		this.delete = new ButtonText(this);
		this.delete.size.set(70, 18);
		this.delete.setText(Locale.delete);
		this.delete.setOnClick(function()
		{
			self.composer.removePass(self.pass);
			self.editor.updatePostNodes();
		});
	}

	PassNode.prototype = Object.create(TableForm.prototype);

	PassNode.passes = {};

	PassNode.createPass = function(element, type)
	{
		if(PassNode.passes[type] !== undefined)
		{
			return new PassNode.passes[type](element);
		}

		return new PassNode(element, type);
	};

	PassNode.registerPass = function(type, Constructor)
	{
		PassNode.passes[type] = Constructor;
	};

	PassNode.prototype.setPass = function(pass)
	{
		this.pass = pass;

		this.enabled.setValue(pass.enabled);
		this.clear.setValue(pass.clear);
		this.renderToScreen.setValue(pass.renderToScreen);
	};

	PassNode.prototype.setComposer = function(composer)
	{
		this.composer = composer;
	};

	PassNode.prototype.setEditor = function(editor)
	{
		this.editor = editor;

		this.add(this.up);
		this.add(this.down);
		this.add(this.delete);
	};

	function CameraEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, "camera", Global.FILE_PATH + "icons/camera/camera.png");

		var self = this;

		this.camera = null;
		
		// Canvas
		this.canvas = new RendererCanvas(undefined, Editor$1.getRendererConfig());

		this.form = new TableForm();
		this.form.setAutoSize(false);

		// Main
		this.main = new DualContainer(this);
		this.main.tabPosition = 0.6;
		this.main.attachA(this.canvas);
		this.main.attachB(this.form);

		// Camera
		this.form.addText(Locale.camera);
		this.form.nextRow();

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(200, 18);
		this.name.setOnChange(function()
		{
			if(self.camera !== null)
			{
				Editor$1.addAction(new ChangeAction(self.camera, "name", self.name.getText()));
				Editor$1.updateObjectsViewsGUI();
			}
		});
		this.form.add(this.name);
		this.form.nextRow();

		this.form.addText(Locale.postProcessing);
		this.form.nextRow();

		var addRenderPassButton = function(name, PassConstructor)
		{
			var button = new ButtonText(self.form);
			button.size.set(100, 18);
			button.text.setText(name);
			button.setOnClick(function()
			{
				var pass = new PassConstructor();

				var composer = self.camera.composer;
				pass.renderToScreen = true;
				for(var i = 0; i < composer.passes.length; i++)
				{
					composer.passes[i].renderToScreen = false;
				}
				
				self.camera.composer.addPass(pass);
				self.updatePostNodes();
			});
			self.form.add(button);
		};


		addRenderPassButton(Locale.render, RenderPass);
		addRenderPassButton("FXAA", FXAAPass);
		addRenderPassButton("Colorify", ColorifyPass);
		self.form.nextRow();
		addRenderPassButton("Unreal Bloom", UnrealBloomPass);
		addRenderPassButton("Bloom", BloomPass);
		addRenderPassButton("Hue & Saturation", HueSaturationPass);
		self.form.nextRow();
		addRenderPassButton("SSAO NOH", SSAONOHPass);
		addRenderPassButton("Bokeh", BokehPass);
		addRenderPassButton("Technicolor", TechnicolorPass);
		self.form.nextRow();
		addRenderPassButton("Film", FilmPass);
		addRenderPassButton("Dot Screen", DotScreenPass);
		addRenderPassButton("Sobel", SobelPass);
		self.form.nextRow();
		addRenderPassButton("SSAO", SSAOPass);
		addRenderPassButton(Locale.copy, CopyPass);
		addRenderPassButton("Adaptive Tone Mapping", AdaptiveToneMappingPass);
		self.form.nextRow();
		addRenderPassButton("After image", AfterimagePass);
		self.form.nextRow();
		
		this.postNodes = new TableForm(this.form);
		this.form.add(this.postNodes);
		this.form.nextRow();
	}

	CameraEditor.prototype = Object.create(TabComponent.prototype);

	// Activate
	CameraEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);

		this.name.setText(this.camera.name);
		this.updatePostNodes();
	};

	// Update post processing nodes
	CameraEditor.prototype.updatePostNodes = function()
	{
		this.postNodes.removeAll();

		var passes = this.camera.composer.passes;
		for(var i = 0; i < passes.length; i++)
		{
			var node = PassNode.createPass(this.postNodes.element, passes[i].type);
			node.setPass(passes[i]);
			node.setComposer(this.camera.composer);
			node.setEditor(this);

			this.postNodes.add(node);
			this.postNodes.nextRow();
		}
		
		this.postNodes.updateInterface();
		this.form.updateInterface();
	};

	// Destroy
	CameraEditor.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);

		this.canvas.destroy();
	};

	// Update tab state
	CameraEditor.prototype.update = function()
	{
		if(this.camera !== null)
		{
			this.camera.aspect = this.canvas.size.x / this.canvas.size.y;
			this.camera.updateProjectionMatrix();
			this.camera.resize(this.canvas.size.x, this.canvas.size.y);
			this.camera.render(this.canvas.renderer, this.camera.getScene());
		}
	};

	// Update tab metadata
	CameraEditor.prototype.updateMetadata = function()
	{
		if(this.camera !== null)
		{
			this.setName(this.camera.name);
			this.name.setText(this.camera.name);

			// Check if object has a parent
			if(this.camera.parent === null)
			{
				this.close();
				return;
			}

			// Check if object exists in parent
			var children = this.camera.parent.children;
			for(var i = 0; i < children.length; i++)
			{
				if(this.camera.uuid === children[i].uuid)
				{
					return;
				}
			}

			// If not found close tab
			if(i >= children.length)
			{
				this.close();
			}
		}
	};

	CameraEditor.prototype.attach = function(camera)
	{
		this.camera = camera;

		this.updateMetadata();
	};

	CameraEditor.prototype.isAttached = function(camera)
	{
		return this.camera === camera;
	};

	CameraEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.main.size.copy(this.size);
		this.main.updateInterface();
	};

	/**
	 * Represents a tree node element.
	 *
	 * A tree node is placed inside a tree view or inside another tree node.
	 * 
	 * @class TreeNode
	 * @param {TreeNode} parent Parent tree node.
	 */
	function TreeNode(container)
	{
		// Container
		this.container = container;

		// Attributes
		this.size = new three.Vector2(0, 0);
		this.position = new three.Vector2(0, 0);
		this.visible = true;

		// Object attached
		this.object = null;
		this.uuid = null;
		this.folded = false;
		this.selected = false;

		// Children and parent tree nodes
		this.parent = null;
		this.children = [];
		this.level = 0;

		// Element
		this.element = document.createElement("div");
		this.element.style.position = "absolute";
		this.element.draggable = true;
		this.element.style.left = "0px";
		this.element.style.height = "20px";
		this.element.style.width = "100%";
		this.element.style.cursor = "pointer";
		this.element.style.boxSizing = "border-box";
		this.container.element.appendChild(this.element);

		// Arrow
		this.arrow = document.createElement("img");
		this.arrow.draggable = false;
		this.arrow.style.position = "absolute";
		this.arrow.style.opacity = 0.5;
		this.arrow.style.width = "15px";
		this.arrow.style.height = "15px";
		this.arrow.style.left = "5px";
		this.arrow.style.top = "3px";
		this.element.appendChild(this.arrow);

		// Icon
		this.icon = document.createElement("img");
		this.icon.draggable = false;
		this.icon.style.position = "absolute";
		this.icon.style.pointerEvents = "none";
		this.icon.style.width = "15px";
		this.icon.style.height = "15px";
		this.icon.style.left = "25px";
		this.icon.style.top = "3px";
		this.element.appendChild(this.icon);

		// Label
		this.label = document.createElement("span");
		this.label.style.overflow = "hidden";
		this.label.style.position = "absolute";
		this.label.style.pointerEvents = "none";
		this.label.style.whiteSpace = "nowrap";
		this.label.style.top = "3px";
		this.element.appendChild(this.label);

		// Label text
		this.labelText = document.createTextNode("");
		this.label.appendChild(this.labelText);

		var self = this;
		var dragState = TreeNode.NONE;

		this.arrow.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};

		this.arrow.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};

		this.arrow.onclick = function(event)
		{
			event.stopPropagation();
			
			self.updateFoldedState(!self.folded);
		};

		this.element.onmouseenter = function()
		{
			if(!self.selected)
			{
				self.styleMouseOver();
			}
		};

		this.element.onmouseleave = function()
		{
			if(!self.selected)
			{
				self.styleNormal();
			}
		};

		this.element.ondragstart = function(event)
		{
			if(!self.object.locked)
			{
				event.dataTransfer.setData("uuid", self.object.uuid);
				DragBuffer.push(self.object);
			}
		};

		this.element.ondragend = function(event)
		{
			event.preventDefault();

			dragState = TreeNode.NONE;
			self.clearBorder();

			if(!self.object.locked)
			{
				DragBuffer.pop(self.object.uuid);
			}
		};

		this.element.ondragleave = function()
		{
			event.preventDefault();

			dragState = TreeNode.NONE;
			self.clearBorder();
		};

		this.element.oncontextmenu = function(event)
		{
			if(!self.object.locked)
			{
				// Scene and program flags
				var isProgram = self.object instanceof Program;
				var isScene = self.object instanceof Scene;

				// Context menu
				var context = new ContextMenu(DocumentBody);
				context.size.set(150, 20);
				context.position.set(event.clientX, event.clientY);
				
				// Open editor
				if(isScene)
				{
					context.addOption(Locale.sceneEditor, openSceneTab);
				}
				else if(isProgram)
				{
					context.addOption(Locale.createScene, function()
					{
						Editor$1.addDefaultScene();
					});			
				}
				else if(self.object.isObject3D === true)
				{
					context.addOption(Locale.objectEditor, openSceneTab);

					if(self.object instanceof Script)
					{
						context.addOption(Locale.scriptEditor, openScriptTab);
					}
					else if(self.object instanceof ParticleEmitter)
					{
						context.addOption(Locale.particleEditor, openParticleTab);
					}
				}
		
				if(self.object instanceof LightProbe)
				{
					context.addOption(Locale.calculateProbe, function()
					{
						self.object.generate();
					});
				}

				// Group objects
				context.addOption(Locale.groupObjects, function()
				{
					// TODO <USE THE MOVE ACTIONS INSTEAD TO KEEP EVERYTHING ON THE SAME POSITION>
					
					var actions = [];
					var group = new Container();
					var parent = self.object.parent;
					var found = false;

					for(var i = 0; i < Editor$1.selection.length; i++)
					{
						if(Editor$1.selection[i] instanceof three.Object3D)
						{
							actions.push(new RemoveAction(Editor$1.selection[i]));
							group.add(Editor$1.selection[i]);

							if(Editor$1.selection[i] === self.object)
							{
								found = true;
							}
						}
					}

					if(!found)
					{
						actions.push(new RemoveAction(self.object));
						group.add(self.object);
					}

					actions.push(new AddAction(group, parent));
					Editor$1.addAction(new ActionBundle(actions));
				});

				// Recalculate Origin
				context.addOption(Locale.centerOrigin, function()
				{
					ObjectUtils.centerGeometryOrigin(self.object);
				});

				// Rename
				context.addOption(Locale.rename, function()
				{
					Editor$1.renameObject(self.object);
				});

				// Delete
				if(!isProgram)
				{
					context.addOption(Locale.delete, function()
					{
						Editor$1.deleteObject(self.object);
					});
				}

				// Mesh specific stuff
				if(self.object instanceof three.Mesh || self.object instanceof three.SkinnedMesh || self.object instanceof three.InstancedMesh)
				{
					// If mesh has a geometry attached
					if(self.object.geometry !== undefined)
					{
						// Generate normals for the attached geometry
						context.addOption(Locale.computeNormals, function()
						{
							var geometry = self.object.geometry.clone();
							geometry.computeVertexNormals();
							Editor$1.addAction(new ChangeAction(self.object, "geometry", geometry));
						});

						// Apply transformation to geometry
						context.addOption(Locale.applyTransformation, function()
						{
							var geometry = self.object.geometry.clone();
							geometry.applyMatrix4(self.object.matrixWorld);

							var actions = [];
							actions.push(new ChangeAction(self.object, "geometry", geometry));
							actions.push(new ChangeAction(self.object, "position", new three.Vector3(0, 0, 0)));
							actions.push(new ChangeAction(self.object, "scale", new three.Vector3(1, 1, 1)));
							actions.push(new ChangeAction(self.object, "quaternion", new three.Quaternion(0, 0, 0, 1)));
							Editor$1.addAction(new ActionBundle(actions));
						});
					}
				}

				// Convert mesh to instanced mesh
				if(self.object instanceof three.Mesh && self.object.geometry !== undefined)
				{
					context.addOption(Locale.toInstancedMesh, function()
					{
						var instanced = new three.InstancedMesh(self.object.geometry, self.object.material, 1);
						instanced.position.copy(self.object.position);
						instanced.scale.copy(self.object.scale);
						instanced.quaternion.copy(self.object.quaternion);

						Editor$1.addAction(new SwapAction(self.object, instanced));
					});
				}

				// Add physics to object
				if(self.object instanceof three.Mesh || self.object instanceof three.SkinnedMesh)
				{
					// Add physics object
					function createPhysics(object, mode)
					{
						var physics = new PhysicsObject();
						physics.addShape(PhysicsGenerator.createShape(object, mode));
						physics.name = object.name;
						physics.position.copy(object.position);
						physics.quaternion.copy(object.quaternion);

						object.position.set(0, 0, 0);
						object.quaternion.set(0, 0, 0, 1);

						var actions = [];
						actions.push(new SwapAction(object, physics, true));
						actions.push(new AddAction(object, physics));
						Editor$1.addAction(new ActionBundle(actions));
					}

					var physics = context.addMenu("Add physics");

					physics.addOption(Locale.box, function()
					{
						createPhysics(self.object, PhysicsGenerator.Type.BOX);
					});

					physics.addOption(Locale.sphere, function()
					{
						createPhysics(self.object, PhysicsGenerator.Type.SPHERE);
					});

					physics.addOption(Locale.cylinder, function()
					{
						createPhysics(self.object, PhysicsGenerator.Type.CYLINDER);
					});
		
					physics.addOption(Locale.convexHull, function()
					{
						createPhysics(self.object, PhysicsGenerator.Type.HULL);
					});
				}

				// Change attribute of an object and all its children
				function setObjectAttribute(object, attribute, value)
				{
					var actions = [];

					if(object[attribute] !== undefined)
					{
						actions.push(new ChangeAction(object, attribute, value));
					}

					object.traverse(function(child)
					{
						actions.push(new ChangeAction(child, attribute, value));
					});

					return actions;
				}
				if(!isScene && !isProgram)
				{
					var autoUpdate = context.addMenu(Locale.static);

					// Set object and children to static mode
					autoUpdate.addOption(Locale.static, function()
					{
						var actions = setObjectAttribute(self.object, "matrixAutoUpdate", false);
						Editor$1.addAction(new ActionBundle(actions));
					});

					// Set object and children to dynamic mode
					autoUpdate.addOption(Locale.dynamic, function()
					{
						var actions = setObjectAttribute(self.object, "matrixAutoUpdate", true);
						Editor$1.addAction(new ActionBundle(actions));
					});

					var shadow = context.addMenu(Locale.shadows);

					// Set object and children shadow casting mode
					shadow.addOption(Locale.enable, function()
					{
						var cast = setObjectAttribute(self.object, "castShadow", true);
						var receive = setObjectAttribute(self.object, "receiveShadow", true);
						Editor$1.addAction(new ActionBundle(cast.concat(receive)));
					});

					// Set object and children shadow casting mode
					shadow.addOption(Locale.disable, function()
					{
						var cast = setObjectAttribute(self.object, "castShadow", false);
						var receive = setObjectAttribute(self.object, "receiveShadow", false);
						Editor$1.addAction(new ActionBundle(cast.concat(receive)));
					});

					// Duplicate object
					context.addOption(Locale.duplicate, function()
					{
						var object = new ObjectLoader().parse(self.object.toJSON());
						object.traverse(function(child)
						{
							child.uuid = three.Math.generateUUID();
						});
						Editor$1.addAction(new AddAction(object, self.object.parent));
					});

					// Copy object
					context.addOption(Locale.copy, function()
					{
						Editor$1.copyObject(self.object);
					});

					// Cut object
					context.addOption(Locale.cut, function()
					{
						Editor$1.cutObject(self.object);
					});
				}
				
				if(!isProgram)
				{
					// Paste object form clipboard
					context.addOption(Locale.paste, function()
					{
						Editor$1.pasteObject(self.object);
					});
				}

				context.updateInterface();
			}
		};

		this.element.ondragover = function(event)
		{
			event.preventDefault();

			if(DragBuffer.buffer[0] instanceof TabComponent)
			{
				return;
			}

			if(!self.object.locked)
			{
				// Object drag
				if(DragBuffer.buffer[0] instanceof three.Object3D)
				{
					if(event.layerY < 5)
					{
						dragState = TreeNode.ABOVE;
					}
					else if(event.layerY > 15)
					{
						dragState = TreeNode.BELLOW;
					}
					else
					{
						dragState = TreeNode.INSIDE;
					}

					self.setBorder(dragState);
				}
				// Resources, files, etc
				else
				{
					dragState = TreeNode.INSIDE;
					self.setBorder(dragState);
				}
			}
		};

		// Drop event (fired on the drop target)
		this.element.ondrop = function(event)
		{
			event.preventDefault();
			self.clearBorder();

			if(self.object.locked)
			{
				return;
			}

			// Collect element from buffer
			var uuid = event.dataTransfer.getData("uuid");
			var object = DragBuffer.get(uuid);

			// Object 3D
			if(object instanceof three.Object3D)
			{
				if(object === self.object)
				{
					Editor$1.alert(Locale.cannotAddItself);
					return;
				}
				else if(object.contains(self.object))
				{
					Editor$1.alert(Locale.cannotAddToChildren);
					return;
				}
				else
				{
					var selfIsScene = self.object instanceof Scene;
					var selfIsProgram = self.object instanceof Program;
					var dragIsScene = object instanceof Scene;

					// Above
					if(dragState === TreeNode.ABOVE)
					{
						if((dragIsScene && selfIsScene) || (!dragIsScene && !selfIsProgram && !selfIsScene))
						{
							var index = self.object.parent.children.indexOf(self.object);
							Editor$1.addAction(new MoveAction(object, self.object.parent, index));
						}
					}
					// Bellow
					else if(dragState === TreeNode.BELLOW)
					{
						if((dragIsScene && selfIsScene) || (!dragIsScene && !selfIsProgram && !selfIsScene))
						{
							var index = self.object.parent.children.indexOf(self.object) + 1;
							Editor$1.addAction(new MoveAction(object, self.object.parent, index));
						}
					}
					// Inside
					else // if(dragState === TreeNode.INSIDE)
					{	
						if((selfIsScene && !dragIsScene) || (dragIsScene && selfIsProgram) || (!selfIsScene && !selfIsProgram && !dragIsScene))
						{
							Editor$1.addAction(new MoveAction(object, self.object));	
						}
					}
				}
			}
			// Material
			else if(object instanceof three.Material)
			{
				var actions = [];
				self.object.traverse(function(children)
				{
					if(children.material !== undefined)
					{
						actions.push(new ChangeAction(children, "material", object));
					}
				});

				if(actions.length > 0)
				{
					Editor$1.addAction(new ActionBundle(actions));
				}
			}
			// Dragged file
			else if(event.dataTransfer.files.length > 0)
			{
				var files = event.dataTransfer.files;
				for(var i = 0; i < files.length; i++)
				{
					var file = files[i];

					if(Model.fileIsModel(file))
					{
						Loaders.loadModel(file, self.object);
					}
				}
			}
		};

		this.element.onclick = function(event)
		{
			if(event.shiftKey && Editor$1.selection.length > 0 && Editor$1.selection[Editor$1.selection.length - 1].isObject3D === true)
			{
				var object = Editor$1.selection[Editor$1.selection.length - 1];
				var node = object.gui.node;

				var selecting = false;
				var done = false;
				
				Editor$1.program.traverse(function(child)
				{
					if(done === true)
					{
						return;
					}

					if(selecting === false)
					{
						if(child === object || child === self.object)
						{
							if(!Editor$1.isSelected(child))
							{
								Editor$1.addToSelection(child);
							}
							selecting = true;
						}
					}
					else
					{
						if(child === object || child === self.object)
						{
							if(!Editor$1.isSelected(child))
							{
								Editor$1.addToSelection(child);
							}

							selecting = false;
							done = true;
						}
						else
						{
							Editor$1.addToSelection(child);
						}
					}
				});
			}
			else if(event.ctrlKey)
			{
				if(Editor$1.isSelected(self.object))
				{
					Editor$1.unselectObject(self.object);
				}
				else
				{
					Editor$1.addToSelection(self.object);
				}
			}
			else
			{
				Editor$1.selectObject(self.object);
			}
		};

		this.element.ondblclick = function()
		{
			if(!self.object.locked)
			{
				if(self.object instanceof Script)
				{
					openTab(ScriptEditor, self.object);
				}
				else if(self.object instanceof Scene)
				{
					openTab(SceneEditor, self.object);
				}
				else if(self.object instanceof ParticleEmitter)
				{
					openTab(ParticleEditor, self.object);
				}
				else if(self.object instanceof three.Camera)
				{
					openTab(CameraEditor, self.object);
				}
				else
				{
					self.updateFoldedState(!self.folded);
				}
			}
		};

		function openTab(Constructor, object)
		{
			var tab = Editor$1.gui.tab.getTab(Constructor, object);
			if(tab === null)
			{
				tab = Editor$1.gui.tab.addTab(Constructor, true);
				tab.attach(self.object);
			}
			tab.select();
		}

		function openSceneTab()
		{
			openTab(SceneEditor, self.object);
		}

		function openScriptTab()
		{
			openTab(ScriptEditor, self.object);
		}

		function openParticleTab()
		{
			openTab(ParticleEditor, self.object);
		}
	}

	TreeNode.ARROW_DOWN = "source/files/icons/misc/arrow_down.png";
	TreeNode.ARROW_RIGHT = "source/files/icons/misc/arrow_right.png";

	/**
	 * Default value.
	 * 
	 * @static
	 * @attribute NONE
	 */
	TreeNode.NONE = -1;

	/**
	 * Place inside the object.
	 * 
	 * @static
	 * @attribute INSIDE
	 */
	TreeNode.INSIDE = 0;

	/**
	 * Place above object.
	 * 
	 * @static
	 * @attribute ABOVE
	 */
	TreeNode.ABOVE = 1;

	/**
	 * Place bellow object.
	 * 
	 * @static
	 * @attribute BELLOW
	 */
	TreeNode.BELLOW = 2;

	TreeNode.prototype = Object.create(Component.prototype);

	/**
	 * Clear node element border.
	 *
	 * @method clearBorder
	 */
	TreeNode.prototype.clearBorder = function()
	{
		this.element.style.border = null;
		this.element.style.borderTop = null;
		this.element.style.borderBottom = null;
	};


	/**
	 * Set base style of the tree node.
	 *
	 * @method styleNormal
	 */
	TreeNode.prototype.styleNormal = function()
	{
		this.element.style.backgroundColor = null;
	};

	/**
	 * Set style for node selected.
	 *
	 * @method styleSelected
	 */
	TreeNode.prototype.styleSelected = function()
	{
		this.element.style.backgroundColor = "var(--button-over-color)";
	};

	/**
	 * Set style of the node on mouse over
	 *
	 * @method styleMouseOver
	 */
	TreeNode.prototype.styleMouseOver = function()
	{
		this.element.style.backgroundColor = "var(--bar-color)";
	};

	/**
	 * Set selection state of this tree node.
	 * 
	 * @method setSelected
	 * @param {boolean} selected If true set selected, otherwise se unselected.
	 */
	TreeNode.prototype.setSelected = function(selected)
	{
		this.selected = selected;

		if(this.selected === true)
		{
			this.styleSelected();
		}
		else
		{
			this.styleNormal();
		}
	};

	/**
	 * Set node border.
	 * 
	 * @method setBorder
	 * @param {number} place Border position.
	 */
	TreeNode.prototype.setBorder = function(place)
	{
		this.clearBorder();

		if(place === TreeNode.ABOVE)
		{
			this.element.style.borderTop = "1px solid #999999";
		}
		else if(place === TreeNode.BELLOW)
		{
			this.element.style.borderBottom = "1px solid #999999";
		}
		else // if(place === TreeNode.INSIDE)
		{
			this.element.style.border = "1px solid #999999";
		}
	};

	/**
	 * Attach a object to this tree element, the icon and name of the node is set automatically.
	 * 
	 * @method attach
	 * @param {Object3D} object
	 */
	TreeNode.prototype.attach = function(object)
	{
		this.object = object;
		this.object.gui = {node: this};

		this.uuid = object.uuid;
		this.folded = object.folded;
		this.setSelected(Editor$1.isSelected(object));

		this.element.draggable = !object.locked;
		this.labelText.data = object.name;
		this.icon.src = this.object.locked ? ObjectIcons.locked : ObjectIcons.get(object.type);
		this.arrow.src = this.folded ? TreeNode.ARROW_RIGHT : TreeNode.ARROW_DOWN;
	};

	/**
	 * Add tree element from object.
	 *
	 * @method addObject
	 * @param {Object3D} object
	 */
	TreeNode.prototype.addObject = function(object)
	{
		var element = new TreeNode(this.container);
		element.attach(object);
		element.parent = this;
		this.children.push(element);
		return element;
	};

	/**
	 * Add tree node from object.
	 *
	 * @method insertObject
	 * @param {Object3D} object
	 * @param {number} index
	 */
	TreeNode.prototype.insertObject = function(object, index)
	{
		var element = new TreeNode(this.container);
		element.attach(object);
		element.parent = this;
		this.children.splice(index, 0, element);
		return element;
	};

	/**
	 * Remove element using its uuid.
	 *
	 * @method removeElementUUID
	 */
	TreeNode.prototype.removeElementUUID = function(uuid)
	{	
		for(var i = 0; i < this.children.length; i++)
		{
			if(this.children[i].uuid === uuid)
			{
				break;
			}
		}

		if(i < this.children.length)
		{
			var element = this.children[i];
			this.children.splice(i, 1);
			return element;
		}

		return null;
	};

	/**
	 * Update folded state for this tree element.
	 *
	 * @method updatedFoldedState
	 * @param {boolean} folded.
	 */
	TreeNode.prototype.updateFoldedState = function(folded)
	{
		if(folded !== undefined)
		{
			this.folded = folded;
		}

		this.object.folded = this.folded;
		this.arrow.src = this.folded ? TreeNode.ARROW_RIGHT : TreeNode.ARROW_DOWN;
		this.container.updateChildPosition();
	};

	/**
	 * Expand all elements from this node to the root.
	 *
	 * @method expandToRoot
	 */
	TreeNode.prototype.expandToRoot = function()
	{
		var parent = this.parent;

		while(parent !== null)
		{
			parent.updateFoldedState(false);
			parent.setVisibility(true);
			parent = parent.parent;
		}
		
		this.element.scrollIntoView({behavior: "smooth", block: "center", inline: "center"});
	};

	TreeNode.prototype.destroy = function()
	{
		if(this.container.element.contains(this.element))
		{
			this.container.element.removeChild(this.element);
		}
		
		for(var i = 0; i < this.children.length; i++)
		{
			this.children[i].destroy();
		}
	};

	TreeNode.prototype.updateInterface = function()
	{
		if(this.visible)
		{
			var offset = this.level * 20;

			// Arrow
			if(this.object.isEmpty())
			{
				this.arrow.style.display = "none";
			}
			else
			{
				this.arrow.style.display = "block";
				this.arrow.style.left = (5 + offset) + "px";
			}

			this.icon.style.left = (25 + offset) + "px";
			this.label.style.left = (45 + offset) + "px";
			this.labelText.data = this.object.name;

			this.element.style.display = "block";
			this.element.style.top = this.position.y + "px";

			for(var i = 0; i < this.children.length; i++)
			{
				this.children[i].updateInterface();
			}
		}
		else
		{
			this.element.style.display = "none";
		}
	};

	/**
	 * Search box input element.
	 * 
	 * @class SearchBox
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function SearchBox(parent)
	{
		Component.call(this, parent, "div");

		/**
		 * Input text box of the search box.
		 *
		 * @property search
		 * @type {TextBox}
		 */
		this.search = new TextBox(this);
		this.search.setMode(Component.TOP_RIGHT);
		this.search.element.placeholder = Locale.search;

		/**
		 * Search icon.
		 *
		 * @property searchIcon
		 * @type {Component}
		 */
		this.searchIcon = new ImageContainer(this);
		this.searchIcon.setImage(Global.FILE_PATH + "icons/misc/search.png");
	}

	SearchBox.prototype = Object.create(Component.prototype);

	SearchBox.prototype.setOnChange = function(callback)
	{
		this.search.setOnInput(callback, 100);
	};

	SearchBox.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		this.searchIcon.size.set(this.size.y * 0.6, this.size.y * 0.6);
		this.searchIcon.position.set(this.size.y * 0.2, this.size.y * 0.2);
		this.searchIcon.updateInterface();

		this.search.size.set(this.size.x - this.size.y * 1.4, this.size.y * 0.8);
		this.search.position.set(this.size.y * 0.2, this.size.y * 0.1);
		this.search.updateInterface();
	};

	/**
	 * TreeView component is used to represent a object tree.
	 *
	 * Each tree entry represents direclty a Object3D object present in the editor.
	 * 
	 * @class TreeView
	 * @extends {TabComponent}
	 * @param {Component} parent Parent element.
	 * @param {boolean} closeable If the tab is closeable.
	 * @param {TabGroup} container The container where this tab is inserted.
	 * @param {number} index Index inside the container button array.
	 */
	function TreeView(parent, closeable, container, index)
	{	
		TabComponent.call(this, parent, closeable, container, index, "Project Explorer", Global.FILE_PATH + "icons/misc/menu.png");

		var self = this;

		this.element.style.overflow = "auto";
		this.element.style.backgroundColor = null;

		this.search = new SearchBox(this);
		this.search.element.style.backgroundColor = "var(--bar-color)";
		this.search.setOnChange(function()
		{	
			self.selectByName(self.search.search.getText());
		});

		this.program = null;
		this.root = null;
	}

	TreeView.prototype = Object.create(TabComponent.prototype);

	/**
	 * Select tree nodes by their name.
	 *
	 * All nodes that contain the name will be selected.
	 *
	 * @method selectByName
	 * @param {string} name String with portion of the name to be found and filtered.
	 */
	TreeView.prototype.selectByName = function(search)
	{
		search = search.toLowerCase();

		Editor$1.clearSelection();

		function filterRecursive(node)
		{
			var text = node.object.name.toLowerCase();
			if(text.search(search) !== -1)
			{
				Editor$1.addToSelection(node.object);
			}

			for(var i = 0; i < node.children.length; i++)
			{
				filterRecursive(node.children[i]);
			}
		}

		filterRecursive(this.root);
	};


	/**
	 * Attach a program to the tree view.
	 *
	 * @method attach
	 */
	TreeView.prototype.attach = function(program)
	{	
		if(this.program === program)
		{
			return;
		}

		this.program = program;

		// Destroy old root object
		if(this.root !== null)
		{
			this.root.destroy();
			this.root = null;
		}

		// Create program tree
		this.buildTree();
		this.updateChildPosition();
	};

	/**
	 * Traverse the whole tree view and call the callback method.
	 * 
	 * The callback method receives the object attached to the tree and the depth.
	 * 
	 * @method traverse
	 * @param {Function} callback Callback function(treeNode)
	 */
	TreeView.prototype.traverse = function(callback)
	{
		function traverse(node)
		{
			callback(node);

			for(var i = 0; i < node.children.length; i++)
			{
				traverse(node.children[i]);
			}
		}

		traverse(this.root); 
	};

	/**
	 * Add new object to a parent in a specific position.
	 * 
	 * @method addObject
	 * @param {Object3D} object New object to add to the tree.
	 * @param {Object3D} parent Parent to insert the object.
	 * @param {number} index Index to insert the object.
	 */
	TreeView.prototype.addObject = function(object, parent, index)
	{
		var parentNode = null;
		this.traverse(function(node)
		{
			if(node.uuid === parent.uuid)
			{
				parentNode = node;
			}
		});

		// Create object and children
		var element = parentNode.insertObject(object, index);
		for(var k = 0; k < object.children.length; k++)
		{
			insertObject(element, object.children[k]);
		}

		this.updateChildPosition();

		// Auxiliar method to insert object recursivelly
		function insertObject(parent, object)
		{
			var element = parent.addObject(object);

			for(var k = 0; k < object.children.length; k++)
			{
				insertObject(element, object.children[k]);
			}
		}
	};

	/**
	 * Remove a object from the treeview.
	 * 
	 * @method removeObject
	 * @param {Object3D} object Object to be removed from the tree.
	 * @param {Object3D} parent Parent object.
	 */
	TreeView.prototype.removeObject = function(object, parent)
	{
		var parentNode = null;
		this.traverse(function(node)
		{
			if(node.uuid === parent.uuid)
			{
				parentNode = node;
			}
		});

		var node = parentNode.removeElementUUID(object.uuid);

		if(node !== null)
		{
			node.destroy();	
		}
		else
		{
			console.warn("nunuStudio: Failed to remove node from treeview.", object, parent, node, parentNode);
		}

		this.updateChildPosition();
	};

	/**
	 * Move object in the tree, from a position to another position and parent.
	 * 
	 * @method addObject
	 * @param {Object3D} object New object to add to the tree.
	 * @param {Object3D} oldParent Old parent to remove the object from.
	 * @param {Object3D} newParent New parent to insert the object into.
	 * @param {number} index New index to insert the object.
	 */
	TreeView.prototype.moveObject = function(object, oldParent, newParent, index)
	{
		this.removeObject(object, oldParent);
		this.addObject(object, newParent, index);
		this.updateChildPosition();
	};

	/**
	 * Fill the tree view with the attached object children.
	 * 
	 * @method buildTree
	 */
	TreeView.prototype.buildTree = function()
	{
		function fillTree(root, object)
		{
			var element = root.addObject(object);

			for(var i = 0; i < object.children.length; i++)
			{
				fillTree(element, object.children[i]);
			}
		}

		if(this.root !== null)
		{
			this.root.destroy();
			this.root = null;
		}

		this.root = new TreeNode(this);
		this.root.attach(this.program);
		this.root.updateInterface();

		for(var i = 0; i < this.program.children.length; i++)
		{
			fillTree(this.root, this.program.children[i]);
		}
	};

	/**
	 * Update tree view children positions.
	 *
	 * @method updateChildPosition
	 */
	TreeView.prototype.updateChildPosition = function()
	{
		// Check if parent if folded (recursive)
		function checkParentFolded(element)
		{
			if(element.parent === null)
			{
				return false;
			}

			if(element.folded === true)
			{
				return true;
			}

			return checkParentFolded(element.parent);
		}

		// Update childs position (recursive)
		function updateChildPosition(parent, position, level, folded)
		{
			var children = parent.children;
			var length = parent.children.length;

			for(var i = 0; i < length; i++)
			{
				var element = children[i];

				if(folded || checkParentFolded(parent))
				{
					element.setVisibility(false);
					folded = true;
				}
				else
				{
					element.visible = true;
					element.position.set(0, position);
					element.level = level;
					element.updateInterface();
		 
					folded = false;
					position += 20;
				}

				if(element.children.length > 0)
				{
					position = updateChildPosition(children[i], position, level + 1, folded);
				}
			}

			return position;
		}

		if(this.root !== null)
		{
			this.root.position.set(0, this.search.size.y);
			this.root.updateInterface();

			this.size.y = updateChildPosition(this.root, 42, 1, this.root.folded);
		}
	};

	TreeView.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.search.size.set(this.size.x, 25);
		this.search.updateInterface();
	};

	/**
	 * Profiling tab is used to measure the performance of the application booth in the editor and while it is running.
	 *
	 * Can measure FPS, CPU usage, memory etc, some metrics may only be available when the editor is running in desktop.
	 *
	 * @constructor
	 * @class ProfilingTab
	 * @extends {TabComponent}
	 * @param parent
	 * @param closeable
	 * @param container
	 * @param index
	 */
	function ProfilingTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.profiling, Global.FILE_PATH + "icons/misc/speedometer.png");

		// Canvas
		this.canvas = new Canvas();
	}

	ProfilingTab.prototype = Object.create(TabComponent.prototype);

	ProfilingTab.prototype.update = function()
	{
		// Renderer info
		var tabs = Editor$1.gui.tab.getActiveTab();
		for(var i = 0; i < tabs.length; i++)
		{
			var tab = tabs[i];
			var renderer = tab.renderer || (tab.canvas ? tab.canvas.renderer : undefined);
			if(renderer !== undefined)
			{
				var info = renderer.info;
				// TODO <CHANGE THIS>
				//console.log(info);
			}
		}

		// System metrics
		// TODO <ADD CODE HERE>
	};

	ProfilingTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

	};

	/**
	 * A panel inspector is used to inspect and change the attributes of an object.
	 *
	 * The panel has a form element that should be used to place the object attribute editing GUI.
	 *
	 * @constructor
	 * @class Inspector
	 * @extends {Component}
	 * @param {Component} parent
	 * @param {Object} object Object to be edited by this inspector panel.
	 */
	function Inspector(parent, object)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "auto";
		this.preventDragEvents();

		/**
		 * Object attached to this panel.
		 * 
		 * @property object
		 * @type {Object3D}
		 */ 
		this.object = null;
		this.attach(object);

		/**
		 * Inspector form.
		 *
		 * @property form
		 * @type {TableForm}
		 */
		this.form = new TableForm(this);
		this.form.setAutoSize(false);
	}

	Inspector.prototype = Object.create(Component.prototype);

	/** 
	 * Attach object to panel.
	 *
	 * @method attach
	 * @param {Object3D} object
	 */
	Inspector.prototype.attach = function(object)
	{
		this.object = object;
	};

	/**
	 * Update panel information to match the attached object.
	 *
	 * @method updateInspector
	 */
	Inspector.prototype.updateInspector = function(){};

	Inspector.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	function TextureInspector(parent, object)
	{
		Inspector.call(this, parent, object);

		var self = this;

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(190, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "name", self.name.getText()));
			Editor$1.updateObjectsViewsGUI();
		});
		this.form.add(this.name);
		this.form.nextRow();

		// UUID
		if(Editor$1.settings.general.showUUID)
		{
			this.form.addText(Locale.uuid);
			this.uuid = this.form.addText("");
			this.form.nextRow();
		}

		// WrapS
		this.form.addText(Locale.wrapHor);
		this.wrapS = new DropdownList(this.form);
		this.wrapS.size.set(120, 18);
		this.wrapS.addValue(Locale.clampEdge, three.ClampToEdgeWrapping);
		this.wrapS.addValue(Locale.repeat, three.RepeatWrapping);
		this.wrapS.addValue(Locale.repeatMirror, three.MirroredRepeatWrapping);
		this.wrapS.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "wrapS", self.wrapS.getValue()));
		});
		this.form.add(this.wrapS);
		this.form.nextRow();

		// WrapT
		this.form.addText(Locale.wrapVert);
		this.wrapT = new DropdownList(this.form);
		this.wrapT.size.set(120, 18);
		this.wrapT.addValue(Locale.clampEdge, three.ClampToEdgeWrapping);
		this.wrapT.addValue(Locale.repeat, three.RepeatWrapping);
		this.wrapT.addValue(Locale.repeatMirror, three.MirroredRepeatWrapping);
		this.wrapT.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "wrapT", self.wrapT.getValue()));
		});
		this.form.add(this.wrapT);
		this.form.nextRow();

		// Repeat
		this.form.addText(Locale.repeat);
		this.repeat = new VectorBox(this.form);
		this.repeat.setType(VectorBox.VECTOR2);
		this.repeat.size.set(120, 18);
		this.repeat.setStep(0.01);
		this.repeat.setOnChange(function()
		{
			var value = self.repeat.getValue();
			self.object.repeat.set(value.x, value.y);
		});
		this.form.add(this.repeat);
		this.form.nextRow();

		// Offset
		this.form.addText(Locale.offset);
		this.offset = new VectorBox(this.form);
		this.offset.setType(VectorBox.VECTOR2);
		this.offset.size.set(120, 18);
		this.offset.setStep(0.01);
		this.offset.setOnChange(function()
		{
			var value = self.offset.getValue();
			self.object.offset.set(value.x, value.y);
		});
		this.form.add(this.offset);
		this.form.nextRow();

		// Center
		this.form.addText(Locale.center);
		this.center = new VectorBox(this.form);
		this.center.setType(VectorBox.VECTOR2);
		this.center.size.set(120, 18);
		this.center.setStep(0.01);
		this.center.setOnChange(function()
		{
			var value = self.center.getValue();
			self.object.center.set(value.x, value.y);
		});
		this.form.add(this.center);
		this.form.nextRow();

		// Rotation
		this.form.addText(Locale.rotation);
		this.rotation = new NumberBox(this.form);
		this.rotation.size.set(60, 18);
		this.rotation.setStep(0.1);
		this.rotation.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "rotation", self.rotation.getValue()));
		});
		this.form.add(this.rotation);
		this.form.nextRow();

		// Minification filter
		this.form.addText(Locale.minFilter);
		this.minFilter = new DropdownList(this.form);
		this.minFilter.size.set(150, 18);
		this.minFilter.addValue(Locale.nearest, three.NearestFilter);
		this.minFilter.addValue(Locale.linear, three.LinearFilter);
		this.minFilter.addValue("MIP Nearest Nearest", three.NearestMipMapNearestFilter);
		this.minFilter.addValue("MIP Nearest Linear", three.NearestMipMapLinearFilter);
		this.minFilter.addValue("MIP Linear Nearest", three.LinearMipMapNearestFilter);
		this.minFilter.addValue("MIP Linear Linear", three.LinearMipMapLinearFilter);
		this.minFilter.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "minFilter", self.minFilter.getValue()));
		});
		this.form.add(this.minFilter);
		this.form.nextRow();

		// Magnification filter
		this.form.addText(Locale.magFilter);
		this.magFilter = new DropdownList(this.form);
		this.magFilter.size.set(150, 18);
		this.magFilter.addValue(Locale.nearest, three.NearestFilter);
		this.magFilter.addValue(Locale.linear, three.LinearFilter);
		this.magFilter.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "magFilter", self.magFilter.getValue()));
		});
		this.form.add(this.magFilter);
		this.form.nextRow();

		// Premultiply Alpha
		this.form.addText(Locale.premulAlpha);
		this.premultiplyAlpha = new CheckBox(this.form);
		this.premultiplyAlpha.size.set(18, 18);
		this.premultiplyAlpha.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "premultiplyAlpha", self.premultiplyAlpha.getValue()));
		});
		this.form.add(this.premultiplyAlpha);
		this.form.nextRow();

		// Flip Y
		this.form.addText(Locale.flipY);
		this.flipY = new CheckBox(this.form);
		this.flipY.size.set(18, 18);
		this.flipY.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "flipY", self.flipY.getValue()));
		});
		this.form.add(this.flipY);
		this.form.nextRow();
	}

	TextureInspector.prototype = Object.create(Inspector.prototype);

	TextureInspector.prototype.updateInspector = function()
	{
		this.name.setText(this.object.name);
			
		if(this.uuid !== undefined)
		{
			this.uuid.setText(this.object.uuid);
		}

		this.wrapT.setValue(this.object.wrapT);
		this.wrapS.setValue(this.object.wrapS);
		this.repeat.setValue(this.object.repeat);
		this.offset.setValue(this.object.offset);
		this.center.setValue(this.object.center);
		this.rotation.setValue(this.object.rotation);
		this.magFilter.setValue(this.object.magFilter);
		this.minFilter.setValue(this.object.minFilter);
		this.premultiplyAlpha.setValue(this.object.premultiplyAlpha);
		this.flipY.setValue(this.object.flipY);
	};

	function ResourceInspector(parent, object)
	{
		Inspector.call(this, parent, object);

		var self = this;

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(190, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "name", self.name.getText()));
			Editor$1.updateObjectsViewsGUI();
		});
		this.form.add(this.name);
		this.form.nextRow();

		// UUID
		if(Editor$1.settings.general.showUUID)
		{
			this.form.addText(Locale.uuid);
			this.uuid = this.form.addText("");
			this.form.nextRow();
		}
		
		// Type
		if(Editor$1.settings.general.showType)
		{
			this.form.addText(Locale.type);
			this.type = this.form.addText("");
			this.form.nextRow();
		}
	}

	ResourceInspector.prototype = Object.create(Inspector.prototype);

	ResourceInspector.prototype.updateInspector = function()
	{
		this.name.setText(this.object.name);
			
		if(this.uuid !== undefined)
		{
			this.uuid.setText(this.object.uuid);
		}
		
		if(this.type !== undefined)
		{
			this.type.setText(this.object.type);
		}
	};

	/**
	 * Media element can be used to play media content.
	 *
	 * Should be used as a base for other multimedia elements like audio and video.
	 *
	 * @class Media
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 * @param {string} type Type of the media element (e.g audio, video)
	 */
	function Media(parent, type)
	{
		Component.call(this, parent, "div");

		/**
		 * Media DOM element that compatible with media controls.
		 *
		 * @attribute media
		 * @type {Element}
		 */
		this.media = document.createElement(type);
		this.element.appendChild(this.media);
	}

	Media.prototype = Object.create(Component.prototype);

	Media.prototype.constructor = Media;

	/**
	 * Set element Media volume.
	 * 
	 * @method setVolume
	 * @param {number} volume Volume level from 0 to 1.
	 */
	Media.prototype.setVolume = function(volume)
	{
		this.media.volume = volume;	
	};

	/**
	 * Set video to be played.
	 *
	 * @method setValue
	 * @param {Video} value Video resource to play.
	 */
	Media.prototype.setValue = function(video)
	{
		this.media.src = video.data;
	};

	/**
	 * Set URL of the media to play.
	 *
	 * @method setURL
	 * @param {string} value Media url.
	 */
	Media.prototype.setURL = function(value)
	{
		this.media.src = value;
	};

	/**
	 * Set the playback time.
	 *
	 * @method setTime
	 * @param {number} time Time to be set.
	 */
	Media.prototype.setTime = function(time)
	{
		this.media.currentTime = time;
	};

	/**
	 * Set autoplay mode.
	 * 
	 * @method setAutoplay
	 * @param {boolean} value If true the media starts playing automatically.
	 */
	Media.prototype.setAutoplay = function(value)
	{
		this.media.autoplay = value;
	};

	/**
	 * Check if the media is playing.
	 * 
	 * @method isPlaying
	 * @return {boolean} True if the media is playing.
	 */
	Media.prototype.isPlaying = function(value)
	{
		return !this.media.paused;
	};

	/**
	 * Set loop mode.
	 * 
	 * @method setLoop
	 * @param {boolean} value If true the media plays in loop.
	 */
	Media.prototype.setLoop = function(value)
	{
		this.media.loop = value;
	};

	/**
	 * Set playback rate.
	 * 
	 * @method setPlaybackRate
	 * @param {number} setPlaybackRate The velocity of playback.
	 */
	Media.prototype.setPlaybackRate = function(playbackRate)
	{
		this.media.playbackRate = playbackRate;
	};

	/**
	 * Play media playback.
	 * 
	 * @method play
	 */
	Media.prototype.play = function()
	{
		this.media.play();
	};

	/**
	 * Stop media playback.
	 * 
	 * @method stop
	 */
	Media.prototype.stop = function()
	{
		this.media.currentTime = 0;
		this.media.pause();
	};

	/**
	 * Pause media.
	 * 
	 * @method pause
	 */
	Media.prototype.pause = function()
	{
		this.media.pause();
	};

	Media.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		this.media.style.width = this.size.x + "px";
		this.media.style.height = this.size.y + "px";
	};

	/**
	 * Video player element, based on the video tag.
	 *
	 * @class VideoPlayer
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function VideoPlayer(parent)
	{
		Media.call(this, parent, "video");

		this.media.playbackRate = 1.0;
		this.media.loop = true;
		this.media.volume = 0.0;
		this.media.autoplay = true;
	}

	VideoPlayer.prototype = Object.create(Media.prototype);

	function VideoInspector(parent, object)
	{
		ResourceInspector.call(this, parent, object);

		this.form.addText("Video");
		this.video = new VideoPlayer(this.form);
		this.video.size.set(120, 120);
		this.form.add(this.video);
		this.form.nextRow();
	}

	VideoInspector.prototype = Object.create(ResourceInspector.prototype);

	VideoInspector.prototype.updateInspector = function()
	{
		ResourceInspector.prototype.updateInspector.call(this);

		this.video.setValue(this.object);
	};

	/**
	 * Image chooser is used for the user to select images.
	 *
	 * Images can be selected by opening a file explorer or by drag and drop.
	 *
	 * @class ImageChooser
	 * @extends {Component}
	 */
	function ImageChooser(parent)
	{
		Component.call(this, parent, "div");

		// Image
		this.img = document.createElement("img");
		this.img.style.visibility = "inherit";
		this.img.style.position = "absolute";
		this.img.style.borderStyle = "none";
		this.img.style.left = "0px";
		this.img.style.top = "0px";
		this.img.style.width = "100%";
		this.img.style.height = "100%";
		this.img.style.objectFit = "contain";
		this.img.style.backgroundImage = "url(\"" + Global.FILE_PATH + "alpha.png\")";
		this.img.style.backgroundRepeat = "repeat";
		this.img.style.backgroundSize = "120px 120px";
		this.element.appendChild(this.img);

		// Value
		this.value = null;

		var self = this;

		this.element.ondragover = Component.preventDefault;
		this.element.ondragstart = Component.preventDefault;

		// On drop get file dropped
		this.element.ondrop = function(event)
		{
			event.preventDefault();

			if(event.dataTransfer.files.length > 0)
			{
				var file = event.dataTransfer.files[0];

				if(Image.fileIsImage(file))
				{
					readImageFile(file);
				}
			}
			else
			{
				var uuid = event.dataTransfer.getData("uuid");
				var value = DragBuffer.get(uuid);

				if(value instanceof Image)
				{
					self.setValue(value);
					self.onChange(value);
				}
				else
				{
					Editor$1.alert("Only images accepted");
				}
			}
		};

		// Onclick select image file
		this.element.onclick = function()
		{
			if(self.onChange !== null)
			{
				FileSystem.chooseFile(function(files)
				{
					if(files.length > 0)
					{
						readImageFile(files[0]);
					}
				}, "image/*, .tga");
			}
		};

		var readImageFile = function(file)
		{
			var reader = new FileReader();
			reader.onload = function()
			{
				self.setValue(new Image(reader.result));
				self.onChange(self.value);
			};
			reader.readAsDataURL(file);
		};

		/**
		 * On change callback function.
		 *
		 * @property onChange
		 * @type {Function}
		 */
		this.onChange = null;
	}

	ImageChooser.prototype = Object.create(Component.prototype);

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	ImageChooser.prototype.setOnChange = function(onChange)
	{
		this.onChange = onChange;
		this.img.style.cursor = "pointer";
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setValue
	 * @param {Object} image
	 */
	ImageChooser.prototype.setValue = function(image)
	{
		this.value = image;
		this.img.src = image.data;
	};

	/**
	 * Get value stored in the input element.
	 *
	 * @method setValue
	 * @return {Object} Image URL.
	 */
	ImageChooser.prototype.getValue = function()
	{
		return this.value;
	};

	function ImageInspector(parent, object)
	{
		ResourceInspector.call(this, parent, object);

		this.form.addText(Locale.image);
		this.image = new ImageChooser(this.form);
		this.image.size.set(120, 120);
		this.form.add(this.image);
		this.form.nextRow();
	}

	ImageInspector.prototype = Object.create(ResourceInspector.prototype);

	ImageInspector.prototype.updateInspector = function()
	{
		ResourceInspector.prototype.updateInspector.call(this);

		this.image.setValue(this.object);
	};

	function GeometryInspector(parent, object)
	{
		ResourceInspector.call(this, parent, object);

		var self = this;

		// Geometry preview
		this.form.addText(Locale.geometry);
		this.preview = new RendererCanvas(this.form);
		this.preview.size.set(120, 180);
		this.preview.setOnResize(function(x, y)
		{
			self.camera.aspect = x / y;
			self.camera.updateProjectionMatrix();
		});
		this.form.add(this.preview);
		this.form.nextRow();

		// Mouse
		this.mouse = new Mouse(window, false);
		this.mouse.setCanvas(this.preview.canvas);

		// Scene
		this.scene = new three.Scene();

		// Grid
		this.grid = null;

		var directional = new three.DirectionalLight(0x777777, 1.0);
		directional.position.set(3e3, 1e4, 4e2);
		this.scene.add(directional);
		this.scene.add(new three.AmbientLight(0x888888));

		// Camera
		this.camera = new PerspectiveCamera(90, this.preview.size.x / this.preview.size.y);

		// Controls
		this.controls = new EditorOrbitControls();
		this.controls.attach(this.camera);
		this.scene.add(this.controls);

		// Mesh
		this.mesh = new three.Mesh(new three.Geometry(), new three.MeshPhongMaterial());
		this.scene.add(this.mesh);

		// Render loop timer
		this.timer = new AnimationTimer(function()
		{
			if(self.object === null)
			{
				return;
			}
			
			self.mouse.update();
			self.controls.update(self.mouse);
			self.preview.renderer.render(self.scene, self.camera);
		});
		this.timer.start();
	}

	GeometryInspector.prototype = Object.create(ResourceInspector.prototype);

	GeometryInspector.prototype.destroy = function()
	{
		ResourceInspector.prototype.destroy.call(this);

		this.timer.stop();
	};

	GeometryInspector.prototype.updateInspector = function()
	{
		ResourceInspector.prototype.updateInspector.call(this);

		var geometry = this.object;
		geometry.computeBoundingBox();
		
		var box = geometry.boundingBox;
		var center = new three.Vector3();
		center.addVectors(box.min, box.max);
		center.multiplyScalar(-0.5);

		var size = new three.Vector3();
		box.getSize(size);

		var max = size.toArray().reduce(function(a, b)
		{
			return a > b ? a : b;
		});

		if(this.grid !== null)
		{
			this.scene.remove(this.grid);
		}

		this.grid = new three.GridHelper(max * 2, 50, 0x888888);
		this.scene.add(this.grid);

		this.mesh.geometry = geometry;
		this.mesh.position.copy(center);

		this.controls.focusObject(this.mesh);
	};

	function AudioPlayer(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";

		var self = this;

		// WebAudio context
		this.context = three.AudioContext.getContext();

		// Timer
		this.timer = document.createElement("div");
		this.timer.style.position = "absolute";
		this.timer.style.display = "flex";
		this.timer.style.justifyContent = "center";
		this.timer.style.alignItems = "center";
		this.timer.style.width = "40px";
		this.timer.style.height = "100%";
		this.timer.style.right = "0px";
		this.element.appendChild(this.timer);

		// Text
		this.timerText = document.createTextNode("00:00");
		this.timer.appendChild(this.timerText);

		// Button
		this.button = document.createElement("button");
		this.button.style.position = "absolute";
		this.button.style.cursor = "pointer";
		this.button.style.background = "transparent";
		this.button.style.border = "none";
		this.button.style.outline = "none";
		this.element.appendChild(this.button);
		this.button.onclick = function()
		{
			self.toggle();
		};

		// Icon
		this.icon = document.createElement("img");
		this.icon.style.position = "absolute";
		this.icon.style.left = "15%";
		this.icon.style.top = "15%";
		this.icon.style.width = "70%";
		this.icon.style.height = "70%";
		this.icon.src = Global.FILE_PATH + "icons/misc/play.png";
		this.button.appendChild(this.icon);

		// Track
		this.track = document.createElement("div");
		this.track.style.position = "absolute";
		this.track.style.backgroundColor = "var(--bar-color)";
		this.track.style.cursor = "pointer";
		this.element.appendChild(this.track);

		// Progress
		this.progress = document.createElement("div");
		this.progress.style.pointerEvents = "none";
		this.progress.style.position = "absolute";
		this.progress.style.backgroundColor = "var(--button-over-color)";
		this.progress.style.height = "100%";
		this.track.appendChild(this.progress);

		// Scrubber
		this.scrubber = document.createElement("div");
		this.scrubber.style.position = "absolute";
		this.scrubber.style.backgroundColor = "var(--color-light)";
		this.scrubber.style.cursor = "pointer";
		this.scrubber.style.width = "6px";
		this.track.appendChild(this.scrubber);

		// Audio source and buffer
		this.buffer = null;
		this.source = null;

		// Playback control
		this.time = 0;
		this.startTime = 0;
		this.playing = false;
		this.loop = false;

		// Drag control
		this.seekStart = 0;
		this.seekTime = 0;
		this.seekProgress = 0;
		this.dragging = false;

		// Event manager
		this.manager = new EventManager();
		this.manager.add(window, "mousemove", function(event)
		{
			self.seekProgress = (event.pageX - self.seekStart) / (self.track.offsetWidth);
			self.seekProgress += self.seekTime / self.buffer.duration;

			if(self.seekProgress < 0)
			{
				self.seekProgress = 0;
			}
			else if(self.seekProgress > 1)
			{
				self.seekProgress = 1;
			}

			self.progress.style.width = (self.seekProgress * 100) + "%";
			self.scrubber.style.left = self.progress.style.width;
		});

		this.manager.add(window, "mouseup", function(event)
		{	
			self.dragging = false;
			self.time = self.seekProgress * self.buffer.duration;

			if(self.playing)
			{
				self.play(self.time);
			}

			self.manager.destroy();
		});

		this.scrubber.onmousedown = function(event)
		{
			self.seekStart = event.pageX;
			self.seekTime = self.time;
			self.dragging = true;
			self.manager.create();

			event.stopPropagation();
		};

		this.track.onmousedown = function(event)
		{
			var progress = event.layerX / this.offsetWidth;

			self.seekProgress = progress;
			self.time = progress * self.buffer.duration;

			self.progress.style.width = (self.seekProgress * 100) + "%";
			self.scrubber.style.left = self.progress.style.width;

			if(self.playing)
			{
				self.play(self.time);
			}

			self.scrubber.onmousedown(event);
		};

		// Update elements
		function draw()
		{
			if(self.playing)
			{
				self.time = self.context.currentTime - self.startTime;

				var seconds = Math.round(self.time % 60);
				if(seconds < 10)
				{
					seconds = "0" + seconds;
				}

				var minutes = Math.round(self.time / 60);
				if(minutes < 10)
				{
					minutes = "0" + minutes;
				}
				
				self.timerText.data = minutes + ":" + seconds;

				if(self.buffer !== null)
				{
					if(self.time >= self.buffer.duration)
					{
						self.stop();
					}

					var progress = (self.time / self.buffer.duration) * 100;

					if(!self.dragging)
					{
						self.progress.style.width = progress + "%";
						self.scrubber.style.left = progress + "%";
					}
				}
			}

			if(self.parent !== null)
			{
				requestAnimationFrame(draw);
			}
		}
		draw();
	}

	AudioPlayer.prototype = Object.create(Component.prototype);

	// Decode audio
	AudioPlayer.prototype.setAudioBuffer = function(buffer, onLoad)
	{
		var self = this;

		this.context.decodeAudioData(buffer.slice(0), function(buffer)
		{
			self.buffer = buffer;

			if(onLoad !== undefined)
			{
				onLoad(buffer);
			}
		}.bind(this));
	};

	// Connect audio source
	AudioPlayer.prototype.connect = function()
	{
		if(this.playing)
		{
			this.pause();
		}

		this.source = this.context.createBufferSource();
		this.source.buffer = this.buffer;
		this.source.connect(this.context.destination);
	};

	// Disconnect source
	AudioPlayer.prototype.disconnect = function()
	{
		this.source.disconnect();
	};

	// Play audio
	AudioPlayer.prototype.play = function(time)
	{
		this.connect();

		if(time !== undefined)
		{
			this.time = time;
		}

		this.source.loop = this.loop;
		this.startTime = this.context.currentTime - this.time;
		this.source.start(this.context.currentTime, this.time);
		this.playing = true;

		this.icon.src = Global.FILE_PATH + "icons/misc/pause.png";
	};

	// Pause audio
	AudioPlayer.prototype.pause = function()
	{
		if(this.playing)
		{
			this.playing = false;
			this.source.stop();
			this.time = this.context.currentTime - this.startTime;

			this.icon.src = Global.FILE_PATH + "icons/misc/play.png";
		}
	};

	// Stop audio playback
	AudioPlayer.prototype.stop = function()
	{	
		if(this.playing)
		{
			this.source.stop();
			this.time = 0;
			this.playing = false;

			this.icon.src = Global.FILE_PATH + "icons/misc/play.png";
		}
	};

	// Seek time
	AudioPlayer.prototype.seek = function(time)
	{
		if(this.playing)
		{
			this.play(time);
		}
		else
		{
			this.time = time;
		}
	};

	// Toggle play/pause
	AudioPlayer.prototype.toggle = function()
	{
		if(!this.playing)
		{
			this.play();
		}
		else
		{
			this.pause();
		}
	};

	AudioPlayer.prototype.destroy = function()
	{
		try
		{
			this.disconnect();
			this.stop();
		}
		catch(e){}

		Component.prototype.destroy.call(this);
	};

	AudioPlayer.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		// Button
		this.button.style.width = this.element.style.height;
		this.button.style.height = this.element.style.height;

		// Track
		this.track.style.top = (this.size.y * 0.25) + "px";
		this.track.style.left = (this.size.y * 1.05) + "px";
		this.track.style.width = (this.size.x - this.size.y * 1.5 - 35) + "px";
		this.track.style.height = (this.size.y * 0.5) + "px";

		// Scrubber
		this.scrubber.style.height = (this.size.y * 0.8) + "px";
		this.scrubber.style.top = (-this.size.y * 0.15) + "px";
	};

	function AudioInspector(parent, object)
	{
		ResourceInspector.call(this, parent, object);

		// Audio player
		this.form.addText(Locale.audio);
		this.player = new AudioPlayer(this.form);
		this.player.size.set(190, 18);
		this.form.add(this.player);
		this.form.nextRow();
	}

	AudioInspector.prototype = Object.create(ResourceInspector.prototype);

	AudioInspector.prototype.destroy = function()
	{
		ResourceInspector.prototype.destroy.call(this);

		this.player.destroy();
	};

	AudioInspector.prototype.updateInspector = function()
	{
		ResourceInspector.prototype.updateInspector.call(this);

		this.player.setAudioBuffer(this.object.data);
	};

	function ObjectInspector(parent, object)
	{
		Inspector.call(this, parent, object);

		var self = this;

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(0, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "name", self.name.getText()));
			Editor$1.updateObjectsViewsGUI();
		});
		this.form.add(this.name);
		this.form.nextRow();

		// UUID
		if(Editor$1.settings.general.showUUID)
		{
			this.form.addText(Locale.uuid);
			this.uuid = this.form.addText("");
			this.form.nextRow();
		}
		
		// Type
		if(Editor$1.settings.general.showType)
		{
			this.form.addText(Locale.type);
			this.type = this.form.addText("");
			this.form.nextRow();
		}

		// Position
		this.form.addText(Locale.position);
		this.position = new VectorBox(this.form);
		this.position.size.set(0, 18);
		this.position.setStep(0.01);
		this.position.setOnChange(function()
		{
			var position = self.position.getValue();
			var object = self.object.position;

			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(object, "x", position.x),
				new ChangeAction(object, "y", position.y),
				new ChangeAction(object, "z", position.z)
			]));
		});
		this.form.add(this.position);
		this.form.nextRow();

		var text = this.form.addText(Locale.scale);

		// Scale lock
		this.scaleRatioLock = new CheckBox(text);
		this.scaleRatioLock.setAltText("Lock scale ratio");
		this.scaleRatioLock.size.set(18, 18);
		this.scaleRatioLock.setMode(Component.TOP_RIGHT);
		this.scaleRatioLock.updateInterface();
		
		// Scale
		this.scale = new VectorBox(this.form);
		this.scale.size.set(0, 18);
		this.scale.setStep(0.01);
		this.scale.setOnChange(function()
		{
			var scale = self.scale.getValue();
			var object = self.object.scale;
			
			if(self.scaleRatioLock.getValue())
			{
				if(scale.x !== object.x)
				{
					var ratio = scale.x / object.x;
					scale.y *= ratio;
					scale.z *= ratio;
				}
				else if(scale.y !== object.y)
				{
					var ratio = scale.y / object.y;
					scale.x *= ratio;
					scale.z *= ratio;
				}
				else if(scale.z !== object.z)
				{
					var ratio = scale.z / object.z;
					scale.x *= ratio;
					scale.y *= ratio;
				}

				self.scale.setValue(scale.x, scale.y, scale.z);
			}

			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(object, "x", scale.x),
				new ChangeAction(object, "y", scale.y),
				new ChangeAction(object, "z", scale.z)
			]));
		});
		this.form.add(this.scale);
		this.form.nextRow();

		// Rotation
		this.form.addText(Locale.rotation);
		this.rotation = new VectorBox(this.form);
		this.rotation.size.set(0, 18);
		this.rotation.setStep(0.01);
		this.rotation.isAngle = true;
		this.rotation.setOnChange(function()
		{
			var rotation = self.rotation.getValue();
			var object = self.object.rotation;

			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(object, "x", rotation.x),
				new ChangeAction(object, "y", rotation.y),
				new ChangeAction(object, "z", rotation.z)
			]));
		});
		this.form.add(this.rotation);
		this.form.nextRow();

		// Visible
		this.form.addText("Visible");
		this.visible = new CheckBox(this.form);
		this.visible.size.set(18, 18);
		this.visible.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "visible", self.visible.getValue()));
		});
		this.form.add(this.visible);
		this.form.nextRow();

		// Render order
		this.form.addText("Render order");
		this.renderOrder = new NumberBox(this.form);
		this.renderOrder.size.set(0, 18);
		this.renderOrder.setRange(0, Number.MAX_SAFE_INTEGER);
		this.renderOrder.setStep(1);
		this.renderOrder.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "renderOrder", self.renderOrder.getValue()));
		});
		this.form.add(this.renderOrder);
		this.form.nextRow();

		// Static
		this.form.addText("Static Object");
		this.static = new CheckBox(this.form);
		this.static.size.set(18, 18);
		this.static.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "matrixAutoUpdate", !self.static.getValue()));
		});
		this.form.add(this.static);
		this.form.nextRow();
	}

	ObjectInspector.prototype = Object.create(Inspector.prototype);

	ObjectInspector.prototype.updateInspector = function()
	{
		this.name.setText(this.object.name);
			
		if(this.uuid !== undefined)
		{
			this.uuid.setText(this.object.uuid);
		}
		
		if(this.type !== undefined)
		{
			this.type.setText(this.object.type);
		}

		this.position.setValue(this.object.position);
		this.scale.setValue(this.object.scale);
		this.rotation.setValue(this.object.rotation);
		this.visible.setValue(this.object.visible);
		this.renderOrder.setValue(this.object.renderOrder);
		this.static.setValue(!this.object.matrixAutoUpdate);
	};

	function DrawableInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Cast shadow
		this.form.addText(Locale.castShadows);
		this.castShadow = new CheckBox(this.form);
		this.castShadow.size.set(18, 18);
		this.castShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "castShadow", self.castShadow.getValue()));
		});
		this.form.add(this.castShadow);
		this.form.nextRow();

		// Receive shadow
		this.form.addText(Locale.receiveShadows);
		this.receiveShadow = new CheckBox(this.form);
		this.receiveShadow.size.set(18, 18);
		this.receiveShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "receiveShadow", self.receiveShadow.getValue()));
		});
		this.form.add(this.receiveShadow);
		this.form.nextRow();

		// Frustum culled
		this.form.addText("Frustum Culled");
		this.frustumCulled = new CheckBox(this.form);
		this.frustumCulled.size.set(18, 18);
		this.frustumCulled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "frustumCulled", self.frustumCulled.getValue()));
		});
		this.form.add(this.frustumCulled);
		this.form.nextRow();
	}

	DrawableInspector.prototype = Object.create(ObjectInspector.prototype);

	DrawableInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.castShadow.setValue(this.object.castShadow);
		this.receiveShadow.setValue(this.object.receiveShadow);
		this.frustumCulled.setValue(this.object.frustumCulled);
	};

	/**
	 * Text area input is used to handle multi line string values.
	 *
	 * @class TextArea
	 * @extends {Component}
	 */
	function TextArea(parent)
	{
		Component.call(this, parent, "textarea");

		this.element.style.overflow = "auto";
		this.element.style.resize = "none";
		this.element.style.backgroundColor = "var(--box-color)";
		this.element.style.fontFamily = "var(--font-main-family);";
		this.element.style.color = "var(--color-light)";
		this.element.style.outline = "none";
		this.element.style.borderStyle = "none";
		this.element.style.boxSizing = "border-box";
		this.element.style.borderRadius = "4px";

		var self = this;

		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			context.addOption(Locale.copy, function()
			{
				var value = self.element.value;
				Editor$1.clipboard.set(value.slice(self.element.selectionStart, self.element.selectionEnd), "text");
			});
			context.addOption(Locale.cut, function()
			{
				var value = self.element.value;
				Editor$1.clipboard.set(value.slice(self.element.selectionStart, self.element.selectionEnd), "text");
				self.element.value = value.slice(0, self.element.selectionStart) + value.slice(self.element.selectionEnd, value.length);
			});
			context.addOption(Locale.paste, function()
			{
				var value = self.element.value;
				var paste = Editor$1.clipboard.get("text");
				if(paste !== undefined)
				{
					self.element.value = value.slice(0, self.element.selectionStart) + paste + value.slice(self.element.selectionEnd, value.length);
				}
			});
			context.addOption(Locale.selectAll, function()
			{
				self.element.select();
			});
			context.updateInterface();
		};
	}

	TextArea.prototype = Object.create(Component.prototype);

	/**
	 * The text in the textarea is not wrapped. This is default.
	 *
	 * @static
	 * @attribute SOFT
	 * @type {string}
	 */
	TextArea.SOFT = "soft";

	/**
	 * The text in the textarea is wrapped (contains newlines).
	 *
	 * When "hard" is used, the cols attribute must be specified.
	 *
	 * @static
	 * @attribute HARD
	 * @type {string}
	 */
	TextArea.HARD = "hard";

	/**
	 * Set font configuration to use for the text presented in this component.
	 *
	 * May also affect some types of children components. 
	 * 
	 * @method setFont
	 * @param {string} fontFamily Font family.
	 * @param {number} fontWeight Font weigth, sets how thick or thin characters in text should be displayed.
	 * @param {string} fontStyle Font style, specifies the font style for a text.
	 */
	TextArea.prototype.setFont = function(fontFamily, fontWeight, fontStyle)
	{
		this.element.style.fontFamily = fontFamily;

		if(fontWeight !== undefined)
		{
			this.element.style.fontWeight = fontWeight;
		}

		if(fontStyle !== undefined)
		{
			this.element.style.fontStyle = fontStyle;
		}
	};

	/**
	 * Set the wrap mode used for this text area.
	 *
	 * Only affects the value on form submission.
	 *
	 * @method setWrap
	 * @param {string} mode The wrap mode to use.
	 */
	TextArea.prototype.setWrap = function(mode)
	{
		this.element.wrap = mode;
	};

	/**
	 * Set the disabled state of the element.
	 *
	 * @method setDisabled
	 * @param {boolean} disabled
	 */
	TextArea.prototype.setDisabled = function(value)
	{
		this.element.disabled = value;
	};

	/**
	 * Set oninput callback called after every letter typed into the box.
	 *
	 * Should be used only for immediate input effect, or can be used with a timeout value to prevent high CPU usage.
	 *
	 * @method setOnInput
	 * @param {Function} onInput Callback method called everytime the user types something.
	 * @param {number} timeout Time (ms) after the user stopped typing to activate the callback.
	 */
	TextArea.prototype.setOnInput = function(onInput, timeout)
	{
		if(timeout !== undefined)
		{
			var timer = null;

			this.element.oninput = function(event)
			{
				if(timer !== null)
				{
					clearTimeout(timer);
					timer = null;
				}

				timer = setTimeout(function()
				{
					onInput();
					timer = null;
				}, timeout);
			};
		}
		else
		{
			this.element.oninput = onInput;
		}
	};

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	TextArea.prototype.setOnChange = function(onChange)
	{
		this.element.onchange = onChange;
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setText
	 * @param {Object} text
	 */
	TextArea.prototype.setText = function(text)
	{
		this.element.value = text;
	};

	/**
	 * Get text stored in the input element.
	 *
	 * @method getText
	 * @return {string} Text stored in the input element.
	 */
	TextArea.prototype.getText = function()
	{
		return this.element.value;
	};

	/**
	 * Set value stored in the input element. Same as setText().
	 *
	 * @method setValue
	 * @param {Object} text
	 */
	TextArea.prototype.setValue = TextArea.prototype.setText;

	/**
	 * Get text stored in the input element. Same as getText().
	 *
	 * @method getValue
	 * @return {string} Text stored in the input element.
	 */
	TextArea.prototype.getValue = TextArea.prototype.getText;

	function ColorChooser(parent)
	{
		Component.call(this, parent, "input");

		this.element.type = "text";
		this.element.style.outline = "none";
		this.element.style.borderStyle = "none";
		this.element.style.boxSizing = "border-box";
		this.element.style.textIndent = "4px";
		this.element.style.borderRadius = "4px";
		this.element.style.boxShadow = "none";
		this.element.style.MozAppearance = "textfield";
		this.element.style.webkitAppearance = "caret";
		this.element.style.appearance = "textfield";

		/**
		 * Color chooser.
		 *
		 * @attribute color
		 * @type {jscolor}
		 */
		this.color = new jscolor(this.element);
		this.color.backgroundColor = "var(--box-color)";
		this.color.insetColor = "var(--box-color)";
		this.color.shadow = false;
		this.color.borderWidth = 0;
		this.color.borderRadius = 0;
		this.color.zIndex = 2000;

		/**
		 * On change function.
		 *
		 * @attribute onChange
		 * @type {Function}
		 */
		this.onChange = null;
	}

	ColorChooser.prototype = Object.create(Component.prototype);

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	ColorChooser.prototype.setOnChange = function(onChange)
	{
		this.element.onchange = onChange;
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setValue
	 * @param {number} r Red color channel, if a Color value is received it is used instead.
	 * @param {number} g Green color channel.
	 * @param {number} b Blue color channel.
	 */
	ColorChooser.prototype.setValue = function(r, g, b)
	{
		if(r instanceof three.Color)
		{
			this.color.fromRGB(r.r * 255, r.g * 255, r.b * 255);
		}
		else
		{
			this.color.fromRGB(r * 255, g * 255, b * 255);
		}
	};

	/**
	 * Set value from numeric hex.
	 *
	 * @method setValueHex
	 * @param {number} hex
	 */
	ColorChooser.prototype.setValueHex = function(hex)
	{
		hex = Math.floor(hex);
		this.color.fromRGB(hex >> 16 & 255, hex >> 8 & 255, hex & 255);
	};

	/**
	 * Set value from CSS string.
	 *
	 * @method setValueString
	 * @param {number} color
	 */
	ColorChooser.prototype.setValueString = function(color)
	{
		this.color.fromString(color);
	};

	/**
	 * Get color value HEX as string.
	 *
	 * @method getValueString
	 * @return {string} String hex color.
	 */
	ColorChooser.prototype.getValueString = function(color)
	{
		return this.color.toHEXString();
	};

	/**
	 * Get color value object.
	 *
	 * @method getValue
	 * @return {Object} Color object.
	 */
	ColorChooser.prototype.getValue = function()
	{
		return {r: this.color.rgb[0] / 255, g: this.color.rgb[1] / 255, b: this.color.rgb[2] / 255};
	};

	/**
	 * Get color value HEX.
	 *
	 * @method getValueHex
	 * @return {number} Numeric hex color.
	 */
	ColorChooser.prototype.getValueHex = function()
	{
		return (this.color.rgb[0] << 16 ^ this.color.rgb[1] << 8 ^ this.color.rgb[2] << 0);
	};

	function TextSpriteInspector(parent, object)
	{
		DrawableInspector.call(this, parent, object);

		var self = this;

		// Text
		this.form.addText(Locale.text);
		this.text = new TextArea(this.form);
		this.text.size.set(0, 55);
		this.text.setOnInput(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "text", self.text.getText()));
		}, 500);
		this.form.add(this.text);
		this.form.nextRow();

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(0, 18);
		this.color.setValue(0, 0, 0);
		this.color.setOnChange(function()
		{	
			Editor$1.addAction(new ChangeAction(self.object, "color", self.color.getValueString()));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Align
		this.form.addText(Locale.align);
		this.align = new DropdownList(this.form);
		this.align.size.set(0, 18);
		this.align.addValue(Locale.left, TextSprite.LEFT);
		this.align.addValue(Locale.right, TextSprite.RIGHT);
		this.align.addValue(Locale.center, TextSprite.CENTER);
		this.align.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "align", self.align.getValue()));
		});
		this.form.add(this.align);
		this.form.nextRow();

		// Resolution
		this.form.addText(Locale.resolution);
		this.resolution = new NumberBox(this.form);
		this.resolution.size.set(0, 18);
		this.resolution.setRange(0, Number.MAX_SAFE_INTEGER);
		this.resolution.setStep(0.1);
		this.resolution.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "resolution", self.resolution.getValue()));
		});
		this.form.add(this.resolution);
		this.form.nextRow();

		var safeFonts = ["Andale Mono", "Arial", "Arial Bold", "Arial Italic", "Arial Bold Italic", "Arial Black", "Comic Sans MS", "Comic Sans MS Bold", "Courier New",
		"Courier New Bold", "Courier New Italic", "Courier New Bold Italic", "Georgia", "Georgia Bold", "Georgia Italic", "Georgia Bold Italic", "Impact", "Lucida Console",
		"Lucida Sans Unicode", "Marlett", "Minion Web", "Symbol", "Times New Roman", "Times New Roman Bold", "Times New Roman Italic", "Times New Roman Bold Italic", "Tahoma",
		"Trebuchet MS", "Trebuchet MS Bold", "Trebuchet MS Italic", "Trebuchet MS Bold Italic", "Verdana", "Verdana Bold", "Verdana Italic", "Verdana Bold Italic", "Webdings"];

		// Fonts
		this.form.addText(Locale.font);
		this.font = new DropdownList(this.form);
		this.font.size.set(0, 18);
		for(var i = 0; i < safeFonts.length; i++)
		{
			this.font.addValue(safeFonts[i], safeFonts[i]);
		}
		this.font.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "font", self.font.getValue()));
		});
		this.form.add(this.font);
		this.form.nextRow();

		// Outline
		this.form.addText(Locale.outline);
		this.outline = new CheckBox(this.form);
		this.outline.size.set(18, 18);
		this.outline.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "outline", self.outline.getValue()));
		});
		this.form.add(this.outline);
		this.form.nextRow();

		// Outline Width
		this.form.addText(Locale.outlineWidth);
		this.outlineWidth = new NumberBox(this.form);
		this.outlineWidth.size.set(0, 18);
		this.outlineWidth.setRange(0, Number.MAX_SAFE_INTEGER);
		this.outlineWidth.setStep(0.1);
		this.outlineWidth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "outlineWidth", self.outlineWidth.getValue()));
		});
		this.form.add(this.outlineWidth);
		this.form.nextRow();

		// Outline Color
		this.form.addText(Locale.outlineColor);
		this.outlineColor = new ColorChooser(this.form);
		this.outlineColor.size.set(0, 18);
		this.outlineColor.setValue(0, 0, 0);
		this.outlineColor.setOnChange(function()
		{	
			Editor$1.addAction(new ChangeAction(self.object, "outlineColor", self.outlineColor.getValueString()));
		});
		this.form.add(this.outlineColor);
		this.form.nextRow();
	}

	TextSpriteInspector.prototype = Object.create(DrawableInspector.prototype);

	TextSpriteInspector.prototype.updateInspector = function()
	{
		DrawableInspector.prototype.updateInspector.call(this);

		this.text.setText(this.object.text);
		this.color.setValueString(this.object.color);
		this.align.setValue(this.object.align);
		this.resolution.setValue(this.object.resolution);
		this.font.setValue(this.object.font);
		this.outline.setValue(this.object.outline);
		this.outlineWidth.setValue(this.object.outlineWidth);
		this.outlineColor.setValueString(this.object.outlineColor);
	};

	function TorusKnotGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.torusKnot);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();
		
		// Tube
		this.form.addText(Locale.tube);
		this.tube = new NumberBox(this.form);
		this.tube.size.set(0, 18);
		this.tube.setStep(0.1);
		this.tube.setOnChange(updateGeometry);
		this.form.add(this.tube);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.form.nextRow();
		
		this.form.addText(Locale.radial);
		this.radialSegments = new NumberBox(this.form);
		this.radialSegments.size.set(0, 18);
		this.radialSegments.setStep(1);
		this.radialSegments.setOnChange(updateGeometry);
		this.form.add(this.radialSegments);
		this.form.nextRow();
		
		this.form.addText(Locale.tubular);
		this.tubularSegments = new NumberBox(this.form);
		this.tubularSegments.size.set(0, 18);
		this.tubularSegments.setStep(1);
		this.tubularSegments.setOnChange(updateGeometry);
		this.form.add(this.tubularSegments);
		this.form.nextRow();

		// Axis winds
		this.form.addText(Locale.axisWinds);
		this.p = new NumberBox(this.form);
		this.p.size.set(0, 18);
		this.p.setStep(0.1);
		this.p.setOnChange(updateGeometry);
		this.form.add(this.p);
		this.form.nextRow();

		// Circle winds
		this.form.addText(Locale.circleWinds);
		this.q = new NumberBox(this.form);
		this.q.size.set(0, 18);
		this.q.setStep(0.1);
		this.q.setOnChange(updateGeometry);
		this.form.add(this.q);
		this.form.nextRow();
		
		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	TorusKnotGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.TorusKnotBufferGeometry : three.TorusKnotGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.tube.getValue(), this.tubularSegments.getValue(), this.radialSegments.getValue(), this.p.getValue(), this.q.getValue())));
	};

	TorusKnotGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 1);
		this.tube.setValue(this.object.geometry.parameters.tube || 0.4);
		this.radialSegments.setValue(this.object.geometry.parameters.radialSegments || 8);
		this.tubularSegments.setValue(this.object.geometry.parameters.tubularSegments || 64);
		this.p.setValue(this.object.geometry.parameters.p || 2);
		this.q.setValue(this.object.geometry.parameters.q || 3);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function TorusGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.torus);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();
		
		// Tube
		this.form.addText(Locale.tube);
		this.tube = new NumberBox(this.form);
		this.tube.size.set(0, 18);
		this.tube.setStep(0.1);
		this.tube.setOnChange(updateGeometry);
		this.form.add(this.tube);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.form.nextRow();
		
		this.form.addText(Locale.radial);
		this.radialSegments = new NumberBox(this.form);
		this.radialSegments.size.set(0, 18);
		this.radialSegments.setStep(1);
		this.radialSegments.setOnChange(updateGeometry);
		this.form.add(this.radialSegments);
		this.form.nextRow();
		
		this.form.addText(Locale.tubular);
		this.tubularSegments = new NumberBox(this.form);
		this.tubularSegments.size.set(0, 18);
		this.tubularSegments.setStep(1);
		this.tubularSegments.setOnChange(updateGeometry);
		this.form.add(this.tubularSegments);
		this.form.nextRow();
		
		// Arc
		this.form.addText(Locale.arc);
		this.arc = new NumberBox(this.form);
		this.arc.size.set(0, 18);
		this.arc.setStep(0.1);
		this.arc.setRange(0, Math.PI * 2);
		this.arc.setOnChange(updateGeometry);
		this.form.add(this.arc);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	TorusGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.TorusBufferGeometry : three.TorusGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.tube.getValue(), this.radialSegments.getValue(), this.tubularSegments.getValue(), this.arc.getValue())));
	};

	TorusGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 100);
		this.tube.setValue(this.object.geometry.parameters.tube || 40);
		this.radialSegments.setValue(this.object.geometry.parameters.radialSegments || 8);
		this.tubularSegments.setValue(this.object.geometry.parameters.tubularSegments || 6);
		this.arc.setValue(this.object.geometry.parameters.arc || Math.PI * 2);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	/**
	 * Slider element is used to select a numeric value using a visual slider bar.
	 * 
	 * @class Slider
	 * @extends {Component}
	 * @param {Component} parent Parent element.
	 */
	function Slider(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";

		var self = this;

		// Text
		this.text = document.createElement("div");
		this.text.style.position = "absolute";
		this.text.style.display = "none";
		this.text.style.justifyContent = "center";
		this.text.style.alignItems = "center";
		this.text.style.zIndex = "10000";
		this.text.style.border = "3px solid";
		this.text.style.borderRadius = "5px";
		this.text.style.color = "var(--color-light)";
		this.text.style.backgroundColor = "var(--bar-color)";
		this.text.style.borderColor = "var(--bar-color)";	
		document.body.appendChild(this.text);

		// Text value
		this.textValue = document.createTextNode("");
		this.text.appendChild(this.textValue);

		// Mouse mouse move event
		this.element.onmousemove = function(event)
		{
			self.text.style.display = "flex";
			self.text.style.width = "fit-content";
			self.text.style.height = "fit-content";
			self.text.style.left = event.clientX + "px";
			self.text.style.top = (event.clientY - 30) + "px";
		};

		// Mouse out event
		this.element.onmouseout = function()
		{
			self.text.style.display = "none";
		};

		// Track
		this.track = document.createElement("div");
		this.track.style.position = "absolute";
		this.track.style.backgroundColor = "var(--bar-color)";
		this.track.style.cursor = "pointer";
		this.track.style.left = "0px";
		this.track.style.width = "100%";
		this.track.style.top = "25%";
		this.track.style.height = "50%";
		this.element.appendChild(this.track);

		// Progress
		this.progress = document.createElement("div");
		this.progress.style.pointerEvents = "none";
		this.progress.style.position = "absolute";
		this.progress.style.backgroundColor = "var(--button-over-color)";
		this.progress.style.height = "100%";
		this.track.appendChild(this.progress);

		// Scrubber
		this.scrubber = document.createElement("div");
		this.scrubber.style.position = "absolute";
		this.scrubber.style.backgroundColor = "var(--color-light)";
		this.scrubber.style.cursor = "pointer";
		this.scrubber.style.height = "160%";
		this.scrubber.style.top = "-25%";
		this.scrubber.style.width = "6px";
		this.track.appendChild(this.scrubber);

		/**
		 * Value stored in the slider.
		 *
		 * @property value
		 * @type {number}
		 */
		this.value = 0.0;

		/**
		 * On change callback function.
		 *
		 * @property onChange
		 * @type {Function}
		 */
		this.onChange = null;

		// Range
		this.min = 1.0;
		this.max = 2.0;
		this.step = null;

		// Drag control
		this.mouseStart = 0;
		this.valueStart = 0;

		/**
		 * Event manager to handle window events.
		 *
		 * @property manager
		 * @type {EventManager}
		 */
		this.manager = new EventManager();
		this.manager.add(window, "mousemove", function(event)
		{
			var delta = (event.pageX - self.mouseStart) / (self.size.x);
			var value = self.valueStart + delta * (self.max - self.min);
			self.setValue(value);

			if(self.onChange !== null)
			{
				self.onChange(self.value);
			}
		});

		this.manager.add(window, "mouseup", function(event)
		{	
			self.manager.destroy();
		});

		this.scrubber.onmousedown = function(event)
		{
			self.mouseStart = event.pageX;
			self.valueStart = self.value;
			self.manager.create();
			event.stopPropagation();
		};

		this.track.onmousedown = function(event)
		{
			var percentage = (event.layerX / self.size.x);

			self.setValue(percentage * (self.max - self.min) + self.min);
			self.progress.style.width = (percentage * 100) + "%";
			self.scrubber.style.left = self.progress.style.width;
			self.scrubber.onmousedown(event);

			if(self.onChange !== null)
			{
				self.onChange(self.value);
			}
		};
	}

	Slider.prototype = Object.create(Component.prototype);

	/**
	 * Set if element is disabled.
	 *
	 * @method setDisabled
	 * @param {boolean} value.
	 */
	Slider.prototype.setDisabled = function(value)
	{
		// TODO
	};

	// Set slider min step
	Slider.prototype.setStep = function(step)
	{
		this.step = step;
	};

	/**
	 * Set value range of the slider.
	 *
	 * @method setRange.
	 * @param {number} min
	 * @param {number} max
	 */
	Slider.prototype.setRange = function(min, max)
	{
		this.min = min;
		this.max = max;
	};

	/** 
	 * Set onchange callback.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 * @param {string} name Graph name.
	 */
	Slider.prototype.setOnChange = function(onChange)
	{
		this.onChange = onChange;
	};

	/**
	 * Set Slider value.
	 *
	 * @method setValue
	 * @param {number} value
	 */
	Slider.prototype.setValue = function(value)
	{
		if(value < this.min)
		{
			value = this.min;
		}
		else if(value > this.max)
		{
			value = this.max;
		}

		if(this.step !== null)
		{
			var remainder = value % this.step;

			value -= remainder;
			if(remainder > this.step / 2)
			{
				value += this.step;
			}

			// Check for precision problems
			var stepVal = String(this.step).split(".");
			if(stepVal.length > 1)
			{
				var precision = stepVal[1].length;
				var values = String(value).split(".");
				if(values.length > 1)
				{
					value = Number.parseFloat(values[0] + "." + values[1].substr(0, precision));
				}
			}
		}

		this.value = value;
		this.updateValue();
	};

	/**
	 * Get Slider value.
	 *
	 * @method getValue
	 * @return {number} Value of the slider.
	 */
	Slider.prototype.getValue = function()
	{
		return this.value;
	};

	/**
	 * Update the DOM elements to represent the value.
	 *
	 * @method updateValue
	 */
	Slider.prototype.updateValue = function()
	{
		var progress = ((this.value - this.min) / (this.max - this.min)) * 100;

		this.progress.style.width = progress + "%";
		this.scrubber.style.left = progress + "%";
		this.textValue.data = this.value;
	};

	Slider.prototype.destroy = function()
	{
		Component.prototype.destroy.call(this);
		
		if(document.body.contains(this.text))
		{
			document.body.removeChild(this.text);
		}
	};

	function TetrahedronGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.tetrahedron);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Detail
		this.form.addText(Locale.detail);
		this.detail = new Slider(this.form);
		this.detail.size.set(90, 18);
		this.detail.setRange(0, 8);
		this.detail.setStep(1);
		this.detail.setOnChange(updateGeometry);
		this.form.add(this.detail);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	TetrahedronGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.TetrahedronBufferGeometry : three.TetrahedronGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.detail.getValue())));
	};

	TetrahedronGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 2);
		this.detail.setValue(this.object.geometry.parameters.detail || 0);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function TerrainGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.plane);
		this.form.nextRow();
		
		// Scale
		this.form.addText(Locale.scale);
		this.scale = new NumberBox(this.form);
		this.scale.size.set(60, 18);
		this.scale.setStep(0.1);
		this.scale.setRange(0, Number.MAX_SAFE_INTEGER);
		this.scale.setOnChange(updateGeometry);
		this.form.add(this.scale);
		this.form.nextRow();

		// Image
		this.form.addText(Locale.image);
		this.image = new ImageChooser(this.form);
		this.image.size.set(0, 100);
		this.image.setOnChange(updateGeometry);
		this.form.add(this.image);
		this.form.nextRow();

		// Size
		this.form.addText(Locale.size);
		this.sizeRow = new NumberRow(this.form);
		this.sizeRow.size.set(0, 18);

		this.width = this.sizeRow.addValue("X");
		this.width.setStep(0.1);
		this.width.setOnChange(updateGeometry);

		this.height = this.sizeRow.addValue("Y");
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);

		this.form.add(this.sizeRow);
		this.form.nextRow();
		
		// Segments
		this.form.addText(Locale.segments);
		this.segmentsRow = new NumberRow(this.form);
		this.segmentsRow.size.set(0, 18);

		this.widthSegments = this.segmentsRow.addValue("X");
		this.widthSegments.setStep(1);
		this.widthSegments.setOnChange(updateGeometry);

		this.heightSegments = this.segmentsRow.addValue("Y");
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);

		this.form.add(this.segmentsRow);
		this.form.nextRow();
	}

	TerrainGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var geometry = new TerrainBufferGeometry(this.width.getValue(), this.height.getValue(), this.widthSegments.getValue(), this.heightSegments.getValue(), this.scale.getValue(), this.image.getValue());
		Editor$1.addAction(new ChangeAction(this.object, "geometry", geometry));
	};

	TerrainGeometryForm.prototype.updateValues = function()
	{
		this.width.setValue(this.object.geometry.parameters.width || 1);
		this.height.setValue(this.object.geometry.parameters.height || 1);
		this.widthSegments.setValue(this.object.geometry.parameters.widthSegments || 1);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.scale.setValue(this.object.geometry.parameters.scale);
		this.image.setValue(this.object.geometry.image);
	};

	function SphereGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.sphere);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.form.nextRow();
		
		this.form.addText(Locale.width);
		this.widthSegments = new NumberBox(this.form);
		this.widthSegments.size.set(0, 18);
		this.widthSegments.setStep(1);
		this.widthSegments.setOnChange(updateGeometry);
		this.form.add(this.widthSegments);
		this.form.nextRow();

		this.form.addText(Locale.height);
		this.heightSegments = new NumberBox(this.form);
		this.heightSegments.size.set(0, 18);
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);
		this.form.add(this.heightSegments);
		this.form.nextRow();

		this.form.addText(Locale.phiStart);
		this.phiStart = new NumberBox(this.form);
		this.phiStart.size.set(0, 18);
		this.phiStart.setStep(0.01);
		this.phiStart.setOnChange(updateGeometry);
		this.form.add(this.phiStart);
		this.form.nextRow();
		
		this.form.addText(Locale.phiLength);
		this.phiLength = new NumberBox(this.form);
		this.phiLength.size.set(0, 18);
		this.phiLength.setStep(0.01);
		this.phiLength.setOnChange(updateGeometry);
		this.form.add(this.phiLength);
		this.form.nextRow();

		this.form.addText(Locale.thetaStart);
		this.thetaStart = new NumberBox(this.form);
		this.thetaStart.size.set(0, 18);
		this.thetaStart.setStep(0.01);
		this.thetaStart.setOnChange(updateGeometry);
		this.form.add(this.thetaStart);
		this.form.nextRow();

		this.form.addText(Locale.thetaLength);
		this.thetaLength = new NumberBox(this.form);
		this.thetaLength.size.set(0, 18);
		this.thetaLength.setStep(0.01);
		this.thetaLength.setOnChange(updateGeometry);
		this.form.add(this.thetaLength);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	SphereGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.SphereBufferGeometry : three.SphereGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.widthSegments.getValue(), this.heightSegments.getValue(), this.phiStart.getValue(), this.phiLength.getValue(), this.thetaStart.getValue(), this.thetaLength.getValue())));
	};

	SphereGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 50);
		this.widthSegments.setValue(this.object.geometry.parameters.widthSegments || 8);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 6);
		this.phiStart.setValue(this.object.geometry.parameters.phiStart || 0);
		this.phiLength.setValue(this.object.geometry.parameters.phiLength || Math.PI * 2);
		this.thetaStart.setValue(this.object.geometry.parameters.thetaStart || 0);
		this.thetaLength.setValue(this.object.geometry.parameters.thetaLength || Math.PI);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function BoxGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.box);
		this.form.nextRow();
		
		// Size
		this.form.addText(Locale.size);
		this.sizeRow = new NumberRow(this.form);
		this.sizeRow.size.set(0, 18);

		this.width = this.sizeRow.addValue("X");
		this.width.setStep(0.1);
		this.width.setOnChange(updateGeometry);

		this.height = this.sizeRow.addValue("Y");
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);

		this.depth = this.sizeRow.addValue("Z");
		this.depth.setStep(0.1);
		this.depth.setOnChange(updateGeometry);

		this.form.add(this.sizeRow);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.segmentsRow = new NumberRow(this.form);
		this.segmentsRow.size.set(0, 18);

		this.widthSegments = this.segmentsRow.addValue("X");
		this.widthSegments.setStep(1);
		this.widthSegments.setOnChange(updateGeometry);

		this.heightSegments = this.segmentsRow.addValue("Y");
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);

		this.depthSegments = this.segmentsRow.addValue("Z");
		this.depthSegments.setStep(1);
		this.depthSegments.setOnChange(updateGeometry);

		this.form.add(this.segmentsRow);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	BoxGeometryForm.prototype.updateGeometry = function()
	{
		var GeometryConstructor = this.buffer.getValue() ? three.BoxBufferGeometry : three.BoxGeometry;
		var geometry = new GeometryConstructor(this.width.getValue(), this.height.getValue(), this.depth.getValue(), this.widthSegments.getValue(), this.heightSegments.getValue(), this.depthSegments.getValue());

		this.object.geometry.dispose();
		Editor$1.addAction(new ChangeAction(this.object, "geometry", geometry));
	};


	BoxGeometryForm.prototype.updateValues = function()
	{
		this.width.setValue(this.object.geometry.parameters.width || 1);
		this.height.setValue(this.object.geometry.parameters.height || 1);
		this.depth.setValue(this.object.geometry.parameters.depth || 1);
		this.widthSegments.setValue(this.object.geometry.parameters.widthSegments || 1);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.depthSegments.setValue(this.object.geometry.parameters.depthSegments || 1);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function RoundedBoxGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.roundedBox);
		this.form.nextRow();

		// Size
		this.form.addText(Locale.width);
		this.width = new NumberBox(this.form);
		this.width.size.set(0, 18);
		this.width.setStep(0.1);
		this.width.setOnChange(updateGeometry);
		this.form.add(this.width);
		this.form.nextRow();

		this.form.addText(Locale.height);
		this.height = new NumberBox(this.form);
		this.height.size.set(0, 18);
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);
		this.form.add(this.height);
		this.form.nextRow();

		this.form.addText(Locale.depth);
		this.depth = new NumberBox(this.form);
		this.depth.size.set(0, 18);
		this.depth.setStep(0.1);
		this.depth.setOnChange(updateGeometry);
		this.form.add(this.depth);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.01);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Radius segments
		this.form.addText(Locale.radiusSegments);
		this.radiusSegments = new NumberBox(this.form);
		this.radiusSegments.size.set(0, 18);
		this.radiusSegments.setStep(1.0);
		this.radiusSegments.setOnChange(updateGeometry);
		this.form.add(this.radiusSegments);
		this.form.nextRow();
	}

	RoundedBoxGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();

		var geometry = new RoundedBoxBufferGeometry(this.width.getValue(), this.height.getValue(), this.depth.getValue(), this.radius.getValue(), this.radiusSegments.getValue());

		Editor$1.addAction(new ChangeAction(this.object, "geometry", geometry));
	};

	RoundedBoxGeometryForm.prototype.updateValues = function()
	{
		this.width.setValue(this.object.geometry.parameters.width);
		this.height.setValue(this.object.geometry.parameters.height);
		this.depth.setValue(this.object.geometry.parameters.depth);
		this.radius.setValue(this.object.geometry.parameters.radius);
		this.radiusSegments.setValue(this.object.geometry.parameters.radiusSegments);

	};

	function RingGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.ring);
		this.form.nextRow();
		
		// Inner radius
		this.form.addText(Locale.innerRadius);
		this.innerRadius = new NumberBox(this.form);
		this.innerRadius.size.set(60, 18);
		this.innerRadius.setStep(0.1);
		this.innerRadius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.innerRadius.setOnChange(updateGeometry);
		this.form.add(this.innerRadius);
		this.form.nextRow();

		// Outer radius
		this.form.addText(Locale.outerRadius);
		this.outerRadius = new NumberBox(this.form);
		this.outerRadius.size.set(60, 18);
		this.outerRadius.setStep(0.1);
		this.outerRadius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.outerRadius.setOnChange(updateGeometry);
		this.form.add(this.outerRadius);
		this.form.nextRow();

		// Theta segments
		this.form.addText(Locale.thetaSegments);
		this.thetaSegments = new NumberBox(this.form);
		this.thetaSegments.size.set(60, 18);
		this.thetaSegments.setStep(1.0);
		this.thetaSegments.setRange(3, Number.MAX_SAFE_INTEGER);
		this.thetaSegments.setOnChange(updateGeometry);
		this.form.add(this.thetaSegments);
		this.form.nextRow();

		// Phi segments
		this.form.addText(Locale.phiSegments);
		this.phiSegments = new NumberBox(this.form);
		this.phiSegments.size.set(60, 18);
		this.phiSegments.setStep(1.0);
		this.phiSegments.setRange(3, Number.MAX_SAFE_INTEGER);
		this.phiSegments.setOnChange(updateGeometry);
		this.form.add(this.phiSegments);
		this.form.nextRow();

		// Theta start
		this.form.addText(Locale.thetaStart);
		this.thetaStart = new NumberBox(this.form);
		this.thetaStart.size.set(60, 18);
		this.thetaStart.setStep(0.1);
		this.thetaStart.setOnChange(updateGeometry);
		this.form.add(this.thetaStart);
		this.form.nextRow();

		// Theta length
		this.form.addText(Locale.thetaLength);
		this.thetaLength = new NumberBox(this.form);
		this.thetaLength.size.set(60, 18);
		this.thetaLength.setStep(0.1);
		this.thetaLength.setOnChange(updateGeometry);
		this.form.add(this.thetaLength);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	RingGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.RingBufferGeometry : three.RingGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.innerRadius.getValue(), this.outerRadius.getValue(), this.thetaSegments.getValue(), this.phiSegments.getValue(), this.thetaStart.getValue(), this.thetaLength.getValue())));
	};

	RingGeometryForm.prototype.updateValues = function()
	{
		this.innerRadius.setValue(this.object.geometry.parameters.innerRadius || 0.5);
		this.outerRadius.setValue(this.object.geometry.parameters.outerRadius || 1);
		this.thetaSegments.setValue(this.object.geometry.parameters.thetaSegments || 8);
		this.phiSegments.setValue(this.object.geometry.parameters.phiSegments || 8);
		this.thetaStart.setValue(this.object.geometry.parameters.thetaStart || 0);
		this.thetaLength.setValue(this.object.geometry.parameters.thetaLength || Math.PI * 2);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function PlaneGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.plane);
		this.form.nextRow();
		
		// Size
		this.form.addText(Locale.size);
		this.sizeRow = new NumberRow(this.form);
		this.sizeRow.size.set(0, 18);

		this.width = this.sizeRow.addValue("X");
		this.width.setStep(0.1);
		this.width.setOnChange(updateGeometry);

		this.height = this.sizeRow.addValue("Y");
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);

		this.form.add(this.sizeRow);
		this.form.nextRow();
		
		// Segments
		this.form.addText(Locale.segments);
		this.segmentsRow = new NumberRow(this.form);
		this.segmentsRow.size.set(0, 18);

		this.widthSegments = this.segmentsRow.addValue("X");
		this.widthSegments.setStep(1);
		this.widthSegments.setOnChange(updateGeometry);

		this.heightSegments = this.segmentsRow.addValue("Y");
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);

		this.form.add(this.segmentsRow);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	PlaneGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.PlaneBufferGeometry : three.PlaneGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.width.getValue(), this.height.getValue(), this.widthSegments.getValue(), this.heightSegments.getValue())));
	};

	PlaneGeometryForm.prototype.updateValues = function()
	{
		this.width.setValue(this.object.geometry.parameters.width || 1);
		this.height.setValue(this.object.geometry.parameters.height || 1);
		this.widthSegments.setValue(this.object.geometry.parameters.widthSegments || 1);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function OctahedronGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.octahedron);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Detail
		this.form.addText(Locale.detail);
		this.detail = new Slider(this.form);
		this.detail.size.set(90, 18);
		this.detail.setRange(0, 8);
		this.detail.setStep(1);
		this.detail.setOnChange(updateGeometry);
		this.form.add(this.detail);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	OctahedronGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.OctahedronBufferGeometry : three.OctahedronGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.detail.getValue())));
	};

	OctahedronGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 2);
		this.detail.setValue(this.object.geometry.parameters.detail || 0);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function IcosahedronGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.icosahedron);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Detail
		this.form.addText(Locale.detail);
		this.detail = new Slider(this.form);
		this.detail.size.set(90, 18);
		this.detail.setRange(0, 8);
		this.detail.setStep(1);
		this.detail.setOnChange(updateGeometry);
		this.form.add(this.detail);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	IcosahedronGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.IcosahedronBufferGeometry : three.IcosahedronGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.detail.getValue())));
	};

	IcosahedronGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 2);
		this.detail.setValue(this.object.geometry.parameters.detail || 0);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function DodecahedronGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.dodecahedron);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Detail
		this.form.addText(Locale.detail);
		this.detail = new Slider(this.form);
		this.detail.size.set(90, 18);
		this.detail.setRange(0, 8);
		this.detail.setStep(1);
		this.detail.setOnChange(updateGeometry);
		this.form.add(this.detail);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	DodecahedronGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.DodecahedronBufferGeometry : three.DodecahedronGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.detail.getValue())));
	};

	DodecahedronGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 2);
		this.detail.setValue(this.object.geometry.parameters.detail || 0);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function CylinderGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.cylinder);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.form.nextRow();

		this.form.addText(Locale.top);
		this.radiusTop = new NumberBox(this.form);
		this.radiusTop.size.set(0, 18);
		this.radiusTop.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radiusTop.setOnChange(updateGeometry);
		this.form.add(this.radiusTop);
		this.form.nextRow();

		this.form.addText(Locale.bottom);
		this.radiusBottom = new NumberBox(this.form);
		this.radiusBottom.size.set(0, 18);
		this.radiusBottom.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radiusBottom.setOnChange(updateGeometry);
		this.form.add(this.radiusBottom);
		this.form.nextRow();

		// Height
		this.form.addText(Locale.height);
		this.height = new NumberBox(this.form);
		this.height.size.set(0, 18);
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);
		this.form.add(this.height);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.form.nextRow();

		this.form.addText(Locale.radial);
		this.radialSegments = new NumberBox(this.form);
		this.radialSegments.size.set(0, 18);
		this.radialSegments.setRange(3, Number.MAX_SAFE_INTEGER);
		this.radialSegments.setStep(1);
		this.radialSegments.setOnChange(updateGeometry);
		this.form.add(this.radialSegments);
		this.form.nextRow();

		this.form.addText(Locale.height);
		this.heightSegments = new NumberBox(this.form);
		this.heightSegments.size.set(0, 18);
		this.heightSegments.setRange(1, Number.MAX_SAFE_INTEGER);
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);
		this.form.add(this.heightSegments);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	CylinderGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.CylinderBufferGeometry : three.CylinderGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radiusTop.getValue(), this.radiusBottom.getValue(), this.height.getValue(), this.radialSegments.getValue(), this.heightSegments.getValue())));
	};

	CylinderGeometryForm.prototype.updateValues = function()
	{
		this.radiusTop.setValue(this.object.geometry.parameters.radiusTop || 20);
		this.radiusBottom.setValue(this.object.geometry.parameters.radiusBottom || 20);
		this.height.setValue(this.object.geometry.parameters.height || 100);
		this.radialSegments.setValue(this.object.geometry.parameters.radialSegments || 8);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function ConeGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.cone);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(0, 18);
		this.radius.setStep(0.1);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		this.form.addText(Locale.height);
		this.height = new NumberBox(this.form);
		this.height.size.set(0, 18);
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);
		this.form.add(this.height);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.form.nextRow();

		this.form.addText(Locale.radial);
		this.radialSegments = new NumberBox(this.form);
		this.radialSegments.size.set(0, 18);
		this.radialSegments.setRange(3, Number.MAX_SAFE_INTEGER);
		this.radialSegments.setStep(1);
		this.radialSegments.setOnChange(updateGeometry);
		this.radialSegments.setOnChange(updateGeometry);
		this.form.add(this.radialSegments);
		this.form.nextRow();

		this.form.addText(Locale.height);
		this.heightSegments = new NumberBox(this.form);
		this.heightSegments.size.set(0, 18);
		this.heightSegments.setRange(1, Number.MAX_SAFE_INTEGER);
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);
		this.heightSegments.setOnChange(updateGeometry);
		this.form.add(this.heightSegments);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	ConeGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.ConeBufferGeometry : three.ConeGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.height.getValue(), this.radialSegments.getValue(), this.heightSegments.getValue())));
	};

	ConeGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 20);
		this.height.setValue(this.object.geometry.parameters.height || 100);
		this.radialSegments.setValue(this.object.geometry.parameters.radialSegments || 8);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function CircleGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.circle);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(60, 18);
		this.radius.setStep(0.1);
		this.radius.setRange(0, Number.MAX_SAFE_INTEGER);
		this.radius.setOnChange(updateGeometry);
		this.form.add(this.radius);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.segments = new NumberBox(this.form);
		this.segments.size.set(60, 18);
		this.segments.setStep(1.0);
		this.segments.setRange(3, Number.MAX_SAFE_INTEGER);
		this.segments.setOnChange(updateGeometry);
		this.form.add(this.segments);
		this.form.nextRow();

		// Theta start
		this.form.addText(Locale.tethaStart);
		this.thetaStart = new NumberBox(this.form);
		this.thetaStart.size.set(60, 18);
		this.thetaStart.setStep(0.1);
		this.thetaStart.setOnChange(updateGeometry);
		this.form.add(this.thetaStart);
		this.form.nextRow();

		// Theta length
		this.form.addText(Locale.tethaLength);
		this.thetaLength = new NumberBox(this.form);
		this.thetaLength.size.set(60, 18);
		this.thetaLength.setStep(0.1);
		this.thetaLength.setOnChange(updateGeometry);
		this.form.add(this.thetaLength);
		this.form.nextRow();

		// Buffer
		this.buffer = new CheckBox(this.form);
		this.form.addText(Locale.buffered);
		this.buffer.size.set(18, 18);
		this.buffer.setOnChange(updateGeometry);
		this.form.add(this.buffer);
		this.form.nextRow();
	}

	CircleGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();
		var GeometryConstructor = this.buffer.getValue() ? three.CircleBufferGeometry : three.CircleGeometry;
		Editor$1.addAction(new ChangeAction(this.object, "geometry", new GeometryConstructor(this.radius.getValue(), this.segments.getValue(), this.thetaStart.getValue(), this.thetaLength.getValue())));
	};

	CircleGeometryForm.prototype.updateValues = function()
	{
		this.radius.setValue(this.object.geometry.parameters.radius || 1);
		this.segments.setValue(this.object.geometry.parameters.segments || 32);
		this.thetaStart.setValue(this.object.geometry.parameters.thetaStart || 0);
		this.thetaLength.setValue(this.object.geometry.parameters.thetaLength || Math.PI * 2);
		this.buffer.setValue(this.object.geometry instanceof three.BufferGeometry);
	};

	function CapsuleGeometryForm(form, object)
	{
		this.form = form;
		this.object = object;
		
		var self = this;

		var updateGeometry = function()
		{
			self.updateGeometry();
		};

		this.form.addText(Locale.capsule);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.form.nextRow();
		
		this.form.addText(Locale.top);
		this.radiusTop = new NumberBox(this.form);
		this.radiusTop.size.set(0, 18);
		this.radiusTop.setStep(0.1);
		this.radiusTop.setOnChange(updateGeometry);
		this.form.add(this.radiusTop);
		this.form.nextRow();

		this.form.addText(Locale.bottom);
		this.radiusBottom = new NumberBox(this.form);
		this.radiusBottom.size.set(0, 18);
		this.radiusBottom.setStep(0.1);
		this.radiusBottom.setOnChange(updateGeometry);
		this.form.add(this.radiusBottom);
		this.form.nextRow();

		// Height
		this.form.addText(Locale.height);
		this.height = new NumberBox(this.form);
		this.height.size.set(0, 18);
		this.height.setStep(0.1);
		this.height.setOnChange(updateGeometry);
		this.form.add(this.height);
		this.form.nextRow();

		// Theta start
		this.form.addText(Locale.thetaStart);
		this.thetaStart = new NumberBox(this.form);
		this.thetaStart.size.set(0, 18);
		this.thetaStart.setStep(0.01);
		this.thetaStart.setOnChange(updateGeometry);
		this.form.add(this.thetaStart);
		this.form.nextRow();

		// Theta length
		this.form.addText(Locale.thetaLength);
		this.thetaLength = new NumberBox(this.form);
		this.thetaLength.size.set(0, 18);
		this.thetaLength.setStep(0.01);
		this.thetaLength.setOnChange(updateGeometry);
		this.form.add(this.thetaLength);
		this.form.nextRow();

		// Segments
		this.form.addText(Locale.segments);
		this.form.nextRow();

		this.form.addText(Locale.radial);
		this.radialSegments = new NumberBox(this.form);
		this.radialSegments.size.set(0, 18);
		this.radialSegments.setRange(3, Number.MAX_SAFE_INTEGER);
		this.radialSegments.setStep(1);
		this.radialSegments.setOnChange(updateGeometry);
		this.form.add(this.radialSegments);
		this.form.nextRow();

		this.form.addText(Locale.height);
		this.heightSegments = new NumberBox(this.form);
		this.heightSegments.size.set(0, 18);
		this.heightSegments.setRange(1, Number.MAX_SAFE_INTEGER);
		this.heightSegments.setStep(1);
		this.heightSegments.setOnChange(updateGeometry);
		this.form.add(this.heightSegments);
		this.form.nextRow();

		this.form.addText(Locale.top);
		this.capsTopSegments = new NumberBox(this.form);
		this.capsTopSegments.size.set(0, 18);
		this.capsTopSegments.setRange(1, Number.MAX_SAFE_INTEGER);
		this.capsTopSegments.setStep(1);
		this.capsTopSegments.setOnChange(updateGeometry);
		this.form.add(this.capsTopSegments);
		this.form.nextRow();

		this.form.addText(Locale.bottom);
		this.capsBottomSegments = new NumberBox(this.form);
		this.capsBottomSegments.size.set(0, 18);
		this.capsBottomSegments.setRange(1, Number.MAX_SAFE_INTEGER);
		this.capsBottomSegments.setStep(1);
		this.capsBottomSegments.setOnChange(updateGeometry);
		this.form.add(this.capsBottomSegments);
		this.form.nextRow();
	}

	CapsuleGeometryForm.prototype.updateGeometry = function()
	{
		this.object.geometry.dispose();

		var geometry = new CapsuleBufferGeometry(this.radiusTop.getValue(), this.radiusBottom.getValue(), this.height.getValue(),
										this.radialSegments.getValue(), this.heightSegments.getValue(), this.capsTopSegments.getValue(),
										this.capsBottomSegments.getValue(), this.thetaStart.getValue(), this.thetaLength.getValue());

		Editor$1.addAction(new ChangeAction(this.object, "geometry", geometry));
	};

	CapsuleGeometryForm.prototype.updateValues = function()
	{
		this.radiusTop.setValue(this.object.geometry.parameters.radiusTop || 0.5);
		this.radiusBottom.setValue(this.object.geometry.parameters.radiusBottom || 0.5);
		this.height.setValue(this.object.geometry.parameters.height || 1.0);
		this.radialSegments.setValue(this.object.geometry.parameters.radialSegments || 32);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.radialSegments.setValue(this.object.geometry.parameters.radialSegments || 32);
		this.heightSegments.setValue(this.object.geometry.parameters.heightSegments || 1);
		this.capsTopSegments.setValue(this.object.geometry.parameters.capsTopSegments || 8);
		this.capsBottomSegments.setValue(this.object.geometry.parameters.capsBottomSegments || 8);
		this.thetaStart.setValue(this.object.geometry.parameters.thetaStart || 0);
		this.thetaLength.setValue(this.object.geometry.parameters.thetaLength || Math.PI * 2);
	};

	function GeometryForm(){}

	GeometryForm.create = function(form, object)
	{
		var geometry = object.geometry;
		
		if(geometry instanceof three.BoxGeometry || geometry instanceof three.BoxBufferGeometry)
		{
			return new BoxGeometryForm(form, object);
		}
		else if(geometry instanceof three.SphereGeometry || geometry instanceof three.SphereBufferGeometry)
		{
			return new SphereGeometryForm(form, object);
		}
		else if(geometry instanceof three.TorusGeometry || geometry instanceof three.TorusBufferGeometry)
		{
			return new TorusGeometryForm(form, object);
		}
		else if(geometry instanceof three.PlaneGeometry || geometry instanceof three.PlaneBufferGeometry)
		{
			return new PlaneGeometryForm(form, object);
		}
		else if(geometry instanceof three.ConeGeometry || geometry instanceof three.ConeBufferGeometry)
		{
			return new ConeGeometryForm(form, object);
		}
		else if(geometry instanceof three.CylinderGeometry || geometry instanceof three.CylinderBufferGeometry)
		{
			return new CylinderGeometryForm(form, object);
		}
		else if(geometry instanceof three.TetrahedronGeometry || geometry instanceof three.TetrahedronBufferGeometry)
		{
			return new TetrahedronGeometryForm(form, object);
		}
		else if(geometry instanceof three.DodecahedronGeometry || geometry instanceof three.DodecahedronBufferGeometry)
		{
			return new DodecahedronGeometryForm(form, object);
		}
		else if(geometry instanceof three.CircleGeometry || geometry instanceof three.CircleBufferGeometry)
		{
			return new CircleGeometryForm(form, object);
		}
		else if(geometry instanceof three.TorusKnotGeometry || geometry instanceof three.TorusKnotBufferGeometry)
		{
			return new TorusKnotGeometryForm(form, object);
		}
		else if(geometry instanceof three.RingGeometry || geometry instanceof three.RingBufferGeometry)
		{
			return new RingGeometryForm(form, object);
		}
		else if(geometry instanceof three.IcosahedronGeometry || geometry instanceof three.IcosahedronBufferGeometry)
		{
			return new IcosahedronGeometryForm(form, object);
		}
		else if(geometry instanceof three.OctahedronGeometry || geometry instanceof three.OctahedronBufferGeometry)
		{
			return new OctahedronGeometryForm(form, object);
		}
		else if(geometry instanceof CapsuleBufferGeometry)
		{
			return new CapsuleGeometryForm(form, object);
		}
		else if(geometry instanceof RoundedBoxBufferGeometry)
		{
			return new RoundedBoxGeometryForm(form, object);
		}
		else if(geometry instanceof TerrainBufferGeometry)
		{
			return new TerrainGeometryForm(form, object);
		}

		return null;
	};

	function MeshInspector(parent, object)
	{
		DrawableInspector.call(this, parent, object);

		this.geometry = GeometryForm.create(this.form, this.object);
	}

	MeshInspector.prototype = Object.create(DrawableInspector.prototype);

	MeshInspector.prototype.updateInspector = function()
	{
		DrawableInspector.prototype.updateInspector.call(this);
		
		if(this.geometry !== null)
		{
			try
			{
				this.geometry.updateValues();
			}
			catch(e)
			{
				this.geometry.destroy();
				this.geometry = GeometryForm.create(this.form, this.object);
			}
		}
	};

	function TextMeshInspector(parent, object)
	{
		DrawableInspector.call(this, parent, object);

		var self = this;

		function updateGeometry()
		{
			self.object.updateGeometry();
		}

		// Text
		this.form.addText(Locale.text);
		this.text = new TextArea(this.form);
		this.text.size.set(190, 55);
		this.text.setOnInput(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "text", self.text.getText()), updateGeometry));
		}, 500);
		this.form.add(this.text);
		this.form.nextRow();

		// Size
		this.form.addText(Locale.size);
		this.textSize = new NumberBox(this.form);
		this.textSize.size.set(0, 18);
		this.textSize.setRange(0, Number.MAX_SAFE_INTEGER);
		this.textSize.setStep(0.1);
		this.textSize.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "size", self.textSize.getValue()), updateGeometry));
		});
		this.form.add(this.textSize);
		this.form.nextRow();

		// Extruded
		this.extruded = new CheckBox(this.form);
		this.form.addText("Extruded");
		this.extruded.size.set(18, 18);
		this.extruded.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "extruded", self.extruded.getValue()), updateGeometry));
		});
		this.form.add(this.extruded);
		this.form.nextRow();

		// Height
		this.form.addText(Locale.thickness);
		this.height = new NumberBox(this.form);
		this.height.size.set(0, 18);
		this.height.setRange(0, Number.MAX_SAFE_INTEGER);
		this.height.setStep(0.1);
		this.height.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "height", self.height.getValue()), updateGeometry));
		});
		this.form.add(this.height);
		this.form.nextRow();

		// Curve segments
		this.form.addText("Curve Detail");
		this.curveSegments = new NumberBox(this.form);
		this.curveSegments.size.set(0, 18);
		this.curveSegments.setRange(0, Number.MAX_SAFE_INTEGER);
		this.curveSegments.setStep(1.0);
		this.curveSegments.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "curveSegments", self.curveSegments.getValue()), updateGeometry));
		});
		this.form.add(this.curveSegments);
		this.form.nextRow();

		// Bevel
		this.bevel = new CheckBox(this.form);
		this.form.addText(Locale.bevel);
		this.bevel.size.set(18, 18);
		this.bevel.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "bevel", self.bevel.getValue()), updateGeometry));
		});
		this.form.add(this.bevel);
		this.form.nextRow();

		// Bevel thickness
		this.form.addText("Bevel Thickness");
		this.bevelThickness = new NumberBox(this.form);
		this.bevelThickness.size.set(0, 18);
		this.bevelThickness.setRange(0, Number.MAX_SAFE_INTEGER);
		this.bevelThickness.setStep(0.1);
		this.bevelThickness.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "bevelThickness", self.bevelThickness.getValue()), updateGeometry));
		});
		this.form.add(this.bevelThickness);
		this.form.nextRow();

		// Bevel size
		this.form.addText("Bevel Size");
		this.bevelSize = new NumberBox(this.form);
		this.bevelSize.size.set(0, 18);
		this.bevelSize.setRange(0, Number.MAX_SAFE_INTEGER);
		this.bevelSize.setStep(0.1);
		this.bevelSize.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "bevelSize", self.bevelSize.getValue()), updateGeometry));
		});
		this.form.add(this.bevelSize);
		this.form.nextRow();
	}

	TextMeshInspector.prototype = Object.create(DrawableInspector.prototype);

	TextMeshInspector.prototype.updateInspector = function()
	{
		DrawableInspector.prototype.updateInspector.call(this);

		this.text.setText(this.object.text);
		this.textSize.setValue(this.object.size);
		this.extruded.setValue(this.object.extruded);
		this.height.setValue(this.object.height);
		this.curveSegments.setValue(this.object.curveSegments);
		this.bevel.setValue(this.object.bevel);
		this.bevelThickness.setValue(this.object.bevelThickness);
		this.bevelSize.setValue(this.object.bevelSize);
	};

	function TextBitmapInspector(parent, object)
	{
		DrawableInspector.call(this, parent, object);

		var self = this;

		// Text
		this.form.addText(Locale.text);
		this.text = new TextArea(this.form);
		this.text.size.set(0, 55);
		this.text.setOnInput(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "text", self.text.getText()));
		}, 500);
		this.form.add(this.text);
		this.form.nextRow();

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(100, 18);
		this.color.setValue(0, 0, 0);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Shader
		this.form.addText(Locale.shader);
		this.shader = new DropdownList(this.form);
		this.shader.size.set(0, 18);
		this.shader.addValue("SDF", TextBitmap.SDF);
		this.shader.addValue("MSDF", TextBitmap.MSDF);
		this.shader.addValue("Bitmap", TextBitmap.BITMAP);
		this.shader.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "shader", self.shader.getValue()));
		});
		this.form.add(this.shader);
		this.form.nextRow();

		// Align
		this.form.addText(Locale.align);
		this.align = new DropdownList(this.form);
		this.align.size.set(0, 18);
		this.align.addValue(Locale.left, TextBitmap.LEFT);
		this.align.addValue(Locale.right, TextBitmap.RIGHT);
		this.align.addValue(Locale.center, TextBitmap.CENTER);
		this.align.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "align", self.align.getValue()));
		});
		this.form.add(this.align);
		this.form.nextRow();

		// Line Height
		this.form.addText(Locale.lineHeight);
		this.lineHeight = new NumberBox(this.form);
		this.lineHeight.size.set(0, 18);
		this.lineHeight.setRange(0, Number.MAX_SAFE_INTEGER);
		this.lineHeight.setStep(0.1);
		this.lineHeight.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "lineHeight", self.lineHeight.getValue()));
		});
		this.form.add(this.lineHeight);
		this.form.nextRow();

		// Line Height
		this.form.addText(Locale.letterSpacing);
		this.letterSpacing = new NumberBox(this.form);
		this.letterSpacing.size.set(0, 18);
		this.letterSpacing.setRange(0, Number.MAX_SAFE_INTEGER);
		this.letterSpacing.setStep(0.1);
		this.letterSpacing.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "letterSpacing", self.letterSpacing.getValue()));
		});
		this.form.add(this.letterSpacing);
		this.form.nextRow();

		// Width
		this.form.addText(Locale.width);
		this.width = new NumberBox(this.form);
		this.width.size.set(0, 18);
		this.width.setRange(0, Number.MAX_SAFE_INTEGER);
		this.width.setStep(0.1);
		this.width.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "width", self.width.getValue()));
		});
		this.form.add(this.width);
		this.form.nextRow();

		// Threshold
		this.form.addText(Locale.threshold);
		this.threshold = new Slider(this.form);
		this.threshold.size.set(0, 18);
		this.threshold.setRange(0, 1.0);
		this.threshold.setStep(0.01);
		this.threshold.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "threshold", self.threshold.getValue()));
		});
		this.form.add(this.threshold);
		this.form.nextRow();

		// Smoothing
		this.form.addText(Locale.smoothing);
		this.smoothing = new Slider(this.form);
		this.smoothing.size.set(0, 18);
		this.smoothing.setRange(0, 5.0);
		this.smoothing.setStep(0.01);
		this.smoothing.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "smoothing", self.smoothing.getValue()));
		});
		this.form.add(this.smoothing);
		this.form.nextRow();
	}

	TextBitmapInspector.prototype = Object.create(DrawableInspector.prototype);

	TextBitmapInspector.prototype.updateInspector = function()
	{
		DrawableInspector.prototype.updateInspector.call(this);

		this.text.setText(this.object.text);
		this.lineHeight.setValue(this.object.lineHeight);
		this.letterSpacing.setValue(this.object.letterSpacing);
		this.align.setValue(this.object.align);
		this.width.setValue(this.object.width);
		this.color.setValue(this.object.color);
		this.threshold.setValue(this.object.threshold);
		this.smoothing.setValue(this.object.smoothing);
	};

	function SpineInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Animation
		this.form.addText("Animation");
		this.animation = new DropdownList(this.form);
		this.animation.size.set(100, 18);
		this.animation.setOnChange(function()
		{
			self.object.setAnimation(0, self.animation.getValue());
		});
		this.form.add(this.animation);
		this.form.nextRow();

		// Skin
		this.form.addText("Skin");
		this.skin = new DropdownList(this.form);
		this.skin.size.set(100, 18);
		this.skin.setOnChange(function()
		{
			self.object.setSkin(self.skin.getValue());
		});
		this.form.add(this.skin);
		this.form.nextRow();

		// Cast shadow
		this.castShadow = new CheckBox(this.form);
		this.form.addText(Locale.castShadows);
		this.castShadow.size.set(18, 18);
		this.castShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "castShadow", self.castShadow.getValue()));
		});
		this.form.add(this.castShadow);
		this.form.nextRow();

		// Receive shadow
		this.receiveShadow = new CheckBox(this.form);
		this.form.addText(Locale.receiveShadows);
		this.receiveShadow.size.set(18, 18);
		this.receiveShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "receiveShadow", self.receiveShadow.getValue()));
		});
		this.form.add(this.receiveShadow);
		this.form.nextRow();
	}

	SpineInspector.prototype = Object.create(ObjectInspector.prototype);

	// Update panel content from attached object
	SpineInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
			
		this.animation.clearValues();
		this.skin.clearValues();
		
		var animations = this.object.getAnimations();
		for(var i = 0; i < animations.length; i++)
		{
			this.animation.addValue(animations[i].name, animations[i].name);
		}

		var skins = this.object.getSkins();
		for(var i = 0; i < skins.length; i++)
		{
			this.skin.addValue(skins[i].name, skins[i].name);
		}

		this.animation.setValue(this.object.animation);
		this.skin.setValue(this.object.skin);
		this.castShadow.setValue(this.object.castShadow);
		this.receiveShadow.setValue(this.object.receiveShadow);
	};

	function ScriptInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		this.form.addText(Locale.libraryMode);
		this.mode = new DropdownList(this.form);
		this.mode.size.set(100, 18);
		this.mode.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "mode", self.mode.getValue()));
		});
		this.mode.addValue(Locale.evaluate, Script.EVALUATE);
		this.mode.addValue(Locale.append, Script.APPEND);
		this.mode.addValue(Locale.include, Script.INCLUDE);
		this.form.add(this.mode);
		this.form.nextRow();
	}

	ScriptInspector.prototype = Object.create(ObjectInspector.prototype);

	ScriptInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.mode.setValue(this.object.mode);
	};

	function CubeTextureBox(parent)
	{
		Component.call(this, parent, "div");

		// Texture preview division
		this.preview = document.createElement("div");
		this.preview.style.cursor = "pointer";
		this.preview.style.position = "absolute";
		this.preview.style.top = "0px";
		this.preview.style.left = "0px";
		this.element.appendChild(this.preview);

		// Alpha background
		this.alpha = document.createElement("img");
		this.alpha.src = Global.FILE_PATH + "alpha.png";
		this.alpha.style.pointerEvents = "none";
		this.alpha.style.position = "absolute";
		this.alpha.style.left = "0px";
		this.alpha.style.top = "0px";
		this.alpha.style.width = "100%";
		this.alpha.style.height = "100%";
		this.preview.appendChild(this.alpha);

		// Image
		this.img = document.createElement("img");
		this.img.style.pointerEvents = "none";
		this.img.style.position = "absolute";
		this.img.style.left = "0px";
		this.img.style.top = "0px";
		this.img.style.width = "100%";
		this.img.style.height = "100%";
		this.preview.appendChild(this.img);

		var self = this;

		// On drop get file dropped
		this.preview.ondrop = function(event)
		{
			// File
			if(event.dataTransfer.files.length > 0)
			{
				var file = event.dataTransfer.files[0];
				var reader = new FileReader();
				reader.onload = function()
				{
					var image = new Image(reader.result);
					var texture = new CubeTexture([image]);
					texture.name = image.name;
					Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
					self.setTexture(texture);
				};
				reader.readAsDataURL(file);
			}
			// Resource
			else
			{		
				var uuid = event.dataTransfer.getData("uuid");
				var texture = DragBuffer.get(uuid);

				// Cube texture
				if(texture instanceof three.Texture && texture.isCubeTexture)
				{
					self.setTexture(texture);
				}
				// Image
				else if(texture instanceof Image)
				{
					var texture = new CubeTexture([texture]);
					texture.name = texture.name;
					Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
					self.setTexture(texture);
				}
			}

			event.preventDefault();
		};

		this.form = new TableForm(this);
		this.form.defaultTextWidth = 60;
		this.form.spacing.set(10, 5);

		// Use texture
		this.form.addText(Locale.useTexture);
		this.useTexture = new CheckBox(this.form);
		this.useTexture.size.set(30, 15);
		this.form.add(this.useTexture);
		this.form.nextRow();

		// WrapS
		this.form.addText(Locale.mapping);
		this.mapping = new DropdownList(this);
		this.mapping.size.set(120, 18);
		this.mapping.addValue("Cube Reflection", three.CubeReflectionMapping);
		this.mapping.addValue("Cube Refraction", three.CubeRefractionMapping);
		this.mapping.addValue("Equirectangular Reflection", three.EquirectangularReflectionMapping);
		this.mapping.addValue("Equirectangular Reflection", three.EquirectangularRefractionMapping);
		this.mapping.addValue("Spherical Reflection", three.SphericalReflectionMapping);
		this.mapping.addValue("Cube UV Reflection", three.CubeUVReflectionMapping);
		this.mapping.addValue("Cube UV Reflection", three.CubeUVRefractionMapping);
		this.form.add(this.mapping);
		this.form.nextRow();

		// onChange function
		this.onChange = null;

		// Texture
		this.texture = null;
	}

	CubeTextureBox.prototype = Object.create(Component.prototype);

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	CubeTextureBox.prototype.setOnChange = function(onChange)
	{
		this.onChange = onChange;
		this.useTexture.setOnChange(onChange);
		this.mapping.setOnChange(onChange);
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setValue
	 * @param {Texture} texture
	 */
	CubeTextureBox.prototype.setValue = function(texture)
	{
		if(texture !== null && texture.isCubeTexture)
		{
			this.texture = texture;

			this.useTexture.setValue(true);
			this.mapping.setValue(texture.mapping);

			this.updatePreview();

		}
		else
		{
			this.useTexture.setValue(false);
			this.texture = null;
		}
	};

	/**
	 * Get value stored in the input element.
	 *
	 * @method setValue
	 * @return {Object} Value stored in the input element.
	 */
	CubeTextureBox.prototype.getValue = function()
	{
		if(this.useTexture.getValue())
		{
			if(this.texture !== null)
			{
				this.texture.mapping = this.mapping.getValue();
				this.texture.needsUpdate = true;

				return this.texture;
			}
		}

		return null;
	};

	// Set Texture
	CubeTextureBox.prototype.setTexture = function(texture)
	{
		this.setValue(texture);

		if(this.onChange !== null)
		{
			this.onChange();
		}
	};

	// Update texture preview
	CubeTextureBox.prototype.updatePreview = function()
	{
		if(this.texture instanceof CubeTexture)
		{
			this.img.src = this.texture.images[0].data;
		}
		else if(this.texture instanceof CompressedTexture)
		{
			// TODO <ADD CODE HERE>
			this.img.src = Global.FILE_PATH + "icon.png";
		}
	};

	// Update Interface
	CubeTextureBox.prototype.updateInterface = function()
	{
		if(this.visible)
		{
			this.element.style.visibility = "visible";
		
			// Preview
			this.preview.style.width = this.size.y + "px";
			this.preview.style.height = this.size.y + "px";

			// Form
			this.form.position.set(this.size.y + 5, 0);
			this.form.size.set(this.size.x - this.form.position.x, this.size.y);
			this.form.visible = this.visible;
			this.form.updateInterface();

			// Element
			this.element.style.top = this.position.y + "px";
			this.element.style.left = this.position.x + "px";
			this.element.style.width = this.size.x + "px";
			this.element.style.height = this.size.y + "px";
		}
		else
		{
			this.element.style.visibility = "hidden";
		}

	};

	function SceneInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Select scene as default
		this.default = new CheckBox(this.form);
		this.form.addText(Locale.defaultScene);
		this.default.size.set(18, 18);
		this.default.setOnChange(function()
		{
			if(self.object !== null)
			{
				var program = self.object.parent;
				
				if(self.default.getValue())
				{
					Editor$1.addAction(new ChangeAction(program, "defaultScene",  self.object.uuid));
				}
				else
				{
					Editor$1.addAction(new ChangeAction(program, "defaultScene",  null));
				}
			}
		});
		this.form.add(this.default);
		this.form.nextRow();

		// Background color
		this.form.addText(Locale.background);
		this.background = new ColorChooser(this.form);
		this.background.size.set(100, 18);
		this.background.setValue(0, 0, 0);
		this.background.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "background", new three.Color(self.background.getValueHex())));
		});
		this.form.add(this.background);
		this.form.nextRow();

		// Background texture
		this.form.addText("");
		this.backgroundTexture = new TextureChooser(this.form);
		this.backgroundTexture.acceptAll = true;
		this.backgroundTexture.size.set(0, 100);
		this.backgroundTexture.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.object, "background", self.backgroundTexture.getValue()));
		});
		this.form.add(this.backgroundTexture);
		this.form.nextRow();

		this.form.addText("");
		this.backgroundTransparent = new ButtonText(this.form);
		this.backgroundTransparent.setText(Locale.setTransparent);
		this.backgroundTransparent.size.set(100, 18);
		this.backgroundTransparent.setOnClick(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "background", null));
		});
		this.form.add(this.backgroundTransparent);
		this.form.nextRow();

		// Environment map
		this.form.addText(Locale.environmentMap);
		this.environment = new CubeTextureBox(this.form);
		this.environment.size.set(0, 100);
		this.environment.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.object, "environment", self.environment.getValue()));
		});
		this.form.add(this.environment);
		this.form.nextRow();

		// Fog
		this.form.addText(Locale.fog);
		this.fog = new DropdownList(this.form);
		this.fog.size.set(100, 18);
		this.fog.addValue(Locale.none, three.Fog.NONE);
		this.fog.addValue(Locale.linear, three.Fog.LINEAR);
		this.fog.addValue(Locale.exponential, three.Fog.EXPONENTIAL);
		this.fog.setOnChange(function()
		{
			self.object.setFogMode(self.fog.getSelectedIndex());
			self.updateInspector();
		});
		this.form.add(this.fog);
		this.form.nextRow();

		// Linear fog properties
		this.fogLinearForm = new TableForm(this.form);
		this.fogLinearForm.spacing.set(5, 5);

		// Linear fog color
		this.fogLinearForm.addText(Locale.color);
		this.fogLinearColor = new ColorChooser(this.fogLinearForm);
		this.fogLinearColor.size.set(80, 18);
		this.fogLinearColor.setOnChange(function()
		{
			var color = self.fogLinearColor.getValueHex();
			self.fogExponentialColor.setValueHex(color);
			self.object.fog.color.setHex(color);
		});
		this.fogLinearForm.add(this.fogLinearColor);
		this.fogLinearForm.nextRow();

		// Linear fog near
		this.fogLinearForm.addText(Locale.near);
		this.fogNear = new NumberBox(this.fogLinearForm);
		this.fogNear.size.set(60, 18);
		this.fogNear.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.fog, "near", self.fogNear.getValue()));
		});
		this.fogLinearForm.add(this.fogNear);
		this.fogLinearForm.nextRow();

		// Linear fog far
		this.fogLinearForm.addText(Locale.near);
		this.fogFar = new NumberBox(this.fogLinearForm);
		this.fogFar.size.set(60, 18);
		this.fogFar.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.fog, "far", self.fogFar.getValue()));
		});
		this.fogLinearForm.add(this.fogFar);
		this.fogLinearForm.updateInterface();

		// Add linear fog form
		this.form.add(this.fogLinearForm);
		this.form.nextRow();

		// Exponential fog properties
		this.fogExponentialForm = new TableForm(this.form);
		this.fogExponentialForm.spacing.set(5, 5);

		// Exponential fog color
		this.fogExponentialForm.addText(Locale.color);
		this.fogExponentialColor = new ColorChooser(this.fogExponentialForm);
		this.fogExponentialColor.size.set(80, 18);
		this.fogExponentialColor.setOnChange(function()
		{
			var color = self.fogExponentialColor.getValueHex();
			self.fogLinearColor.setValueHex(color);
			self.object.fog.color.setHex(color);
		});
		this.fogExponentialForm.add(this.fogExponentialColor);
		this.fogExponentialForm.nextRow();

		// Exponential fog density
		this.fogExponentialForm.addText(Locale.density);
		this.fogDensity = new NumberBox(this.fogExponentialForm);
		this.fogDensity.size.set(100, 18);
		this.fogDensity.setStep(0.0001);
		this.fogDensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.fog, "density", self.fogDensity.getValue()));
		});
		this.fogExponentialForm.add(this.fogDensity);
		this.fogExponentialForm.updateInterface();

		// Add exponential fog form
		this.form.add(this.fogExponentialForm);
		this.form.nextRow();
		
		// Physics world
		this.form.addText(Locale.physics);
		this.form.nextRow();

		// Use physics
		this.form.addText(Locale.usePhysics);
		this.usePhysics = new CheckBox(this.form);
		this.usePhysics.size.set(18, 18);
		this.usePhysics.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "usePhysics", self.usePhysics.getValue()));
		});
		this.form.add(this.usePhysics);
		this.form.nextRow();

		// Gravity
		this.form.addText(Locale.gravity);
		this.gravity = new VectorBox(this.form);
		this.gravity.setOnChange(function()
		{
			var gravity = self.gravity.getValue();
			self.object.world.gravity.set(gravity.x, gravity.y, gravity.z);
		});
		this.form.add(this.gravity);
		this.form.nextRow();

		this.form.addText(Locale.tolerance);
		this.tolerance = new NumberBox(this.form);
		this.tolerance.size.set(50, 18);
		this.tolerance.setRange(0, 1000);
		this.tolerance.setStep(0.01);
		this.tolerance.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.world.solver, "tolerance", self.tolerance.getValue()));
		});
		this.form.add(this.tolerance);
		this.form.nextRow();

		this.form.addText(Locale.iterations);
		this.iterations = new NumberBox(this.form);
		this.iterations.size.set(50, 18);
		this.iterations.setRange(0, 1000);
		this.iterations.setStep(1);
		this.iterations.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.world.solver, "iterations", self.iterations.getValue()));
		});
		this.form.add(this.iterations);
		this.form.nextRow();
	}

	// Super prototypes
	SceneInspector.prototype = Object.create(ObjectInspector.prototype);

	// Update panel content from attached object
	SceneInspector.prototype.updateInspector = function()
	{
		this.default.setValue(this.object.uuid === this.object.parent.defaultScene);
		
		if(this.object.fog instanceof three.Fog)
		{
			this.fog.setValue(three.Fog.LINEAR);
			this.fogLinearColor.setValueHex(this.object.fog.color.getHex());
			this.fogNear.setValue(this.object.fog.near);
			this.fogFar.setValue(this.object.fog.far);
			this.updateForms();
		}
		else if(this.object.fog instanceof three.FogExp2)
		{
			this.fog.setValue(three.Fog.EXPONENTIAL);
			this.fogExponentialColor.setValueHex(this.object.fog.color.getHex());
			this.fogDensity.setValue(this.object.fog.density);
			this.updateForms();
		}
		else
		{
			this.fog.setValue(three.Fog.NONE);
			this.updateForms();
		}

		if(this.object.background !== null)
		{
			if(this.object.background instanceof three.Color)
			{
				this.background.setValue(this.object.background.r, this.object.background.g, this.object.background.b);
			}
			else if(this.object.background instanceof three.Texture)
			{
				this.backgroundTexture.setValue(this.object.background);
			}
		}
		else
		{
			this.background.setValue(0, 0, 0);
			this.backgroundTexture.setValue(null);
		}

		this.environment.setValue(this.object.environment);
		this.usePhysics.setValue(this.object.usePhysics);
		this.gravity.setValue(this.object.world.gravity.x, this.object.world.gravity.y, this.object.world.gravity.z);
		this.tolerance.setValue(this.object.world.solver.tolerance);
		this.iterations.setValue(this.object.world.solver.iterations);
	};

	// Update wich forms should be visible in the panel
	SceneInspector.prototype.updateForms = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.fogLinearForm.visible = (this.object.fog instanceof three.Fog) ? true : false;
		this.fogLinearForm.updateInterface();

		this.fogExponentialForm.visible = (this.object.fog instanceof three.FogExp2) ? true : false;
		this.fogExponentialForm.updateInterface();

		this.form.updateInterface();
	};

	/**
	 * A form template can be used to describe a small group of properties of a form that are common to multiple objects.
	 *
	 * @class FormSnippet
	 * @param {Form} form Base form object to place the template fields.
	 * @param {Object} object Object that contains the attributes being edited.
	 */
	function FormSnippet(form, object)
	{
		/**
		 * Form object to place the GUI elements.
		 *
		 * @property form
		 * @type {Form}
		 */
		this.form = form;

		/**
		 * Object to edit the attributes.
		 *
		 * @property object
		 * @type {Object}
		 */
		this.object = object;
	}

	/** 
	 * Attach a new object to the form template and update the template values.
	 *
	 * @method attach
	 * @param {Object} object
	 */
	FormSnippet.prototype.attach = function(object)
	{
		this.object = object;
		this.updateValues();
	};

	/** 
	 * Update the value of the attributes edited by this template reading them from the object.
	 *
	 * @method updateValues
	 */
	FormSnippet.prototype.updateValues = function(){};

	/** 
	 * Renderer configuration object form template.
	 *
	 * Contains all rendering related configurations, to be used booth for editor settings and the program object.
	 * 
	 * @class RendererConfigurationFormSnippet
	 * @extends {FormSnippet}
	 */
	function RendererConfigurationFormSnippet(form, object)
	{
		FormSnippet.call(this, form, object);

		var self = this;

		var updateRenderers = function()
		{
			var tabs = Editor$1.gui.tab.getActiveTab();

			for(var i = 0; i < tabs.length; i++)
			{
				var tab = tabs[i];

				if(tab instanceof SceneEditor)
				{
					tab.canvas.reloadContext();
				}
			}
		};

		this.form.addText(Locale.backend).setAltText(Locale.hintBackend);
		this.backend = new DropdownList(this.form);
		this.backend.size.set(150, 18);
		this.backend.addValue(Locale.webgl, RendererConfiguration.WEBGL);
		this.backend.addValue(Locale.webgl2, RendererConfiguration.WEBGL2);
		this.backend.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "backend", self.backend.getValue()), updateRenderers));
		});
		this.form.add(this.backend);
		this.form.nextRow();

		// Antialiasing
		this.form.addText(Locale.antialiasing).setAltText(Locale.hintAntialiasing);
		this.antialiasing = new CheckBox(this.form);
		this.antialiasing.size.set(18, 18);
		this.antialiasing.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "antialiasing", self.antialiasing.getValue()), updateRenderers));
		});
		this.form.add(this.antialiasing);
		this.form.nextRow();

		// Alpha
		this.form.addText(Locale.alpha).setAltText(Locale.hintAlpha);
		this.alpha = new CheckBox(this.form);
		this.alpha.size.set(18, 18);
		this.alpha.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "alpha", self.alpha.getValue()), updateRenderers));
		});
		this.form.add(this.alpha);
		this.form.nextRow();

		// Premultiplied Alpha
		this.form.addText(Locale.premultipliedAlpha).setAltText(Locale.hintPremultipliedAlpha);
		this.premultipliedAlpha = new CheckBox(this.form);
		this.premultipliedAlpha.size.set(18, 18);
		this.premultipliedAlpha.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "premultipliedAlpha", self.premultipliedAlpha.getValue()), updateRenderers));
		});
		this.form.add(this.premultipliedAlpha);
		this.form.nextRow();

		// Preserver drawing buffer
		this.form.addText(Locale.preserveDrawingBuffer);
		this.preserveDrawingBuffer = new CheckBox(this.form);
		this.preserveDrawingBuffer.size.set(18, 18);
		this.preserveDrawingBuffer.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "preserveDrawingBuffer", self.preserveDrawingBuffer.getValue()), updateRenderers));
		});
		this.form.add(this.preserveDrawingBuffer);
		this.form.nextRow();

		// Logaritmic depth
		this.form.addText(Locale.physicallyCorrectLights).setAltText(Locale.hintPhysicallyCorrectLights);
		this.physicallyCorrectLights = new CheckBox(this.form);
		this.physicallyCorrectLights.size.set(18, 18);
		this.physicallyCorrectLights.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "physicallyCorrectLights", self.physicallyCorrectLights.getValue()), updateRenderers));
		});
		this.form.add(this.physicallyCorrectLights);
		this.form.nextRow();

		// Logaritmic depth
		this.form.addText(Locale.logarithmicDepthBuffer).setAltText(Locale.hintLogarithmicDepthBuffer);
		this.logarithmicDepthBuffer = new CheckBox(this.form);
		this.logarithmicDepthBuffer.size.set(18, 18);
		this.logarithmicDepthBuffer.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "logarithmicDepthBuffer", self.logarithmicDepthBuffer.getValue()), updateRenderers));
		});
		this.form.add(this.logarithmicDepthBuffer);
		this.form.nextRow();

		// Auto clear
		this.form.addText(Locale.autoClear);
		this.autoClear = new CheckBox(this.form);
		this.autoClear.size.set(18, 18);
		this.autoClear.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "autoClear", self.autoClear.getValue()), updateRenderers));
		});
		this.form.add(this.autoClear);
		this.form.nextRow();

		this.form.addText(Locale.autoClearColor).setAltText(Locale.hintAutoClearColor);
		this.autoClearColor = new CheckBox(this.form);
		this.autoClearColor.size.set(18, 18);
		this.autoClearColor.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "autoClearColor", self.autoClearColor.getValue()), updateRenderers));
		});
		this.form.add(this.autoClearColor);
		this.form.nextRow();

		this.form.addText(Locale.autoClearDepth).setAltText(Locale.hintAutoClearDepth);
		this.autoClearDepth = new CheckBox(this.form);
		this.autoClearDepth.size.set(18, 18);
		this.autoClearDepth.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "autoClearDepth", self.autoClearDepth.getValue()), updateRenderers));
		});
		this.form.add(this.autoClearDepth);
		this.form.nextRow();

		this.form.addText(Locale.autoClearStencil).setAltText(Locale.hintAutoClearStencil);
		this.autoClearStencil = new CheckBox(this.form);
		this.autoClearStencil.size.set(18, 18);
		this.autoClearStencil.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "autoClearStencil", self.autoClearStencil.getValue()), updateRenderers));
		});
		this.form.add(this.autoClearStencil);
		this.form.nextRow();

		this.form.addText(Locale.stencil).setAltText(Locale.hintStencil);
		this.stencil = new CheckBox(this.form);
		this.stencil.size.set(18, 18);
		this.stencil.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "stencil", self.stencil.getValue()), updateRenderers));
		});
		this.form.add(this.stencil);
		this.form.nextRow();

		this.form.addText(Locale.sortObjects).setAltText(Locale.hintSortObjects);
		this.sortObjects = new CheckBox(this.form);
		this.sortObjects.size.set(18, 18);
		this.sortObjects.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "sortObjects", self.sortObjects.getValue()), updateRenderers));
		});
		this.form.add(this.sortObjects);
		this.form.nextRow();

		// Shadows
		this.form.addText(Locale.shadows);
		this.shadows = new CheckBox(this.form);
		this.shadows.size.set(18, 18);
		this.shadows.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "shadows", self.shadows.getValue()), updateRenderers));
		});
		this.form.add(this.shadows);
		this.form.nextRow();

		// Shadows settings
		this.form.addText(Locale.shadowType);
		this.shadowsType = new DropdownList(this.form);
		this.shadowsType.size.set(150, 18);
		this.shadowsType.addValue("Basic", three.BasicShadowMap);
		this.shadowsType.addValue("PCF", three.PCFShadowMap);
		this.shadowsType.addValue("PCF Soft", three.PCFSoftShadowMap);
		this.shadowsType.addValue("VSM", VSMShadowMap);
		this.shadowsType.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "shadowsType", self.shadowsType.getValue()), updateRenderers));
		});
		this.form.add(this.shadowsType);
		this.form.nextRow();

		this.form.addText(Locale.shadowsAutoUpdate).setAltText(Locale.hintShadowsAutoUpdate);
		this.shadowsAutoUpdate = new CheckBox(this.form);
		this.shadowsAutoUpdate.size.set(18, 18);
		this.shadowsAutoUpdate.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "shadowsAutoUpdate", self.shadowsAutoUpdate.getValue()), updateRenderers));
		});
		this.form.add(this.shadowsAutoUpdate);
		this.form.nextRow();

		// Gamma
		this.form.addText(Locale.gammaFactor);
		this.gammaFactor = new NumberBox(this.form);
		this.gammaFactor.size.set(60, 18);
		this.gammaFactor.setRange(0.0, Number.MAX_SAFE_INTEGER);
		this.gammaFactor.setStep(0.1);
		this.gammaFactor.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "gammaFactor", self.gammaFactor.getValue()), updateRenderers));
		});
		this.form.add(this.gammaFactor);
		this.form.nextRow();
		
		// Power preference
		this.form.addText(Locale.powerPreference).setAltText(Locale.hintPowerPreference);
		this.powerPreference = new DropdownList(this.form);
		this.powerPreference.size.set(150, 18);
		this.powerPreference.addValue(Locale.default, "default");
		this.powerPreference.addValue(Locale.highPerformance, "high-performance");
		this.powerPreference.addValue(Locale.lowPower, "low-power");
		this.powerPreference.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "powerPreference", self.powerPreference.getValue()), updateRenderers));
		});
		this.form.add(this.powerPreference);
		this.form.nextRow();

		// Precision
		this.form.addText(Locale.precision).setAltText(Locale.hintPrecision);
		this.precision = new DropdownList(this.form);
		this.precision.size.set(150, 18);
		this.precision.addValue(Locale.highp, "highp");
		this.precision.addValue(Locale.mediump, "mediump");
		this.precision.addValue(Locale.lowp, "lowp");
		this.precision.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "precision", self.precision.getValue()), updateRenderers));
		});
		this.form.add(this.precision);
		this.form.nextRow();

		// Tonemapping
		this.form.addText(Locale.tonemapping).setAltText(Locale.hintTonemapping);
		this.toneMapping = new DropdownList(this.form);
		this.toneMapping.size.set(150, 18);
		this.toneMapping.addValue(Locale.none, three.NoToneMapping);
		this.toneMapping.addValue(Locale.linear, three.LinearToneMapping);
		this.toneMapping.addValue("Reinhard", three.ReinhardToneMapping);
		this.toneMapping.addValue("Uncharted", three.Uncharted2ToneMapping);
		this.toneMapping.addValue("Cineon", three.CineonToneMapping);
		this.toneMapping.addValue("ACES Filmic", three.ACESFilmicToneMapping);
		this.toneMapping.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "toneMapping", self.toneMapping.getValue()), updateRenderers));
		});
		this.form.add(this.toneMapping);
		this.form.nextRow();

		// Tonemapping exposure
		this.form.addText(Locale.exposure);
		this.toneMappingExposure = new NumberBox(this.form);
		this.toneMappingExposure.size.set(60, 18);
		this.toneMappingExposure.setRange(0.0, Number.MAX_SAFE_INTEGER);
		this.toneMappingExposure.setStep(0.1);
		this.toneMappingExposure.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "toneMappingExposure", self.toneMappingExposure.getValue()), updateRenderers));
		});
		this.form.add(this.toneMappingExposure);
		this.form.nextRow();

		// Tonemapping whitepoint
		this.form.addText(Locale.whitepoint);
		this.toneMappingWhitePoint = new NumberBox(this.form);
		this.toneMappingWhitePoint.size.set(60, 18);
		this.toneMappingWhitePoint.setRange(0.0, Number.MAX_SAFE_INTEGER);
		this.toneMappingWhitePoint.setStep(0.1);
		this.toneMappingWhitePoint.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "toneMappingWhitePoint", self.toneMappingWhitePoint.getValue()), updateRenderers));
		});
		this.form.add(this.toneMappingWhitePoint);
		this.form.nextRow();

		// Check shader errors
		this.form.addText(Locale.checkShaderErrors).setAltText(Locale.hintCheckShaderErrors);
		this.checkShaderErrors = new CheckBox(this.form);
		this.checkShaderErrors.size.set(18, 18);
		this.checkShaderErrors.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "checkShaderErrors", self.checkShaderErrors.getValue()), updateRenderers));
		});
		this.form.add(this.checkShaderErrors);
		this.form.nextRow();
	}

	RendererConfigurationFormSnippet.prototype = Object.create(FormSnippet.prototype);

	RendererConfigurationFormSnippet.prototype.updateValues = function()
	{
		this.backend.setValue(this.object.backend);
		this.autoClear.setValue(this.object.autoClear);
		this.autoClearColor.setValue(this.object.autoClearColor);
		this.autoClearDepth.setValue(this.object.autoClearDepth);
		this.autoClearStencil.setValue(this.object.autoClearStencil);
		this.antialiasing.setValue(this.object.antialiasing);
		this.shadows.setValue(this.object.shadows);
		this.stencil.setValue(this.object.stencil);
		this.shadowsType.setValue(this.object.shadowsType);
		this.shadowsAutoUpdate.setValue(this.object.shadowsAutoUpdate);
		this.toneMapping.setValue(this.object.toneMapping);
		this.toneMappingExposure.setValue(this.object.toneMappingExposure);
		this.toneMappingWhitePoint.setValue(this.object.toneMappingWhitePoint);
		this.sortObjects.setValue(this.object.sortObjects);
		this.gammaFactor.setValue(this.object.gammaFactor);
		this.precision.setValue(this.object.precision);
		this.alpha.setValue(this.object.alpha);
		this.premultipliedAlpha.setValue(this.object.premultipliedAlpha);
		this.preserveDrawingBuffer.setValue(this.object.preserveDrawingBuffer);
		this.powerPreference.setValue(this.object.powerPreference);
		this.logarithmicDepthBuffer.setValue(this.object.logarithmicDepthBuffer);
		this.physicallyCorrectLights.setValue(this.object.physicallyCorrectLights);
		this.checkShaderErrors.setValue(this.object.checkShaderErrors);
	};

	function ProgramInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Program information
		this.form.addText(Locale.information);
		this.form.nextRow();

		// Author
		this.form.addText(Locale.author);
		this.author = new TextBox(this.form);
		this.author.position.set(50, 35);
		this.author.size.set(190, 18);
		this.author.updateInterface();
		this.author.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "author", self.author.getText()));
		});
		this.form.add(this.author);
		this.form.nextRow();
		
		// Version
		this.form.addText(Locale.version);
		this.version = new TextBox(this.form);
		this.version.size.set(100, 18);
		this.version.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "version", self.version.getText()));
		});
		this.form.add(this.version);
		this.form.nextRow();

		// Mouse lock
		this.lockPointer = new CheckBox(this.form);
		this.form.addText("Lock pointer");
		this.lockPointer.size.set(18, 18);
		this.lockPointer.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "lockPointer", self.lockPointer.getValue()));
		});
		this.form.add(this.lockPointer);
		this.form.nextRow();
		
		// Handle pixel ratio
		this.handlePixelRatio = new CheckBox(this.form);
		this.form.addText(Locale.pixelRatio);
		this.handlePixelRatio.size.set(18, 18);
		this.handlePixelRatio.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "handlePixelRatio", self.handlePixelRatio.getValue()));
		});
		this.form.add(this.handlePixelRatio);
		this.form.nextRow();

		// VR
		this.form.addText(Locale.virtualReality);
		this.form.nextRow();

		// VR Enabled
		this.vr = new CheckBox(this.form);
		this.form.addText("VR Enabled");
		this.vr.size.set(18, 18);
		this.vr.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "vr", self.vr.getValue()));
		});
		this.form.add(this.vr);
		this.form.nextRow();

		// VR Movement Scale
		this.form.addText("Room Scale");
		this.vrScale = new NumberBox(this.form);
		this.vrScale.size.set(50, 18);
		this.vrScale.setRange(0, 1000);
		this.vrScale.setStep(0.05);
		this.vrScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "vrScale", self.vrScale.getValue()));
		});
		this.form.add(this.vrScale);
		this.form.nextRow();

		// Rendering
		this.form.addText(Locale.rendering);
		this.form.nextRow();
		this.rendererConfig = new RendererConfigurationFormSnippet(this.form, object.rendererConfig);
	}

	ProgramInspector.prototype = Object.create(ObjectInspector.prototype);

	ProgramInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.author.setText(this.object.author);
		this.version.setText(this.object.version);
		this.lockPointer.setValue(this.object.lockPointer);
		this.handlePixelRatio.setValue(this.object.handlePixelRatio);
		this.vr.setValue(this.object.vr);
		this.vrScale.setValue(this.object.vrScale);

		this.rendererConfig.attach(this.object.rendererConfig);
	};

	function PhysicsInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Scale
		this.scale.setOnChange(function()
		{
			if(self.object !== null)
			{
				var scale = self.scale.getValue();
				self.object.scale.set(scale.x, scale.y, scale.z);

				// Update physics objects
				var shapes = self.object.body.shapes;
				for(var i = 0; i < shapes.length; i++)
				{
					var shape = shapes[i];
					
					if(shape.type === cannon.Shape.types.BOX)
					{
						shape.halfExtents.x = scale.x / 2.0;
						shape.halfExtents.y = scale.y / 2.0;
						shape.halfExtents.z = scale.z / 2.0;
					}
					else if(shape.type === cannon.Shape.types.SPHERE)
					{
						shape.radius = scale.x;
					}
				}

			}
		});

		this.form.addText(Locale.physics);
		this.form.nextRow();

		// Mode
		this.form.addText(Locale.mode);
		this.mode = new DropdownList(this.form);
		this.mode.setAltText(Locale.hintPhysicsMode);
		this.mode.size.set(100, 18);
		this.mode.addValue(Locale.local, PhysicsObject.LOCAL);
		this.mode.addValue(Locale.world, PhysicsObject.WORLD);
		this.mode.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "mode", self.mode.getValue()));
		});
		this.form.add(this.mode);
		this.form.nextRow();

		// Body Type
		this.form.addText(Locale.type);
		this.bodyType = new DropdownList(this.form);
		this.bodyType.setAltText(Locale.hintPhysicsType);
		this.bodyType.size.set(100, 18);
		this.bodyType.addValue(Locale.static, cannon.Body.STATIC);
		this.bodyType.addValue(Locale.dynamic, cannon.Body.DYNAMIC);
		this.bodyType.addValue(Locale.kinematic, cannon.Body.KINEMATIC);
		this.bodyType.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "type", self.bodyType.getValue()));
		});
		this.form.add(this.bodyType);
		this.form.nextRow();

		// Body mass
		this.form.addText(Locale.mass);
		this.mass = new NumberBox(this.form);
		this.mass.size.set(50, 18);
		this.mass.setStep(0.1);
		this.mass.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "mass", self.mass.getValue()));
		});
		this.form.add(this.mass);
		this.form.nextRow();

		// Body linear damping
		this.form.addText(Locale.linearDamping);
		this.linearDamping = new NumberBox(this.form);
		this.linearDamping.size.set(50, 18);
		this.linearDamping.setStep(0.01);
		this.linearDamping.setRange(0, 1);
		this.linearDamping.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "linearDamping", self.linearDamping.getValue()));
		});
		this.form.add(this.linearDamping);
		this.form.nextRow();

		// Body angular damping
		this.form.addText(Locale.angularDamping);
		this.angularDamping = new NumberBox(this.form);
		this.angularDamping.size.set(50, 18);
		this.angularDamping.setStep(0.01);
		this.angularDamping.setRange(0, 1);
		this.angularDamping.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "angularDamping", self.angularDamping.getValue()));
		});
		this.form.add(this.angularDamping);
		this.form.nextRow();

		// Fixed rotation
		this.form.addText(Locale.lockRotation);
		this.fixedRotation = new CheckBox(this.form);
		this.fixedRotation.size.set(18, 18);
		this.fixedRotation.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "fixedRotation", self.fixedRotation.getValue()));
		});
		this.form.add(this.fixedRotation);
		this.form.nextRow();

		// Collising group
		this.form.addText(Locale.physicsGroup);
		this.collisionFilterGroup = new NumberBox(this.form);
		this.collisionFilterGroup.size.set(30, 18);
		this.collisionFilterGroup.setStep(1);
		this.collisionFilterGroup.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "collisionFilterGroup", self.collisionFilterGroup.getValue()));
		});
		this.form.add(this.collisionFilterGroup);
		this.form.nextRow();

		// Allow sleep
		this.allowSleep = new CheckBox(this.form);
		this.form.addText(Locale.allowSleep);
		this.allowSleep.size.set(18, 18);
		this.allowSleep.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "allowSleep", self.allowSleep.getValue()));
		});
		this.form.add(this.allowSleep);
		this.form.nextRow();

		// Sleep speed limit
		this.form.addText(Locale.sleepSpeedLimit);
		this.sleepSpeedLimit = new NumberBox(this.form);
		this.sleepSpeedLimit.size.set(50, 18);
		this.sleepSpeedLimit.setStep(0.01);
		this.sleepSpeedLimit.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "sleepSpeedLimit", self.sleepSpeedLimit.getValue()));
		});
		this.form.add(this.sleepSpeedLimit);
		this.form.nextRow();

		// Sleep time limit
		this.form.addText(Locale.sleepTimeLimit);
		this.sleepTimeLimit = new NumberBox(this.form);
		this.sleepTimeLimit.size.set(50, 18);
		this.sleepTimeLimit.setStep(0.01);
		this.sleepTimeLimit.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.body, "sleepTimeLimit", self.sleepTimeLimit.getValue()));
		});
		this.form.add(this.sleepTimeLimit);
		this.form.nextRow();
	}

	PhysicsInspector.prototype = Object.create(ObjectInspector.prototype);

	PhysicsInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.mode.setValue(this.object.mode);
		this.bodyType.setValue(this.object.body.type);
		this.mass.setValue(this.object.body.mass);
		this.linearDamping.setValue(this.object.body.linearDamping);
		this.angularDamping.setValue(this.object.body.angularDamping);
		this.allowSleep.setValue(this.object.body.allowSleep);
		this.sleepTimeLimit.setValue(this.object.body.sleepTimeLimit);
		this.sleepSpeedLimit.setValue(this.object.body.sleepSpeedLimit);
		this.fixedRotation.setValue(this.object.body.fixedRotation);
		this.collisionFilterGroup.setValue(this.object.body.collisionFilterGroup);
	};

	function SkyInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Sky color
		this.form.addText(Locale.skyColor);
		this.form.nextRow();

		function updateSky()
		{
			self.object.updateSky();
		}

		// Top color
		this.form.addText("Top color");
		this.colorTop = new ColorGradientChooser(this.form);
		this.colorTop.size.set(190, 18);
		this.colorTop.setOnChange(function(color, index)
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object.colorTop, index, color.clone()), updateSky));
		});
		this.form.add(this.colorTop);
		this.form.nextRow();

		// Bottom color
		this.form.addText("Bottom color");
		this.colorBottom = new ColorGradientChooser(this.form);
		this.colorBottom.size.set(190, 18);
		this.colorBottom.setOnChange(function(color, index)
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object.colorBottom, index, color.clone()), updateSky));
		});
		this.form.add(this.colorBottom);
		this.form.nextRow();

		// Sun color
		this.form.addText("Sun Color");
		this.sunColor = new ColorChooser(this.form);
		this.sunColor.size.set(80, 18);
		this.sunColor.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "sunColor", self.sunColor.getValueHex()), updateSky));
		});
		this.form.add(this.sunColor);
		this.form.nextRow();

		// Moon color
		this.form.addText("Moon Color");
		this.moonColor = new ColorChooser(this.form);
		this.moonColor.size.set(80, 18);
		this.moonColor.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "moonColor", self.moonColor.getValueHex()), updateSky));
		});
		this.form.add(this.moonColor);
		this.form.nextRow();

		// Intensity
		this.form.addText(Locale.intensity);
		this.intensity = new Slider(this.form);
		this.intensity.size.set(160, 18);
		this.intensity.setStep(0.01);
		this.intensity.setRange(0, 1);
		this.intensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "intensity", self.intensity.getValue()));
		});
		this.form.add(this.intensity);
		this.form.nextRow();

		// Day time
		this.form.addText("Day time");
		this.form.nextRow();

		// Auto update
		this.form.addText(Locale.autoUpdate);
		this.autoUpdate = new CheckBox(this.form);
		this.autoUpdate.size.set(18, 18);
		this.autoUpdate.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "autoUpdate", self.autoUpdate.getValue()));
		});
		this.form.add(this.autoUpdate);
		this.form.nextRow();

		// Day time
		this.form.addText("Day duration");
		this.dayTime = new NumberBox(this.form);
		this.dayTime.size.set(60, 18);
		this.dayTime.setStep(0.1);
		this.dayTime.setOnChange(function()
		{
			// Check and set day time
			var dayTime = self.dayTime.getValue();
			if(dayTime < 0)
			{
				dayTime = 0;
				self.dayTime.setValue(dayTime);
			}
			Editor$1.addAction(new ChangeAction(self.object, "dayTime", dayTime));

			// Check actual time
			if(self.object.time > dayTime)
			{
				Editor$1.addAction(new ChangeAction(self.object, "time", dayTime));
				self.time.setValue(dayTime);
			}

			self.time.setRange(0, dayTime);
			self.object.updateSky();
		});
		this.form.add(this.dayTime);
		this.form.addText("s", true);
		this.form.nextRow();

		// Actual time 
		this.form.addText(Locale.time);
		this.time = new NumberBox(this.form);
		this.time.size.set(60, 18);
		this.time.setStep(0.1);
		this.time.setOnChange(function()
		{
			var time = self.time.getValue();

			if(time < 0)
			{
				time = 0;
				self.time.setValue(time);
			}
			else if(time > self.object.dayTime)
			{
				time = self.object.dayTime;
				self.time.setValue(time);
			}

			Editor$1.addAction(new ChangeAction(self.object, "time", time));
			self.object.updateSky();
		});
		this.form.add(this.time);
		this.form.addText("s", true);
		this.form.nextRow();

		// Sun distance
		this.form.addText(Locale.sunDistance);
		this.sunDistance = new NumberBox(this.form);
		this.sunDistance.size.set(60, 18);
		this.sunDistance.setStep(10);
		this.sunDistance.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.object, "sunDistance", self.sunDistance.getValue()), updateSky));
		});
		this.form.add(this.sunDistance);
		this.form.nextRow();

		// Shadow map
		this.form.addText(Locale.shadows);
		this.form.nextRow();

		// Cast shadow
		this.castShadow = new CheckBox(this.form);
		this.form.addText(Locale.castShadows);
		this.castShadow.size.set(18, 18);
		this.castShadow.position.set(5, 85);
		this.castShadow.updateInterface();
		this.castShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.sun, "castShadow", self.castShadow.getValue()));
		});
		this.form.add(this.castShadow);
		this.form.nextRow();

		// Shadow resolution
		this.form.addText(Locale.resolution);
		this.shadowWidth = new DropdownList(this.form);
		this.shadowWidth.size.set(60, 18);
		this.shadowWidth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.sun.shadow.mapSize, "width", self.shadowWidth.getValue()));
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowWidth);
		this.form.addText("x", true);
		this.shadowHeight = new DropdownList(this.form);
		this.shadowHeight.size.set(60, 18);
		this.shadowHeight.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.sun.shadow.mapSize, "height", self.shadowHeight.getValue()));
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowHeight);
		this.form.nextRow();

		for(var i = 5; i < 13; i++)
		{
			var size = Math.pow(2, i);
			this.shadowWidth.addValue(size.toString(), size);
			this.shadowHeight.addValue(size.toString(), size);
		}

		// Shadowmap camera near
		this.form.addText(Locale.near);
		this.shadowNear = new NumberBox(this.form);
		this.shadowNear.size.set(60, 18);
		this.shadowNear.setStep(0.1);
		this.shadowNear.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.sun.shadow.camera, "near", self.shadowNear.getValue()));
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowNear);
		this.form.nextRow();
		
		// Shadowmap camera far
		this.form.addText(Locale.near);
		this.shadowFar = new NumberBox(this.form);
		this.shadowFar.size.set(60, 18);
		this.shadowFar.setStep(0.1);
		this.shadowFar.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.sun.shadow.camera, "far", self.shadowFar.getValue()));
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowFar);
		this.form.nextRow();

		// Shadowmap camera left
		this.form.addText(Locale.left);
		this.shadowLeft = new NumberBox(this.form);
		this.shadowLeft.size.set(60, 18);
		this.shadowLeft.setStep(0.1);
		this.shadowLeft.setOnChange(function()
		{
			self.object.sun.shadow.camera.left = self.shadowLeft.getValue();
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowLeft);
		this.form.nextRow();

		// Shadowmap camera right
		this.form.addText(Locale.right);
		this.shadowRight = new NumberBox(this.form);
		this.shadowRight.size.set(60, 18);
		this.shadowRight.setStep(0.1);
		this.shadowRight.setOnChange(function()
		{
			self.object.sun.shadow.camera.right = self.shadowRight.getValue();
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowRight);
		this.form.nextRow();

		// Shadowmap camera top
		this.form.addText(Locale.top);
		this.shadowTop = new NumberBox(this.form);
		this.shadowTop.size.set(60, 18);
		this.shadowTop.setStep(0.1);
		this.shadowTop.setOnChange(function()
		{
			self.object.sun.shadow.camera.top = self.shadowTop.getValue();
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowTop);
		this.form.nextRow();

		// Shadowmap camera bottom
		this.form.addText(Locale.bottom);
		this.shadowBottom = new NumberBox(this.form);
		this.shadowBottom.size.set(60, 18);
		this.shadowBottom.setStep(0.1);
		this.shadowBottom.setOnChange(function()
		{
			self.object.sun.shadow.camera.bottom = self.shadowBottom.getValue();
			self.object.sun.updateShadowMap();
		});
		this.form.add(this.shadowBottom);
		this.form.nextRow();
	}

	SkyInspector.prototype = Object.create(ObjectInspector.prototype);

	SkyInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.colorTop.setValue(this.object.colorTop);
		this.colorBottom.setValue(this.object.colorBottom);
		
		this.sunColor.setValueHex(this.object.sunColor);
		this.moonColor.setValueHex(this.object.moonColor);
		this.intensity.setValue(this.object.intensity);

		this.autoUpdate.setValue(this.object.autoUpdate);
		this.dayTime.setValue(this.object.dayTime);
		this.time.setValue(this.object.time);
		this.sunDistance.setValue(this.object.sunDistance);

		this.castShadow.setValue(this.object.sun.castShadow);
		this.shadowWidth.setValue(this.object.sun.shadow.mapSize.width);
		this.shadowHeight.setValue(this.object.sun.shadow.mapSize.height);
		this.shadowNear.setValue(this.object.sun.shadow.camera.near);
		this.shadowFar.setValue(this.object.sun.shadow.camera.far);
		this.shadowLeft.setValue(this.object.sun.shadow.camera.left);
		this.shadowRight.setValue(this.object.sun.shadow.camera.right);
		this.shadowTop.setValue(this.object.sun.shadow.camera.top);
		this.shadowBottom.setValue(this.object.sun.shadow.camera.bottom);
	};

	function ParticleEmitterInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Dynamic emitter
		this.form.addText(Locale.dynamicEmitter);
		this.dynamicEmitter = new CheckBox(this.form);
		this.dynamicEmitter.size.set(18, 18);
		this.dynamicEmitter.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "dynamicEmitter", self.dynamicEmitter.getValue()));
		});
		this.form.add(this.dynamicEmitter);
		this.form.nextRow();
	}

	ParticleEmitterInspector.prototype = Object.create(ObjectInspector.prototype);

	ParticleEmitterInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.dynamicEmitter.setValue(this.object.dynamicEmitter);
	};

	function CubeCameraInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Auto update
		this.form.addText(Locale.autoUpdate);
		this.autoUpdate = new CheckBox(this.form);
		this.autoUpdate.size.set(18, 18);
		this.autoUpdate.position.set(5, 85);
		this.autoUpdate.updateInterface();
		this.autoUpdate.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "autoUpdate", self.autoUpdate.getValue()));
		});
		this.form.add(this.autoUpdate);
		this.form.nextRow();

		// Resolution
		this.form.addText(Locale.resolution);
		this.resolution = new DropdownList(this.form);
		this.resolution.size.set(60, 18);
		this.resolution.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "resolution", self.resolution.getValue()));
		});
		this.form.add(this.resolution);
		this.form.nextRow();
		
		for(var i = 4; i < 13; i++)
		{
			var size = Math.pow(2, i);
			this.resolution.addValue(size.toString(), size);
		}

		// Near
		this.form.addText(Locale.near);
		this.near = new NumberBox(this.form);
		this.near.size.set(60, 18);
		this.near.setStep(0.1);
		this.near.setRange(0, Number.MAX_SAFE_INTEGER);
		this.near.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "near", self.near.getValue()));
		});
		this.form.add(this.near);
		this.form.nextRow();
		
		// Far
		this.form.addText(Locale.near);
		this.far = new NumberBox(this.form);
		this.far.size.set(80, 18);
		this.far.setRange(0, Number.MAX_SAFE_INTEGER);
		this.far.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "far", self.far.getValue()));
		});
		this.form.add(this.far);
		this.form.nextRow();
	}

	CubeCameraInspector.prototype = Object.create(ObjectInspector.prototype);

	CubeCameraInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.autoUpdate.setValue(this.object.autoUpdate);
		this.resolution.setValue(this.object.resolution);
		this.near.setValue(this.object.near);
		this.far.setValue(this.object.far);
	};

	function InstancedMeshInspector(parent, object)
	{
		MeshInspector.call(this, parent, object);

		var self = this;
		
		this.form.addText(Locale.count);
		this.count = new NumberBox(this.form);
		this.count.size.set(0, 18);
		this.count.setRange(0, 1000);
		this.count.setStep(1);
		this.count.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "count", self.count.getValue()));
		});
		this.form.add(this.count);
		this.form.nextRow();

	}

	InstancedMeshInspector.prototype = Object.create(MeshInspector.prototype);

	InstancedMeshInspector.prototype.updateInspector = function()
	{
		MeshInspector.prototype.updateInspector.call(this);

		this.count.setValue(this.object.count);
	};

	function LockedInspector(parent, object)
	{
		Inspector.call(this, parent, object);

		// Name
		this.form.addText(Locale.name);
		this.name = this.form.addText("");
		this.form.nextRow();

		// Type
		if(Editor$1.settings.general.showType)
		{
			this.form.addText(Locale.type);
			this.type = this.form.addText("");
			this.form.nextRow();
		}

		// UUID
		if(Editor$1.settings.general.showUUID)
		{
			this.form.addText(Locale.uuid);
			this.uuid = this.form.addText("");
			this.form.nextRow();
		}
	}

	LockedInspector.prototype = Object.create(Inspector.prototype);

	// Update panel information
	LockedInspector.prototype.updateInspector = function()
	{
		this.name.setText(this.object.name);
		
		if(this.type !== undefined)
		{
			this.type.setText(this.object.type);
		}

		if(this.uuid !== undefined)
		{
			this.uuid.setText(this.object.uuid);
		}
	};

	/** 
	 * Shadow map configuration form for light objects that emitt shadows.
	 *
	 * @class LightShadowFormSnippet
	 * @extends {FormSnippet}
	 */
	function LightShadowFormSnippet(form, object)
	{
		FormSnippet.call(this, form, object);

		var self = this;
		
		// Resolution
		this.form.addText(Locale.resolution);
		this.width = new DropdownList(this.form);
		this.width.size.set(60, 18);
		this.width.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.mapSize, "width", self.width.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.width);
		this.form.addText("x", true);
		this.height = new DropdownList(this.form);
		this.height.size.set(60, 18);
		this.height.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.mapSize, "height", self.height.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.height);
		this.form.nextRow();

		for(var i = 5; i < 14; i++)
		{
			var size = Math.pow(2, i);
			this.width.addValue(size.toString(), size);
			this.height.addValue(size.toString(), size);
		}

		// Bias
		this.form.addText(Locale.bias).setAltText(Locale.hintShadowBias);
		this.bias = new NumberBox(this.form);
		this.bias.size.set(60, 18);
		this.bias.setStep(0.0001);
		this.bias.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow, "bias", self.bias.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.bias);
		this.form.nextRow();

		// Radius
		this.form.addText(Locale.radius);
		this.radius = new NumberBox(this.form);
		this.radius.size.set(60, 18);
		this.radius.setStep(0.1);
		this.radius.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow, "radius", self.radius.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.radius);
		this.form.nextRow();


		// Camera near
		this.form.addText(Locale.near);
		this.cameraNear = new NumberBox(this.form);
		this.cameraNear.size.set(60, 18);
		this.cameraNear.setStep(0.1);
		this.cameraNear.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.camera, "near", self.shadowNear.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.cameraNear);
		this.form.nextRow();
		
		// Camera far
		this.form.addText(Locale.far);
		this.cameraFar = new NumberBox(this.form);
		this.cameraFar.size.set(60, 18);
		this.cameraFar.setStep(0.1);
		this.cameraFar.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.camera, "far", self.shadowFar.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.cameraFar);
		this.form.nextRow();

		// Camera left
		this.form.addText(Locale.left);
		this.cameraLeft = new NumberBox(this.form);
		this.cameraLeft.size.set(60, 18);
		this.cameraLeft.setStep(0.1);
		this.cameraLeft.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.camera, "left", self.shadowLeft.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.cameraLeft);
		this.form.nextRow();

		// Camera right
		this.form.addText(Locale.right);
		this.cameraRight = new NumberBox(this.form);
		this.cameraRight.size.set(60, 18);
		this.cameraRight.setStep(0.1);
		this.cameraRight.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.camera, "right", self.shadowRight.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.cameraRight);
		this.form.nextRow();

		// Camera top
		this.form.addText(Locale.top);
		this.cameraTop = new NumberBox(this.form);
		this.cameraTop.size.set(60, 18);
		this.cameraTop.setStep(0.1);
		this.cameraTop.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.camera, "top", self.shadowTop.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.cameraTop);
		this.form.nextRow();

		// Camera bottom
		this.form.addText(Locale.bottom);
		this.cameraBottom = new NumberBox(this.form);
		this.cameraBottom.size.set(60, 18);
		this.cameraBottom.setStep(0.1);
		this.cameraBottom.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object.shadow.camera, "bottom", self.shadowBottom.getValue()));
			self.object.updateShadowMap();
		});
		this.form.add(this.cameraBottom);
		this.form.nextRow();
	}

	LightShadowFormSnippet.prototype = Object.create(FormSnippet.prototype);

	LightShadowFormSnippet.prototype.updateValues = function()
	{
		this.bias.setValue(this.object.shadow.bias);
		this.radius.setValue(this.object.shadow.radius);
		this.width.setValue(this.object.shadow.mapSize.width);
		this.height.setValue(this.object.shadow.mapSize.height);
		this.cameraNear.setValue(this.object.shadow.camera.near);
		this.cameraFar.setValue(this.object.shadow.camera.far);
		this.cameraLeft.setValue(this.object.shadow.camera.left);
		this.cameraRight.setValue(this.object.shadow.camera.right);
		this.cameraTop.setValue(this.object.shadow.camera.top);
		this.cameraBottom.setValue(this.object.shadow.camera.bottom);
	};

	function SpotLightInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(80, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Penumbra
		this.form.addText(Locale.penumbra);
		this.penumbra = new Slider(this.form);
		this.penumbra.size.set(160, 18);
		this.penumbra.position.set(65, 110);
		this.penumbra.setRange(0, 1);
		this.penumbra.setStep(0.01);
		this.penumbra.updateInterface();
		this.penumbra.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "penumbra", self.penumbra.getValue()));
		});
		this.form.add(this.penumbra);
		this.form.nextRow();

		// Angle
		this.form.addText(Locale.angle);
		this.angle = new Slider(this.form);
		this.angle.size.set(160, 18);
		this.angle.setRange(0, 1.57);
		this.angle.setStep(0.01);
		this.angle.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "angle", self.angle.getValue()));
		});
		this.form.add(this.angle);
		this.form.nextRow();

		// Shadow map
		this.form.addText(Locale.shadows);
		this.form.nextRow();

		// Cast shadow
		this.castShadow = new CheckBox(this.form);
		this.form.addText(Locale.castShadows);
		this.castShadow.size.set(18, 18);
		this.castShadow.position.set(5, 85);
		this.castShadow.updateInterface();
		this.castShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "castShadow", self.castShadow.getValue()));
		});
		this.form.add(this.castShadow);
		this.form.nextRow();

		// Shadow
		this.shadow = new LightShadowFormSnippet(this.form, object);
	}

	SpotLightInspector.prototype = Object.create(ObjectInspector.prototype);

	SpotLightInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.color.setValue(this.object.color.r, this.object.color.g, this.object.color.b);
		this.angle.setValue(this.object.angle);
		this.penumbra.setValue(this.object.penumbra);
		this.castShadow.setValue(this.object.castShadow);

		this.shadow.attach(this.object);
	};

	function RectAreaLightInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(80, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Intensity
		this.form.addText(Locale.intensity);
		this.intensity = new Slider(this.form);
		this.intensity.size.set(160, 18);
		this.intensity.setStep(0.1);
		this.intensity.setRange(0, 500);
		this.intensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "intensity", self.intensity.getValue()));
		});
		this.form.add(this.intensity);
		this.form.nextRow();

		// Rect width
		this.form.addText(Locale.width);
		this.width = new NumberBox(this.form);
		this.width.size.set(60, 18);
		this.width.setStep(0.1);
		this.width.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "width", self.width.getValue()));
		});
		this.form.add(this.width);
		this.form.nextRow();
		
		// Rect height
		this.form.addText(Locale.height);
		this.height = new NumberBox(this.form);
		this.height.size.set(60, 18);
		this.height.setStep(0.1);
		this.height.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "height", self.height.getValue()));
		});
		this.form.add(this.height);
		this.form.nextRow();
	}

	RectAreaLightInspector.prototype = Object.create(ObjectInspector.prototype);

	RectAreaLightInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.color.setValue(this.object.color.r, this.object.color.g, this.object.color.b);
		this.intensity.setValue(this.object.intensity);
		this.width.setValue(this.object.width);
		this.height.setValue(this.object.height);
	};

	function PointLightInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(80, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Distance
		this.form.addText(Locale.distance);
		this.distance = new NumberBox(this.form);
		this.distance.size.set(60, 18);
		this.distance.setStep(0.1);
		this.distance.setRange(0, Number.MAX_SAFE_INTEGER);
		this.distance.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "distance", self.distance.getValue()));
		});
		this.form.add(this.distance);
		this.form.nextRow();

		// Intensity
		this.form.addText(Locale.intensity);
		this.intensity = new Slider(this.form);
		this.intensity.size.set(160, 18);
		this.intensity.setStep(0.1);
		this.intensity.setRange(0, 10);
		this.intensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "intensity", self.intensity.getValue()));
		});
		this.form.add(this.intensity);
		this.form.nextRow();

		// Shadow map
		this.form.addText(Locale.shadows);
		this.form.nextRow();

		// Cast shadow
		this.castShadow = new CheckBox(this.form);
		this.form.addText(Locale.castShadows);
		this.castShadow.size.set(18, 18);
		this.castShadow.position.set(5, 85);
		this.castShadow.updateInterface();
		this.castShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "castShadow", self.castShadow.getValue()));
		});
		this.form.add(this.castShadow);
		this.form.nextRow();

		// Shadow
		this.shadow = new LightShadowFormSnippet(this.form, object);

	}

	PointLightInspector.prototype = Object.create(ObjectInspector.prototype);

	PointLightInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.color.setValue(this.object.color.r, this.object.color.g, this.object.color.b);
		this.distance.setValue(this.object.distance);
		this.intensity.setValue(this.object.intensity);
		this.castShadow.setValue(this.object.castShadow);

		this.shadow.attach(this.object);
	};

	function LightProbeInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Intensity
		this.form.addText(Locale.intensity);
		this.intensity = new Slider(this.form);
		this.intensity.size.set(160, 18);
		this.intensity.setStep(0.1);
		this.intensity.setRange(0, 10);
		this.intensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "intensity", self.intensity.getValue()));
		});
		this.form.add(this.intensity);
		this.form.nextRow();	
	}

	LightProbeInspector.prototype = Object.create(ObjectInspector.prototype);

	LightProbeInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.intensity.setValue(this.object.intensity);
	};

	function HemisphereLightInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Sky color
		this.form.addText(Locale.skyColor);
		this.color = new ColorChooser(this.form);
		this.color.size.set(80, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Ground color
		this.form.addText(Locale.groundColor);
		this.groundColor = new ColorChooser(this.form);
		this.groundColor.size.set(80, 18);
		this.groundColor.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "groundColor", new three.Color(self.groundColor.getValueHex())));
		});
		this.form.add(this.groundColor);
		this.form.nextRow();
	}

	HemisphereLightInspector.prototype = Object.create(ObjectInspector.prototype);

	HemisphereLightInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.color.setValue(this.object.color.r, this.object.color.g, this.object.color.b);
		this.groundColor.setValue(this.object.groundColor.r, this.object.groundColor.g, this.object.groundColor.b);
	};

	function DirectionalLightInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(80, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Shadow map
		this.form.addText(Locale.shadows);
		this.form.nextRow();

		// Cast shadow
		this.form.addText(Locale.castShadows);
		this.castShadow = new CheckBox(this.form);
		this.castShadow.size.set(18, 18);
		this.castShadow.position.set(5, 85);
		this.castShadow.updateInterface();
		this.castShadow.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "castShadow", self.castShadow.getValue()));
		});
		this.form.add(this.castShadow);
		this.form.nextRow();

		// Shadow
		this.shadow = new LightShadowFormSnippet(this.form, object);
	}

	DirectionalLightInspector.prototype = Object.create(ObjectInspector.prototype);

	DirectionalLightInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.color.setValue(this.object.color.r, this.object.color.g, this.object.color.b);
		this.castShadow.setValue(this.object.castShadow);
		
		this.shadow.attach(this.object);
	};

	function AmbientLightInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(80, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "color", new three.Color(self.color.getValueHex())));
		});
		this.form.add(this.color);
		this.form.nextRow();
	}

	AmbientLightInspector.prototype = Object.create(ObjectInspector.prototype);

	AmbientLightInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.color.setValue(this.object.color.r, this.object.color.g, this.object.color.b);
	};

	function LeapInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Mode
		this.form.addText(Locale.mode);
		this.mode = new DropdownList(this.form);
		this.mode.size.set(80, 18);
		this.mode.addValue("Desk", Script.INIT);
		this.mode.addValue("HMD", Script.LOOP);
		this.mode.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "mode", self.mode.getSelectedIndex()));
		});
		this.form.add(this.mode);
		this.form.nextRow();

		// Debug model
		this.debugModel = new CheckBox(this.form);
		this.form.addText("Debug model");
		this.debugModel.size.set(18, 18);
		this.debugModel.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "debugModel", self.debugModel.getValue()));
		});
		this.form.add(this.debugModel);
		this.form.nextRow();

		// Gestures Enabled
		this.gesturesEnabled = new CheckBox(this.form);
		this.form.addText("Gestures Enabled");
		this.gesturesEnabled.size.set(18, 18);
		this.gesturesEnabled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "gesturesEnabled", self.gesturesEnabled.getValue()));
		});
		this.form.add(this.gesturesEnabled);
		this.form.nextRow();

		// Poses Enabled
		this.posesEnabled = new CheckBox(this.form);
		this.form.addText("Poses Enabled");
		this.posesEnabled.size.set(18, 18);
		this.posesEnabled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "posesEnabled", self.posesEnabled.getValue()));
		});
		this.form.add(this.posesEnabled);
	}

	LeapInspector.prototype = Object.create(ObjectInspector.prototype);

	LeapInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.mode.setSelectedIndex(this.object.mode);
		this.debugModel.setValue(this.object.debugModel);
		this.gesturesEnabled.setValue(this.object.gesturesEnabled);
		this.posesEnabled.setValue(this.object.posesEnabled);
	};

	function KinectInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Debug model
		this.debugModel = new CheckBox(this.form);
		this.form.addText("Debug model");
		this.debugModel.size.set(18, 18);
		this.debugModel.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "debugModel", self.debugModel.getValue()));
		});
		this.form.add(this.debugModel);
	}

	KinectInspector.prototype = Object.create(ObjectInspector.prototype);

	KinectInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.debugModel.setValue(this.object.debugModel);
	};

	function OrbitControlsInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Distance
		this.form.addText(Locale.distance);
		this.distance = new NumberBox(this.form);
		this.distance.size.set(60, 18);
		this.distance.setStep(0.1);
		this.distance.setRange(0, Number.MAX_SAFE_INTEGER);
		this.distance.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "distance", self.distance.getValue()));
		});
		this.form.add(this.distance);
		this.form.nextRow();

		this.form.addText(Locale.maxDistance);
		this.maxDistance = new NumberBox(this.form);
		this.maxDistance.size.set(60, 18);
		this.maxDistance.setStep(0.1);
		this.maxDistance.setRange(0, Number.MAX_SAFE_INTEGER);
		this.maxDistance.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "maxDistance", self.maxDistance.getValue()));
		});
		this.form.add(this.maxDistance);
		this.form.nextRow();

		this.form.addText(Locale.minDistance);
		this.minDistance = new NumberBox(this.form);
		this.minDistance.size.set(60, 18);
		this.minDistance.setStep(0.1);
		this.minDistance.setRange(0, Number.MAX_SAFE_INTEGER);
		this.minDistance.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "minDistance", self.minDistance.getValue()));
		});
		this.form.add(this.minDistance);
		this.form.nextRow();

		// Needs button pressed
		this.form.addText(Locale.requireButton);
		this.needsButtonPressed = new CheckBox(this.form);
		this.needsButtonPressed.size.set(18, 18);
		this.needsButtonPressed.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "needsButtonPressed", self.needsButtonPressed.getValue()));
		});
		this.form.add(this.needsButtonPressed);
		this.form.nextRow();

		// Movement
		this.form.addText(Locale.movement);
		this.movementEnabled = new CheckBox(this.form);
		this.movementEnabled.size.set(18, 18);
		this.movementEnabled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "movementEnabled", self.movementEnabled.getValue()));
		});
		this.form.add(this.movementEnabled);
		this.form.nextRow();

		// Sensitivity
		this.form.addText(Locale.sensitivity);
		this.sensitivity = new Slider(this.form);
		this.sensitivity.size.set(140, 18);
		this.sensitivity.setStep(0.0001);
		this.sensitivity.setRange(0, 0.05);
		this.sensitivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "sensitivity", self.sensitivity.getValue()));
		});
		this.form.add(this.sensitivity);
		this.form.nextRow();

		// Limit up
		this.form.addText(Locale.limitUp);
		this.limitUp = new NumberBox(this.form);
		this.limitUp.size.set(60, 18);
		this.limitUp.setStep(0.001);
		this.limitUp.setRange(-Math.PI, Math.PI);
		this.limitUp.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "limitUp", self.limitUp.getValue()));
		});
		this.form.add(this.limitUp);
		this.form.nextRow();

		// Limit down
		this.form.addText(Locale.limitDown);
		this.limitDown = new NumberBox(this.form);
		this.limitDown.size.set(60, 18);
		this.limitDown.setStep(0.001);
		this.limitDown.setRange(-Math.PI, Math.PI);
		this.limitDown.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "limitDown", self.limitDown.getValue()));
		});
		this.form.add(this.limitDown);
		this.form.nextRow();

		// Zoom
		this.form.addText(Locale.zoom);
		this.zoomEnabled = new CheckBox(this.form);
		this.zoomEnabled.size.set(18, 18);
		this.zoomEnabled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "zoomEnabled", self.zoomEnabled.getValue()));
		});
		this.form.add(this.zoomEnabled);
		this.form.nextRow();

		// Zoom sensitivity
		this.form.addText(Locale.zoomSpeed);
		this.zoomSensitivity = new Slider(this.form);
		this.zoomSensitivity.size.set(140, 18);
		this.zoomSensitivity.setStep(0.0001);
		this.zoomSensitivity.setRange(0, 0.05);
		this.zoomSensitivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "zoomSensitivity", self.zoomSensitivity.getValue()));
		});
		this.form.add(this.zoomSensitivity);
		this.form.nextRow();

		// Smooth
		this.form.addText(Locale.zoom);
		this.smooth = new CheckBox(this.form);
		this.smooth.size.set(18, 18);
		this.smooth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "smooth", self.smooth.getValue()));
		});
		this.form.add(this.smooth);
		this.form.nextRow();

		// Speed
		this.form.addText(Locale.speed);
		this.speed = new Slider(this.form);
		this.speed.size.set(18, 18);
		this.speed.setStep(0.01);
		this.speed.setRange(0, 1);
		this.speed.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "speed", self.speed.getValue()));
		});
		this.form.add(this.speed);
		this.form.nextRow();

		// Friction
		this.form.addText(Locale.damping);
		this.friction = new Slider(this.form);
		this.friction.size.set(18, 18);
		this.friction.setStep(0.01);
		this.friction.setRange(0, 1);
		this.friction.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "friction", self.friction.getValue()));
		});
		this.form.add(this.friction);
		this.form.nextRow();

		// Invert Navigation
		this.form.addText(Locale.invertNavigation);
		this.invertNavigation = new CheckBox(this.form);
		this.invertNavigation.size.set(18, 18);
		this.invertNavigation.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "invertNavigation", self.invertNavigation.getValue()));
		});
		this.form.add(this.invertNavigation);
		this.form.nextRow();

		// Position
		this.form.addText(Locale.center);
		this.center = new VectorBox(this.form);
		this.center.size.set(0, 18);
		this.center.setStep(0.01);
		this.center.setOnChange(function()
		{
			var center = self.center.getValue();
			var object = self.object.center;

			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(object, "x", center.x),
				new ChangeAction(object, "y", center.y),
				new ChangeAction(object, "z", center.z)
			]));
		});
		this.form.add(this.center);
		this.form.nextRow();

		// Position
		this.form.addText(Locale.vector);
		this.vector = new VectorBox(this.form);
		this.vector.size.set(0, 18);
		this.vector.setStep(0.01);
		this.vector.setOnChange(function()
		{
			var vector = self.vector.getValue();
			var object = self.object.vector;

			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(object, "x", vector.x),
				new ChangeAction(object, "y", vector.y)
			]));
		});
		this.form.add(this.vector);
		this.form.nextRow();
	}

	OrbitControlsInspector.prototype = Object.create(ObjectInspector.prototype);

	OrbitControlsInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.distance.setValue(this.object.distance);
		this.maxDistance.setValue(this.object.maxDistance);
		this.minDistance.setValue(this.object.minDistance);
		this.needsButtonPressed.setValue(this.object.needsButtonPressed);
		this.movementEnabled.setValue(this.object.movementEnabled);
		this.sensitivity.setValue(this.object.sensitivity);
		this.limitUp.setValue(this.object.limitUp);
		this.limitDown.setValue(this.object.limitDown);
		this.zoomEnabled.setValue(this.object.zoomEnabled);
		this.zoomSensitivity.setValue(this.object.zoomSensitivity);
		this.smooth.setValue(this.object.smooth);
		this.friction.setValue(this.object.friction);
		this.speed.setValue(this.object.speed);
		this.invertNavigation.setValue(this.object.invertNavigation);
		this.center.setValue(this.object.center);
		this.vector.setValue(this.object.vector);
	};

	function FirstPersonControlsInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Needs button pressed
		this.form.addText(Locale.requireButton);
		this.needsButtonPressed = new CheckBox(this.form);
		this.needsButtonPressed.size.set(18, 18);
		this.needsButtonPressed.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "needsButtonPressed", self.needsButtonPressed.getValue()));
		});
		this.form.add(this.needsButtonPressed);
		this.form.nextRow();
		
		// Sensitivity
		this.form.addText(Locale.sensitivity);
		this.sensitivity = new Slider(this.form);
		this.sensitivity.size.set(140, 18);
		this.sensitivity.setStep(0.0001);
		this.sensitivity.setRange(0, 0.05);
		this.sensitivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "sensitivity", self.sensitivity.getValue()));
		});
		this.form.add(this.sensitivity);
		this.form.nextRow();

		// Movement
		this.form.addText(Locale.movement);
		this.movementEnabled = new CheckBox(this.form);
		this.movementEnabled.size.set(18, 18);
		this.movementEnabled.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "movementEnabled", self.movementEnabled.getValue()));
		});
		this.form.add(this.movementEnabled);
		this.form.nextRow();

		// Move speed
		this.form.addText(Locale.moveSpeed);
		this.moveSpeed = new Slider(this.form);
		this.moveSpeed.size.set(140, 18);
		this.moveSpeed.setStep(0.01);
		this.moveSpeed.setRange(0, 0.5);
		this.moveSpeed.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "moveSpeed", self.moveSpeed.getValue()));
		});
		this.form.add(this.moveSpeed);
		this.form.nextRow();

		// Move on plane
		this.form.addText(Locale.movePlane);
		this.moveOnPlane = new CheckBox(this.form);
		this.moveOnPlane.size.set(18, 18);
		this.moveOnPlane.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "moveOnPlane", self.moveOnPlane.getValue()));
		});
		this.form.add(this.moveOnPlane);
		this.form.nextRow();
	}

	FirstPersonControlsInspector.prototype = Object.create(ObjectInspector.prototype);

	FirstPersonControlsInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.needsButtonPressed.setValue(this.object.needsButtonPressed);
		this.movementEnabled.setValue(this.object.movementEnabled);
		this.sensitivity.setValue(this.object.sensitivity);
		this.moveSpeed.setValue(this.object.moveSpeed);
		this.moveOnPlane.setValue(this.object.moveOnPlane);
	};

	/** 
	 * Viewport object form snippet, used to edit camera/renderer viewport.
	 *
	 * @class ViewportFormSnippet
	 * @extends {FormSnippet}
	 */
	function ViewportFormSnippet(form, object)
	{
		FormSnippet.call(this, form, object);

		var self = this;
		
		// Offset
		this.form.addText(Locale.position);
		this.offset = new VectorBox(this.form);
		this.offset.setType(VectorBox.VECTOR2);
		this.offset.setStep(0.05);
		this.offset.size.set(160, 18);
		this.offset.setOnChange(function()
		{	
			var value = self.offset.getValue();
			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(self.object.offset, "x", value.x),
				new ChangeAction(self.object.offset, "y", value.y)
			]));
		});
		this.form.add(this.offset);
		this.form.nextRow();

		// Size
		this.form.addText(Locale.size);
		this.sizeBox = new VectorBox(this.form);
		this.sizeBox.setType(VectorBox.VECTOR2);
		this.sizeBox.setStep(0.05);
		this.sizeBox.size.set(160, 18);
		this.sizeBox.setOnChange(function()
		{
			var value = self.sizeBox.getValue();
			Editor$1.addAction(new ActionBundle(
			[
				new ChangeAction(self.object.size, "x", value.x),
				new ChangeAction(self.object.size, "y", value.y)
			]));
		});
		this.form.add(this.sizeBox);
		this.form.nextRow();

		// Mode
		this.form.addText(Locale.mode);
		this.modeDrop = new DropdownList(this.form);
		this.modeDrop.size.set(0, 18);
		this.modeDrop.addValue(Locale.relative, Viewport.RELATIVE);
		this.modeDrop.addValue(Locale.absolute, Viewport.ABSOLUTE);
		this.modeDrop.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "mode", self.modeDrop.getValue()));
		});
		this.form.add(this.modeDrop);
		this.form.nextRow();

		// Anchor
		this.form.addText(Locale.anchor);
		this.anchor = new DropdownList(this.form);
		this.anchor.size.set(0, 18);
		this.anchor.addValue(Locale.bottomRight, Viewport.BOTTOM_RIGHT);
		this.anchor.addValue(Locale.bottomLeft, Viewport.BOTTOM_LEFT);
		this.anchor.addValue(Locale.topRight, Viewport.TOP_RIGHT);
		this.anchor.addValue(Locale.topLeft, Viewport.TOP_LEFT);
		this.anchor.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "anchor", self.anchor.getValue()));
		});
		this.form.add(this.anchor);
		this.form.nextRow();
	}

	ViewportFormSnippet.prototype = Object.create(FormSnippet.prototype);

	ViewportFormSnippet.prototype.updateValues = function()
	{
		this.offset.setValue(this.object.offset);
		this.sizeBox.setValue(this.object.size);
		this.modeDrop.setValue(this.object.mode);
		this.anchor.setValue(this.object.anchor);
	};

	function PerspectiveCameraInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Fov
		this.form.addText(Locale.fov);
		this.fov = new Slider(this.form);
		this.fov.size.set(160, 18);
		this.fov.setRange(30, 160);
		this.fov.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "fov", self.fov.getValue()));
			self.object.updateProjectionMatrix();
		});
		this.form.add(this.fov);
		this.form.nextRow();

		// Camera used
		this.use = new CheckBox(this.form);
		this.form.addText(Locale.useCamera);
		this.use.size.set(18, 18);
		this.use.setOnChange(function()
		{
			var scene = self.object.getScene();
			if(self.use.getValue() && scene !== null)
			{
				scene.addCamera(self.object);
			}
			else
			{
				scene.removeCamera(self.object);
			}
		});
		this.form.add(this.use);
		this.form.nextRow();

		// Distance
		this.form.addText(Locale.clippingPlanes);
		this.form.nextRow();

		// Near
		this.form.addText(Locale.near);
		this.near = new NumberBox(this.form);
		this.near.size.set(60, 18);
		this.near.setStep(0.1);
		this.near.setRange(0, Number.MAX_SAFE_INTEGER);
		this.near.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "near", self.near.getValue()));
		});
		this.form.add(this.near);
		this.form.nextRow();
		
		// Far
		this.form.addText(Locale.near);
		this.far = new NumberBox(this.form);
		this.far.size.set(80, 18);
		this.far.setRange(0, Number.MAX_SAFE_INTEGER);
		this.far.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "far", self.far.getValue()));
		});
		this.form.add(this.far);
		this.form.nextRow();

		// Viewport
		this.form.addText(Locale.viewport);
		this.form.nextRow();
		this.viewport = new ViewportFormSnippet(this.form, object);
		
		// Order
		this.form.addText(Locale.renderOrder).setAltText(Locale.hintRenderOrder);
		this.order = new NumberBox(this.form);
		this.order.size.set(80, 18);
		this.order.setRange(0, Number.MAX_SAFE_INTEGER);
		this.order.setStep(1);
		this.order.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "order", self.order.getValue()));
			var scene = self.object.getScene();
			scene.updateCameraOrder();
		});
		this.form.add(this.order);
		this.form.nextRow();

		// Clear color
		this.clearColor = new CheckBox(this.form);
		this.form.addText(Locale.clearColor);
		this.clearColor.size.set(18, 18);
		this.clearColor.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "clearColor", self.clearColor.getValue()));
		});
		this.form.add(this.clearColor);
		this.form.nextRow();

		// Clear depth
		this.clearDepth = new CheckBox(this.form);
		this.form.addText(Locale.clearDepth);
		this.clearDepth.size.set(18, 18);
		this.clearDepth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "clearDepth", self.clearDepth.getValue()));
		});
		this.form.add(this.clearDepth);
		this.form.nextRow();

		// Clear stencil
		this.clearStencil = new CheckBox(this.form);
		this.form.addText(Locale.clearStencil);
		this.clearStencil.size.set(18, 18);
		this.clearStencil.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "clearStencil", self.clearStencil.getValue()));
		});
		this.form.add(this.clearStencil);
		this.form.nextRow();
	}

	PerspectiveCameraInspector.prototype = Object.create(ObjectInspector.prototype);

	PerspectiveCameraInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.fov.setValue(this.object.fov);
		this.use.setValue(this.object.getScene().isCameraActive(this.object));
		this.near.setValue(this.object.near);
		this.far.setValue(this.object.far);
		this.order.setValue(this.object.order);
		this.clearColor.setValue(this.object.clearColor);
		this.clearDepth.setValue(this.object.clearDepth);
		this.clearStencil.setValue(this.object.clearStencil);
		this.viewport.attach(this.object.viewport);
	};

	function OrthographicCameraInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Size
		this.form.addText(Locale.size);
		this.sizeBox = new NumberBox(this.form);
		this.sizeBox.size.set(80, 18);
		this.sizeBox.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "size", self.sizeBox.getValue()));
			self.object.updateProjectionMatrix();
		});
		this.form.add(this.sizeBox);
		this.form.nextRow();

		// Camera resize Mode
		this.form.addText("Resize Mode");
		this.mode = new DropdownList(this.form);
		this.mode.size.set(130, 18);
		this.mode.addValue(Locale.horizontal, OrthographicCamera.RESIZE_HORIZONTAL);
		this.mode.addValue(Locale.vertical, OrthographicCamera.RESIZE_VERTICAL);
		this.mode.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "mode", self.mode.getSelectedIndex()));
		});
		this.form.add(this.mode);
		this.form.nextRow();

		// Camera used
		this.use = new CheckBox(this.form);
		this.form.addText(Locale.useCamera);
		this.use.size.set(18, 18);
		this.use.setOnChange(function()
		{
			var scene = self.object.getScene();
			if(self.use.getValue() && scene !== null)
			{
				scene.addCamera(self.object);
			}
			else
			{
				scene.removeCamera(self.object);
			}
		});
		this.form.add(this.use);
		this.form.nextRow();
		
		// Distance
		this.form.addText(Locale.clippingPlanes);
		this.form.nextRow();

		// Near
		this.form.addText(Locale.near);
		this.near = new NumberBox(this.form);
		this.near.size.set(60, 18);
		this.near.setStep(0.1);
		this.near.setRange(0, Number.MAX_SAFE_INTEGER);
		this.near.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "near", self.near.getValue()));
		});
		this.form.add(this.near);
		this.form.nextRow();
		
		// Far
		this.form.addText(Locale.near);
		this.far = new NumberBox(this.form);
		this.far.size.set(80, 18);
		this.far.setRange(0, Number.MAX_SAFE_INTEGER);
		this.far.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "far", self.far.getValue()));
		});
		this.form.add(this.far);
		this.form.nextRow();

		// Viewport
		this.form.addText(Locale.viewport);
		this.form.nextRow();
		this.viewport = new ViewportFormSnippet(this.form, object);

		// Order
		this.form.addText(Locale.renderOrder).setAltText(Locale.hintRenderOrder);
		this.order = new NumberBox(this.form);
		this.order.size.set(80, 18);
		this.order.setRange(0, Number.MAX_SAFE_INTEGER);
		this.order.setStep(1);
		this.order.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "order", self.order.getValue()));

			var scene = self.object.getScene();
			scene.updateCameraOrder();
		});
		this.form.add(this.order);
		this.form.nextRow();

		// Clear color
		this.form.addText(Locale.clearColor);
		this.clearColor = new CheckBox(this.form);
		this.clearColor.size.set(18, 18);
		this.clearColor.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "clearColor", self.clearColor.getValue()));
		});
		this.form.add(this.clearColor);
		this.form.nextRow();

		// Clear depth
		this.clearDepth = new CheckBox(this.form);
		this.form.addText(Locale.clearDepth);
		this.clearDepth.size.set(18, 18);
		this.clearDepth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "clearDepth", self.clearDepth.getValue()));
		});
		this.form.add(this.clearDepth);
		this.form.nextRow();

		// Clear stencil
		this.clearStencil = new CheckBox(this.form);
		this.form.addText(Locale.clearStencil);
		this.clearStencil.size.set(18, 18);
		this.clearStencil.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "clearStencil", self.clearStencil.getValue()));
		});
		this.form.add(this.clearStencil);
		this.form.nextRow();
	}

	OrthographicCameraInspector.prototype = Object.create(ObjectInspector.prototype);

	OrthographicCameraInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);
		
		this.sizeBox.setValue(this.object.size);
		this.mode.setSelectedIndex(this.object.mode);
		this.use.setValue(this.object.getScene().cameras.indexOf(this.object) !== -1);
		this.near.setValue(this.object.near);
		this.far.setValue(this.object.far);
		this.order.setValue(this.object.order);
		this.clearColor.setValue(this.object.clearColor);
		this.clearDepth.setValue(this.object.clearDepth);
		this.clearStencil.setValue(this.object.clearStencil);
		this.viewport.attach(this.object.viewport);
	};

	function AudioEmitterInspector(parent, object)
	{
		ObjectInspector.call(this, parent, object);

		var self = this;

		// Audio player
		this.form.addText(Locale.audio);
		this.player = new AudioPlayer(this.form);
		this.player.size.set(190, 18);
		this.form.add(this.player);
		this.form.nextRow();

		// Volume
		this.form.addText(Locale.volume);
		this.volume = new Slider(this.form);
		this.volume.size.set(80, 18);
		this.volume.setRange(0, 1);
		this.volume.setStep(0.01);
		this.volume.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "volume", self.volume.getValue()));
		});
		this.form.add(this.volume);
		this.form.nextRow();

		// Playback Rate
		this.form.addText("Playback Rate");
		this.playbackRate = new NumberBox(this.form);
		this.playbackRate.size.set(60, 18);
		this.playbackRate.setStep(0.1);
		this.playbackRate.setRange(0, Number.MAX_SAFE_INTEGER);
		this.playbackRate.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "playbackRate", self.playbackRate.getValue()));
		});
		this.form.add(this.playbackRate);
		this.form.nextRow();

		// Autoplay
		this.autoplay = new CheckBox(this.form);
		this.form.addText("Autoplay");
		this.autoplay.size.set(18, 18);
		this.autoplay.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "autoplay", self.autoplay.getValue()));
		});
		this.form.add(this.autoplay);
		this.form.nextRow();

		// Loop
		this.loop = new CheckBox(this.form);
		this.form.addText(Locale.loop);
		this.loop.size.set(18, 18);
		this.loop.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "loop", self.loop.getValue()));
		});
		this.form.add(this.loop);
		this.form.nextRow();
	}

	AudioEmitterInspector.prototype = Object.create(ObjectInspector.prototype);

	AudioEmitterInspector.prototype.destroy = function()
	{
		ObjectInspector.prototype.destroy.call(this);

		this.player.destroy();
	};

	AudioEmitterInspector.prototype.updateInspector = function()
	{
		ObjectInspector.prototype.updateInspector.call(this);

		this.player.setAudioBuffer(this.object.audio.data);
		this.volume.setValue(this.object.volume);
		this.static.setValue(!this.object.matrixAutoUpdate);
		this.autoplay.setValue(this.object.autoplay);
		this.loop.setValue(this.object.loop);
		this.playbackRate.setValue(this.object.playbackRate);
	};

	function MaterialInspector(parent, object)
	{
		Inspector.call(this, parent, object);

		var self = this;

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(190, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "name", self.name.getText()));
			Editor$1.updateObjectsViewsGUI();
		});
		this.form.add(this.name);
		this.form.nextRow();

		// UUID
		if(Editor$1.settings.general.showUUID)
		{
			this.form.addText(Locale.uuid);
			this.uuid = this.form.addText("");
			this.form.nextRow();
		}
		
		// Type
		if(Editor$1.settings.general.showType)
		{
			this.form.addText(Locale.type);
			this.type = this.form.addText("");
			this.form.nextRow();
		}

		// Side
		this.form.addText(Locale.side);
		this.side = new DropdownList(this.form);
		this.side.position.set(100, 85);
		this.side.size.set(100, 18);
		this.side.addValue(Locale.front, three.FrontSide);
		this.side.addValue(Locale.back, three.BackSide);
		this.side.addValue(Locale.double, three.DoubleSide);
		this.side.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "side", self.side.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.side);
		this.form.nextRow();

		// Test depth
		this.form.addText(Locale.depthTest);
		this.depthTest = new CheckBox(this.form);
		this.depthTest.size.set(18, 18);
		this.depthTest.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "depthTest", self.depthTest.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.depthTest);
		this.form.nextRow();
		
		// Write depth
		this.form.addText(Locale.depthWrite);
		this.depthWrite = new CheckBox(this.form);
		this.depthWrite.size.set(18, 18);
		this.depthWrite.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "depthWrite", self.depthWrite.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.depthWrite);
		this.form.nextRow();

		// Depth mode
		this.form.addText(Locale.depthMode);
		this.depthFunc = new DropdownList(this.form);
		this.depthFunc.position.set(100, 85);
		this.depthFunc.size.set(100, 18);
		this.depthFunc.addValue(Locale.never, three.NeverDepth);
		this.depthFunc.addValue(Locale.always, three.AlwaysDepth);
		this.depthFunc.addValue(Locale.less, three.LessDepth);
		this.depthFunc.addValue(Locale.lessOrEqual, three.LessEqualDepth);
		this.depthFunc.addValue(Locale.greaterOrEqual, three.GreaterEqualDepth);
		this.depthFunc.addValue(Locale.greater, three.GreaterDepth);
		this.depthFunc.addValue(Locale.notEqual, three.NotEqualDepth);
		this.depthFunc.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "depthFunc", self.depthFunc.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.depthFunc);
		this.form.nextRow();

		// Transparent
		this.form.addText(Locale.transparent);
		this.transparent = new CheckBox(this.form);
		this.transparent.size.set(18, 18);
		this.transparent.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "transparent", self.transparent.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.transparent);
		this.form.nextRow();

		// Opacity level
		this.form.addText(Locale.opacity);
		this.opacity = new Slider(this.form);
		this.opacity.size.set(160, 18);
		this.opacity.setRange(0, 1);
		this.opacity.setStep(0.01);
		this.opacity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "opacity", self.opacity.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.opacity);
		this.form.nextRow();
		
		// Alpha test
		this.form.addText(Locale.alphaTest);
		this.alphaTest = new Slider(this.form);
		this.alphaTest.size.set(160, 18);
		this.alphaTest.setRange(0, 1);
		this.alphaTest.setStep(0.01);
		this.alphaTest.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "alphaTest", self.alphaTest.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.alphaTest);
		this.form.nextRow();
		
		// Blending mode
		this.form.addText(Locale.blendingMode);
		this.blending = new DropdownList(this.form);
		this.blending.position.set(100, 85);
		this.blending.size.set(100, 18);
		this.blending.addValue(Locale.none, three.NoBlending);
		this.blending.addValue(Locale.normal, three.NormalBlending);
		this.blending.addValue(Locale.additive, three.AdditiveBlending);
		this.blending.addValue(Locale.subtractive, three.SubtractiveBlending);
		this.blending.addValue(Locale.multiply, three.MultiplyBlending);
		this.blending.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.object, "blending", self.blending.getValue()));
			self.object.needsUpdate = true;
		});
		this.form.add(this.blending);
		this.form.nextRow();
	}

	MaterialInspector.prototype = Object.create(Inspector.prototype);

	MaterialInspector.prototype.updateInspector = function()
	{
		this.name.setText(this.object.name);
			
		if(this.uuid !== undefined)
		{
			this.uuid.setText(this.object.uuid);
		}
		
		if(this.type !== undefined)
		{
			this.type.setText(this.object.type);
		}

		this.name.setText(this.object.name);
		this.side.setValue(this.object.side);
		this.depthTest.setValue(this.object.depthTest);
		this.depthWrite.setValue(this.object.depthWrite);
		this.depthFunc.setValue(this.object.depthFunc);
		this.transparent.setValue(this.object.transparent);
		this.opacity.setValue(this.object.opacity);
		this.alphaTest.setValue(this.object.alphaTest);
		this.blending.setValue(this.object.blending);
	};

	/**
	 * Inspector container is used to display object inspector panels.
	 *
	 * It is responsible for selection the appropiate panel for the type of object selected.
	 *
	 * @class InspectorContainer
	 * @extends {TabComponent}
	 */
	function InspectorContainer(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, "Inspector", Global.FILE_PATH + "icons/misc/magnifier.png");

		this.element.style.overflow = "auto";
		this.element.style.backgroundColor = "var(--panel-color)";

		/**
		 * Text shown when there is no object select to show on the inspector.
		 *
		 * @attribute emptyText
		 * @type {Text}
		 */
		this.emptyText = new Text(this);
		this.emptyText.allowWordBreak(true);
		this.emptyText.setTextSize(12);
		this.emptyText.setTextColor("var(--color-light)");
		this.emptyText.setText(Locale.nothingToShow);

		this.panel = null;
	}

	InspectorContainer.prototype = Object.create(TabComponent.prototype);

	InspectorContainer.prototype.destroyInspector = function()
	{
		if(this.panel !== null)
		{
			this.panel.destroy();
			this.panel = null;
		}

		this.emptyText.setVisibility(true);
	};

	InspectorContainer.prototype.attach = function(object)
	{
		if(this.panel !== null)
		{
			this.panel.attach(object);
			this.panel.updateInspector();
		}
	};

	InspectorContainer.prototype.isAttached = function(object)
	{
		if(this.panel !== null)
		{
			return this.panel.object === object;
		}

		return false;
	};

	InspectorContainer.prototype.updateObjectsView = function()
	{
		if(this.panel !== null)
		{	
			var object = this.panel.object;

			if(object.isObject3D === true && object.parent === null)
			{
				if(!(object instanceof Program))
				{
					this.destroyInspector();
				}
			}
		}
	};

	InspectorContainer.prototype.updateSelection = function()
	{	
		var object = Editor$1.hasObjectSelected() ? Editor$1.selection[0] : null;
		
		if(this.panel !== null && this.panel.object === object)
		{
			return;
		}

		this.destroyInspector();

		if(object instanceof three.Object3D)
		{
			if(object.locked)
			{
				this.panel = new LockedInspector(this, object);
			}
			else if(object instanceof ParticleEmitter)
			{
				this.panel = new ParticleEmitterInspector(this, object);
			}
			else if(object instanceof SpineAnimation)
			{
				this.panel = new SpineInspector(this, object);
			}
			else if(object instanceof InstancedMesh)
			{
				this.panel = new InstancedMeshInspector(this, object);
			}
			else if(object instanceof three.SkinnedMesh)
			{
				this.panel = new MeshInspector(this, object);
			}
			else if(object instanceof TextSprite)
			{
				this.panel = new TextSpriteInspector(this, object);
			}
			else if(object instanceof TextBitmap)
			{
				this.panel = new TextBitmapInspector(this, object);
			}
			else if(object instanceof TextMesh)
			{
				this.panel = new TextMeshInspector(this, object);
			}
			else if(object instanceof three.Mesh || object instanceof three.Points || object instanceof three.Line)
			{
				this.panel = new MeshInspector(this, object);
			}
			else if(object instanceof three.Light)
			{
				if(object instanceof three.PointLight)
				{
					this.panel = new PointLightInspector(this, object);
				}
				else if(object instanceof three.RectAreaLight)
				{
					this.panel = new RectAreaLightInspector(this, object);
				}
				else if(object instanceof three.SpotLight)
				{
					this.panel = new SpotLightInspector(this, object);
				}
				else if(object instanceof three.DirectionalLight)
				{
					this.panel = new DirectionalLightInspector(this, object);
				}
				else if(object instanceof three.HemisphereLight)
				{
					this.panel = new HemisphereLightInspector(this, object);
				}
				else if(object instanceof three.LightProbe)
				{
					this.panel = new LightProbeInspector(this, object);
				}
				else
				{
					this.panel = new AmbientLightInspector(this, object);
				}
			}
			else if(object instanceof Sky)
			{
				this.panel = new SkyInspector(this, object);
			}
			else if(object instanceof LeapMotion)
			{
				this.panel = new LeapInspector(this, object);
			}
			else if(object instanceof KinectDevice)
			{
				this.panel = new KinectInspector(this, object);
			}
			else if(object instanceof PerspectiveCamera)
			{
				this.panel = new PerspectiveCameraInspector(this, object);
			}
			else if(object instanceof OrthographicCamera)
			{
				this.panel = new OrthographicCameraInspector(this, object);
			}
			else if(object instanceof CubeCamera)
			{
				this.panel = new CubeCameraInspector(this, object);
			}
			else if(object instanceof three.Audio)
			{
				this.panel = new AudioEmitterInspector(this, object);
			}
			else if(object instanceof Scene)
			{
				this.panel = new SceneInspector(this, object);
			}
			else if(object instanceof Script)
			{
				this.panel = new ScriptInspector(this, object);
			}
			else if(object instanceof Program)
			{
				this.panel = new ProgramInspector(this, object);
			}
			else if(object instanceof PhysicsObject)
			{
				this.panel = new PhysicsInspector(this, object);
			}
			else if(object instanceof OrbitControls)
			{
				this.panel = new OrbitControlsInspector(this, object);
			}
			else if(object instanceof FirstPersonControls)
			{
				this.panel = new FirstPersonControlsInspector(this, object);
			}
			else
			{
				this.panel = new ObjectInspector(this, object);
			}
		}
		else if(object instanceof three.Geometry || object instanceof three.BufferGeometry)
		{
			this.panel = new GeometryInspector(this, object);
		}
		else if(object instanceof Resource)
		{
			if(object instanceof three.Audio)
			{
				this.panel = new AudioInspector(this, object);
			}
			else if(object instanceof Image)
			{
				this.panel = new ImageInspector(this, object);
			}
			else if(object instanceof Video)
			{
				this.panel = new VideoInspector(this, object);
			}
			else
			{
				this.panel = new ResourceInspector(this, object);
			}
		}
		else if(object instanceof three.Material)
		{
			this.panel = new MaterialInspector(this, object);
		}
		else if(object instanceof three.Texture)
		{
			this.panel = new TextureInspector(this, object);
		}

		if(this.panel !== null)
		{
			this.emptyText.setVisibility(false);
			
			this.panel.updateInspector();
			this.panel.size.copy(this.size);
			this.panel.updateInterface();
		}
	};

	InspectorContainer.prototype.updateValues = function()
	{	
		if(this.panel !== null)
		{
			this.panel.updateInspector();
		}
	};

	InspectorContainer.prototype.updateSize = function()
	{	
		TabComponent.prototype.updateSize.call(this);

		this.emptyText.position.x = (this.size.x * 0.1);
		this.emptyText.size.set(this.size.x * 0.8, this.size.y);
		this.emptyText.updateInterface();

		if(this.panel !== null)
		{
			this.panel.size.copy(this.size);
			this.panel.updateInterface();
		}
	};

	/** 
	 * The preview renderer is used to generate preview thumbnails to preview resources in the editor.
	 *
	 * @class PreviewRenderer
	 */
	function PreviewRenderer()
	{
		/**
		 * WebGL renderer used to generate the preview.
		 *
		 * @attribute renderer
		 * @type {WebGLRenderer}
		 */
		this.renderer = new three.WebGLRenderer({alpha: true});
		this.renderer.setSize(128, 128);
		
		/**
		 * DOM canvas where the result is rendered to.
		 *
		 * @attribute canvas
		 * @type {Component}
		 */
		this.canvas = this.renderer.domElement;
		
		/**
		 * Scene to compose the render
		 *
		 * @attribute scene
		 * @type {Scene}
		 */
		this.scene = new three.Scene();
	}

	/**
	 * Render the thumbnail to internal canvas and copy image to html image element.
	 *
	 * The result is returned in the onRender callback. Image data is passed as argument.
	 *
	 * @static
	 * @method render
	 * @param {Object} resource Resource to generate the preview.
	 * @param {Function} onRender Callback method that receives Base64 encoded data with the thumbnail produced.
	 */
	PreviewRenderer.prototype.render = function(resource, onRender){};

	/**
	 * Set thumbnail renderer size.
	 *
	 * @method setSize
	 * @param {number} x
	 * @param {number} y
	 */
	PreviewRenderer.prototype.setSize = function(x, y)
	{
		this.renderer.setSize(x, y);
	};

	/**
	 * Render the thumbnail to internal canvas and copy image to html image element.
	 *
	 * The result is returned in the onRender callback. Image data is passed as argument.
	 *
	 * @method render
	 * @param {Object} resource Resource to generate the preview.
	 * @param {Function} onRender Callback method that receives Base64 encoded data with the thumbnail produced.
	 */
	PreviewRenderer.prototype.render = function(resource, onRender){};

	/** 
	 * The cube map flat renderer generates preview for cube map textures.
	 *
	 * Is draws the faces of the cube map into a flat surface.
	 *
	 * @class CubemapFlatRenderer
	 */
	function CubemapFlatRenderer(envMap, faceSize, paddingLeft, paddingRight)
	{
		this.faceSize = faceSize;
		this.paddingLeft = paddingLeft;
		this.paddingRight = paddingRight;

		function setEnvLookupVector(vIdx, vEnvLookup, outputArray)
		{
			outputArray[3 * vIdx] = vEnvLookup[0];
			outputArray[3 * vIdx + 1] = vEnvLookup[1];
			outputArray[3 * vIdx + 2] = vEnvLookup[2];
		}

		// Each vertex of a cube face has an associated envmap lookup vector. These vectors are interpolated for each fragment and used to lookup envmap pixels.
		var geometryEnvLookupVectors =
		[
			// up left,  up right,   low left,    low right
			[[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1]], // cube face 0
			[[-1, 1, -1], [-1, 1, 1], [-1, -1, -1], [-1, -1, 1]], // face 1
			[[-1, 1, -1], [1, 1, -1], [-1, 1, 1], [1, 1, 1]], // face 2
			[[-1, -1, 1], [1, -1, 1], [-1, -1, -1], [1, -1, -1]], // face 3
			[[-1, 1, 1], [1, 1, 1], [-1, -1, 1], [1, -1, 1]], // face 4
			[[1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1]] // face 5
		];

		var material = new three.ShaderMaterial(
		{
			vertexShader: "attribute vec3 envLookup;\n\
		varying vec3 vEnvLookup;\n\
		void main()\n\
		{\n\
			vEnvLookup = envLookup;\n\
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\
		}",
			fragmentShader: "uniform samplerCube envMap;\n\
		varying vec3 vEnvLookup;\n\
		void main()\n\
		{\n\
			gl_FragColor = textureCube(envMap, vEnvLookup);\n\
		}",
			uniforms:
			{
				envMap: {type: "t", value: envMap}
			}
		});
		
		this.camera = new three.OrthographicCamera(-1, 1, 1, -1, 0, 1);
		this.scene  = new three.Scene();

		this.faces = [];
		for(var i = 0; i < 6; i++)
		{
			var geometry = new three.PlaneBufferGeometry(faceSize, faceSize);
			var envLookupArray = new Float32Array(12);
			geometry.setAttribute("envLookup", new three.BufferAttribute(envLookupArray, 3));
			for(var j = 0; j < 4; j++)
			{
				setEnvLookupVector(j, geometryEnvLookupVectors[i][j], envLookupArray);
			}
			this.faces[i] = new three.Mesh(geometry, material);
			this.scene.add(this.faces[i]);
		}

		/**
		 * Faces layout offsets.
		 *   2
		 * 1 4 0 5
		 *   3
		 *
		 * @attribute faceOffsets
		 * @type {Array}
		 */
		this.faceOffsets =
		[
			[2 * faceSize, faceSize],
			[0, faceSize],
			[faceSize, 0],
			[faceSize, 2 * faceSize],
			[faceSize, faceSize],
			[3 * faceSize, faceSize]
		];
	}
	CubemapFlatRenderer.prototype.setSize = function(width, height)
	{
		var halfWidth = width / 2;
		var halfHeight = height / 2;

		this.camera.left = -halfWidth;
		this.camera.right = halfWidth;
		this.camera.top = halfHeight;
		this.camera.bottom = -halfHeight;
		this.camera.updateProjectionMatrix();

		var offsetX = -halfWidth + this.paddingLeft + this.faceSize / 2;
		var offsetY = halfHeight - this.paddingRight - this.faceSize / 2;

		for(var i = 0; i < this.faces.length; i += 1)
		{
			this.faces[i].position.set(offsetX + this.faceOffsets[i][0], offsetY - this.faceOffsets[i][1], 0);
		}
	};

	CubemapFlatRenderer.prototype.render = function(renderer)
	{
		renderer.render(this.scene, this.camera);
	};

	/** 
	 * The texture renderer is used to generate preview thumbnails.
	 *
	 * @class TextureRenderer
	 * @extends {PreviewRenderer}
	 */
	function TextureRenderer()
	{
		PreviewRenderer.call(this);

		// Camera
		this.camera = new OrthographicCamera(1, 1, OrthographicCamera.RESIZE_VERTICAL);

		// Material
		this.material = new three.MeshBasicMaterial({transparent: true});

		// Plane
		this.plane = new three.Mesh(new three.PlaneBufferGeometry(1, 1), this.material);
		this.plane.position.set(0, 0, -1);
		this.scene.add(this.plane);
	}

	TextureRenderer.prototype = Object.create(PreviewRenderer.prototype);

	/**
	 * Create a DOM element with the texture preview render.
	 *
	 * @static
	 * @method generateElement
	 * @param {Texture} texture Texture to preview.
	 */
	TextureRenderer.generateElement = function(texture)
	{
		var preview = document.createElement("img");
		TextureRenderer.render(texture, function(url)
		{
			preview.src = url;
		});

		return preview;
	};

	TextureRenderer.render = function(texture, onRender)
	{
		if(TextureRenderer.instance === undefined)
		{
			TextureRenderer.instance = new TextureRenderer();
		}

		TextureRenderer.instance.render(texture, onRender);
	};

	TextureRenderer.prototype.render = function(texture, onRender)
	{
		if(texture.isCubeTexture)
		{
			var cube = new CubemapFlatRenderer(texture, 64/4, 0, 64/8);
			cube.setSize(64, 64);
			cube.render(this.renderer);
			onRender(this.canvas.toDataURL());
		}
		else
		{
			this.material.map = texture;
			this.material.needsUpdate = true;
			this.renderer.render(this.scene, this.camera);
			onRender(this.canvas.toDataURL());
		}
	};

	/** 
	 * The material renderer is used to generate preview thumbnails.
	 *
	 * @class MaterialRenderer
	 * @extends {PreviewRenderer}
	 */
	function MaterialRenderer()
	{
		PreviewRenderer.call(this);

		// Camera
		this.camera = new OrthographicCamera(2.15, 1);

		// Geometry
		this.geometry = new three.SphereGeometry(1, 16, 16);

		// Mesh
		this.mesh = new three.Mesh(this.geometry);
		this.scene.add(this.mesh);

		// Points
		this.points = new three.Points(this.geometry);
		this.scene.add(this.points);

		// Line
		this.line = new three.Line(this.geometry);
		this.scene.add(this.line);

		// Sprite
		this.sprite = new three.Sprite();
		this.sprite.scale.set(2, 2, 1);
		this.scene.add(this.sprite);

		// Ambient light
		var ambient = new three.AmbientLight(0x999999);
		this.scene.add(ambient);

		// Point light
		var point = new three.PointLight(0x999999);
		point.position.set(-0.5, 1, 1.5);
		this.scene.add(point);
	}

	MaterialRenderer.prototype = Object.create(PreviewRenderer.prototype);

	/**
	 * Create a DOM element with the material preview render.
	 *
	 * @static
	 * @method generateElement
	 * @param {Material} material Material to preview.
	 */
	MaterialRenderer.generateElement = function(material)
	{
		var preview = document.createElement("img");
		MaterialRenderer.render(material, function(url)
		{
			preview.src = url;
		});

		return preview;
	};

	MaterialRenderer.render = function(material, onRender)
	{
		if(MaterialRenderer.instance === undefined)
		{
			MaterialRenderer.instance = new MaterialRenderer();
		}

		MaterialRenderer.instance.render(material, onRender);
	};

	MaterialRenderer.prototype.render = function(material, onRender)
	{
		if(material instanceof three.SpriteMaterial)
		{
			this.mesh.visible = false;
			this.sprite.visible = true;
			this.points.visible = false;
			this.line.visible = false;

			this.sprite.material = material;
			this.camera.position.set(0, 0, 0.5);
		}
		else if(material instanceof three.LineBasicMaterial)
		{
			this.mesh.visible = false;
			this.sprite.visible = false;
			this.points.visible = false;
			this.line.visible = true;

			this.line.material = material;
			this.camera.position.set(0, 0, 0.5);
		}
		else if(material instanceof three.PointsMaterial)
		{
			this.mesh.visible = false;
			this.sprite.visible = false;
			this.points.visible = true;
			this.line.visible = false;

			this.points.material = material;
			this.camera.position.set(0, 0, 0.5);
		}
		else
		{
			this.sprite.visible = false;
			this.mesh.visible = true;
			this.points.visible = false;
			this.line.visible = false;

			this.mesh.material = material;
			this.camera.position.set(0, 0, 1.5);
		}

		// Render
		this.renderer.render(this.scene, this.camera);

		// Callback
		onRender(this.canvas.toDataURL());
	};

	/**
	 * Console tab is used for the user to access the system console output (that can be also accessed from the dev tools console).
	 *
	 * It is also possible to test some JS code directly on the console and navigate the project resources here.
	 *
	 * @class ConsoleTab
	 * @extends {TabComponent}
	 */
	function ConsoleTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, "Console", Global.FILE_PATH + "icons/misc/console.png");

		var self = this;

		/**
		 * History of the last commands written into the console.
		 *
		 * Can be navigate to view previously used commands.
		 * 
		 * @attribute history
		 * @type {Array}
		 */
		this.history = [];

		/**
		 * History pointer for navigation of the history using the up arrow in the console input box.
		 * 
		 * @attribute historyPointer
		 * @type {number}
		 */
		this.historyPointer = -1;

		/**
		 * Stores a pointer to the original console functions.
		 *
		 * Used to enable and disable the virtual console.
		 *
		 * @attribute handlers
		 * @type {Object}
		 */
		this.handlers = 
		{
			log: window.console.log,
			info: window.console.info,
			warn: window.console.warn,
			error: window.console.error,
			clear: window.console.clear
		};

		/**
		 * Indicates if the virtual console is enable or disable.
		 *
		 * @attribute enable
		 * @type {boolean} 
		 */
		this.enabled = true;

		/**
		 * Search box to filter console content.
		 *
		 * @property search
		 * @type {SearchBox}
		 */
		this.search = new SearchBox(this.bar);
		this.search.setMode(Component.TOP_RIGHT);
		this.search.size.set(200, 25);
		this.search.position.set(1, 0);
		this.search.updateInterface();
		this.search.setOnChange(function()
		{
			self.filterByName(self.search.search.getText());
		});

		/**
		 * Console content division, where the messages are displayed.
		 *
		 * @attribute console
		 * @type {Component}
		 */
		this.content = document.createElement("div");
		this.content.style.position = "absolute";
		this.content.style.overflow = "auto";
		this.content.style.top = "0px";
		this.content.style.left = "0px";
		this.content.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(150, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.clear, function()
			{
				console.clear();
			});

			context.addOption(self.enabled ? Locale.disable : Locale.enable, function()
			{
				self.useConsole(!self.enabled);
			});

			context.updateInterface();
		};
		this.element.appendChild(this.content);

		/**
		 * Console input code division, where the user inserts JS code.
		 *
		 * @attribute input
		 * @type {DOM} 
		 */
		this.input = document.createElement("div");
		this.input.style.position = "absolute";
		this.input.style.overflow = "auto";
		this.input.style.bottom = "0px";
		this.input.style.left = "0px";
		this.element.appendChild(this.input);

		/**
		 * Command input division, shown as a codemirror code editor division for docs and hint access.
		 *
		 * @attribute code
		 * @type {CodeMirror}
		 */
		this.code = new CodeMirror(this.input, {
			dragDrop: false,
			firstLineNumber: 1,
			indentUnit: 0,
			indentWithTabs: false,
			keyMap: Editor$1.settings.code.keymap,
			lineNumbers: false,
			lineWrapping: false,
			matchBrackets: true,
			mode: "javascript",
			styleActiveLine: false,
			styleSelectedText: false,
			tabSize: Editor$1.settings.code.tabSize,
			theme: Editor$1.settings.code.theme,
			undoDepth: 0,
			value: "",
			viewportMargin: 1,
			wholeLineUpdateBefore: false,
			showMatchesOnScrollbar: false,
			lint: false,
			hintOptions:
			{
				hint: CodeMirror.hint.anyword,
				completeSingle: false
			}
		});

		/**
		 * Tern server used to provide code analysis.
		 *
		 * @attribute server
		 * @type {CodeMirror.TernServer}
		 */
		this.server = new CodeMirror.TernServer(
		{
			caseInsensitive: false,
			defs: Editor$1.ternDefinitions
		});

		this.code.on("keypress", function(cm, event)
		{
			var typed = String.fromCharCode(event.charCode);

			if(/[\w\.]/.exec(typed))
			{
				self.server.complete(cm);

				// If there is no tern sugestion suggest known words
				if(cm.state.completionActive == null || cm.state.completionActive.widget === null)
				{
					CodeMirror.commands.autocomplete(cm, null);
				}
			}
		});

		this.code.setOption("extraKeys",
		{
			"Enter": function(cm)
			{
				self.runCommand(self.code.getValue());
				self.code.setValue("");
			},
			"Up": function(cm)
			{
				if(self.history.length > 0 && self.historyPointer > 0)
				{
					self.setText(self.history[self.historyPointer--]);
				}
			}
		});

		this.input.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.copy, function()
			{
				var text = self.code.getSelection();
				if(text !== "")
				{
					Editor$1.clipboard.set(text, "text");
				}
			});
			context.addOption(Locale.cut, function()
			{
				var text = self.code.getSelection();
				if(text !== "")
				{
					Editor$1.clipboard.set(text, "text");
					self.code.replaceSelection("");
				}
			});
			context.addOption(Locale.paste, function()
			{
				self.code.replaceSelection(Editor$1.clipboard.get("text"));
			});
			
			context.updateInterface();
		};

		this.useConsole(this.enabled);
	}

	ConsoleTab.prototype = Object.create(TabComponent.prototype);

	/**
	 * Run a user command from the console, commands are regular code, they have access to the global application space.
	 *
	 * Its possible to create global variables and access enviroments varibles for the program loaded into the platform.
	 *
	 * @method runCommand
	 */
	ConsoleTab.prototype.runCommand = function(code)
	{
		var container = document.createElement("div");
		container.style.paddingLeft = "5px";
		container.style.paddingTop = "5px";
		container.style.paddingBottom = "5px";
		CodeMirror.runMode(code, "javascript", container, {
			mode: "javascript",
			tabSize: Editor$1.settings.code.tabSize,
			theme: Editor$1.settings.code.theme,
		});
		this.content.appendChild(container);
		
		try
		{
			window.program = Editor$1.program;
			var result = eval.call(window, code);
			if(result !== undefined) {
				console.log(result);
			}
		}
		catch(e)
		{
			console.error(e);
		}

		this.history.push(code);
		this.historyPointer = this.history.length - 1;
	};

	/**
	 * Get stack trace up until the point that this method was called.
	 *
	 * Includes the place were this method was called.
	 *
	 * Result is returned as a array of strings and may be different from browser to browser.
	 *
	 * @static
	 * @method getStackTrace
	 */
	ConsoleTab.getStackTrace = function()
	{
		var stack;

		try
		{
			throw new Error("");
		}
		catch(error)
		{
			stack = error.stack || "";
			stack = stack.split("\n").map(function(line)
			{
				return line.trim();
			});
			return stack.splice(stack[0] == "Error" ? 2 : 1);
		}

		return "";
	};

	/**
	 * Use this console as the predefined console.
	 *
	 * Overrides the browser provided window.console methods and displays the logs in this tab.
	 *
	 * @method useConsole
	 * @param {boolean} enabled
	 */
	ConsoleTab.prototype.useConsole = function(enabled)
	{
		var self = this;

		this.enabled = enabled;

		if(this.enabled)
		{
			window.console.log = function()
			{
				self.log(arguments);
				self.handlers.log.apply(null, arguments);
			};

			window.console.warn = function()
			{
				self.warn(arguments);
				self.handlers.warn.apply(null, arguments);
			};

			window.console.error = function()
			{
				self.error(arguments);
				self.handlers.error.apply(null, arguments);
			};

			window.console.clear = function()
			{
				self.clear(arguments);
				self.handlers.clear.apply(null, arguments);
			};
		}
		else
		{
			window.console.log = self.handlers.log;
			window.console.warn = self.handlers.warn;
			window.console.error = self.handlers.error;
			window.console.clear = self.handlers.clear;
		}
	};

	/**
	 * Show a log messsage in the console.
	 *
	 * The content is display using different element depending on its type.
	 *
	 * Multiple objects are shown in different lines.
	 *
	 * @method warn
	 */
	ConsoleTab.prototype.log = function(args)
	{
		for(var i = 0; i < args.length; i++)
		{
			this.content.appendChild(ConsoleTab.createMessage(args[i]));
		}

		// TODO <REMOVE CODE>
		// var stack = ConsoleTab.getStackTrace();
		// this.handlers.log(stack, stack[2]);
		// TODO <CHECK IF THIS Class is a part of the call stack to detect recursion>

		this.content.appendChild(ConsoleTab.createBar());
		this.content.scrollTop = Number.MAX_SAFE_INTEGER;
	};

	/**
	 * Show an warning message from a console.warn() call.
	 *
	 * @method warn
	 */
	ConsoleTab.prototype.warn = function(args)
	{
		for(var i = 0; i < args.length; i++)
		{
			var log = ConsoleTab.createMessage(args[i]);
			log.style.color = "var(--color-console-warn)";
			log.style.backgroundColor = "var(--color-console-warn-background)";
			this.content.appendChild(log);
		}

		this.content.appendChild(ConsoleTab.createBar());
		this.content.scrollTop = Number.MAX_SAFE_INTEGER;
	};

	/**
	 * Show an error message from a console.error() call.
	 *
	 * @method error
	 */
	ConsoleTab.prototype.error = function(args)
	{
		for(var i = 0; i < args.length; i++)
		{
			var log = ConsoleTab.createMessage(args[i]);
			log.style.color = "var(--color-console-error)";
			log.style.backgroundColor = "var(--color-console-error-background)";
			this.content.appendChild(log);
		}

		this.content.appendChild(ConsoleTab.createBar());
		this.content.scrollTop = Number.MAX_SAFE_INTEGER;
	};

	/**
	 * Clear content from the console, remove all nodes created and reset GUI.
	 *
	 * @method clear 
	 */
	ConsoleTab.prototype.clear = function(args)
	{
		this.history = [];

		while(this.content.hasChildNodes())
		{
	    	this.content.removeChild(this.content.lastChild);
		}

		this.content.scrollTop = Number.MAX_SAFE_INTEGER;
	};

	ConsoleTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.content.style.height = (this.size.y - 30) + "px";
		this.content.style.width = this.size.x + "px";

		this.input.style.height = "30px";
		this.input.style.width = this.size.x + "px";
		this.code.setSize(this.size.x, 30);
	};

	/**
	 * Create a new log division element and fill with information from the object.
	 *
	 * Checks the type of the object and creates the log accordingly.
	 * 
	 * @static
	 * @method createMessage
	 * @param {Object} object Object to be logged into the console.
	 * @return {Element} Element created.
	 */
	ConsoleTab.createMessage = function(object)
	{
		var log = document.createElement("div");
		log.style.width = "100%";
		log.style.color = "var(--color-light)";

		if(object === undefined)
		{
			var container = document.createElement("div");
			container.style.paddingLeft = "5px";
			container.style.paddingTop = "5px";
			container.style.paddingBottom = "5px";
			container.appendChild(document.createTextNode("undefined"));
			log.appendChild(container);
		}
		else if(object === null)
		{
			var container = document.createElement("div");
			container.style.paddingLeft = "5px";
			container.style.paddingTop = "5px";
			container.style.paddingBottom = "5px";
			container.appendChild(document.createTextNode("null"));
			log.appendChild(container);
		}
		else if(object instanceof Image)
		{
			var preview = document.createElement("img");
			preview.src = object.data;
			preview.height = 70;
			log.appendChild(preview);

			var table = document.createElement("table");
			table.style.display = "inline-block";

			var type = table.insertRow(0);
			type.insertCell(0).appendChild(document.createTextNode("Image"));

			var name = table.insertRow(1);
			name.insertCell(0).appendChild(document.createTextNode(Locale.name));
			name.insertCell(1).appendChild(document.createTextNode(object.name));

			var uuid = table.insertRow(2);
			uuid.insertCell(0).appendChild(document.createTextNode(Locale.uuid));
			uuid.insertCell(1).appendChild(document.createTextNode(object.uuid));

			var format = table.insertRow(3);
			format.insertCell(0).appendChild(document.createTextNode("Format"));
			format.insertCell(1).appendChild(document.createTextNode(object.format));

			var encoding = table.insertRow(4);
			encoding.insertCell(0).appendChild(document.createTextNode("Encoding"));
			encoding.insertCell(1).appendChild(document.createTextNode(object.encoding));

			log.appendChild(table);
		}
		else if(object instanceof three.Texture)
		{
			var preview = TextureRenderer.generateElement(object);
			preview.height = 70;
			log.appendChild(preview);

			var table = document.createElement("table");
			table.style.display = "inline-block";

			var type = table.insertRow(0);
			type.insertCell(0).appendChild(document.createTextNode(Locale.type));
			type.insertCell(1).appendChild(document.createTextNode(object.type));

			var name = table.insertRow(1);
			name.insertCell(0).appendChild(document.createTextNode(Locale.name));
			name.insertCell(1).appendChild(document.createTextNode(object.name));

			var uuid = table.insertRow(2);
			uuid.insertCell(0).appendChild(document.createTextNode(Locale.uuid));
			uuid.insertCell(1).appendChild(document.createTextNode(object.uuid));

			log.appendChild(table);
		}
		else if(object instanceof three.Material)
		{
			var preview = MaterialRenderer.generateElement(object);
			preview.height = 60;
			log.appendChild(preview);

			var table = document.createElement("table");
			table.style.display = "inline-block";

			var type = table.insertRow(0);
			type.insertCell(0).appendChild(document.createTextNode(Locale.type));
			type.insertCell(1).appendChild(document.createTextNode(object.type));

			var name = table.insertRow(1);
			name.insertCell(0).appendChild(document.createTextNode(Locale.name));
			name.insertCell(1).appendChild(document.createTextNode(object.name));

			var uuid = table.insertRow(2);
			uuid.insertCell(0).appendChild(document.createTextNode(Locale.uuid));
			uuid.insertCell(1).appendChild(document.createTextNode(object.uuid));

			log.appendChild(table);
		}
		else if(object.isVector2)
		{
			var table = document.createElement("table");
			table.style.display = "inline-block";

			var coord = table.insertRow(0);
			coord.insertCell(0).appendChild(document.createTextNode("X"));
			coord.insertCell(1).appendChild(document.createTextNode("Y"));

			var value = table.insertRow(1);
			value.insertCell(0).appendChild(document.createTextNode(object.x));
			value.insertCell(1).appendChild(document.createTextNode(object.y));

			log.appendChild(table);
		}
		else if(object.isVector3)
		{
			var table = document.createElement("table");
			table.style.display = "inline-block";

			var coord = table.insertRow(0);
			coord.insertCell(0).appendChild(document.createTextNode("X"));
			coord.insertCell(1).appendChild(document.createTextNode("Y"));
			coord.insertCell(2).appendChild(document.createTextNode("Z"));

			var value = table.insertRow(1);
			value.insertCell(0).appendChild(document.createTextNode(object.x));
			value.insertCell(1).appendChild(document.createTextNode(object.y));
			value.insertCell(2).appendChild(document.createTextNode(object.z));

			log.appendChild(table);
		}
		else if(object.isVector4 || object.isQuaternion)
		{
			var table = document.createElement("table");
			table.style.display = "inline-block";

			var coord = table.insertRow(0);
			coord.insertCell(0).appendChild(document.createTextNode("X"));
			coord.insertCell(1).appendChild(document.createTextNode("Y"));
			coord.insertCell(2).appendChild(document.createTextNode("Z"));
			coord.insertCell(3).appendChild(document.createTextNode("W"));

			var value = table.insertRow(1);
			value.insertCell(0).appendChild(document.createTextNode(object.x));
			value.insertCell(1).appendChild(document.createTextNode(object.y));
			value.insertCell(2).appendChild(document.createTextNode(object.z));
			value.insertCell(3).appendChild(document.createTextNode(object.w));

			log.appendChild(table);
		}
		else if(object instanceof three.Matrix4)
		{
			var table = document.createElement("table");
			table.style.display = "inline-block";

			for(var i = 0, j = 0; i < 16; i += 4, j++)
			{
				var row = table.insertRow(j);
				row.insertCell(0).appendChild(document.createTextNode(object.elements[i]));
				row.insertCell(1).appendChild(document.createTextNode(object.elements[i + 1]));
				row.insertCell(2).appendChild(document.createTextNode(object.elements[i + 2]));
				row.insertCell(3).appendChild(document.createTextNode(object.elements[i + 3]));
			}

			log.appendChild(table);
		}
		else if(object instanceof three.Matrix3)
		{
			var table = document.createElement("table");
			table.style.display = "inline-block";

			for(var i = 0, j = 0; i < 9; i += 3, j++)
			{
				var row = table.insertRow(j);
				row.insertCell(0).appendChild(document.createTextNode(object.elements[i]));
				row.insertCell(1).appendChild(document.createTextNode(object.elements[i + 1]));
				row.insertCell(2).appendChild(document.createTextNode(object.elements[i + 2]));
			}

			log.appendChild(table);
		}
		else if(object instanceof Error)
		{
			var container = document.createElement("div");
			container.style.paddingLeft = "5px";
			container.style.paddingTop = "5px";
			container.style.paddingBottom = "5px";
			container.appendChild(document.createTextNode(object = object.message));
			log.appendChild(container);
		}
		else if(object instanceof Object)
		{
			var container = document.createElement("div");
			container.style.paddingLeft = "5px";
			container.style.paddingTop = "5px";
			container.style.paddingBottom = "5px";

			try
			{
				container.appendChild(document.createTextNode(JSON.stringify(object, null, "\t")));
			}
			catch(e)
			{
				container.appendChild(document.createTextNode(object));
			}

			log.appendChild(container);
		}
		else
		{
			var container = document.createElement("div");
			container.style.paddingLeft = "5px";
			container.style.paddingTop = "5px";
			container.style.paddingBottom = "5px";
			container.appendChild(document.createTextNode(object));
			log.appendChild(container);
		}

		return log;
	};

	/**
	 * Create a separator bar division.
	 *
	 * @static
	 * @method createBar
	 * @return {Element} Element created.
	 */
	ConsoleTab.createBar = function()
	{
		var bar = document.createElement("div");
		bar.style.width = "100%";
		bar.style.height = "1px";
		bar.style.backgroundColor = "var(--bar-color)";
		return bar;
	};

	/**
	 * Asset represents an resource in the asset explorer.
	 *
	 * There are multiple types of assets this class should be used as base for other types.
	 *
	 * @class Asset
	 * @param {Component} parent
	 * @extends {Component}
	 */
	function Asset(parent)
	{
		Component.call(this, parent, "div");

		this.asset = null;

		this.scale = new three.Vector2(0.7, 0.7);

		// Element
		this.element.style.display = "block";
		this.element.style.float = "left";
		this.element.style.position = "relative";
		this.element.style.cursor = "pointer";
		this.element.style.width = "70px";
		this.element.style.height = "70px";

		// Icon
		this.icon = document.createElement("img");
		this.icon.draggable = false;
		this.icon.style.display = "block";
		this.icon.style.position = "absolute";
		this.icon.style.bottom = "20px";
		this.icon.style.right = "5px";
		this.icon.style.width = "30%";
		this.icon.style.height = "30%";
		this.icon.style.pointerEvents = "none";
		this.icon.style.opacity = "0.5";
		this.icon.style.zIndex = "1";
		this.element.appendChild(this.icon);

		// Text
		this.text = document.createElement("div");
		this.text.style.position = "absolute";
		this.text.style.overflow = "hidden";
		this.text.style.textAlign = "center";
		this.text.style.pointerEvents = "none";
		this.text.style.textOverflow = "ellipsis";
		this.text.style.whiteSpace = "nowrap";
		this.text.style.color = "var(--color-light)";
		this.text.style.height = "20px";
		this.text.style.width = "100%";
		this.text.style.bottom = "0px";
		this.element.appendChild(this.text);

		// Text
		this.name = document.createTextNode("");
		this.text.appendChild(this.name);

		var self = this;

		this.element.onmouseenter = function()
		{
			this.style.backgroundColor = "var(--button-over-color)";
		};

		this.element.onmouseleave = function()
		{
			if(!Editor$1.isSelected(self.asset))
			{
				this.style.backgroundColor = null;
			}
		};

		this.element.onclick = function(event)
		{
			if(event.ctrlKey)
			{
				if(Editor$1.isSelected(self.asset))
				{
					Editor$1.unselectObject(self.asset);
				}
				else
				{
					Editor$1.addToSelection(self.asset);
				}
			}
			else
			{
				Editor$1.selectObject(self.asset);
			}
		};
	}

	Asset.prototype = Object.create(Component.prototype);

	/**
	 * Update selection state and the matching visual elements.
	 *
	 * @method setSelected
	 * @param {boolean} selected If true set selected, otherwise se unselected.
	 */
	Asset.prototype.setSelected = function(selected)
	{
		// this.selected = selected;

		this.element.style.backgroundColor = selected ? "var(--button-over-color)" : null;
	};

	/**
	 * Set the size of the asset.
	 *
	 * @method setSize
	 * @param {number} size Size in px.
	 */
	Asset.prototype.setSize = function(size)
	{
		this.element.style.width = size + "px";
		this.element.style.height = size + "px";
	};

	/**
	 * Attach resource to this asset.
	 *
	 * @method attach
	 * @param {Resource} asset
	 */
	Asset.prototype.attach = function(asset)
	{
		this.asset = asset;
		this.asset.gui = {node: this};
		
		this.updateMetadata();
	};

	/**
	 * Set icon to use in the asset.
	 *
	 * @method setIcon
	 * @param {string} icon Image URL.
	 */
	Asset.prototype.setIcon = function(icon)
	{
		this.icon.src = icon;
	};

	/**
	 * Set asset label.
	 *
	 * @method setText
	 * @param {string} text Asset label.
	 */
	Asset.prototype.setText = function(text)
	{
		this.name.data = text;
	};

	Asset.prototype.updateMetadata = function()
	{
		this.setText(this.asset.name);
	};

	Asset.prototype.updateInterface = function(){};

	function AssetExplorerMenu(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.backgroundColor = "var(--bar-color)";
		this.element.style.overflow = "visible";
		
		// Import
		var menu = new DropdownMenu(this);
		menu.setText(Locale.import);
		menu.size.set(100, 25);
		menu.position.set(0, 0);

		//3D Models Loader
		menu.addOption(Locale.models3D, function()
		{
			FileSystem.chooseFile(function(files)
			{	
				for(var i = 0; i < files.length; i++)
				{
					Loaders.loadModel(files[i]);
				}
			}, ".obj, .dae, .gltf, .glb, .awd, .ply, .vtk, .vtp, .wrl, .vrml, .fbx, .pcd, .json, .3ds, .stl, .x, .js");
		}, Global.FILE_PATH + "icons/models/models.png");

		// Load Font
		menu.addOption(Locale.font, function()
		{
			FileSystem.chooseFile(function(files)
			{
				for(var i = 0; i < files.length; i++)
				{
					Loaders.loadFont(files[i]);
				}
			}, ".json, .ttf, .otf");
		}, Global.FILE_PATH + "icons/misc/font.png");

		// Load text
		menu.addOption(Locale.text, function()
		{
			FileSystem.chooseFile(function(files)
			{
				for(var i = 0; i < files.length; i++)
				{
					Loaders.loadText(files[i]);
				}
			}, ".js, .txt, .glsl, .json, .xml, .yaml, .csv, .css, .html");
		}, Global.FILE_PATH + "icons/misc/file.png");

		// Audio file
		menu.addOption(Locale.audio, function()
		{
			FileSystem.chooseFile(function(files)
			{
				for(var i = 0; i < files.length; i++)
				{
					Loaders.loadAudio(files[i]);
				}
			}, "audio/*");
		}, Global.FILE_PATH + "icons/misc/audio.png");
		
		// Spine Animation
		if(Nunu.runningOnDesktop())
		{
			menu.addOption(Locale.spineAnimation, function()
			{
				FileSystem.chooseFile(function(files)
				{
					for(var i = 0; i < files.length; i++)
					{
						Loaders.loadSpineAnimation(files[i]);
					}
				}, ".json, .spine");
			}, Global.FILE_PATH + "icons/misc/spine.png");
		}

		menu.updateInterface();

		// Textures
		var texture = new DropdownMenu(this);
		texture.setText(Locale.texture);
		texture.size.set(100, 25);
		texture.position.set(100, 0);

		// Image texture
		texture.addOption(Locale.texture, function()
		{
			FileSystem.chooseFile(function(files)
			{
				for(var i = 0; i < files.length; i++)
				{
					Loaders.loadTexture(files[i]);
				}
			}, "image/*");
		}, Global.FILE_PATH + "icons/misc/image.png");

		// Spritesheet texture
		texture.addOption(Locale.spriteSheetTexture, function()
		{
			FileSystem.chooseFile(function(files)
			{
				for(var i = 0; i < files.length; i++)
				{
					var file = files[i];
					var name = FileSystem.getFileName(file.name);
					var extension = FileSystem.getFileExtension(file.name);

					var reader = new FileReader();

					reader.onload = function()
					{
						var texture = new SpriteSheetTexture(new Image(reader.result, extension), 1, 1 ,1);
						texture.name = name;
						Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
					};

					reader.readAsArrayBuffer(file);
				}
			}, "image/*");
		}, Global.FILE_PATH + "icons/misc/grid.png");

		// Cube texture
		texture.addOption(Locale.cubeTexture, function()
		{
			var texture = new CubeTexture([Editor$1.defaultImage, Editor$1.defaultImage, Editor$1.defaultImage, Editor$1.defaultImage, Editor$1.defaultImage, Editor$1.defaultImage]);
			texture.name = "cube";
			Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
		}, Global.FILE_PATH + "icons/misc/cube.png");

		// Canvas texture
		texture.addOption(Locale.canvasTexture, function()
		{
			var texture = new CanvasTexture(512, 512);
			texture.placeholder();
			texture.name = "canvas";
			Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
		}, Global.FILE_PATH + "icons/misc/canvas.png");

		// Video texture
		texture.addOption(Locale.videoTexture, function()
		{
			FileSystem.chooseFile(function(files)
			{
				for(var i = 0; i < files.length; i++)
				{
					Loaders.loadVideoTexture(files[i]);
				}
			}, "video/*");
		}, Global.FILE_PATH + "icons/misc/video.png");

		// Webcam texture
		texture.addOption(Locale.webcamTexture, function()
		{
			var texture = new WebcamTexture();
			texture.name = "webcam";
			Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
		}, Global.FILE_PATH + "icons/hw/webcam.png");

		texture.updateInterface();

		// Material
		var material = new DropdownMenu(this);
		material.setText(Locale.material);
		material.size.set(100, 25);
		material.position.set(200, 0);
		
		material.addOption(Locale.standardMaterial, function()
		{
			var material = new three.MeshStandardMaterial();
			material.name = "standard";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.addOption(Locale.physicalMaterial, function()
		{
			var material = new three.MeshPhysicalMaterial();
			material.name = "physical";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.addOption(Locale.phongMaterial, function()
		{
			var material = new three.MeshPhongMaterial();
			material.name = "phong";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");
		
		material.addOption(Locale.basicMaterial, function()
		{
			var material = new three.MeshBasicMaterial();
			material.name = "basic";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.addOption(Locale.toonMaterial, function()
		{
			var material = new three.MeshToonMaterial();
			material.name = "toon";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.addOption(Locale.lambertMaterial, function()
		{
			var material = new three.MeshLambertMaterial();
			material.name = "lambert";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.addOption(Locale.matcapMaterial, function()
		{
			var material = new three.MeshMatcapMaterial();
			material.name = "matcap";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.addOption(Locale.spriteMaterial, function()
		{
			var material = new three.SpriteMaterial({color: 0xFFFFFF});
			material.name = "sprite";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/image.png");

		material.addOption(Locale.pointsMaterial, function()
		{
			var material = new three.PointsMaterial();
			material.name = "points";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/models/points.png");

		material.addOption(Locale.lineMaterial, function()
		{
			var material = new three.LineBasicMaterial();
			material.name = "line";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/nodes.png");

		material.addOption(Locale.lineDashedMaterial, function()
		{
			var material = new three.LineDashedMaterial();
			material.name = "line";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/nodes.png");

		material.addOption(Locale.shaderMaterial, function()
		{
			var material = new three.ShaderMaterial(
			{
				vertexShader: "void main()\n{\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}",
				fragmentShader: "void main()\n{\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}"
			});
			material.name = "shader";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/script/script.png");

		material.addOption(Locale.rawShaderMaterial, function()
		{
			var material = new three.RawShaderMaterial();
			material.name = "rawshader";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/script/script.png");


		var others = material.addMenu(Locale.more);

		others.addOption(Locale.normalMaterial, function()
		{
			var material = new three.MeshNormalMaterial();
			material.name = "normal";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");
		
		others.addOption(Locale.depthMaterial, function()
		{
			var material = new three.MeshDepthMaterial();
			material.name = "depth";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		others.addOption(Locale.distanceMaterial, function()
		{
			var material = new three.MeshDistanceMaterial();
			material.name = "distance";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		others.addOption(Locale.shadowMaterial, function()
		{
			var material = new three.ShadowMaterial();
			material.name = "shadow";
			Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
		}, Global.FILE_PATH + "icons/misc/material.png");

		material.updateInterface();

		// Create menu
		var create = new DropdownMenu(this);
		create.setText(Locale.code);
		create.size.set(100, 25);
		create.position.set(300, 0);
		
		create.addOption(Locale.html, function()
		{
			var resource = new TextFile("<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n</head>\n<body>\n\n</body>\n</html>", "html");
			resource.name = "html";
			Editor$1.addAction(new AddResourceAction(resource, Editor$1.program, "resources"));
		}, Global.FILE_PATH + "icons/script/script.png");

		create.addOption(Locale.javascript, function()
		{
			var resource = new TextFile("", "js");
			resource.name = "js";
			Editor$1.addAction(new AddResourceAction(resource, Editor$1.program, "resources"));
		}, Global.FILE_PATH + "icons/script/script.png");

		create.updateInterface();
	}

	AssetExplorerMenu.prototype = Object.create(Component.prototype);

	function VideoAsset(parent)
	{
		Asset.call(this, parent);

		this.preview = document.createElement("video");
		this.preview.volume = 0;
		this.preview.draggable = true;
		this.preview.style.position = "absolute";
		this.preview.style.top = "5%";
		this.preview.style.left = "17%";
		this.preview.style.width = "66%";
		this.preview.style.height = "66%";
		this.element.appendChild(this.preview);

		this.setIcon(Global.FILE_PATH + "icons/misc/video.png");

		var self = this;

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.rename, function()
			{
				Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.delete + " " + Locale.video, self.asset.name)));
			});
			
			context.addOption(Locale.delete, function()
			{
				if(Editor$1.confirm(Locale.delete + " " + Locale.video))
				{
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "videos"));
				}
			});

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});

			context.addOption(Locale.cut, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "videos"));
			});

			context.addOption(Locale.export, function()
			{
				if(Nunu.runningOnDesktop())
				{
					FileSystem.chooseFile(function(files)
					{
						if(files.length > 0)
						{
							self.asset.export(files[0].path);
						}
					}, "." + self.asset.encoding, true);
				}
				else
				{
					FileSystem.chooseFileName(function(file)
					{
						self.asset.export(file);
					}, "." + self.asset.encoding);
				}
			});
			
			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Insert into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	VideoAsset.prototype = Object.create(Asset.prototype);

	VideoAsset.prototype.attach = function(asset)
	{
		Asset.prototype.attach.call(this, asset);

		this.preview.src = asset.data;
	};

	VideoAsset.prototype.updateMetadata = function()
	{
		if(this.asset !== null)
		{
			this.setText(this.asset.name);
		}
	};

	function TextureEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.texture, Global.FILE_PATH + "icons/misc/image.png");

		var self = this;

		this.texture = null;

		// Canvas
		this.canvas = new RendererCanvas();
		this.canvas.setOnResize(function(x, y)
		{
			self.camera.aspect = x / y;
			self.camera.mode = (self.camera.aspect > 1) ? OrthographicCamera.RESIZE_HORIZONTAL : OrthographicCamera.RESIZE_VERTICAL;
			self.camera.updateProjectionMatrix();
		});

		// Camera
		this.camera = new OrthographicCamera(1.2, 1, OrthographicCamera.RESIZE_VERTICAL);

		// Scene
		this.scene = new three.Scene();

		// Background
		var alpha = new Texture(Global.FILE_PATH + "alpha.png");
		alpha.wrapS = three.RepeatWrapping;
		alpha.wrapT = three.RepeatWrapping;
		alpha.magFilter = three.Nearest;
		alpha.minFilter = three.Nearest;
		alpha.repeat.set(400, 400);
		
		var geometry = new three.PlaneBufferGeometry(1, 1);

		this.background = new three.Mesh(geometry, new three.MeshBasicMaterial({map: alpha}));
		this.background.position.set(0, 0, -2);
		this.background.scale.set(200, 200, 0);
		this.scene.add(this.background);
		
		// Plane geometry
		this.sprite = new three.Mesh(geometry, new three.MeshBasicMaterial({transparent: true}));
		this.sprite.position.set(0, 0, -1);
		this.scene.add(this.sprite);

		this.form = new TableForm();
		this.form.setAutoSize(false);
		this.form.addText("Texture Editor");
		this.form.nextRow();

		// Dual division
		this.division = new DualContainer(this);
		this.division.tabPosition = 0.5;
		this.division.tabPositionMin = 0.1;
		this.division.tabPositionMax = 0.9;
		this.division.attachA(this.canvas);
		this.division.attachB(this.form);

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(200, 18);
		this.name.setOnChange(function()
		{
			if(self.texture !== null)
			{
				Editor$1.addAction(new ChangeAction(self.texture, "name", self.name.getText()));
				self.updatePreview();
				Editor$1.updateObjectsViewsGUI();
			}
		});
		this.form.add(this.name);
		this.form.nextRow();

		// WrapS
		this.form.addText(Locale.wrapHor);
		this.wrapS = new DropdownList(this.form);
		this.wrapS.size.set(120, 18);
		this.wrapS.addValue(Locale.clampEdge, three.ClampToEdgeWrapping);
		this.wrapS.addValue(Locale.repeat, three.RepeatWrapping);
		this.wrapS.addValue(Locale.repeatMirror, three.MirroredRepeatWrapping);
		this.wrapS.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "wrapS", self.wrapS.getValue()));
			self.updatePreview();
		});
		this.form.add(this.wrapS);
		this.form.nextRow();

		// WrapT
		this.form.addText(Locale.wrapVert);
		this.wrapT = new DropdownList(this.form);
		this.wrapT.size.set(120, 18);
		this.wrapT.addValue(Locale.clampEdge, three.ClampToEdgeWrapping);
		this.wrapT.addValue(Locale.repeat, three.RepeatWrapping);
		this.wrapT.addValue(Locale.repeatMirror, three.MirroredRepeatWrapping);
		this.wrapT.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "wrapT", self.wrapT.getValue()));
			self.updatePreview();
		});
		this.form.add(this.wrapT);
		this.form.nextRow();

		// Repeat
		this.form.addText(Locale.repeat);
		this.repeat = new VectorBox(this.form);
		this.repeat.setType(VectorBox.VECTOR2);
		this.repeat.size.set(120, 18);
		this.repeat.setStep(0.01);
		this.repeat.setOnChange(function()
		{
			var value = self.repeat.getValue();
			self.texture.repeat.set(value.x, value.y);
			self.updatePreview();
		});
		this.form.add(this.repeat);
		this.form.nextRow();

		// Offset
		this.form.addText(Locale.offset);
		this.offset = new VectorBox(this.form);
		this.offset.setType(VectorBox.VECTOR2);
		this.offset.size.set(120, 18);
		this.offset.setStep(0.01);
		this.offset.setOnChange(function()
		{
			var value = self.offset.getValue();
			self.texture.offset.set(value.x, value.y);
			self.updatePreview();
		});
		this.form.add(this.offset);
		this.form.nextRow();

		// Center
		this.form.addText(Locale.center);
		this.center = new VectorBox(this.form);
		this.center.setType(VectorBox.VECTOR2);
		this.center.size.set(120, 18);
		this.center.setStep(0.01);
		this.center.setOnChange(function()
		{
			var value = self.center.getValue();
			self.texture.center.set(value.x, value.y);
			self.updatePreview();
		});
		this.form.add(this.center);
		this.form.nextRow();

		// Rotation
		this.form.addText(Locale.rotation);
		this.rotation = new NumberBox(this.form);
		this.rotation.size.set(60, 18);
		this.rotation.setStep(0.1);
		this.rotation.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "rotation", self.rotation.getValue()));
			self.updatePreview();
		});
		this.form.add(this.rotation);
		this.form.nextRow();

		// Minification filter
		this.form.addText(Locale.minFilter);
		this.minFilter = new DropdownList(this.form);
		this.minFilter.size.set(150, 18);
		this.minFilter.addValue(Locale.nearest, three.NearestFilter);
		this.minFilter.addValue(Locale.linear, three.LinearFilter);
		this.minFilter.addValue("MIP Nearest Nearest", three.NearestMipMapNearestFilter);
		this.minFilter.addValue("MIP Nearest Linear", three.NearestMipMapLinearFilter);
		this.minFilter.addValue("MIP Linear Nearest", three.LinearMipMapNearestFilter);
		this.minFilter.addValue("MIP Linear Linear", three.LinearMipMapLinearFilter);
		this.minFilter.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "minFilter", self.minFilter.getValue()));
			self.updatePreview();
		});
		this.form.add(this.minFilter);
		this.form.nextRow();

		// Magnification filter
		this.form.addText(Locale.magFilter);
		this.magFilter = new DropdownList(this.form);
		this.magFilter.size.set(150, 18);
		this.magFilter.addValue(Locale.nearest, three.NearestFilter);
		this.magFilter.addValue(Locale.linear, three.LinearFilter);
		this.magFilter.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "magFilter", self.magFilter.getValue()));
			self.updatePreview();
		});
		this.form.add(this.magFilter);
		this.form.nextRow();

		// Premultiply Alpha
		this.form.addText(Locale.premulAlpha);
		this.premultiplyAlpha = new CheckBox(this.form);
		this.premultiplyAlpha.size.set(18, 18);
		this.premultiplyAlpha.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "premultiplyAlpha", self.premultiplyAlpha.getValue()));
			self.updatePreview();
		});
		this.form.add(this.premultiplyAlpha);
		this.form.nextRow();

		// Flip Y
		this.form.addText(Locale.flipY);
		this.flipY = new CheckBox(this.form);
		this.flipY.size.set(18, 18);
		this.flipY.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "flipY", self.flipY.getValue()));
			self.updatePreview();
		});
		this.form.add(this.flipY);
		this.form.nextRow();
	}

	TextureEditor.prototype = Object.create(TabComponent.prototype);

	// Activate
	TextureEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);
		
		this.updatePreview();

		var texture = this.texture;
		this.name.setText(texture.name);
		this.wrapT.setValue(texture.wrapT);
		this.wrapS.setValue(texture.wrapS);
		this.repeat.setValue(texture.repeat);
		this.offset.setValue(texture.offset);
		this.center.setValue(texture.center);
		this.rotation.setValue(texture.rotation);
		this.magFilter.setValue(texture.magFilter);
		this.minFilter.setValue(texture.minFilter);
		this.premultiplyAlpha.setValue(texture.premultiplyAlpha);
		this.flipY.setValue(texture.flipY);
	};

	// Destroy
	TextureEditor.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);

		this.canvas.destroy();
	};

	// Update test material
	TextureEditor.prototype.updatePreview = function()
	{
		this.sprite.material.map.needsUpdate = true;
		this.sprite.material.needsUpdate = true;
	};

	// Check if texture is attached to tab
	TextureEditor.prototype.isAttached = function(texture)
	{
		return this.texture === texture;
	};

	// Update object data
	TextureEditor.prototype.updateMetadata = function()
	{
		if(this.texture !== null)
		{
			// Set name
			if(this.texture.name !== undefined)
			{
				this.setName(this.texture.name);
				this.name.setText(this.texture.name);
			}

			// If not found close tab
			if(Editor$1.program.textures[this.texture.uuid] === undefined)
			{
				this.close();
			}
		}
	};

	// Attach texure
	TextureEditor.prototype.attach = function(texture)
	{
		this.texture = texture;
		this.sprite.material.map = texture;
		
		this.updateMetadata();
		this.updatePreview();
	};

	TextureEditor.prototype.update = function()
	{
		this.canvas.renderer.render(this.scene, this.camera);
	};

	TextureEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.division.size.copy(this.size);
		this.division.updateInterface();
	};

	function VideoTextureEditor(parent, closeable, container, index)
	{
		TextureEditor.call(this, parent, closeable, container, index);

		var self = this;
		
		// Volume
		this.form.addText(Locale.volume);
		this.volume = new Slider(this.form);
		this.volume.size.set(80, 18);
		this.volume.setRange(0, 1);
		this.volume.setStep(0.01);
		this.volume.setOnChange(function()
		{
			self.texture.setVolume(self.volume.getValue());
		});
		this.form.add(this.volume);
		this.form.nextRow();

		// Playback Rate
		this.form.addText("Playback Rate");
		this.playbackRate = new NumberBox(this.form);
		this.playbackRate.size.set(60, 18);
		this.playbackRate.setStep(0.1);
		this.playbackRate.setRange(0, Number.MAX_SAFE_INTEGER);
		this.playbackRate.setOnChange(function()
		{
			self.texture.setPlaybackRate(self.playbackRate.getValue());
		});
		this.form.add(this.playbackRate);
		this.form.nextRow();

		// Autoplay
		this.autoplay = new CheckBox(this.form);
		this.form.addText("Autoplay");
		this.autoplay.size.set(18, 18);
		this.autoplay.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "autoplay", self.autoplay.getValue()));
		});
		this.form.add(this.autoplay);
		this.form.nextRow();

		// Loop
		this.loop = new CheckBox(this.form);
		this.form.addText(Locale.loop);
		this.loop.size.set(18, 18);
		this.loop.setOnChange(function()
		{
			self.texture.setLoop(self.loop.getValue());
		});
		this.form.add(this.loop);
		this.form.nextRow();
	}

	VideoTextureEditor.prototype = Object.create(TextureEditor.prototype);

	VideoTextureEditor.prototype.attach = function(texture)
	{
		TextureEditor.prototype.attach.call(this, texture);

		this.volume.setValue(this.texture.volume);
		this.autoplay.setValue(this.texture.autoplay);
		this.loop.setValue(this.texture.loop);
		this.playbackRate.setValue(this.texture.playbackRate);
	};

	function SpriteSheetTextureEditor(parent, closeable, container, index)
	{
		TextureEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Image
		this.form.addText(Locale.image);
		this.source = new ImageChooser(this.form);
		this.source.size.set(0, 100);
		this.source.setOnChange(function()
		{
			Editor$1.addAction(new CallbackAction(new ChangeAction(self.texture, "source", self.source.getValue()), function()
			{
				self.texture.updateSource();
			}));
		});
		this.form.add(this.source);
		this.form.nextRow();

		// Sheet format
		this.form.addText("Sheet format");
		this.frames = new VectorBox(this.form);
		this.frames.setType(VectorBox.VECTOR2);
		this.frames.size.set(120, 18);
		this.frames.setValue(1, 1, 0);
		this.frames.setStep(1.0);
		this.frames.setOnChange(function()
		{
			var value = self.frames.getValue();
			self.texture.framesHorizontal = value.x;
			self.texture.framesVertical = value.y;

			self.totalFrames.setValue(self.texture.totalFrames);
			self.beginFrame.setValue(self.texture.beginFrame);
			self.endFrame.setValue(self.texture.endFrame);
		});
		this.form.add(this.frames);
		this.form.nextRow();

		// Total frames
		this.form.addText("Total Frames");
		this.totalFrames = new NumberBox(this.form);
		this.totalFrames.size.set(60, 18);
		this.totalFrames.setStep(1.0);
		this.totalFrames.setRange(0, Number.MAX_SAFE_INTEGER);
		this.totalFrames.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "totalFrames", self.totalFrames.getValue()));
			self.beginFrame.setValue(self.texture.beginFrame);
			self.endFrame.setValue(self.texture.endFrame);
		});
		this.form.add(this.totalFrames);
		this.form.nextRow();

		// Begin frame
		this.form.addText("Begin Frame");
		this.beginFrame = new NumberBox(this.form);
		this.beginFrame.size.set(60, 18);
		this.beginFrame.setStep(1.0);
		this.beginFrame.setRange(0, Number.MAX_SAFE_INTEGER);
		this.beginFrame.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "beginFrame", self.beginFrame.getValue()));
		});
		this.form.add(this.beginFrame);
		this.form.nextRow();

		// End frame
		this.form.addText("End Frame");
		this.endFrame = new NumberBox(this.form);
		this.endFrame.size.set(60, 18);
		this.endFrame.setStep(1.0);
		this.endFrame.setRange(0, Number.MAX_SAFE_INTEGER);
		this.endFrame.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "endFrame", self.endFrame.getValue()));
		});
		this.form.add(this.endFrame);
		this.form.nextRow();

		// Speed
		this.form.addText(Locale.speed);
		this.animationSpeed = new NumberBox(this.form);
		this.animationSpeed.size.set(60, 18);
		this.animationSpeed.setStep(0.01);
		this.animationSpeed.setRange(0, Number.MAX_SAFE_INTEGER);
		this.animationSpeed.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "animationSpeed", self.animationSpeed.getValue()));
		});
		this.form.add(this.animationSpeed);
		this.form.nextRow();
	}

	SpriteSheetTextureEditor.prototype = Object.create(TextureEditor.prototype);

	SpriteSheetTextureEditor.prototype.attach = function(texture)
	{
		TextureEditor.prototype.attach.call(this, texture);

		this.source.setValue(this.texture.source);
		this.frames.setValue(this.texture.framesHorizontal, this.texture.framesVertical);
		this.totalFrames.setValue(this.texture.totalFrames);
		this.beginFrame.setValue(this.texture.beginFrame);
		this.endFrame.setValue(this.texture.endFrame);
		this.animationSpeed.setValue(this.texture.animationSpeed);
	};

	function CubeTextureEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.texture, Global.FILE_PATH + "icons/misc/cube.png");

		var self = this;

		this.texture = null;

		// Canvas
		this.canvas = new RendererCanvas();
		this.canvas.setOnResize(function(x, y)
		{
			self.camera.aspect = x / y;
			self.camera.updateProjectionMatrix();
		});

		// Mouse
		this.mouse = new Mouse(window, true);
		this.mouse.setCanvas(this.canvas.element);

		// Camera
		this.camera = new PerspectiveCamera(100, this.canvas.width / this.canvas.height);

		// Scene
		this.scene = new three.Scene();

		// Texture
		this.texture = null;

		// Form
		this.form = new TableForm();
		this.form.setAutoSize(false);
		this.form.addText("Cube Texture Editor");
		this.form.nextRow();

		// Dual division
		this.division = new DualContainer(this);
		this.division = new DualContainer(this);
		this.division.tabPosition = 0.5;
		this.division.tabPositionMin = 0.1;
		this.division.tabPositionMax = 0.9;
		this.division.attachA(this.canvas);
		this.division.attachB(this.form);

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(200, 18);
		this.name.setOnChange(function()
		{
			if(self.texture !== null)
			{
				self.texture.name = self.name.getText();
				self.updateMaterial();
				Editor$1.updateObjectsViewsGUI();
			}
		});
		this.form.add(this.name);
		this.form.nextRow();

		// Minification filter
		this.form.addText(Locale.minFilter);
		this.minFilter = new DropdownList(this.form);
		this.minFilter.size.set(150, 18);
		this.minFilter.addValue(Locale.nearest, three.NearestFilter);
		this.minFilter.addValue(Locale.linear, three.LinearFilter);
		this.minFilter.addValue("MIP Nearest Nearest", three.NearestMipMapNearestFilter);
		this.minFilter.addValue("MIP Nearest Linear", three.NearestMipMapLinearFilter);
		this.minFilter.addValue("MIP Linear Nearest", three.LinearMipMapNearestFilter);
		this.minFilter.addValue("MIP Linear Linear", three.LinearMipMapLinearFilter);
		this.minFilter.setOnChange(function()
		{
			if(self.texture !== null)
			{
				self.texture.minFilter = self.minFilter.getValue();
				self.updateMaterial();
			}
		});
		this.form.add(this.minFilter);
		this.form.nextRow();

		// Magnification filter
		this.form.addText(Locale.magFilter);
		this.magFilter = new DropdownList(this.form);
		this.magFilter.size.set(150, 18);
		this.magFilter.addValue(Locale.nearest, three.NearestFilter);
		this.magFilter.addValue(Locale.linear, three.LinearFilter);
		this.magFilter.setOnChange(function()
		{
			if(self.texture !== null)
			{
				self.texture.magFilter = self.magFilter.getValue();
				self.updateMaterial();
			}
		});
		this.form.add(this.magFilter);
		this.form.nextRow();

		// Mapping
		this.form.addText(Locale.mapping);
		this.mapping = new DropdownList(this.form);
		this.mapping.size.set(150, 18);
		this.mapping.addValue("Cube Reflection", three.CubeReflectionMapping);
		this.mapping.addValue("Cube Refraction", three.CubeRefractionMapping);
		this.mapping.addValue("Equirectangular Reflection", three.EquirectangularReflectionMapping);
		this.mapping.addValue("Equirectangular Reflection", three.EquirectangularRefractionMapping);
		this.mapping.addValue("Spherical Reflection", three.SphericalReflectionMapping);
		this.mapping.addValue("Cube UV Reflection", three.CubeUVReflectionMapping);
		this.mapping.addValue("Cube UV Reflection", three.CubeUVRefractionMapping);
		this.mapping.setOnChange(function()
		{
			self.texture.mapping = self.mapping.getValue();
			self.updateMaterial();
		});
		this.form.add(this.mapping);
		this.form.nextRow();

		// Size
		this.form.addText(Locale.size);
		this.textureSize = new DropdownList(this.form);
		this.textureSize.size.set(120, 18);
		this.textureSize.setOnChange(function()
		{
			self.texture.size = self.textureSize.getValue();
			self.texture.updateImages();
		});
		this.form.add(this.textureSize);
		this.form.nextRow();

		// Size options
		for(var i = 2; i < 12; i++)
		{
			var size = Math.pow(2, i);
			this.textureSize.addValue(size + "x" + size, size);
		}

		// Mode
		this.form.addText(Locale.mode);
		this.mode = new DropdownList(this.form);
		this.mode.size.set(120, 18);
		this.mode.setOnChange(function()
		{
			self.texture.mode = self.mode.getValue();
			self.texture.updateImages();
			self.updateMode();
			Editor$1.updateObjectsViewsGUI();
		});
		this.mode.addValue(Locale.cube, CubeTexture.CUBE);
		this.mode.addValue("Cross", CubeTexture.CROSS);
		this.mode.addValue("Equirectangular", CubeTexture.EQUIRECTANGULAR);
		this.form.add(this.mode);
		this.form.nextRow();

		// Flip Y
		this.form.addText(Locale.flipY);
		this.flipY = new CheckBox(this.form);
		this.flipY.size.set(18, 18);
		this.flipY.setOnChange(function()
		{
			self.texture.flipY = self.flipY.getValue();
			self.updateMaterial();
		});
		this.form.add(this.flipY);
		this.form.nextRow();

		// Cube texture
		this.form.addText("Cube texture");
		this.form.nextRow();

		// Cube images
		this.images = new Division(this.form);
		this.images.size.set(400, 300);
		this.form.add(this.images);
		this.form.nextRow();

		// Image
		this.image = new ImageChooser(this.images);
		this.image.position.set(0, 0);
		this.image.size.set(400, 200);
		this.image.setOnChange(function()
		{
			var image = self.image.getValue();
			self.texture.images[0] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.image.updateInterface();

		// Cube faces
		this.cube = [];

		// Top
		this.top = new ImageChooser(this.images);
		this.top.position.set(100, 0);
		this.top.size.set(100, 100);
		this.top.setOnChange(function()
		{
			var image = self.top.getValue();
			self.texture.images[CubeTexture.TOP] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.cube.push(this.top);

		// Left
		this.left = new ImageChooser(this.images);
		this.left.size.set(100, 100);
		this.left.position.set(0, 100);
		this.left.setOnChange(function()
		{
			var image = self.left.getValue();
			self.texture.images[CubeTexture.LEFT] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.cube.push(this.left);

		// Front
		this.front = new ImageChooser(this.images);
		this.front.size.set(100, 100);
		this.front.position.set(100, 100);
		this.front.setOnChange(function()
		{
			var image = self.front.getValue();
			self.texture.images[CubeTexture.FRONT] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.cube.push(this.front);

		// Right
		this.right = new ImageChooser(this.images);
		this.right.size.set(100, 100);
		this.right.position.set(200, 100);
		this.right.setOnChange(function()
		{
			var image = self.right.getValue();
			self.texture.images[CubeTexture.RIGHT] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.cube.push(this.right);

		// Back
		this.back = new ImageChooser(this.images);
		this.back.size.set(100, 100);
		this.back.position.set(300, 100);
		this.back.setOnChange(function()
		{
			var image = self.back.getValue();
			self.texture.images[CubeTexture.BACK] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.cube.push(this.back);

		// Bottom
		this.bottom = new ImageChooser(this.images);
		this.bottom.position.set(100, 200);
		this.bottom.size.set(100, 100);
		this.bottom.setOnChange(function()
		{
			var image = self.bottom.getValue();
			self.texture.images[CubeTexture.BOTTOM] = image;
			self.texture.updateImages();
			Editor$1.updateObjectsViewsGUI();
		});
		this.cube.push(this.bottom);
	}

	CubeTextureEditor.prototype = Object.create(TabComponent.prototype);

	CubeTextureEditor.prototype.updateMaterial = function()
	{
		this.texture.needsUpdate = true;
	};

	// Update input elements
	CubeTextureEditor.prototype.updateMode = function()
	{
		var mode = this.mode.getValue();

		if(mode === CubeTexture.CUBE)
		{
			this.image.visible = false;

			for(var i = 0; i < this.cube.length; i++)
			{
				this.cube[i].visible = true;
				this.cube[i].updateInterface();
			}
		}
		else
		{
			this.image.visible = true;
		
			for(var i = 0; i < this.cube.length; i++)
			{
				this.cube[i].visible = false;
				this.cube[i].updateInterface();
			}

			if(mode === CubeTexture.CROSS)
			{
				this.image.size.set(400, 300);
			}
			else
			{
				this.image.size.set(400, 200);
			}
		}

		this.image.updateInterface();
	};

	CubeTextureEditor.prototype.isAttached = function(texture)
	{
		return this.texture === texture;
	};

	CubeTextureEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);

		this.mouse.create();
	};

	CubeTextureEditor.prototype.deactivate = function()
	{
		TabComponent.prototype.deactivate.call(this);
		
		this.mouse.dispose();
	};

	CubeTextureEditor.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);

		this.mouse.dispose();
		this.canvas.destroy();
	};

	CubeTextureEditor.prototype.updateMetadata = function()
	{
		if(this.texture !== null)
		{
			// Set name
			if(this.texture.name !== undefined)
			{
				this.setName(this.texture.name);
				this.name.setText(this.texture.name);
			}

			// If not found close tab
			if(Editor$1.program.textures[this.texture.uuid] === undefined)
			{
				this.close();
			}
		}
	};

	CubeTextureEditor.prototype.attach = function(texture)
	{
		this.texture = texture;
		this.updateMetadata();

		this.scene.background = texture;

		this.name.setText(texture.name);
		this.magFilter.setValue(texture.magFilter);
		this.minFilter.setValue(texture.minFilter);
		this.mapping.setValue(texture.mapping);
		this.textureSize.setValue(texture.size);
		this.mode.setValue(texture.mode);
		this.flipY.setValue(texture.flipY);

		if(texture.mode === CubeTexture.CROSS || texture.mode === CubeTexture.EQUIRECTANGULAR)
		{
			this.image.setValue(texture.images[0]);
		}
		else
		{
			this.top.setValue(texture.images[CubeTexture.TOP]);
			this.bottom.setValue(texture.images[CubeTexture.BOTTOM]);
			this.left.setValue(texture.images[CubeTexture.LEFT]);
			this.right.setValue(texture.images[CubeTexture.RIGHT]);
			this.front.setValue(texture.images[CubeTexture.FRONT]);
			this.back.setValue(texture.images[CubeTexture.BACK]);
		}

		this.updateMode();
	};

	CubeTextureEditor.prototype.update = function()
	{
		this.mouse.update();
		
		if(this.mouse.buttonPressed(Mouse.LEFT))
		{
			this.camera.rotation.y += this.mouse.delta.x * 0.004;
		}

		this.canvas.renderer.render(this.scene, this.camera);
	};

	CubeTextureEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.division.size.copy(this.size);
		this.division.updateInterface();
	};

	function CanvasTextureEditor(parent, closeable, container, index)
	{
		TextureEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Width
		this.form.addText(Locale.width);
		this.width = new DropdownList(this.form);
		this.width.size.set(120, 18);
		this.width.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "width", self.width.getValue()));
			self.texture.updateSize();
			self.updatePreview();
		});
		this.form.add(this.width);
		this.form.nextRow();

		// Height
		this.form.addText(Locale.height);
		this.height = new DropdownList(this.form);
		this.height.size.set(120, 18);
		this.height.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.texture, "height", self.height.getValue()));
			self.texture.updateSize();
			self.updatePreview();
		});
		this.form.add(this.height);
		this.form.nextRow();

		// Size options
		for(var i = 3; i < 13; i++)
		{
			var size = Math.pow(2, i);
			this.width.addValue(size, size);
			this.height.addValue(size, size);
		}
	}

	CanvasTextureEditor.prototype = Object.create(TextureEditor.prototype);

	CanvasTextureEditor.prototype.attach = function(texture)
	{
		TextureEditor.prototype.attach.call(this, texture);

		this.width.setValue(this.texture.width);
		this.height.setValue(this.texture.height);
	};

	function TextureAsset(parent)
	{
		Asset.call(this, parent);

		this.setIcon(Global.FILE_PATH + "icons/misc/texture.png");

		var self = this;

		this.element.ondblclick = function()
		{
			var Constructor = TextureEditor;

			if(self.asset instanceof VideoTexture)
			{
				Constructor = VideoTextureEditor;
			}
			else if(self.asset instanceof CanvasTexture)
			{
				Constructor = CanvasTextureEditor;
			}
			else if(self.asset instanceof CubeTexture)
			{
				Constructor = CubeTextureEditor;
			}
			else if(self.asset instanceof SpriteSheetTexture)
			{
				Constructor = SpriteSheetTextureEditor;
			}

			var tab = Editor$1.gui.tab.getTab(Constructor, self.asset);
			
			if(tab === null)
			{
				tab = Editor$1.gui.tab.addTab(Constructor, true);
				tab.attach(self.asset);
			}

			tab.select();
		};

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.rename, function()
			{
				if(self.asset !== null)
				{
					Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.renameTexture, self.asset.name)));
				}
			});
			
			context.addOption(Locale.delete, function()
			{
				if(self.asset !== null && Editor$1.confirm(Locale.deleteTexture))
				{
					self.asset.dispose();
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "textures"));
				}
			});

			context.addOption(Locale.copy, function()
			{
				if(self.asset !== null)
				{
					Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				}
			});
			
			context.addOption(Locale.cut, function()
			{
				if(self.asset !== null)
				{
					Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "textures"));
				}
			});

			context.addOption(Locale.duplicate, function()
			{
				try
				{
					var resources =
					{
						videos: {},
						images: {},
						fonts: {},
						textures: {}
					};

					// Serialize
					var json = self.asset.toJSON(resources);
					var images = ObjectLoader.prototype.parseImages.call(this, resources.images);
					var videos = ObjectLoader.prototype.parseVideos.call(this, resources.videos);

					// Loader
					var loader = new TextureLoader();
					loader.setImages(images);
					loader.setVideos(videos);

					// Load
					var texture = loader.parse(json); 
					texture.uuid = three.Math.generateUUID();
					texture.name += "*";
					
					Editor$1.addAction(new AddResourceAction(texture, Editor$1.program, "textures"));
				}
				catch(e)
				{
					Editor$1.alert("Texture duplication failed.\n" + e.stack);
				}
			});
			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Insert into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	TextureAsset.prototype = Object.create(Asset.prototype);

	TextureAsset.prototype.attach = function(asset)
	{
		Asset.prototype.attach.call(this, asset);

		this.preview = TextureRenderer.generateElement(asset);

		if(this.preview !== null)
		{
			this.preview.draggable = true;
			this.preview.style.position = "absolute";
			this.preview.style.top = "5%";
			this.preview.style.left = "17%";
			this.preview.style.width = "66%";
			this.preview.style.height = "66%";
			this.element.appendChild(this.preview);	
		}
	};

	/**
	 * Dual division component is a box with two divisions that can be used to place other content.
	 *
	 * The component can be resized, using a resizable bar that can be vertical or horizontal.
	 *
	 * @class DualDivision
	 */
	function DualDivision(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "hidden";
		this.element.style.backgroundColor = "var(--panel-color)";

		// Division A
		this.divA = new Component(this, "div");
		this.divA.element.style.backgroundColor = "var(--panel-color)";

		// Division B
		this.divB = new Component(this, "div");
		this.divB.element.style.backgroundColor = "var(--panel-color)";
		
		// Resize tab
		this.resizeTab = document.createElement("div");
		this.resizeTab.style.position = "absolute";
		this.resizeTab.style.cursor = "e-resize";
		this.resizeTab.style.backgroundColor = "var(--bar-color)";
		this.element.appendChild(this.resizeTab);

		// Resize Tab
		this.tabPosition = 0.5;
		this.tabPositionMax = 1;
		this.tabPositionMin = 0;
		this.tabSize = 5;
		this.orientation = DualDivision.HORIZONTAL;

		var self = this;

		// Tab mouse down
		this.resizeTab.onmousedown = function(event)
		{
			self.manager.create();
		};

		// Tab resize event manager
		this.manager = new EventManager();
		this.manager.add(window, "mousemove", function(event)
		{
			if(self.orientation === DualDivision.HORIZONTAL)
			{	
				self.tabPosition += event.movementX / self.size.x;
			}
			else if(self.orientation === DualDivision.VERTICAL)
			{
				self.tabPosition += event.movementY / self.size.y;
			}

			// Limit tab position
			if(self.tabPosition > self.tabPositionMax)
			{
				self.tabPosition = self.tabPositionMax;
			}
			else if(self.tabPosition < self.tabPositionMin)
			{
				self.tabPosition = self.tabPositionMin;
			}

			self.updateInterface();
			self.onResize();
		});

		this.manager.add(window, "mouseup", function(event)
		{
			self.manager.destroy();
		});

		// onResize callback
		this.onResize = function()
		{
			Editor$1.gui.updateInterface();
		};
	}

	DualDivision.HORIZONTAL = 0;
	DualDivision.VERTICAL = 1;

	DualDivision.prototype = Object.create(Component.prototype);

	DualDivision.prototype.setOnResize = function(callback)
	{
		this.onResize = callback;
	};

	DualDivision.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		if(this.orientation === DualDivision.HORIZONTAL)
		{
			var tabPositionAbs = this.tabPosition * this.size.x;
			
			this.divA.position.set(0, 0);
			this.divA.size.set(tabPositionAbs, this.size.y);
			this.divA.updateInterface();

			this.divB.size.set(this.size.x - tabPositionAbs - this.tabSize, this.size.y);
			this.divB.position.set(this.divA.size.x + this.tabSize, 0);
			this.divB.updateInterface();

			this.resizeTab.style.cursor = "e-resize";
			this.resizeTab.style.top = "0px";
			this.resizeTab.style.left = this.divA.size.x + "px";
			this.resizeTab.style.width = this.tabSize + "px";
			this.resizeTab.style.height = this.size.y + "px";
		}
		else if(this.orientation === DualDivision.VERTICAL)
		{
			var tabPositionAbs = this.tabPosition * this.size.y;

			this.divA.position.set(0, 0);
			this.divA.size.set(this.size.x, tabPositionAbs);
			this.divA.updateInterface();

			this.divB.size.set(this.size.x, this.size.y - tabPositionAbs - this.tabSize);
			this.divB.position.set(0, this.divA.size.y + this.tabSize);
			this.divB.updateInterface();

			this.resizeTab.style.cursor = "n-resize";
			this.resizeTab.style.top = this.divA.size.y + "px";
			this.resizeTab.style.left = "0px";
			this.resizeTab.style.width = this.size.x + "px";
			this.resizeTab.style.height = this.tabSize + "px";
		}
	};

	function MaterialEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.material, Global.FILE_PATH + "icons/misc/material.png");

		var self = this;

		// Canvas
		this.canvas = new RendererCanvas();
		this.canvas.setOnResize(function(x, y)
		{
			self.camera.aspect = x / y;
			self.camera.updateProjectionMatrix();
		});

		// Mouse
		this.mouse = new Mouse(window, true);
		this.mouse.setCanvas(this.canvas.element);

		// Material and corresponding asset
		this.material = null;
		this.asset = null;

		// Preview scene
		this.scene = new three.Scene();

		// Camera
		this.camera = new three.PerspectiveCamera(80, this.canvas.size.x / this.canvas.size.y);
		this.camera.position.set(0, 0, 2.5);

		// Interactive object
		this.interactive = new three.Object3D();
		this.scene.add(this.interactive);

		// Preview configuration
		this.previewForm = new TableForm();
		this.previewForm.setAutoSize(false);

		// Configuration text
		this.previewForm.addText(Locale.configuration);
		this.previewForm.nextRow();

		// Form
		this.form = new TableForm();
		this.form.setAutoSize(false);

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(200, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "name", self.name.getText()));
		});
		this.form.add(this.name);
		this.form.nextRow();

		// Side
		this.form.addText(Locale.side);
		this.side = new DropdownList(this.form);
		this.side.size.set(100, 18);
		this.side.addValue(Locale.front, three.FrontSide);
		this.side.addValue(Locale.back, three.BackSide);
		this.side.addValue(Locale.double, three.DoubleSide);
		this.side.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "side", self.side.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.side);
		this.form.nextRow();

		// Tone mapping
		this.form.addText(Locale.toneMapped);
		this.toneMapped = new CheckBox(this.form);
		this.toneMapped.size.set(18, 18);
		this.toneMapped.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "toneMapped", self.toneMapped.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.toneMapped);
		this.form.nextRow();

		// Test depth
		this.form.addText(Locale.depthTest);
		this.depthTest = new CheckBox(this.form);
		this.depthTest.size.set(18, 18);
		this.depthTest.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "depthTest", self.depthTest.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.depthTest);
		this.form.nextRow();
		
		// Write depth
		this.form.addText(Locale.depthWrite);
		this.depthWrite = new CheckBox(this.form);
		this.depthWrite.size.set(18, 18);
		this.depthWrite.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "depthWrite", self.depthWrite.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.depthWrite);
		this.form.nextRow();

		// Depth func
		this.form.addText(Locale.depthMode);
		this.depthFunc = new DropdownList(this.form);
		this.depthFunc.size.set(100, 18);
		this.depthFunc.addValue(Locale.never, three.NeverDepth);
		this.depthFunc.addValue(Locale.always, three.AlwaysDepth);
		this.depthFunc.addValue(Locale.less, three.LessDepth);
		this.depthFunc.addValue(Locale.lessOrEqual, three.LessEqualDepth);
		this.depthFunc.addValue(Locale.greaterOrEqual, three.GreaterEqualDepth);
		this.depthFunc.addValue(Locale.greater, three.GreaterDepth);
		this.depthFunc.addValue(Locale.notEqual, three.NotEqualDepth);
		this.depthFunc.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "depthFunc", self.depthFunc.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.depthFunc);
		this.form.nextRow();

		// Transparent
		this.form.addText(Locale.transparent);
		this.transparent = new CheckBox(this.form);
		this.transparent.size.set(18, 18);
		this.transparent.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "transparent", self.transparent.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.transparent);
		this.form.nextRow();

		// Dithering
		this.form.addText(Locale.dithering);
		this.dithering = new CheckBox(this.form);
		this.dithering.size.set(18, 18);
		this.dithering.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "dithering", self.dithering.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.dithering);
		this.form.nextRow();

		// Premultiplied Alpha
		this.form.addText(Locale.premultipliedAlpha);
		this.premultipliedAlpha = new CheckBox(this.form);
		this.premultipliedAlpha.size.set(18, 18);
		this.premultipliedAlpha.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "premultipliedAlpha", self.premultipliedAlpha.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.premultipliedAlpha);
		this.form.nextRow();

		// Opacity level
		this.form.addText(Locale.opacity);
		this.opacity = new Slider(this.form);
		this.opacity.size.set(160, 18);
		this.opacity.setRange(0, 1);
		this.opacity.setStep(0.01);
		this.opacity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "opacity", self.opacity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.opacity);
		this.form.nextRow();
		
		// Alpha test
		this.form.addText(Locale.alphaTest);
		this.alphaTest = new Slider(this.form);
		this.alphaTest.size.set(160, 18);
		this.alphaTest.setRange(0, 1);
		this.alphaTest.setStep(0.01);
		this.alphaTest.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaTest", self.alphaTest.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaTest);
		this.form.nextRow();
		
		// Blending mode
		this.form.addText(Locale.blendingMode);
		this.blending = new DropdownList(this.form);
		this.blending.size.set(100, 18);
		this.blending.addValue(Locale.none, three.NoBlending);
		this.blending.addValue(Locale.normal, three.NormalBlending);
		this.blending.addValue(Locale.additive, three.AdditiveBlending);
		this.blending.addValue(Locale.subtractive, three.SubtractiveBlending);
		this.blending.addValue(Locale.multiply, three.MultiplyBlending);
		this.blending.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "blending", self.blending.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.blending);
		this.form.nextRow();

		// Premultiplied Alpha
		this.form.addText(Locale.premultipliedAlpha);
		this.premultipliedAlpha = new CheckBox(this.form);
		this.premultipliedAlpha.size.set(18, 18);
		this.premultipliedAlpha.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "premultipliedAlpha", self.premultipliedAlpha.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.premultipliedAlpha);
		this.form.nextRow();

		// Vertex Colors
		this.form.addText(Locale.vertexColors);
		this.vertexColors = new CheckBox(this.form);
		this.vertexColors.size.set(18, 18);
		this.vertexColors.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "vertexColors", self.vertexColors.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.vertexColors);
		this.form.nextRow();

		// Polygon Offset
		this.form.addText(Locale.polygonOffset);
		this.polygonOffset = new CheckBox(this.form);
		this.polygonOffset.size.set(18, 18);
		this.polygonOffset.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "polygonOffset", self.polygonOffset.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.polygonOffset);
		this.form.nextRow();

		// Polygon Offset Factor
		this.form.addText(Locale.polygonOffsetFactor);
		this.polygonOffsetFactor = new NumberBox(this.form);
		this.polygonOffsetFactor.size.set(60, 18);
		this.polygonOffsetFactor.setStep(0.001);
		this.polygonOffsetFactor.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "polygonOffsetFactor", self.polygonOffsetFactor.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.polygonOffsetFactor);
		this.form.nextRow();

		// Polygon Offset Units
		this.form.addText(Locale.polygonOffsetUnits);
		this.polygonOffsetUnits = new NumberBox(this.form);
		this.polygonOffsetUnits.size.set(60, 18);
		this.polygonOffsetUnits.setStep(0.001);
		this.polygonOffsetUnits.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "polygonOffsetUnits", self.polygonOffsetUnits.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.polygonOffsetUnits);
		this.form.nextRow();

		// Preview
		this.preview = new DualContainer();
		this.preview.orientation = DualDivision.VERTICAL;
		this.preview.tabPosition = 0.8;
		this.preview.tabPositionMin = 0.3;
		this.preview.tabPositionMax = 0.8;
		this.preview.attachA(this.canvas);
		this.preview.attachB(this.previewForm);

		// Main
		this.main = new DualContainer(this);
		this.main.tabPosition = 0.5;
		this.main.tabPositionMin = 0.05;
		this.main.tabPositionMax = 0.95;
		this.main.attachA(this.preview);
		this.main.attachB(this.form);
	}

	MaterialEditor.geometries = [
		[Locale.sphere, new three.SphereBufferGeometry(1, 40, 40)],
		[Locale.torus, new three.TorusBufferGeometry(0.8, 0.4, 32, 64)],
		[Locale.cube, new three.BoxBufferGeometry(1, 1, 1, 1, 1, 1)],
		[Locale.torusKnot, new three.TorusKnotBufferGeometry(0.7, 0.3, 128, 64)],
		[Locale.cone, new three.ConeBufferGeometry(1, 2, 32)]
	];

	MaterialEditor.prototype = Object.create(TabComponent.prototype);

	// Attach material to material editor
	MaterialEditor.prototype.attach = function(material, asset)
	{
		// Material asset
		if(asset !== undefined)
		{
			this.asset = asset;
		}
		
		// Store material
		this.material = material;
		this.material.needsUpdate = true;

		this.updateMetadata();

		// Generic material elements
		this.name.setText(material.name);
		this.side.setValue(material.side);
		this.depthTest.setValue(material.depthTest);
		this.depthWrite.setValue(material.depthWrite);
		this.depthFunc.setValue(material.depthFunc);
		this.transparent.setValue(material.transparent);
		this.opacity.setValue(material.opacity);
		this.alphaTest.setValue(material.alphaTest);
		this.blending.setValue(material.blending);
		this.premultipliedAlpha.setValue(material.premultipliedAlpha);
		this.dithering.setValue(material.dithering);
		this.toneMapped.setValue(material.toneMapped);
		this.vertexColors.setValue(material.vertexColors);
		this.polygonOffset.setValue(material.polygonOffset);
		this.polygonOffsetFactor.setValue(material.polygonOffsetFactor);
		this.polygonOffsetUnits.setValue(material.polygonOffsetUnits);
	};

	MaterialEditor.prototype.isAttached = function(material)
	{
		return this.material === material;
	};

	MaterialEditor.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);
		
		this.mouse.create();
	};

	MaterialEditor.prototype.deactivate = function()
	{
		TabComponent.prototype.deactivate.call(this);
		
		this.mouse.dispose();
	};

	MaterialEditor.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);

		this.mouse.dispose();
		this.canvas.destroy();
	};

	// Update object data
	MaterialEditor.prototype.updateMetadata = function()
	{
		if(this.material !== null)
		{
			// Set name
			if(this.material.name !== undefined)
			{
				this.setName(this.material.name);
				this.name.setText(this.material.name);
			}

			this.scene.background = this.material.envMap !== null ? this.material.envMap : null;

			// If not found close tab
			if(Editor$1.program.materials[this.material.uuid] === undefined)
			{
				this.close();
			}
		}
	};

	// Update material editor
	MaterialEditor.prototype.update = function()
	{
		this.mouse.update();

		// Render Material
		if(this.material !== null)
		{
			// If needs update file metadata
			if(this.material.needsUpdate)
			{
				Editor$1.updateObjectsViewsGUI();
				
				this.scene.background = this.material.envMap !== null ? this.material.envMap : null;

				this.material.needsUpdate = true;
			}

			// Render scene
			this.canvas.renderer.render(this.scene, this.camera);
		}

		// Move material view
		if(this.mouse.insideCanvas())
		{
			// Zoom
			this.camera.position.z += this.camera.position.z * this.mouse.wheel * 0.001;

			// Rotate object
			if(this.mouse.buttonPressed(Mouse.LEFT))
			{
				var delta = new three.Quaternion();
				delta.setFromEuler(new three.Euler(this.mouse.delta.y * 0.005, this.mouse.delta.x * 0.005, 0, 'XYZ'));
				
				this.interactive.quaternion.multiplyQuaternions(delta, this.interactive.quaternion);
			}
		}
	};

	// Update elements
	MaterialEditor.prototype.updateSize = function()
	{	
		TabComponent.prototype.updateSize.call(this);

		this.main.size.copy(this.size);
		this.main.updateInterface();

		this.previewForm.updateInterface();
		this.form.updateInterface();
	};

	function TextureForm(parent)
	{
		TextureChooser.call(this, parent);

		this.element.style.overflow = "visible";
		
		this.form = new TableForm(this);
		this.form.defaultTextWidth = 60;

		// Use texture
		this.form.addText(Locale.useTexture);
		this.useTexture = new CheckBox(this.form);
		this.useTexture.size.set(18, 18);
		this.form.add(this.useTexture);
		this.form.nextRow();

		// WrapS
		this.form.addText("Wrap Hor");
		this.wrapS = new DropdownList(this);
		this.wrapS.size.set(120, 18);
		this.wrapS.addValue(Locale.clampEdge, three.ClampToEdgeWrapping);
		this.wrapS.addValue(Locale.repeat, three.RepeatWrapping);
		this.wrapS.addValue(Locale.repeatMirror, three.MirroredRepeatWrapping);
		this.form.add(this.wrapS);
		this.form.nextRow();

		// WrapT
		this.form.addText("Wrap Vert");
		this.wrapT = new DropdownList(this);
		this.wrapT.size.set(120, 18);
		this.wrapT.addValue(Locale.clampEdge, three.ClampToEdgeWrapping);
		this.wrapT.addValue(Locale.repeat, three.RepeatWrapping);
		this.wrapT.addValue(Locale.repeatMirror, three.MirroredRepeatWrapping);
		this.form.add(this.wrapT);
		this.form.nextRow();

		// Repeat
		this.form.addText(Locale.repeat);
		this.repeat = new VectorBox(this);
		this.repeat.setType(VectorBox.VECTOR2);
		this.repeat.size.set(120, 18);
		this.repeat.setValue(1, 1, 0);
		this.form.add(this.repeat);
	}

	TextureForm.prototype = Object.create(TextureChooser.prototype);

	/**
	 * Set onchange callback, called after changes.
	 *
	 * @method setOnChange
	 * @param {Function} onChange
	 */
	TextureForm.prototype.setOnChange = function(onChange)
	{
		TextureChooser.prototype.setOnChange.call(this, onChange);

		this.useTexture.setOnChange(onChange);
		this.wrapT.setOnChange(onChange);
		this.wrapS.setOnChange(onChange);
		this.repeat.setOnChange(onChange);
	};

	/**
	 * Set value stored in the input element.
	 *
	 * @method setValue
	 * @param {Object} texture
	 */
	TextureForm.prototype.setValue = function(texture)
	{
		if(texture instanceof three.Texture && !texture.isCubeTexture)
		{
			this.texture = texture;

			this.useTexture.setValue(true);
			this.wrapS.setValue(texture.wrapS);
			this.wrapT.setValue(texture.wrapT);
			this.repeat.setValue(texture.repeat.x, texture.repeat.y);

			this.updatePreview();
		}
		else
		{
			this.texture = null;
		}
	};

	/**
	 * Get value stored in the input element.
	 *
	 * @method getValue
	 * @return {Object} Value stored in the input element.
	 */
	TextureForm.prototype.getValue = function()
	{
		if(this.useTexture.getValue())
		{
			if(this.texture !== null)
			{
				this.texture.wrapS = this.wrapS.getValue();
				this.texture.wrapT = this.wrapT.getValue();
				this.texture.repeat.copy(this.repeat.getValue());
				this.texture.needsUpdate = true;

				return this.texture;
			}
		}

		return null;
	};

	// Load texture from file
	TextureForm.prototype.loadTexture = function(file)
	{
		var self = this;
		var onLoad = function(texture)
		{
			self.texture = texture;
			self.useTexture.setValue(true);
			self.updatePreview();

			if(self.onChange !== null)
			{
				self.onChange();
			}
		};

		if(Image.fileIsImage(file))
		{
			Loaders.loadTexture(file, onLoad);
		}
		else if(Video.fileIsVideo(file))
		{
			Loaders.loadVideoTexture(file, onLoad);
		}
	};

	TextureForm.prototype.updateSize = function()
	{
		TextureChooser.prototype.updateSize.call(this);

		this.form.position.set(this.size.y + 5, 0);
		this.form.size.set(this.size.x - this.form.position.x, this.size.y);
		this.form.updateInterface();
	};

	function SpriteMaterialEditor(parent, closeable, container, index)
	{
		MaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Preview scene
		this.sky = new Sky();
		this.sky.visible = false;
		this.scene.add(this.sky);

		this.camera.position.set(0, 0, 1.5);
		
		this.sprite = new three.Sprite(null);
		this.interactive.add(this.sprite);

		// Sky
		this.previewForm.addText(Locale.sky);
		this.skyEnabled = new CheckBox(this.previewForm);
		this.skyEnabled.size.set(18, 18);
		this.skyEnabled.setValue(this.sky.visible);
		this.skyEnabled.setOnChange(function()
		{
			self.sky.visible = self.skyEnabled.getValue();
		});
		this.previewForm.add(this.skyEnabled);
		this.previewForm.nextRow();
		
		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(100, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "color", new three.Color(self.color.getValueHex())));
			self.material.needsUpdate = true;
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Rotation
		this.form.addText(Locale.rotation);
		this.rotation = new NumberBox(this.form);
		this.rotation.size.set(60, 18);
		this.rotation.setStep(0.01);
		this.rotation.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "rotation", self.rotation.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.rotation);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(100, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();
	}

	SpriteMaterialEditor.prototype = Object.create(MaterialEditor.prototype);

	SpriteMaterialEditor.prototype.attach = function(material, asset)
	{
		MaterialEditor.prototype.attach.call(this, material, asset);

		this.sprite.material = material;

		this.color.setValue(material.color.r, material.color.g, material.color.b);
		this.rotation.setValue(material.rotation);
		this.map.setValue(material.map);
	};

	function ShaderMaterialEditor(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.material, Global.FILE_PATH + "icons/misc/material.png");

		var self = this;

		// Preview configuration
		this.previewForm = new TableForm();
		this.previewForm.setAutoSize(false);
		this.previewForm.addText(Locale.configuration);
		this.previewForm.nextRow();
		
		// Canvas
		this.canvas = new RendererCanvas();
		this.canvas.setOnResize(function(x, y)
		{
			self.camera.aspect = x / y;
			self.camera.updateProjectionMatrix();
		});

		// Mouse
		this.mouse = new Mouse(window, true);
		this.mouse.setCanvas(this.canvas.element);

		// Preview division
		this.preview = new DualContainer();
		this.preview.orientation = DualDivision.VERTICAL;
		this.preview.tabPosition = 0.8;
		this.preview.tabPositionMin = 0.05;
		this.preview.tabPositionMax = 0.95;
		this.preview.attachA(this.canvas);
		this.preview.attachB(this.previewForm);

		// Tab container
		this.tab = new TabGroup();
		this.tab.element.style.backgroundColor = "var(--bar-color)";
		this.tab.buttonSize.set(150, 25);

		// Main container
		this.main = new DualContainer(this);
		this.main.tabPosition = 0.5;
		this.main.tabPositionMin = 0.05;
		this.main.tabPositionMax = 0.95;
		this.main.attachA(this.preview);
		this.main.attachB(this.tab);

		// Material UI File element
		this.asset = null;

		// Attached material
		this.material = null;

		// Material camera
		this.camera = new three.PerspectiveCamera(80, this.canvas.size.x/this.canvas.size.y);
		this.camera.position.set(0, 0, 2.5);
		
		// Scene
		this.scene = new three.Scene();
		
		// Interactive object
		this.interactive = new three.Object3D();
		this.scene.add(this.interactive);
		
		// Scene
		this.sky = new Sky();
		this.sky.visible = false;
		this.scene.add(this.sky);

		this.pointLight = new three.PointLight(0x777777);
		this.pointLight.position.set(-3, 0, 3);
		this.pointLight.visible = false;
		this.scene.add(this.pointLight);
		
		this.ambientLight = new three.AmbientLight(0x555555);
		this.ambientLight.visible = false;
		this.scene.add(this.ambientLight);

		// Mesh
		this.mesh = new three.Mesh(MaterialEditor.geometries[0][1], null);
		this.interactive.add(this.mesh);
		
		// Test model
		this.previewForm.addText(Locale.geometry);
		this.testModel = new DropdownList(this.previewForm);
		this.testModel.size.set(100, 18);
		for(var i = 0; i < MaterialEditor.geometries.length; i++)
		{
			this.testModel.addValue(MaterialEditor.geometries[i][0], i);
		}
		this.testModel.setOnChange(function()
		{
			var value = self.testModel.getSelectedIndex();
			self.mesh.geometry = MaterialEditor.geometries[value][1];
		});
		this.previewForm.add(this.testModel);
		this.previewForm.nextRow();

		// Sky
		this.previewForm.addText(Locale.sky);
		this.skyEnabled = new CheckBox(this.previewForm);
		this.skyEnabled.size.set(18, 18);
		this.skyEnabled.setValue(this.sky.visible);
		this.skyEnabled.setOnChange(function()
		{
			self.sky.visible = self.skyEnabled.getValue();
		});
		this.previewForm.add(this.skyEnabled);
		this.previewForm.nextRow();

		// Point Light
		this.previewForm.addText(Locale.pointLight);
		this.lightEnabled = new CheckBox(this.previewForm);
		this.lightEnabled.size.set(18, 18);
		this.lightEnabled.setValue(this.pointLight.visible);
		this.lightEnabled.setOnChange(function()
		{
			self.pointLight.visible = self.lightEnabled.getValue();
		});
		this.previewForm.add(this.lightEnabled);
		this.previewForm.nextRow();

		// Ambient Light
		this.previewForm.addText(Locale.ambientLight);
		this.ambientLightEnabled = new CheckBox(this.previewForm);
		this.ambientLightEnabled.size.set(18, 18);
		this.ambientLightEnabled.setValue(this.ambientLight.visible);
		this.ambientLightEnabled.setOnChange(function()
		{
			self.ambientLight.visible = self.ambientLightEnabled.getValue();
		});
		this.previewForm.add(this.ambientLightEnabled);
		this.previewForm.nextRow();

		// General
		this.general = this.tab.addTab(TabComponent, false);
		this.general.setIcon(Global.FILE_PATH + "icons/misc/material.png");
		this.general.setName(Locale.material);

		this.form = new TableForm(this.general);
		this.form.setAutoSize(false);

		// Name
		this.form.addText(Locale.name);
		this.name = new TextBox(this.form);
		this.name.size.set(200, 18);
		this.name.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "name", self.name.getText()));
			Editor$1.updateObjectsViewsGUI();
		});
		this.form.add(this.name);
		this.form.nextRow();

		// Side
		this.form.addText(Locale.side);
		this.side = new DropdownList(this.form);
		this.side.position.set(100, 85);
		this.side.size.set(150, 18);
		this.side.addValue(Locale.front, three.FrontSide);
		this.side.addValue(Locale.back, three.BackSide);
		this.side.addValue(Locale.double, three.DoubleSide);
		this.side.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "side", self.side.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.side);
		this.form.nextRow();

		// Test depth
		this.form.addText(Locale.depthTest);
		this.depthTest = new CheckBox(this.form);
		this.depthTest.size.set(18, 18);
		this.depthTest.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "depthTest", self.depthTest.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.depthTest);
		this.form.nextRow();
		
		// Write depth
		this.form.addText(Locale.depthWrite);
		this.depthWrite = new CheckBox(this.form);
		this.depthWrite.size.set(18, 18);
		this.depthWrite.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "depthWrite", self.depthWrite.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.depthWrite);
		this.form.nextRow();

		// Transparent
		this.form.addText(Locale.transparent);
		this.transparent = new CheckBox(this.form);
		this.transparent.size.set(18, 18);
		this.transparent.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "transparent", self.transparent.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.transparent);
		this.form.nextRow();
		
		// Blending mode
		this.form.addText(Locale.blendingMode);
		this.blending = new DropdownList(this.form);
		this.blending.position.set(100, 85);
		this.blending.size.set(100, 18);
		this.blending.addValue(Locale.none, three.NoBlending);
		this.blending.addValue(Locale.normal, three.NormalBlending);
		this.blending.addValue(Locale.additive, three.AdditiveBlending);
		this.blending.addValue(Locale.subtractive, three.SubtractiveBlending);
		this.blending.addValue(Locale.multiply, three.MultiplyBlending);
		this.blending.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "blending", self.blending.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.blending);
		this.form.nextRow();

		// Wireframe
		this.form.addText(Locale.wireframe);
		this.wireframe = new CheckBox(this.form);
		this.wireframe.size.set(18, 18);
		this.wireframe.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "wireframe", self.wireframe.getValue()));
		});
		this.form.add(this.wireframe);
		this.form.nextRow();

		// Fragment tab
		this.fragmentShader = this.tab.addTab(CodeEditor, false);
		this.fragmentShader.setName(Locale.fragment);
		this.fragmentShader.setLanguage("glsl");
		this.fragmentShader.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "fragmentShader", self.fragmentShader.getText()));
			self.material.needsUpdate = true;
		});

		// Vertex tab
		this.vertexShader = this.tab.addTab(CodeEditor, false);
		this.vertexShader.setName(Locale.vertex);
		this.vertexShader.setLanguage("glsl");
		this.vertexShader.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "vertexShader", self.vertexShader.getText()));
			self.material.needsUpdate = true;
		});
	}

	ShaderMaterialEditor.prototype = Object.create(MaterialEditor.prototype);

	ShaderMaterialEditor.prototype.attach = function(material, asset)
	{
		this.mesh.material = material;

		if(asset !== undefined)
		{
			this.asset = asset;
		}

		this.material = material;
		this.updateMetadata();

		// Base
		this.name.setText(material.name);
		this.side.setValue(material.side);
		this.depthTest.setValue(material.depthTest);
		this.depthWrite.setValue(material.depthWrite);
		this.transparent.setValue(material.transparent);
		this.blending.setValue(material.blending);	
		this.wireframe.setValue(material.wireframe);

		// Shader
		this.fragmentShader.setText(material.fragmentShader);
		this.vertexShader.setText(material.vertexShader);
	};

	ShaderMaterialEditor.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.main.size.copy(this.size);
		this.main.updateInterface();

		this.form.size.copy(this.general.size);
		this.form.updateInterface();
	};

	function PointsMaterialEditor(parent, closeable, container, index)
	{
		MaterialEditor.call(this, parent, closeable, container, index);

		// Points
		this.points = new three.Points(MaterialEditor.geometries[0][1], null);
		this.interactive.add(this.points);
		
		// Test model
		this.previewForm.addText(Locale.geometry);
		this.testModel = new DropdownList(this.previewForm);
		this.testModel.size.set(100, 18);
		for(var i = 0; i < MaterialEditor.geometries.length; i++)
		{
			this.testModel.addValue(MaterialEditor.geometries[i][0], i);
		}
		this.testModel.setOnChange(function()
		{
			var value = self.testModel.getSelectedIndex();
			self.points.geometry = MaterialEditor.geometries[value][1];
		});
		this.previewForm.add(this.testModel);
		this.previewForm.nextRow();

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(100, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "color", new three.Color(self.color.getValueHex())));
			self.material.needsUpdate = true;
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Size
		this.form.addText(Locale.size);
		this.pointSize = new NumberBox(this.form);
		this.pointSize.size.set(60, 18);
		this.pointSize.setStep(0.05);
		this.pointSize.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "size", self.pointSize.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.pointSize);
		this.form.nextRow();

		// Size atenuation
		this.form.addText("Size atenuation");
		this.sizeAttenuation = new CheckBox(this.form);
		this.sizeAttenuation.size.set(18, 18);
		this.sizeAttenuation.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "sizeAttenuation", self.sizeAttenuation.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.sizeAttenuation);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();
	}

	PointsMaterialEditor.prototype = Object.create(MaterialEditor.prototype);

	PointsMaterialEditor.prototype.attach = function(material, asset)
	{
		MaterialEditor.prototype.attach.call(this, material, asset);

		this.points.material = material;

		this.pointSize.setValue(material.size);
		this.sizeAttenuation.setValue(material.sizeAttenuation);
		this.color.setValue(material.color.r, material.color.g, material.color.b);
		this.map.setValue(material.map);
	};

	function MeshMaterialEditor(parent, closeable, container, index)
	{
		MaterialEditor.call(this, parent, closeable, container, index);
		
		var self = this;


		// Skinning
		this.form.addText(Locale.skinning);
		this.skinning = new CheckBox(this.form);
		this.skinning.size.set(18, 18);
		this.skinning.updateInterface();
		this.skinning.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "skinning", self.skinning.getValue()));
		});
		this.form.add(this.skinning);
		this.form.nextRow();

		// Morph targets
		this.form.addText(Locale.morphTargets);
		this.morphTargets = new CheckBox(this.form);
		this.morphTargets.size.set(18, 18);
		this.morphTargets.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "morphTargets", self.morphTargets.getValue()));
		});
		this.form.add(this.morphTargets);
		this.form.nextRow();

		// Wireframe
		this.form.addText(Locale.wireframe);
		this.wireframe = new CheckBox(this.form);
		this.wireframe.size.set(18, 18);
		this.wireframe.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "wireframe", self.wireframe.getValue()));
		});
		this.form.add(this.wireframe);
		this.form.nextRow();

		// Wireframe line cap
		this.form.addText(Locale.wireframeLinecap);
		this.wireframeLinecap = new DropdownList(this.form);
		this.wireframeLinecap.size.set(100, 18);
		this.wireframeLinecap.addValue("Butt", "butt");
		this.wireframeLinecap.addValue("Round", "round");
		this.wireframeLinecap.addValue("Square", "square");
		this.wireframeLinecap.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "wireframeLinecap", self.wireframeLinecap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.wireframeLinecap);
		this.form.nextRow();

		// Wireframe line cap
		this.form.addText(Locale.wireframeLinejoin);
		this.wireframeLinejoin = new DropdownList(this.form);
		this.wireframeLinejoin.size.set(100, 18);
		this.wireframeLinejoin.addValue("Bevel", "bevel");
		this.wireframeLinejoin.addValue("Round", "round");
		this.wireframeLinejoin.addValue("Miter", "miter");
		this.wireframeLinejoin.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "wireframeLinejoin", self.wireframeLinejoin.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.wireframeLinejoin);
		this.form.nextRow();

		// Wireframe line width
		this.form.addText(Locale.scale);
		this.wireframeLinewidth = new NumberBox(this.form);
		this.wireframeLinewidth.size.set(60, 18);
		this.wireframeLinewidth.setStep(0.1);
		this.wireframeLinewidth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "wireframeLinewidth", self.wireframeLinewidth.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.wireframeLinewidth);
		this.form.nextRow();

		// Shading mode
		this.form.addText(Locale.shading);
		this.flatShading = new DropdownList(this.form);
		this.flatShading.position.set(100, 85);
		this.flatShading.size.set(100, 18);
		this.flatShading.addValue(Locale.smooth, false);
		this.flatShading.addValue(Locale.flat, true);
		this.flatShading.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "flatShading", self.flatShading.getValue()));
				self.material.needsUpdate = true;
		});
		this.form.add(this.flatShading);
		this.form.nextRow();

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(100, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "color", new three.Color(self.color.getValueHex())));
				self.material.needsUpdate = true;
		});
		this.form.add(this.color);
		this.form.nextRow();


		// Preview scene
		this.sky = new Sky();
		this.scene.add(this.sky);

		this.pointLight = new three.PointLight(0x666666);
		this.pointLight.position.set(-1, 0, 3);
		this.scene.add(this.pointLight);
		
		this.ambientLight = new three.AmbientLight(0x555555);
		this.ambientLight.visible = false;
		this.scene.add(this.ambientLight);

		// Mesh
		this.mesh = new three.Mesh(MaterialEditor.geometries[0][1], null);
		this.interactive.add(this.mesh);
		
		// Test model
		this.previewForm.addText(Locale.geometry);
		this.testModel = new DropdownList(this.previewForm);
		this.testModel.size.set(100, 18);
		for(var i = 0; i < MaterialEditor.geometries.length; i++)
		{
			this.testModel.addValue(MaterialEditor.geometries[i][0], i);
		}
		this.testModel.setOnChange(function()
		{
			var value = self.testModel.getSelectedIndex();
			self.mesh.geometry = MaterialEditor.geometries[value][1];
		});
		this.previewForm.add(this.testModel);
		this.previewForm.nextRow();

		// Sky
		this.previewForm.addText(Locale.sky);
		this.skyEnabled = new CheckBox(this.previewForm);
		this.skyEnabled.size.set(18, 18);
		this.skyEnabled.setValue(this.sky.visible);
		this.skyEnabled.setOnChange(function()
		{
			self.sky.visible = self.skyEnabled.getValue();
		});
		this.previewForm.add(this.skyEnabled);
		this.previewForm.nextRow();

		// Point Light
		this.previewForm.addText(Locale.pointLight);
		this.previewForm.nextRow();

		this.previewForm.addText(Locale.enabled);
		this.lightEnabled = new CheckBox(this.previewForm);
		this.lightEnabled.size.set(18, 18);
		this.lightEnabled.setValue(this.pointLight.visible);
		this.lightEnabled.setOnChange(function()
		{
			self.pointLight.visible = self.lightEnabled.getValue();
		});
		this.previewForm.add(this.lightEnabled);
		this.previewForm.nextRow();

		this.previewForm.addText(Locale.color);
		this.pointLightColor = new ColorChooser(this.previewForm);
		this.pointLightColor.size.set(80, 18);
		this.pointLightColor.setOnChange(function()
		{
			self.pointLight.color.setHex(self.pointLightColor.getValueHex());
		});
		this.previewForm.add(this.pointLightColor);
		this.previewForm.nextRow();

		// Ambient Light
		this.previewForm.addText(Locale.ambientLight);
		this.previewForm.nextRow();

		this.previewForm.addText(Locale.enabled);
		this.ambientLightEnabled = new CheckBox(this.previewForm);
		this.ambientLightEnabled.size.set(18, 18);
		this.ambientLightEnabled.setValue(this.ambientLight.visible);
		this.ambientLightEnabled.setOnChange(function()
		{
			self.ambientLight.visible = self.ambientLightEnabled.getValue();
		});
		this.previewForm.add(this.ambientLightEnabled);
		this.previewForm.nextRow();

		this.previewForm.addText(Locale.color);
		this.ambientLightColor = new ColorChooser(this.previewForm);
		this.ambientLightColor.size.set(80, 18);
		this.ambientLightColor.setOnChange(function()
		{
			self.ambientLight.color.setHex(self.ambientLightColor.getValueHex());
		});
		this.previewForm.add(this.ambientLightColor);
		this.previewForm.nextRow();
	}

	MeshMaterialEditor.prototype = Object.create(MaterialEditor.prototype);

	MeshMaterialEditor.prototype.attach = function(material, asset)
	{
		MaterialEditor.prototype.attach.call(this, material, asset);

		this.sky.visible = material.envMap === null;
		this.mesh.material = material;
		
		this.color.setValue(material.color.r, material.color.g, material.color.b);
		this.skinning.setValue(material.skinning);
		this.morphTargets.setValue(material.morphTargets);
		this.wireframe.setValue(material.wireframe);
		this.wireframeLinecap.setValue(material.wireframeLinecap);
		this.wireframeLinejoin.setValue(material.wireframeLinejoin);
		this.wireframeLinewidth.setValue(material.wireframeLinewidth);
		this.flatShading.setValue(material.flatShading);
	};

	function MeshToonMaterialEditor(parent, closeable, container, index)
	{
		MeshMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Specular color
		this.form.addText(Locale.specular);
		this.specular = new ColorChooser(this.form);
		this.specular.size.set(100, 18);
		this.specular.setOnChange(function()
		{
			self.material.specular.setHex(self.specular.getValueHex());
			self.material.needsUpdate = true;
		});
		this.form.add(this.specular);
		this.form.nextRow();

		// Shininess
		this.form.addText(Locale.shininess);
		this.shininess = new Slider(this.form);
		this.shininess.size.set(160, 18);
		this.shininess.setRange(0, 250);
		this.shininess.setStep(0.1);
		this.shininess.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "shininess", self.shininess.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.shininess);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(0, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();

		// Gradient map
		this.form.addText(Locale.gradientMap);
		this.gradientMap = new TextureForm(this.form);
		this.gradientMap.size.set(0, 100);
		this.gradientMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "gradientMap", self.gradientMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.gradientMap);
		this.form.nextRow();

		// Bump map
		this.form.addText(Locale.bumpMap);
		this.bumpMap = new TextureForm(this.form);
		this.bumpMap.size.set(0, 100);
		this.bumpMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpMap", self.bumpMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpMap);
		this.form.nextRow();

		// Bump scale
		this.form.addText(Locale.scale);
		this.bumpScale = new Slider(this.form);
		this.bumpScale.size.set(160, 18);
		this.bumpScale.setRange(0, 1);
		this.bumpScale.setStep(0.01);
		this.bumpScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpScale", self.bumpScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpScale);
		this.form.nextRow();

		// Normal map
		this.form.addText(Locale.normalMap);
		this.normalMap = new TextureForm(this.form);
		this.normalMap.size.set(0, 100);
		this.normalMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMap", self.normalMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMap);
		this.form.nextRow();

		// Normal map scale
		this.form.addText(Locale.normalScale);
		this.normalScale = new VectorBox(this.form);
		this.normalScale.size.set(0, 18);
		this.normalScale.setType(VectorBox.VECTOR2);
		this.normalScale.setValue(1, 1, 0);
		this.normalScale.setOnChange(function()
		{
			self.material.normalScale.copy(self.normalScale.getValue());
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalScale);
		this.form.nextRow();

		// Normal type
		this.form.addText(Locale.normalType);
		this.normalMapType = new DropdownList(this.form);
		this.normalMapType.size.set(100, 18);
		this.normalMapType.addValue(Locale.tangentSpace, three.TangentSpaceNormalMap);
		this.normalMapType.addValue(Locale.objectSpace, three.ObjectSpaceNormalMap);
		this.normalMapType.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMapType", self.normalMapType.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMapType);
		this.form.nextRow();

		// Displacement map
		this.form.addText(Locale.displacementMap);
		this.displacementMap = new TextureForm(this.form);
		this.displacementMap.size.set(0, 100);
		this.displacementMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementMap", self.displacementMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementMap);
		this.form.nextRow();

		// Displacement map scale
		this.form.addText(Locale.scale);
		this.displacementScale = new NumberBox(this.form);
		this.displacementScale.size.set(60, 18);
		this.displacementScale.setStep(0.05);
		this.displacementScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementScale", self.displacementScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementScale);
		this.form.nextRow();

		// Displacement map bias
		this.form.addText(Locale.bias);
		this.displacementBias = new NumberBox(this.form);
		this.displacementBias.size.set(60, 18);
		this.displacementBias.setStep(0.1);
		this.displacementBias.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementBias", self.displacementBias.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementBias);
		this.form.nextRow();

		// Specular map
		this.form.addText(Locale.specularMap);
		this.specularMap = new TextureForm(this.form);
		this.specularMap.size.set(0, 100);
		this.specularMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "specularMap", self.specularMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.specularMap);
		this.form.nextRow();

		// Emissive map
		this.form.addText(Locale.emissiveMap);
		this.emissiveMap = new TextureForm(this.form);
		this.emissiveMap.size.set(0, 100);
		this.emissiveMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveMap", self.emissiveMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveMap);
		this.form.nextRow();

		// Emissive color
		this.form.addText(Locale.color);
		this.emissive = new ColorChooser(this.form);
		this.emissive.size.set(100, 18);
		this.emissive.setOnChange(function()
		{
			self.material.emissive.setHex(self.emissive.getValueHex());
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissive);
		this.form.nextRow();

		// Emissive intensity
		this.form.addText(Locale.intensity);
		this.emissiveIntensity = new NumberBox(this.form);
		this.emissiveIntensity.size.set(60, 18);
		this.emissiveIntensity.setStep(0.1);
		this.emissiveIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveIntensity", self.emissiveIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveIntensity);
		this.form.nextRow();

		// Ligh map
		this.form.addText(Locale.lightMap);
		this.lightMap = new TextureForm(this.form);
		this.lightMap.size.set(0, 100);
		this.lightMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMap", self.lightMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMap);
		this.form.nextRow();

		// Ligh map intensity
		this.form.addText(Locale.intensity);
		this.lightMapIntensity = new NumberBox(this.form);
		this.lightMapIntensity.size.set(60, 18);
		this.lightMapIntensity.setStep(0.1);
		this.lightMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMapIntensity", self.lightMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMapIntensity);
		this.form.nextRow();

		// Alpha map
		this.form.addText(Locale.alphaMap);
		this.alphaMap = new TextureForm(this.form);
		this.alphaMap.size.set(0, 100);
		this.alphaMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaMap", self.alphaMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaMap);
		this.form.nextRow();

		// Ambient Occlusion map
		this.form.addText(Locale.ambientOcclusion);
		this.aoMap = new TextureForm(this.form);
		this.aoMap.size.set(0, 100);
		this.aoMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMap", self.aoMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMap);
		this.form.nextRow();

		// Ambient Occlusion
		this.form.addText(Locale.intensity);
		this.aoMapIntensity = new NumberBox(this.form);
		this.aoMapIntensity.size.set(60, 18);
		this.aoMapIntensity.setStep(0.05);
		this.aoMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMapIntensity", self.aoMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMapIntensity);
		this.form.nextRow();
	}

	MeshToonMaterialEditor.prototype = Object.create(MeshMaterialEditor.prototype);

	MeshToonMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshMaterialEditor.prototype.attach.call(this, material, asset);

		this.specular.setValue(material.specular.r, material.specular.g, material.specular.b);
		this.shininess.setValue(material.shininess);
		this.map.setValue(material.map);
		this.gradientMap.setValue(material.gradientMap);
		this.bumpMap.setValue(material.bumpMap);
		this.bumpScale.setValue(material.bumpScale);
		this.normalMap.setValue(material.normalMap);
		this.normalScale.setValue(material.normalScale.x, material.normalScale.y);
		this.normalMapType.setValue(material.normalMapType);
		this.displacementMap.setValue(material.displacementMap);
		this.displacementScale.setValue(material.displacementScale);
		this.displacementBias.setValue(material.displacementBias);
		this.specularMap.setValue(material.specularMap);
		this.emissive.setValue(material.emissive.r, material.emissive.g, material.emissive.b);
		this.emissiveIntensity.setValue(material.emissiveIntensity);
		this.emissiveMap.setValue(material.emissiveMap);
		this.lightMap.setValue(material.lightMap);
		this.lightMapIntensity.setValue(material.lightMapIntensity);
		this.alphaMap.setValue(material.alphaMap);
		this.aoMap.setValue(material.aoMap);
		this.aoMapIntensity.setValue(material.aoMapIntensity);
	};

	function MeshStandardMaterialEditor(parent, closeable, container, index)
	{
		MeshMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Roughness
		this.form.addText(Locale.roughness);
		this.roughness = new Slider(this.form);
		this.roughness.size.set(160, 18);
		this.roughness.setRange(0, 1);
		this.roughness.setStep(0.01);
		this.roughness.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "roughness", self.roughness.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.roughness);
		this.form.nextRow();

		// Shininess
		this.form.addText(Locale.metalness);
		this.metalness = new Slider(this.form);
		this.metalness.size.set(160, 18);
		this.metalness.setRange(0, 1);
		this.metalness.setStep(0.01);
		this.metalness.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "metalness", self.metalness.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.metalness);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(0, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();

		// Roughness map
		this.form.addText(Locale.roughnessMap);
		this.roughnessMap = new TextureForm(this.form);
		this.roughnessMap.size.set(0, 100);
		this.roughnessMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "roughnessMap", self.roughnessMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.roughnessMap);
		this.form.nextRow();

		// Metalness map
		this.form.addText(Locale.metalnessMap);
		this.metalnessMap = new TextureForm(this.form);
		this.metalnessMap.size.set(0, 100);
		this.metalnessMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "metalnessMap", self.metalnessMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.metalnessMap);
		this.form.nextRow();

		// Bump map
		this.form.addText(Locale.bumpMap);
		this.bumpMap = new TextureForm(this.form);
		this.bumpMap.size.set(0, 100);
		this.bumpMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpMap", self.bumpMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpMap);
		this.form.nextRow();

		// Bump map scale
		this.form.addText(Locale.bumpScale);
		this.bumpScale = new Slider(this.form);
		this.bumpScale.size.set(160, 18);
		this.bumpScale.setRange(0, 1);
		this.bumpScale.setStep(0.01);
		this.bumpScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpScale", self.bumpScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpScale);
		this.form.nextRow();

		// Normal map
		this.form.addText(Locale.normalMap);
		this.normalMap = new TextureForm(this.form);
		this.normalMap.size.set(0, 100);
		this.normalMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMap", self.normalMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMap);
		this.form.nextRow();

		// Normal map scale
		this.form.addText(Locale.normalScale);
		this.normalScale = new VectorBox(this.form);
		this.normalScale.size.set(0, 18);
		this.normalScale.setType(VectorBox.VECTOR2);
		this.normalScale.setValue(1, 1, 0);
		this.normalScale.setOnChange(function()
		{
			self.material.normalScale.copy(self.normalScale.getValue());
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalScale);
		this.form.nextRow();

		// Normal type
		this.form.addText(Locale.normalType);
		this.normalMapType = new DropdownList(this.form);
		this.normalMapType.size.set(100, 18);
		this.normalMapType.addValue(Locale.tangentSpace, three.TangentSpaceNormalMap);
		this.normalMapType.addValue(Locale.objectSpace, three.ObjectSpaceNormalMap);
		this.normalMapType.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMapType", self.normalMapType.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMapType);
		this.form.nextRow();

		// Displacement map
		this.form.addText(Locale.displacementMap);
		this.displacementMap = new TextureForm(this.form);
		this.displacementMap.size.set(0, 100);
		this.displacementMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementMap", self.displacementMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementMap);
		this.form.nextRow();

		// Displacement map scale
		this.form.addText(Locale.scale);
		this.displacementScale = new NumberBox(this.form);
		this.displacementScale.size.set(60, 18);
		this.displacementScale.setStep(0.05);
		this.displacementScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementScale", self.displacementScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementScale);
		this.form.nextRow();

		// Displacement map bias
		this.form.addText(Locale.bias);
		this.displacementBias = new NumberBox(this.form);
		this.displacementBias.size.set(60, 18);
		this.displacementBias.setStep(0.1);
		this.displacementBias.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementBias", self.displacementBias.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementBias);
		this.form.nextRow();

		// Emissive map
		this.form.addText(Locale.emissiveMap);
		this.emissiveMap = new TextureForm(this.form);
		this.emissiveMap.size.set(0, 100);
		this.emissiveMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveMap", self.emissiveMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveMap);
		this.form.nextRow();

		// Emissive color
		this.form.addText(Locale.color);
		this.emissive = new ColorChooser(this.form);
		this.emissive.size.set(100, 18);
		this.emissive.setOnChange(function()
		{
			self.material.emissive.setHex(self.emissive.getValueHex());
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissive);
		this.form.nextRow();

		// Emissive intensity
		this.form.addText(Locale.intensity);
		this.emissiveIntensity = new NumberBox(this.form);
		this.emissiveIntensity.size.set(60, 18);
		this.emissiveIntensity.setStep(0.1);
		this.emissiveIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveIntensity", self.emissiveIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveIntensity);
		this.form.nextRow();

		// Ligh map
		this.form.addText(Locale.lightMap);
		this.lightMap = new TextureForm(this.form);
		this.lightMap.size.set(0, 100);
		this.lightMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMap", self.lightMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMap);
		this.form.nextRow();

		// Ligh map intensity
		this.form.addText(Locale.intensity);
		this.lightMapIntensity = new NumberBox(this.form);
		this.lightMapIntensity.size.set(60, 18);
		this.lightMapIntensity.setStep(0.1);
		this.lightMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMapIntensity", self.lightMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMapIntensity);
		this.form.nextRow();

		// Alpha map
		this.form.addText(Locale.alphaMap);
		this.alphaMap = new TextureForm(this.form);
		this.alphaMap.size.set(0, 100);
		this.alphaMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaMap", self.alphaMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaMap);
		this.form.nextRow();
		
		// Environment map
		this.form.addText(Locale.environmentMap);
		this.envMap = new CubeTextureBox(this.form);
		this.envMap.size.set(0, 100);
		this.envMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "envMap", self.envMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.envMap);
		this.form.nextRow();

		// Reflectivity
		this.form.addText(Locale.intensity);
		this.envMapIntensity = new NumberBox(this.form);
		this.envMapIntensity.size.set(60, 18);
		this.envMapIntensity.setStep(0.05);
		this.envMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "envMapIntensity", self.envMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.envMapIntensity);
		this.form.nextRow();

		// Reflectivity
		this.form.addText(Locale.refraction);
		this.refractionRatio = new NumberBox(this.form);
		this.refractionRatio.size.set(60, 18);
		this.refractionRatio.setStep(0.05);
		this.refractionRatio.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "refractionRatio", self.refractionRatio.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.refractionRatio);
		this.form.nextRow();
		
		// Ambient Occlusion map
		this.form.addText(Locale.ambientOcclusion);
		this.aoMap = new TextureForm(this.form);
		this.aoMap.size.set(0, 100);
		this.aoMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMap", self.aoMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMap);
		this.form.nextRow();

		// Ambient Occlusion
		this.form.addText(Locale.intensity);
		this.aoMapIntensity = new NumberBox(this.form);
		this.aoMapIntensity.size.set(60, 18);
		this.aoMapIntensity.setStep(0.05);
		this.aoMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMapIntensity", self.aoMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMapIntensity);
		this.form.nextRow();
	}

	MeshStandardMaterialEditor.prototype = Object.create(MeshMaterialEditor.prototype);

	MeshStandardMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshMaterialEditor.prototype.attach.call(this, material, asset);

		this.roughness.setValue(material.roughness);
		this.metalness.setValue(material.metalness);
		this.map.setValue(material.map);
		this.roughnessMap.setValue(material.roughnessMap);
		this.metalnessMap.setValue(material.metalnessMap);
		this.bumpMap.setValue(material.bumpMap);
		this.bumpScale.setValue(material.bumpScale);
		this.normalMap.setValue(material.normalMap);
		this.normalScale.setValue(material.normalScale.x, material.normalScale.y);
		this.normalMapType.setValue(material.normalMapType);
		this.displacementMap.setValue(material.displacementMap);
		this.displacementScale.setValue(material.displacementScale);
		this.displacementBias.setValue(material.displacementBias);
		this.emissive.setValue(material.emissive.r, material.emissive.g, material.emissive.b);
		this.emissiveIntensity.setValue(material.emissiveIntensity);
		this.emissiveMap.setValue(material.emissiveMap);
		this.lightMap.setValue(material.lightMap);
		this.lightMapIntensity.setValue(material.lightMapIntensity);
		this.alphaMap.setValue(material.alphaMap);
		this.envMap.setValue(material.envMap);
		this.envMapIntensity.setValue(material.envMapIntensity);
		this.refractionRatio.setValue(material.refractionRatio);
		this.aoMap.setValue(material.aoMap);
		this.aoMapIntensity.setValue(material.aoMapIntensity);
	};

	function MeshPhysicalMaterialEditor(parent, closeable, container, index)
	{
		MeshStandardMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Clear coat
		this.form.addText(Locale.clearcoat);
		this.clearcoat = new Slider(this.form);
		this.clearcoat.size.set(160, 18);
		this.clearcoat.setRange(0, 1);
		this.clearcoat.setStep(0.01);
		this.clearcoat.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "clearcoat", self.clearcoat.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.clearcoat);
		this.form.nextRow();

		// Clear coat map
		this.form.addText(Locale.clearcoatMap);
		this.clearcoatMap = new TextureForm(this.form);
		this.clearcoatMap.size.set(0, 100);
		this.clearcoatMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "clearcoatMap", self.clearcoatMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.clearcoatMap);
		this.form.nextRow();

		// Clear coat roughness
		this.form.addText(Locale.clearcoatRoughness);
		this.clearcoatRoughness = new Slider(this.form);
		this.clearcoatRoughness.size.set(160, 18);
		this.clearcoatRoughness.setRange(0, 1);
		this.clearcoatRoughness.setStep(0.01);
		this.clearcoatRoughness.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "clearcoatRoughness", self.clearcoatRoughness.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.clearcoatRoughness);
		this.form.nextRow();

		// Clear coat roughness map
		this.form.addText(Locale.clearcoatRoughnessMap);
		this.clearcoatRoughnessMap = new TextureForm(this.form);
		this.clearcoatRoughnessMap.size.set(0, 100);
		this.clearcoatRoughnessMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "clearcoatRoughnessMap", self.clearcoatRoughnessMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.clearcoatRoughnessMap);
		this.form.nextRow();

		// Reflectivity
		this.form.addText(Locale.reflectivity);
		this.reflectivity = new Slider(this.form);
		this.reflectivity.size.set(160, 18);
		this.reflectivity.setRange(0, 1);
		this.reflectivity.setStep(0.01);
		this.reflectivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "reflectivity", self.reflectivity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.reflectivity);
		this.form.nextRow();

		// Transparency
		this.form.addText(Locale.transparency);
		this.transparency = new Slider(this.form);
		this.transparency.size.set(160, 18);
		this.transparency.setRange(0, 1);
		this.transparency.setStep(0.01);
		this.transparency.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "transparency", self.transparency.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.transparency);
		this.form.nextRow();

		// Clear coat normal map
		this.form.addText(Locale.clearcoatNormalMap);
		this.clearcoatNormalMap = new TextureForm(this.form);
		this.clearcoatNormalMap.size.set(0, 100);
		this.clearcoatNormalMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "clearcoatNormalMap", self.clearcoatNormalMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.clearcoatNormalMap);
		this.form.nextRow();

		// Clear coat normal map scale
		this.form.addText(Locale.clearcoatNormalScale);
		this.clearcoatNormalScale = new VectorBox(this.form);
		this.clearcoatNormalScale.size.set(0, 18);
		this.clearcoatNormalScale.setType(VectorBox.VECTOR2);
		this.clearcoatNormalScale.setValue(1, 1, 0);
		this.clearcoatNormalScale.setOnChange(function()
		{
			self.material.clearcoatNormalScale.copy(self.clearcoatNormalScale.getValue());
			self.material.needsUpdate = true;
		});
		this.form.add(this.clearcoatNormalScale);
		this.form.nextRow();
	}

	MeshPhysicalMaterialEditor.prototype = Object.create(MeshStandardMaterialEditor.prototype);

	MeshPhysicalMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshStandardMaterialEditor.prototype.attach.call(this, material, asset);

		this.clearcoat.setValue(material.clearcoat);
		this.clearcoatRoughness.setValue(material.clearcoatRoughness);
		this.reflectivity.setValue(material.reflectivity);
		this.transparency.setValue(material.transparency);
		this.clearcoatNormalMap.setValue(material.clearcoatNormalMap);
		this.clearcoatNormalScale.setValue(material.clearcoatNormalScale);
		this.clearcoatMap.setValue(material.clearcoatMap);
		this.clearcoatRoughnessMap.setValue(material.clearcoatRoughnessMap);
	};

	function MeshPhongMaterialEditor(parent, closeable, container, index)
	{
		MeshMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Specular color
		this.form.addText(Locale.specular);
		this.specular = new ColorChooser(this.form);
		this.specular.size.set(100, 18);
		this.specular.setOnChange(function()
		{
			self.material.specular.setHex(self.specular.getValueHex());
			self.material.needsUpdate = true;
		});
		this.form.add(this.specular);
		this.form.nextRow();

		// Shininess
		this.form.addText(Locale.shininess);
		this.shininess = new Slider(this.form);
		this.shininess.size.set(160, 18);
		this.shininess.setRange(0, 250);
		this.shininess.setStep(0.1);
		this.shininess.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "shininess", self.shininess.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.shininess);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(0, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();

		// Bump map
		this.form.addText(Locale.bumpMap);
		this.bumpMap = new TextureForm(this.form);
		this.bumpMap.size.set(0, 100);
		this.bumpMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpMap", self.bumpMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpMap);
		this.form.nextRow();

		// Bump scale
		this.form.addText(Locale.scale);
		this.bumpScale = new Slider(this.form);
		this.bumpScale.size.set(160, 18);
		this.bumpScale.setRange(0, 1);
		this.bumpScale.setStep(0.01);
		this.bumpScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpScale", self.bumpScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpScale);
		this.form.nextRow();

		// Normal map
		this.form.addText(Locale.normalMap);
		this.normalMap = new TextureForm(this.form);
		this.normalMap.size.set(0, 100);
		this.normalMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMap", self.normalMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMap);
		this.form.nextRow();

		// Normal map scale
		this.form.addText(Locale.normalScale);
		this.normalScale = new VectorBox(this.form);
		this.normalScale.size.set(0, 18);
		this.normalScale.setType(VectorBox.VECTOR2);
		this.normalScale.setValue(1, 1, 0);
		this.normalScale.setOnChange(function()
		{
			self.material.normalScale.copy(self.normalScale.getValue());
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalScale);
		this.form.nextRow();

		// Normal type
		this.form.addText(Locale.normalType);
		this.normalMapType = new DropdownList(this.form);
		this.normalMapType.size.set(100, 18);
		this.normalMapType.addValue(Locale.tangentSpace, three.TangentSpaceNormalMap);
		this.normalMapType.addValue(Locale.objectSpace, three.ObjectSpaceNormalMap);
		this.normalMapType.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMapType", self.normalMapType.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMapType);
		this.form.nextRow();

		// Displacement map
		this.form.addText(Locale.displacementMap);
		this.displacementMap = new TextureForm(this.form);
		this.displacementMap.size.set(0, 100);
		this.displacementMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementMap", self.displacementMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementMap);
		this.form.nextRow();

		// Displacement map scale
		this.form.addText(Locale.scale);
		this.displacementScale = new NumberBox(this.form);
		this.displacementScale.size.set(60, 18);
		this.displacementScale.setStep(0.05);
		this.displacementScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementScale", self.displacementScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementScale);
		this.form.nextRow();

		// Displacement map bias
		this.form.addText(Locale.bias);
		this.displacementBias = new NumberBox(this.form);
		this.displacementBias.size.set(60, 18);
		this.displacementBias.setStep(0.1);
		this.displacementBias.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementBias", self.displacementBias.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementBias);
		this.form.nextRow();

		// Specular map
		this.form.addText(Locale.specularMap);
		this.specularMap = new TextureForm(this.form);
		this.specularMap.size.set(0, 100);
		this.specularMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "specularMap", self.specularMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.specularMap);
		this.form.nextRow();

		// Emissive map
		this.form.addText(Locale.emissiveMap);
		this.emissiveMap = new TextureForm(this.form);
		this.emissiveMap.size.set(0, 100);
		this.emissiveMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveMap", self.emissiveMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveMap);
		this.form.nextRow();

		// Emissive color
		this.form.addText(Locale.color);
		this.emissive = new ColorChooser(this.form);
		this.emissive.size.set(100, 18);
		this.emissive.setOnChange(function()
		{
			self.material.emissive.setHex(self.emissive.getValueHex());
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissive);
		this.form.nextRow();

		// Emissive intensity
		this.form.addText(Locale.intensity);
		this.emissiveIntensity = new NumberBox(this.form);
		this.emissiveIntensity.size.set(60, 18);
		this.emissiveIntensity.setStep(0.1);
		this.emissiveIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveIntensity", self.emissiveIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveIntensity);
		this.form.nextRow();

		// Ligh map
		this.form.addText(Locale.lightMap);
		this.lightMap = new TextureForm(this.form);
		this.lightMap.size.set(0, 100);
		this.lightMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMap", self.lightMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMap);
		this.form.nextRow();

		// Ligh map intensity
		this.form.addText(Locale.intensity);
		this.lightMapIntensity = new NumberBox(this.form);
		this.lightMapIntensity.size.set(60, 18);
		this.lightMapIntensity.setStep(0.1);
		this.lightMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMapIntensity", self.lightMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMapIntensity);
		this.form.nextRow();

		// Alpha map
		this.form.addText(Locale.alphaMap);
		this.alphaMap = new TextureForm(this.form);
		this.alphaMap.size.set(0, 100);
		this.alphaMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaMap", self.alphaMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaMap);
		this.form.nextRow();

		// Environment map
		this.form.addText(Locale.environmentMap);
		this.envMap = new CubeTextureBox(this.form);
		this.envMap.size.set(0, 100);
		this.envMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "envMap", self.envMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.envMap);
		this.form.nextRow();

		// Combine environment map
		this.form.addText(Locale.mode);
		this.combine = new DropdownList(this.form);
		this.combine.size.set(0, 18);
		this.combine.addValue(Locale.multiply, three.MultiplyOperation);
		this.combine.addValue(Locale.mix, three.MixOperation);
		this.combine.addValue(Locale.add, three.AddOperation);
		this.combine.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "combine", self.combine.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.combine);
		this.form.nextRow();

		// Reflectivity
		this.form.addText(Locale.reflectivity);
		this.reflectivity = new NumberBox(this.form);
		this.reflectivity.size.set(0, 18);
		this.reflectivity.setStep(0.05);
		this.reflectivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "reflectivity", self.reflectivity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.reflectivity);
		this.form.nextRow();

		// Refraction
		this.form.addText(Locale.refractionRatio);
		this.refractionRatio = new NumberBox(this.form);
		this.refractionRatio.size.set(0, 18);
		this.refractionRatio.setStep(0.05);
		this.refractionRatio.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "refractionRatio", self.refractionRatio.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.refractionRatio);

		// Ambient Occlusion map
		this.form.addText(Locale.ambientOcclusion);
		this.aoMap = new TextureForm(this.form);
		this.aoMap.size.set(0, 100);
		this.aoMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMap", self.aoMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMap);
		this.form.nextRow();

		// Ambient Occlusion
		this.form.addText(Locale.intensity);
		this.aoMapIntensity = new NumberBox(this.form);
		this.aoMapIntensity.size.set(60, 18);
		this.aoMapIntensity.setStep(0.05);
		this.aoMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMapIntensity", self.aoMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMapIntensity);
		this.form.nextRow();
	}

	MeshPhongMaterialEditor.prototype = Object.create(MeshMaterialEditor.prototype);

	MeshPhongMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshMaterialEditor.prototype.attach.call(this, material, asset);

		this.specular.setValue(material.specular.r, material.specular.g, material.specular.b);
		this.shininess.setValue(material.shininess);
		this.map.setValue(material.map);
		this.bumpMap.setValue(material.bumpMap);
		this.bumpScale.setValue(material.bumpScale);
		this.normalMap.setValue(material.normalMap);
		this.normalScale.setValue(material.normalScale.x, material.normalScale.y);
		this.normalMapType.setValue(material.normalMapType);
		this.displacementMap.setValue(material.displacementMap);
		this.displacementScale.setValue(material.displacementScale);
		this.displacementBias.setValue(material.displacementBias);
		this.specularMap.setValue(material.specularMap);
		this.emissive.setValue(material.emissive.r, material.emissive.g, material.emissive.b);
		this.emissiveIntensity.setValue(material.emissiveIntensity);
		this.emissiveMap.setValue(material.emissiveMap);
		this.lightMap.setValue(material.lightMap);
		this.lightMapIntensity.setValue(material.lightMapIntensity);
		this.alphaMap.setValue(material.alphaMap);
		this.envMap.setValue(material.envMap);
		this.combine.setValue(material.combine);
		this.reflectivity.setValue(material.reflectivity || 0);
		this.refractionRatio.setValue(material.refractionRatio || 0);
		this.aoMap.setValue(material.aoMap);
		this.aoMapIntensity.setValue(material.aoMapIntensity);
	};

	function MeshMatcapMaterialEditor(parent, closeable, container, index)
	{
		MeshMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Matcap map
		this.form.addText("Matcap map");
		this.matcap = new TextureForm(this.form);
		this.matcap.size.set(0, 100);
		this.matcap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "matcap", self.matcap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.matcap);
		this.form.nextRow();

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(0, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();

		// Bump map
		this.form.addText(Locale.bumpMap);
		this.bumpMap = new TextureForm(this.form);
		this.bumpMap.size.set(0, 100);
		this.bumpMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpMap", self.bumpMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpMap);
		this.form.nextRow();

		// Bump scale
		this.form.addText(Locale.scale);
		this.bumpScale = new Slider(this.form);
		this.bumpScale.size.set(160, 18);
		this.bumpScale.setRange(0, 1);
		this.bumpScale.setStep(0.01);
		this.bumpScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "bumpScale", self.bumpScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.bumpScale);
		this.form.nextRow();

		// Normal map
		this.form.addText(Locale.normalMap);
		this.normalMap = new TextureForm(this.form);
		this.normalMap.size.set(0, 100);
		this.normalMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMap", self.normalMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMap);
		this.form.nextRow();

		// Normal map scale
		this.form.addText(Locale.normalScale);
		this.normalScale = new VectorBox(this.form);
		this.normalScale.setType(VectorBox.VECTOR2);
		this.normalScale.setValue(1, 1, 0);
		this.normalScale.size.set(0, 18);
		this.normalScale.setOnChange(function()
		{
			self.material.normalScale.copy(self.normalScale.getValue());
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalScale);
		this.form.nextRow();

		// Normal type
		this.form.addText(Locale.normalType);
		this.normalMapType = new DropdownList(this.form);
		this.normalMapType.size.set(100, 18);
		this.normalMapType.addValue(Locale.tangentSpace, three.TangentSpaceNormalMap);
		this.normalMapType.addValue(Locale.objectSpace, three.ObjectSpaceNormalMap);
		this.normalMapType.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "normalMapType", self.normalMapType.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.normalMapType);
		this.form.nextRow();

		// Displacement map
		this.form.addText(Locale.displacementMap);
		this.displacementMap = new TextureForm(this.form);
		this.displacementMap.size.set(0, 100);
		this.displacementMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementMap", self.displacementMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementMap);
		this.form.nextRow();

		// Displacement map scale
		this.form.addText(Locale.scale);
		this.displacementScale = new NumberBox(this.form);
		this.displacementScale.size.set(60, 18);
		this.displacementScale.setStep(0.05);
		this.displacementScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementScale", self.displacementScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementScale);
		this.form.nextRow();

		// Displacement map bias
		this.form.addText(Locale.bias);
		this.displacementBias = new NumberBox(this.form);
		this.displacementBias.size.set(60, 18);
		this.displacementBias.setStep(0.1);
		this.displacementBias.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "displacementBias", self.displacementBias.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.displacementBias);
		this.form.nextRow();

		// Alpha map
		this.form.addText(Locale.alphaMap);
		this.alphaMap = new TextureForm(this.form);
		this.alphaMap.size.set(0, 100);
		this.alphaMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaMap", self.alphaMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaMap);
		this.form.nextRow();
	}

	MeshMatcapMaterialEditor.prototype = Object.create(MeshMaterialEditor.prototype);

	MeshMatcapMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshMaterialEditor.prototype.attach.call(this, material, asset);

		this.matcap.setValue(material.matcap);
		this.map.setValue(material.map);
		this.bumpMap.setValue(material.bumpMap);
		this.bumpScale.setValue(material.bumpScale);
		this.normalMap.setValue(material.normalMap);
		this.normalScale.setValue(material.normalScale.x, material.normalScale.y);
		this.normalMapType.setValue(material.normalMapType);
		this.displacementMap.setValue(material.displacementMap);
		this.displacementScale.setValue(material.displacementScale);
		this.displacementBias.setValue(material.displacementBias);
		this.alphaMap.setValue(material.alphaMap);
	};

	function MeshLambertMaterialEditor(parent, closeable, container, index)
	{
		MeshMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(0, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();

		// Specular map
		this.form.addText(Locale.specularMap);
		this.specularMap = new TextureForm(this.form);
		this.specularMap.size.set(0, 100);
		this.specularMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "specularMap", self.specularMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.specularMap);
		this.form.nextRow();

		// Alpha map
		this.form.addText(Locale.alphaMap);
		this.alphaMap = new TextureForm(this.form);
		this.alphaMap.size.set(0, 100);
		this.alphaMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaMap", self.alphaMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaMap);
		this.form.nextRow();

		// Emissive map
		this.form.addText(Locale.emissiveMap);
		this.emissiveMap = new TextureForm(this.form);
		this.emissiveMap.size.set(0, 100);
		this.emissiveMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveMap", self.emissiveMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveMap);
		this.form.nextRow();

		// Emissive color
		this.form.addText(Locale.color);
		this.emissive = new ColorChooser(this.form);
		this.emissive.size.set(100, 18);
		this.emissive.setOnChange(function()
		{
			self.material.emissive.setHex(self.emissive.getValueHex());
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissive);
		this.form.nextRow();

		// Emissive intensity
		this.form.addText(Locale.intensity);
		this.emissiveIntensity = new NumberBox(this.form);
		this.emissiveIntensity.size.set(60, 18);
		this.emissiveIntensity.setStep(0.1);
		this.emissiveIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "emissiveIntensity", self.emissiveIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.emissiveIntensity);
		this.form.nextRow();

		// Ligh map
		this.form.addText(Locale.lightMap);
		this.lightMap = new TextureForm(this.form);
		this.lightMap.size.set(0, 100);
		this.lightMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMap", self.lightMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMap);
		this.form.nextRow();

		// Ligh map intensity
		this.form.addText(Locale.intensity);
		this.lightMapIntensity = new NumberBox(this.form);
		this.lightMapIntensity.size.set(60, 18);
		this.lightMapIntensity.setStep(0.1);
		this.lightMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMapIntensity", self.lightMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMapIntensity);
		this.form.nextRow();

		// Environment map
		this.form.addText(Locale.environmentMap);
		this.envMap = new CubeTextureBox(this.form);
		this.envMap.size.set(0, 100);
		this.envMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "envMap", self.envMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.envMap);
		this.form.nextRow();

		// Combine environment map
		this.form.addText(Locale.mode);
		this.combine = new DropdownList(this.form);
		this.combine.position.set(100, 85);
		this.combine.size.set(0, 18);
		this.combine.addValue(Locale.multiply, three.MultiplyOperation);
		this.combine.addValue(Locale.mix, three.MixOperation);
		this.combine.addValue(Locale.add, three.AddOperation);
		this.combine.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "combine", self.combine.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.combine);
		this.form.nextRow();

		// Reflectivity
		this.form.addText(Locale.reflectivity);
		this.reflectivity = new NumberBox(this.form);
		this.reflectivity.size.set(0, 18);
		this.reflectivity.setStep(0.05);
		this.reflectivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "reflectivity", self.reflectivity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.reflectivity);
		this.form.nextRow();

		// Refraction
		this.form.addText(Locale.refractionRatio);
		this.refractionRatio = new NumberBox(this.form);
		this.refractionRatio.size.set(0, 18);
		this.refractionRatio.setStep(0.05);
		this.refractionRatio.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "refractionRatio", self.refractionRatio.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.refractionRatio);

		// Ambient Occlusion map
		this.form.addText(Locale.ambientOcclusion);
		this.aoMap = new TextureForm(this.form);
		this.aoMap.size.set(0, 100);
		this.aoMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMap", self.aoMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMap);
		this.form.nextRow();

		// Ambient Occlusion
		this.form.addText(Locale.intensity);
		this.aoMapIntensity = new NumberBox(this.form);
		this.aoMapIntensity.size.set(60, 18);
		this.aoMapIntensity.setStep(0.05);
		this.aoMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMapIntensity", self.aoMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMapIntensity);
		this.form.nextRow();
	}

	MeshLambertMaterialEditor.prototype = Object.create(MeshMaterialEditor.prototype);

	MeshLambertMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshMaterialEditor.prototype.attach.call(this, material, asset);

		this.color.setValue(material.color.r, material.color.g, material.color.b);
		this.map.setValue(material.map);
		this.specularMap.setValue(material.specularMap);
		this.alphaMap.setValue(material.alphaMap);
		this.emissive.setValue(material.emissive.r, material.emissive.g, material.emissive.b);
		this.emissiveIntensity.setValue(material.emissiveIntensity);
		this.emissiveMap.setValue(material.emissiveMap);
		this.lightMap.setValue(material.lightMap);
		this.lightMapIntensity.setValue(material.lightMapIntensity);
		this.envMap.setValue(material.envMap);
		this.combine.setValue(material.combine);
		this.reflectivity.setValue(material.reflectivity || 0);
		this.refractionRatio.setValue(material.refractionRatio || 0);
		this.aoMap.setValue(material.aoMap);
		this.aoMapIntensity.setValue(material.aoMapIntensity);
	};

	function MeshBasicMaterialEditor(parent, closeable, container, index)
	{
		MeshMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Texture map
		this.form.addText(Locale.textureMap);
		this.map = new TextureForm(this.form);
		this.map.size.set(0, 100);
		this.map.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "map", self.map.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.map);
		this.form.nextRow();

		// Alpha map
		this.form.addText(Locale.alphaMap);
		this.alphaMap = new TextureForm(this.form);
		this.alphaMap.size.set(0, 100);
		this.alphaMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "alphaMap", self.alphaMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.alphaMap);
		this.form.nextRow();

		// Specular map
		this.form.addText(Locale.specularMap);
		this.specularMap = new TextureForm(this.form);
		this.specularMap.size.set(0, 100);
		this.specularMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "specularMap", self.specularMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.specularMap);
		this.form.nextRow();
		
		// Ambient Occlusion map
		this.form.addText(Locale.ambientOcclusion);
		this.aoMap = new TextureForm(this.form);
		this.aoMap.size.set(0, 100);
		this.aoMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMap", self.aoMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMap);
		this.form.nextRow();

		// Ambient Occlusion
		this.form.addText(Locale.intensity);
		this.aoMapIntensity = new NumberBox(this.form);
		this.aoMapIntensity.size.set(60, 18);
		this.aoMapIntensity.setStep(0.05);
		this.aoMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMapIntensity", self.aoMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMapIntensity);
		this.form.nextRow();

		// Ligh map
		this.form.addText(Locale.lightMap);
		this.lightMap = new TextureForm(this.form);
		this.lightMap.size.set(0, 100);
		this.lightMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMap", self.lightMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMap);
		this.form.nextRow();

		// Ligh map intensity
		this.form.addText(Locale.intensity);
		this.lightMapIntensity = new NumberBox(this.form);
		this.lightMapIntensity.size.set(60, 18);
		this.lightMapIntensity.setStep(0.1);
		this.lightMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "lightMapIntensity", self.lightMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.lightMapIntensity);
		this.form.nextRow();

		// Environment map
		this.form.addText(Locale.environmentMap);
		this.envMap = new CubeTextureBox(this.form);
		this.envMap.size.set(0, 100);
		this.envMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "envMap", self.envMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.envMap);
		this.form.nextRow();

		// Combine environment map
		this.form.addText(Locale.mode);
		this.combine = new DropdownList(this.form);
		this.combine.size.set(0, 18);
		this.combine.addValue(Locale.multiply, three.MultiplyOperation);
		this.combine.addValue(Locale.mix, three.MixOperation);
		this.combine.addValue(Locale.add, three.AddOperation);
		this.combine.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "combine", self.combine.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.combine);
		this.form.nextRow();

		// Reflectivity
		this.form.addText(Locale.reflectivity);
		this.reflectivity = new NumberBox(this.form);
		this.reflectivity.size.set(0, 18);
		this.reflectivity.setStep(0.05);
		this.reflectivity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "reflectivity", self.reflectivity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.reflectivity);
		this.form.nextRow();

		// Refraction
		this.form.addText(Locale.refractionRatio);
		this.refractionRatio = new NumberBox(this.form);
		this.refractionRatio.size.set(0, 18);
		this.refractionRatio.setStep(0.05);
		this.refractionRatio.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "refractionRatio", self.refractionRatio.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.refractionRatio);

		// Ambient Occlusion map
		this.form.addText(Locale.ambientOcclusion);
		this.aoMap = new TextureForm(this.form);
		this.aoMap.size.set(0, 100);
		this.aoMap.setOnChange(function(file)
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMap", self.aoMap.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMap);
		this.form.nextRow();

		// Ambient Occlusion
		this.form.addText(Locale.intensity);
		this.aoMapIntensity = new NumberBox(this.form);
		this.aoMapIntensity.size.set(60, 18);
		this.aoMapIntensity.setStep(0.05);
		this.aoMapIntensity.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "aoMapIntensity", self.aoMapIntensity.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.aoMapIntensity);
		this.form.nextRow();
	}

	MeshBasicMaterialEditor.prototype = Object.create(MeshMaterialEditor.prototype);

	MeshBasicMaterialEditor.prototype.attach = function(material, asset)
	{
		MeshMaterialEditor.prototype.attach.call(this, material, asset);

		this.map.setValue(material.map);
		this.alphaMap.setValue(material.alphaMap);
		this.specularMap.setValue(material.specularMap);
		this.aoMap.setValue(material.aoMap);
		this.aoMapIntensity.setValue(material.aoMapIntensity);
		this.lightMap.setValue(material.lightMap);
		this.lightMapIntensity.setValue(material.lightMapIntensity);
		this.envMap.setValue(material.envMap);
		this.combine.setValue(material.combine);
		this.reflectivity.setValue(material.reflectivity || 0);
		this.refractionRatio.setValue(material.refractionRatio || 0);
		this.aoMap.setValue(material.aoMap);
		this.aoMapIntensity.setValue(material.aoMapIntensity);
	};

	function LineBasicMaterialEditor(parent, closeable, container, index)
	{
		MaterialEditor.call(this, parent, closeable, container, index);
		
		// Line
		this.line = new three.LineLoop(MaterialEditor.geometries[0][1], null);
		this.interactive.add(this.line);
		
		// Test model
		this.previewForm.addText(Locale.geometry);
		this.testModel = new DropdownList(this.previewForm);
		this.testModel.size.set(100, 18);
		for(var i = 0; i < MaterialEditor.geometries.length; i++)
		{
			this.testModel.addValue(MaterialEditor.geometries[i][0], i);
		}
		this.testModel.setOnChange(function()
		{
			var value = self.testModel.getSelectedIndex();
			self.line.geometry = MaterialEditor.geometries[value][1];
		});
		this.previewForm.add(this.testModel);
		this.previewForm.nextRow();

		var self = this;

		// Color
		this.form.addText(Locale.color);
		this.color = new ColorChooser(this.form);
		this.color.size.set(100, 18);
		this.color.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "color", new three.Color(self.color.getValueHex())));
			self.material.needsUpdate = true;
		});
		this.form.add(this.color);
		this.form.nextRow();

		// Line width
		this.form.addText(Locale.width);
		this.linewidth = new NumberBox(this.form);
		this.linewidth.size.set(60, 18);
		this.linewidth.setStep(1);
		this.linewidth.setRange(0, Number.MAX_SAFE_INTEGER);
		this.linewidth.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "linewidth", self.linewidth.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.linewidth);
		this.form.nextRow();
	}

	LineBasicMaterialEditor.prototype = Object.create(MaterialEditor.prototype);

	LineBasicMaterialEditor.prototype.attach = function(material, asset)
	{
		MaterialEditor.prototype.attach.call(this, material, asset);

		this.line.material = material;

		this.color.setValue(material.color.r, material.color.g, material.color.b);
		this.linewidth.setValue(material.linewidth);
	};

	LineBasicMaterialEditor.prototype.update = function()
	{
		MaterialEditor.prototype.update.call(this);

		if(this.mouse.insideCanvas() && this.mouse.buttonPressed(Mouse.LEFT))
		;
	};

	function LineDashedMaterialEditor(parent, closeable, container, index)
	{
		LineBasicMaterialEditor.call(this, parent, closeable, container, index);

		var self = this;
		
		// Dash size
		this.form.addText("Dash Size");
		this.dashSize = new NumberBox(this.form);
		this.dashSize.size.set(60, 18);
		this.dashSize.setRange(0, Number.MAX_SAFE_INTEGER);
		this.dashSize.setStep(1);
		this.dashSize.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "dashSize", self.dashSize.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.dashSize);
		this.form.nextRow();

		// Gap size
		this.form.addText("Gap Size");
		this.gapSize = new NumberBox(this.form);
		this.gapSize.size.set(60, 18);
		this.gapSize.setRange(0, Number.MAX_SAFE_INTEGER);
		this.gapSize.setStep(1);
		this.gapSize.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "gapSize", self.gapSize.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.gapSize);
		this.form.nextRow();

		// Dash scale
		this.form.addText("Dash Scale");
		this.dashScale = new NumberBox(this.form);
		this.dashScale.size.set(60, 18);
		this.dashScale.setRange(0, Number.MAX_SAFE_INTEGER);
		this.dashScale.setStep(1);
		this.dashScale.setOnChange(function()
		{
			Editor$1.addAction(new ChangeAction(self.material, "scale", self.dashScale.getValue()));
			self.material.needsUpdate = true;
		});
		this.form.add(this.dashScale);
		this.form.nextRow();
	}

	LineDashedMaterialEditor.prototype = Object.create(LineBasicMaterialEditor.prototype);

	LineDashedMaterialEditor.prototype.attach = function(material, asset)
	{
		LineBasicMaterialEditor.prototype.attach.call(this, material, asset);

		this.dashSize.setValue(material.dashSize);
		this.gapSize.setValue(material.gapSize);
		this.dashScale.setValue(material.scale);
	};

	function MaterialAsset(parent)
	{
		Asset.call(this, parent);

		this.setIcon(Global.FILE_PATH + "icons/misc/material.png");
		
		var self = this;

		// Use to store original material color on highlight
		this.materialColor = new three.Color(0, 0, 0);
		this.materialHighlighted = false;

		// Material Preview
		this.image = document.createElement("img");
		this.image.style.position = "absolute";
		this.image.style.top = "5%";
		this.image.style.left = "17%";
		this.image.style.width = "66%";
		this.image.style.height = "66%";
		this.element.appendChild(this.image);

		// Mouse over event
		this.element.onmouseenter = function()
		{
			this.style.backgroundColor = "var(--button-over-color)";
			self.highlightMaterial();
		};

		// Mouse leave event
		this.element.onmouseleave = function()
		{
			if(!Editor$1.isSelected(self.asset))
			{
				this.style.backgroundColor = null;
			}
			self.restoreMaterial();
		};

		// Double click
		this.element.ondblclick = function()
		{
			if(self.asset instanceof three.Material)
			{
				var tab = Editor$1.gui.tab.getTab(MaterialEditor, self.asset);

				if(tab === null)
				{
					self.restoreMaterial();

					if(self.asset instanceof three.MeshPhongMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshPhongMaterialEditor, true);
					}
					else if(self.asset instanceof three.MeshToonMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshToonMaterialEditor, true);
					}
					else if(self.asset instanceof three.MeshLambertMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshLambertMaterialEditor, true);
					}
					else if(self.asset instanceof three.MeshMatcapMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshMatcapMaterialEditor, true);
					}
					else if(self.asset instanceof three.MeshBasicMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshBasicMaterialEditor, true);
					}
					else if(self.asset instanceof three.MeshPhysicalMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshPhysicalMaterialEditor, true);
					}
					else if(self.asset instanceof three.MeshStandardMaterial)
					{
						tab = Editor$1.gui.tab.addTab(MeshStandardMaterialEditor, true);
					}
					else if(self.asset instanceof three.SpriteMaterial)
					{
						tab = Editor$1.gui.tab.addTab(SpriteMaterialEditor, true);
					}
					else if(self.asset instanceof three.ShaderMaterial)
					{
						tab = Editor$1.gui.tab.addTab(ShaderMaterialEditor, true);
					}
					else if(self.asset instanceof three.LineDashedMaterial)
					{
						tab = Editor$1.gui.tab.addTab(LineDashedMaterialEditor, true);
					}
					else if(self.asset instanceof three.LineBasicMaterial)
					{
						tab = Editor$1.gui.tab.addTab(LineBasicMaterialEditor, true);
					}
					else if(self.asset instanceof three.PointsMaterial)
					{
						tab = Editor$1.gui.tab.addTab(PointsMaterialEditor, true);
					}
					else
					{
						tab = Editor$1.gui.tab.addTab(MeshMaterialEditor, true);
					}

					tab.attach(self.asset, self);
				}

				tab.select();
			}
		};

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.rename, function()
			{
				Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.renameMaterial, self.asset.name)));
			});
			
			context.addOption(Locale.selectObjects, function()
			{	
				Editor$1.clearSelection();
				Editor$1.program.traverse(function(child)
				{
					if(child.material === self.asset)
					{
						Editor$1.addToSelection(child);
					}
				});

				Editor$1.updateSelectionGUI();
			});

			context.addOption(Locale.delete, function()
			{
				if(Editor$1.confirm(Locale.deleteMaterial))
				{
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "materials"));
				}
			});

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});

			context.addOption(Locale.cut, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "materials"));
			});

			context.addOption(Locale.duplicate, function()
			{
				try
				{
					// Serialize
					var json = self.asset.toJSON();

					// Loader
					var loader = new MaterialLoader();
					loader.setTextures(Editor$1.program.textures);

					// Load
					var material = loader.parse(json); 
					material.uuid = three.Math.generateUUID();
					material.name += "*";
					
					Editor$1.addAction(new AddResourceAction(material, Editor$1.program, "materials"));
				}
				catch(e)
				{
					Editor$1.alert("Material duplication failed.\n" + e.stack);
				}
			});

			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Restore material color
			self.restoreMaterial();

			// Insert material into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	// Super prototypes
	MaterialAsset.prototype = Object.create(Asset.prototype);

	// Destroy material file
	MaterialAsset.prototype.destroy = function()
	{
		Asset.prototype.destroy.call(this);

		this.restoreMaterial();
	};

	// Highlight material
	MaterialAsset.prototype.highlightMaterial = function()
	{
		if(this.asset instanceof three.Material && this.asset.color !== undefined)
		{
			this.materialColor.copy(this.asset.color);
			this.asset.color.setRGB(1, 1, 0);
			this.materialHighlighted = true;
		}
	};

	// Restore material to normal color
	MaterialAsset.prototype.restoreMaterial = function()
	{
		if(this.materialHighlighted)
		{
			if(this.asset instanceof three.Material && this.asset.color !== undefined)
			{
				this.asset.color.copy(this.materialColor);
				this.materialHighlighted = false;
			}
		}
	};

	MaterialAsset.prototype.updateMetadata = function()
	{
		if(this.asset !== null)
		{
			var image = this.image;
			
			MaterialRenderer.render(this.asset, function(url)
			{
				image.src = url;
			});
			
			this.setText(this.asset.name);
		}
	};

	function ImageAsset(parent)
	{
		Asset.call(this, parent);

		this.preview = document.createElement("img");
		this.preview.draggable = true;
		this.preview.style.position = "absolute";
		this.preview.style.top = "5%";
		this.preview.style.left = "17%";
		this.preview.style.width = "66%";
		this.preview.style.height = "66%";
		this.preview.style.objectFit = "contain";
		this.element.appendChild(this.preview);

		this.setIcon(Global.FILE_PATH + "icons/misc/image.png");

		var self = this;

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.rename, function()
			{
				if(self.asset !== null)
				{
					Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.rename + " " + Locale.image, self.asset.name)));
				}
			});
			
			context.addOption(Locale.delete, function()
			{
				if(Editor$1.confirm(Locale.delete + " " + Locale.image))
				{
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "images"));
				}
			});

			context.addOption(Locale.export, function()
			{
				if(Nunu.runningOnDesktop())
				{
					FileSystem.chooseFile(function(files)
					{
						if(files.length > 0)
						{
							self.asset.export(files[0].path);
						}
					}, "." + self.asset.encoding, true);
				}
				else
				{
					FileSystem.chooseFileName(function(file)
					{
						self.asset.export(file);
					}, "." + self.asset.encoding);
				}
			});

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});

			context.addOption(Locale.cut, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "images"));
			});

			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Insert into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	ImageAsset.prototype = Object.create(Asset.prototype);

	ImageAsset.prototype.attach = function(asset)
	{
		Asset.prototype.attach.call(this, asset);

		this.preview.src = asset.data;
	};

	/** 
	 * The geometry renderer is used to generate preview thumbnails.
	 *
	 * A basic phong material is used to preview the geometry.
	 *
	 * @class TextureRenderer
	 * @extends {PreviewRenderer}
	 */
	function GeometryRenderer()
	{
		PreviewRenderer.call(this);
		
		this.camera = new OrthographicCamera(3, 1);

		var directional = new three.DirectionalLight(0x777777, 1.0);
		directional.position.set(3000, 10000, 400);
		this.scene.add(directional);
		this.scene.add(new three.AmbientLight(0x888888));

		this.mesh = new three.Mesh(new three.Geometry(), new three.MeshPhongMaterial({color: 0xFFFFFF}));
		this.scene.add(this.mesh);
	}

	GeometryRenderer.prototype = Object.create(PreviewRenderer.prototype);

	GeometryRenderer.render = function(material, onRender)
	{
		if(GeometryRenderer.instance === undefined)
		{
			GeometryRenderer.instance = new GeometryRenderer();
		}

		GeometryRenderer.instance.render(material, onRender);
	};

	GeometryRenderer.prototype.render = function(geometry, onRender)
	{
		geometry.computeBoundingBox();
		
		var box = geometry.boundingBox;
		var center = new three.Vector3();
		center.addVectors(box.min, box.max);
		center.multiplyScalar(-0.5);

		this.mesh.geometry = geometry;
		this.mesh.position.copy(center);

		var x = box.max.x - box.min.x;
		var y = box.max.y - box.min.y;

		this.camera.size = x > y ? x : y;
		this.camera.position.z = 50;
		this.camera.updateProjectionMatrix();
		this.renderer.render(this.scene, this.camera);

		onRender(this.canvas.toDataURL());
	};

	function GeometryAsset(parent)
	{
		Asset.call(this, parent);

		this.setIcon(Global.FILE_PATH + "icons/misc/scene.png");
		
		var self = this;

		// Image
		this.image = document.createElement("img");
		this.image.style.position = "absolute";
		this.image.style.top = "5%";
		this.image.style.left = "17%";
		this.image.style.width = "66%";
		this.image.style.height = "66%";
		this.element.appendChild(this.image);

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.rename, function()
			{
				Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.rename, self.asset.name)));
			});
			
			context.addOption(Locale.delete, function()
			{
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "geometries"));
			});

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});
			
			context.addOption(Locale.cut, function()
			{
				if(self.asset !== null)
				{
					Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "geometries"));
				}
			});

			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Insert into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	GeometryAsset.prototype = Object.create(Asset.prototype);

	GeometryAsset.prototype.updateMetadata = function()
	{
		if(this.asset !== null)
		{
			this.setText(this.asset.name);

			var image = this.image;

			GeometryRenderer.render(this.asset, function(url)
			{
				image.src = url;
			});
		}
	};

	/** 
	 * The font renderer is used to generate preview thumbnails for fonts.
	 *
	 * @class FontRenderer
	 * @extends {PreviewRenderer}
	 */
	function FontRenderer()
	{
		PreviewRenderer.call(this);

		// Camera
		this.camera = new OrthographicCamera(3, 1);

		// Text
		this.text = new TextMesh("Abc", new three.MeshBasicMaterial({color: 0xFFFFFF}), null);
		this.text.position.z = -3;
		this.scene.add(this.text);
	}

	FontRenderer.prototype = Object.create(PreviewRenderer.prototype);

	FontRenderer.render = function(font, onRender)
	{
		if(FontRenderer.instance === undefined)
		{
			FontRenderer.instance = new FontRenderer();
		}

		FontRenderer.instance.render(font, onRender);
	};

	FontRenderer.prototype.render = function(font, onRender)
	{
		this.text.setFont(font);

		this.text.geometry.computeBoundingBox();
		
		var box = this.text.geometry.boundingBox;
		this.text.position.x = -(box.max.x - box.min.x) / 2;
		this.text.position.y = -(box.max.y - box.min.y) / 2;

		this.camera.size = box.max.x - box.min.x;
		this.camera.updateProjectionMatrix();
		
		this.renderer.render(this.scene, this.camera);

		// Callback
		onRender(this.canvas.toDataURL());
	};

	function FontAsset(parent)
	{
		Asset.call(this, parent);

		this.setIcon(Global.FILE_PATH + "icons/misc/font.png");
		
		var self = this;

		// Image
		this.image = document.createElement("img");
		this.image.style.position = "absolute";
		this.image.style.top = "5%";
		this.image.style.left = "17%";
		this.image.style.width = "66%";
		this.image.style.height = "66%";
		this.element.appendChild(this.image);

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.rename, function()
			{
				Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.renameFont, self.asset.name)));
			});
			
			context.addOption(Locale.delete, function()
			{
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "fonts"));
			});

			if(self.asset.format === "arraybuffer")
			{
				context.addOption(Locale.reverse, function()
				{
					if(Editor$1.confirm("Reverse font glyphs?"))
					{
						self.asset.reverseGlyphs();
						self.updateMetadata();
					}
				});
			}

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});
			
			context.addOption(Locale.cut, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "fonts"));
			});

			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Insert into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	FontAsset.prototype = Object.create(Asset.prototype);

	FontAsset.prototype.updateMetadata = function()
	{
		var image = this.image;
		
		FontRenderer.render(this.asset, function(url)
		{
			image.src = url;
		});

		this.setText(this.asset.name);
	};

	/**
	 * The text editor is used to edit text files.
	 *
	 * It can present colors for some programming language (javascript, glsl, html, css, etc).
	 *
	 * @class TextEditor
	 * @extends {CodeEditor}
	 */
	function TextEditor(parent, closeable, container, index)
	{
		CodeEditor.call(this, parent, closeable, container, index);

		var self = this;

		// Change
		this.code.on("change", function(cm)
		{
			if(!cm.state.focused)
			{
				return;
			}

			self.updateCode();
		});

		// Key pressed event
		this.code.on("keypress", function(cm, event)
		{
			var typed = String.fromCharCode(event.charCode);

			if(/[\w\.]/.exec(typed))
			{
				// If there is no tern sugestion suggest known words
				if(cm.state.completionActive == null || cm.state.completionActive.widget === null)
				{
					CodeMirror.commands.autocomplete(cm, null);
				}
			}
		});

		this.resource = null;
	}

	TextEditor.prototype = Object.create(CodeEditor.prototype);

	TextEditor.prototype.updateMetadata = function()
	{
		this.setName(this.resource.name);

		// If not found close tab
		if(Editor$1.program.resources[this.resource.uuid] === undefined)
		{
			this.close();
		}
	};

	TextEditor.prototype.activate = function()
	{
		CodeEditor.prototype.activate.call(this);

		this.updateCode();
	};

	TextEditor.prototype.isAttached = function(resource)
	{
		return this.resource === resource;
	};

	TextEditor.prototype.attach = function(resource)
	{
		this.resource = resource;
		this.setText(resource.data);

		if(resource.encoding == "js")
		{
			this.setLanguage("javascript");
		}
		else if(resource.encoding == "html")
		{
			this.setLanguage("htmlmixed");
		}
		else if(resource.encoding == "css")
		{
			this.setLanguage("css");
		}
		else
		{
			this.setLanguage("");
		}
		
		this.updateMetadata();
		this.updateSettings();
	};

	// Update attached script
	TextEditor.prototype.updateCode = function()
	{
		if(this.resource !== null)
		{
			this.resource.data = this.code.getValue();
		}
	};

	function FileAsset(parent)
	{
		Asset.call(this, parent);

		this.setIcon(Global.FILE_PATH + "icons/misc/file.png");
		
		var self = this;

		// Image
		this.image = document.createElement("img");
		this.image.style.position = "absolute";
		this.image.style.top = "5%";
		this.image.style.left = "17%";
		this.image.style.width = "66%";
		this.image.style.height = "66%";
		this.element.appendChild(this.image);

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);

			context.addOption(Locale.rename, function()
			{
				Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt(Locale.rename + " " + Locale.file, self.asset.name)));
			});
			
			context.addOption(Locale.delete, function()
			{
				if(Editor$1.confirm(Locale.delete + " " + Locale.file))
				{
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "resources"));
				}
			});

			context.addOption(Locale.export, function()
			{
				if(Nunu.runningOnDesktop())
				{
					FileSystem.chooseFile(function(files)
					{
						if(files.length > 0)
						{
							self.asset.export(files[0].path);
						}
					}, "." + self.asset.encoding, true);
				}
				else
				{
					FileSystem.chooseFileName(function(file)
					{
						self.asset.export(file);
					}, "." + self.asset.encoding);
				}
			});

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});
			
			context.addOption(Locale.cut, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "resources"));
			});

			context.updateInterface();
		};


		// Open text editor
		this.element.ondblclick = function()
		{
			var tab = Editor$1.gui.tab.getTab(TextEditor, self.asset);

			if(tab === null)
			{
				tab = Editor$1.gui.tab.addTab(TextEditor, true);
				tab.attach(self.asset, self);
			}
			
			tab.select();
		};
	}

	FileAsset.prototype = Object.create(Asset.prototype);

	FileAsset.prototype.updateMetadata = function()
	{
		this.setText(this.asset.name);

		if(this.asset.encoding === "js" || this.asset.encoding === "glsl")
		{
			this.image.src = Global.FILE_PATH + "icons/script/script.png";
		}
		else
		{
			this.image.src = Global.FILE_PATH + "icons/misc/file.png";
		}
	};

	function AudioAsset(parent)
	{
		Asset.call(this, parent);

		this.setIcon(Global.FILE_PATH + "icons/misc/audio.png");
		
		var self = this;

		// Image
		this.image = document.createElement("img");
		this.image.style.position = "absolute";
		this.image.style.top = "5%";
		this.image.style.left = "17%";
		this.image.style.width = "66%";
		this.image.style.height = "66%";
		this.image.src = Global.FILE_PATH + "icons/misc/audio.png";
		this.element.appendChild(this.image);

		// Context menu event
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(130, 20);
			context.position.set(event.clientX, event.clientY);
			
			var menu = context.addMenu("Create Emitter");

			menu.addOption("Audio Emitter", function()
			{
				if(self.asset !== null)
				{
					var emitter = new AudioEmitter(self.asset);
					emitter.name = self.asset.name;
					Editor$1.addObject(emitter);
				}
			});

			menu.addOption("Positional", function()
			{
				if(self.asset !== null)
				{
					var emitter = new PositionalAudio(self.asset);
					emitter.name = self.asset.name;
					Editor$1.addObject(emitter);
				}
			});

			context.addOption(Locale.rename, function()
			{
				Editor$1.addAction(new ChangeAction(self.asset, "name", Editor$1.prompt("Rename audio", self.asset.name)));
			});

			context.addOption(Locale.export, function()
			{
				if(Nunu.runningOnDesktop())
				{
					FileSystem.chooseFile(function(files)
					{
						if(files.length > 0)
						{
							self.asset.export(files[0].path);
						}
					}, "." + self.asset.encoding, true);
				}
				else
				{
					FileSystem.chooseFileName(function(file)
					{
						self.asset.export(file);
					}, "." + self.asset.encoding);
				}
			});
			
			context.addOption(Locale.delete, function()
			{
				if(Editor$1.confirm("Delete audio?"))
				{
					Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "audio"));
				}
			});

			context.addOption(Locale.copy, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
			});

			context.addOption(Locale.cut, function()
			{
				Editor$1.clipboard.set(JSON.stringify(self.asset.toJSON()), "text");
				Editor$1.addAction(new RemoveResourceAction(self.asset, Editor$1.program, "audio"));
			});

			context.updateInterface();
		};

		// Drag start
		this.element.ondragstart = function(event)
		{
			// Insert into drag buffer
			if(self.asset !== null)
			{
				event.dataTransfer.setData("uuid", self.asset.uuid);
				DragBuffer.push(self.asset);
			}
		};

		// Drag end (called after of ondrop)
		this.element.ondragend = function(event)
		{
			DragBuffer.pop(self.asset.uuid);
		};
	}

	AudioAsset.prototype = Object.create(Asset.prototype);

	function AssetExplorer(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, "Assets", Global.FILE_PATH + "icons/misc/new.png");

		var self = this;

		this.element.ondragover = undefined;

		// Assets
		this.assets = new Component(this, "div");
		this.assets.element.style.overflow = "auto";

		// Drop event
		this.element.ondrop = function(event)
		{
			// Dragged file into explorer
			for(var i = 0; i < event.dataTransfer.files.length; i++)
			{
				var file = event.dataTransfer.files[i];
				var name = file.name;

				// Image
				if(Image.fileIsImage(file))
				{
					Loaders.loadTexture(file);
				}
				// Video
				else if(Video.fileIsVideo(file))
				{
					Loaders.loadVideoTexture(file);
				}
				// Audio
				else if(Audio.fileIsAudio(file))
				{
					Loaders.loadAudio(file);
				}
				// Font
				else if(Font.fileIsFont(file))
				{
					Loaders.loadFont(file);
				}
			}
		};

		// Bar
		this.bar = new AssetExplorerMenu(this);

		/**
		 * Search box to filter by name.
		 *
		 * @property search
		 * @type {SearchBox}
		 */
		this.search = new SearchBox(this.bar);
		this.search.setMode(Component.TOP_RIGHT);
		this.search.size.set(200, 25);
		this.search.position.set(1, 0);
		this.search.updateInterface();
		this.search.setOnChange(function()
		{
			self.filterByName(self.search.search.getText());
		});

		/**
		 * Assets in explorer.
		 *
		 * @property files
		 * @type {Array}
		 */
		this.files = [];

		/**
		 * Resource manager attached to the explorer.
		 *
		 * @property manager
		 * @type {ResourceManger}
		 */
		this.manager = null;
	}

	AssetExplorer.prototype = Object.create(TabComponent.prototype);

	/**
	 * Filter assets by their name.
	 *
	 * Only assets that contain the name will be shown.
	 *
	 * @method filterByName
	 * @param {string} name String with portion of the name to be found and filtered.
	 */
	AssetExplorer.prototype.filterByName = function(search)
	{
		search = search.toLowerCase();

		for(var i = 0; i < this.files.length; i++)
		{
			var text = this.files[i].name.data.toLowerCase();
			this.files[i].setVisibility(text.search(search) !== -1);
		}
	};

	AssetExplorer.prototype.updateSettings = function()
	{
		for(var i = 0; i < this.files.length; i++)
		{
			this.files[i].setSize(Editor$1.settings.general.filePreviewSize);
		}
	};

	/**
	 * Attach a resource manager to this explorer.
	 *
	 * @method attach
	 * @param {ResourceManager} manager.
	 */
	AssetExplorer.prototype.attach = function(manager)
	{
		if(this.manager !== manager)
		{	
			this.manager = manager;
			this.updateObjectsView();
		}
	};

	/** 
	 * Add asset to the explorer.
	 *
	 * @method add
	 * @param {Asset} file
	 */
	AssetExplorer.prototype.add = function(file)
	{
		file.setSize(Editor$1.settings.general.filePreviewSize);
		this.files.push(file);
	};

	/**
	 * Update the full object view in the asset explorer.
	 *
	 * Should only be used to initialize the explorer the first time. After it gets initialized use the add and remove methods.
	 *
	 * @method updateObjectsView
	 */
	AssetExplorer.prototype.updateObjectsView = function()
	{
		// TODO <USE ONLY TO INITIALIZE THE EXPLORER>

		this.clear();

		// Materials
		var materials = this.manager.materials;
		for(var i in materials)
		{
			var file = new MaterialAsset(this.assets);
			file.attach(materials[i]);
			this.add(file);
		}

		// Geometries
		var geometries = this.manager.geometries;
		for(var i in geometries)
		{
			var file = new GeometryAsset(this.assets);
			file.attach(geometries[i]);
			this.add(file);
		}

		// Textures
		var textures = this.manager.textures;
		for(var i in textures)
		{
			var file = new TextureAsset(this.assets);
			file.attach(textures[i]);
			this.add(file);
		}

		// Fonts
		var fonts = this.manager.fonts;
		for(var i in fonts)
		{
			var file = new FontAsset(this.assets);
			file.attach(fonts[i]);
			this.add(file);
		}

		var images = this.manager.images;
		for(var i in images)
		{
			var file = new ImageAsset(this.assets);
			file.attach(images[i]);
			this.add(file);
		}

		var videos = this.manager.videos;
		for(var i in videos)
		{
			var file = new VideoAsset(this.assets);
			file.attach(videos[i]);
			this.add(file);
		}

		// Audio
		var audio = this.manager.audio;
		for(var i in audio)
		{
			var file = new AudioAsset(this.assets);
			file.attach(audio[i]);
			this.add(file);
		}

		// Resources
		var resources = this.manager.resources;
		for(var i in resources)
		{
			var resource = resources[i];

			var file = new FileAsset(this.assets);
			file.attach(resource);
			this.add(file);
		}
	};

	/** 
	 * Clear the explorer, remove all assets.
	 *
	 * @method clear
	 */
	AssetExplorer.prototype.clear = function()
	{
		while(this.files.length > 0)
		{
			this.files.pop().destroy();
		}
	};

	AssetExplorer.prototype.updateSize = function()
	{
		Component.prototype.updateSize.call(this);

		this.bar.size.set(this.size.x, 25);
		this.bar.updateSize();

		this.assets.position.set(0, 25);
		this.assets.size.set(this.size.x, this.size.y - 20);
		this.assets.updateInterface();
	};

	/**
	 * The AnimationMixer is a player for animations on a particular object in the scene.
	 * 
	 * When multiple objects in the scene are animated independently, one AnimationMixer may be used for each object.
	 *
	 * The object stores animations in its animations attribute, wich is an array an of animation clips.
	 * 
	 * @class AnimationMixer
	 * @module Animation
	 * @extends {AnimationMixer}
	 * @param {Object3D} root Animation root object
	 */
	function AnimationMixer(root)
	{
		three.AnimationMixer.call(this, root);

		this.playing = false;
	}

	AnimationMixer.prototype = Object.create(three.AnimationMixer.prototype);

	/**
	 * Create actions from array of animations.
	 * 
	 * @method createActions
	 * @param {Array} actions Array of animations.
	 */
	AnimationMixer.prototype.createActions = function(animations)
	{
		for(var i = 0; i < animations.length; i++)
		{
			var action = this.clipAction(animations[i]);
			action.setLoop(animations[i].loop);
			action.weight = animations[i].weight;
			action.timeScale = animations[i].timeScale;
			action.enabled = animations[i].enabled;
			action.play();
		}

		return this._actions;
	};

	/**
	 * Set animation mixer time.
	 * 
	 * @method setTime
	 * @param {number} time Time in seconds.
	 */
	AnimationMixer.prototype.setTime = function(time)
	{
		this.time = time;

		for(var i = 0; i < this._actions.length; i++)
		{
			this._actions[i].time = time;
		}

		this.update(0, true);
	};

	/**
	 * Play animation.
	 * 
	 * @method play
	 */
	AnimationMixer.prototype.play = function()
	{
		this.playing = true;
	};

	/**
	 * Stop animation playback.
	 * 
	 * @method stop
	 */
	AnimationMixer.prototype.stop = function()
	{
		this.setTime(0);
		this.playing = false;
	};

	/**
	 * Pause animation playback.
	 * 
	 * @method pause
	 */
	AnimationMixer.prototype.pause = function()
	{
		this.playing = false;
	};

	AnimationMixer.prototype.dispose = function()
	{
		this.stopAllAction();
		this.uncacheRoot(this._root);
	};

	/**
	 * Update animation state.
	 * 
	 * @method update
	 * @param {number} delta Time since last call.
	 * @param {boolean} forceUpdate If set true the mixer is updated even if it isnt playing.
	 */
	AnimationMixer.prototype.update = function(delta, forceUpdate)
	{
		if(this.playing || forceUpdate)
		{
			this.time += delta;

			var direction = Math.sign(delta);

			// Run active actions
			for(var i = 0; i < this._actions.length; i++)
			{
				this._actions[i]._update(this.time, delta, direction, this._accuIndex);
			}

			// Update scene graph
			for(var i = 0; i < this._bindings.length; i++)
			{
				this._bindings[i].apply(this._accuIndex);
			}
		}

		return this;
	};

	/**
	 * Animation keyframe is a point the the animation track relative to a specific object.
	 *
	 * Keyframes can be added moved or deleted in the animation timeline.
	 *
	 * @class AnimationKeyframe
	 * @extends {Component}
	 */
	function AnimationKeyframe(parent, editor, trackEditor, track, index)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";
		this.element.style.cursor = "pointer";
		this.element.style.backgroundColor = track.color;

		this.trackEditor = trackEditor;
		this.editor = editor;
		this.track = track;
		this.index = index;

		var self = this;

		this.element.ondblclick = function(event)
		{
			var time = self.track.times[self.index];
			self.editor.mixer.setTime(time);
		};

		// this.elementframe context menu
		this.element.oncontextmenu = function(event)
		{
			var context = new ContextMenu(DocumentBody);
			context.size.set(150, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption(Locale.delete, function()
			{
				if(!Editor$1.confirm("Delete keyframe?"))
				{
					return;
				}

				if(self.track.times.length === 1)
				{
					Editor$1.alert("Track needs to have at least one keyframe!");
					return;
				}
				
				var times = [];
				for(var i = 0; i < self.track.times.length; i++)
				{
					if(i !== self.index)
					{
						times.push(self.track.times[i]);
					}
				}

				var values = [];
				var valueSize = self.track.getValueSize();
				var min = self.index * valueSize;
				var max = min + valueSize - 1;

				for(var i = 0; i < self.track.values.length; i++)
				{
					if(i < min || i > max)
					{
						values.push(self.track.values[i]);
					}
				}

				self.track.times = new Float32Array(times);
				self.track.values = new Float32Array(values);

				self.trackEditor.updateKeyframes();
				self.editor.createAnimationMixer();
			});

			context.addOption(Locale.move, function()
			{
				var time = Number.parseFloat(Editor$1.prompt("Keyframe time"));

				if(isNaN(time))
				{
					Editor$1.alert("Invalid time value!");
					return;
				}

				self.track.times[self.index] = time;
				self.track.sort();

				self.trackEditor.updateKeyframes();
				self.editor.createAnimationMixer();
			});

			context.updateInterface();
		};
	}

	AnimationKeyframe.prototype = Object.create(Component.prototype);

	function AnimationTrack(parent, editor, track)
	{
		Component.call(this, parent, "div");

		this.editor = editor;
		this.track = track;

		this.createKeyframes();
	}

	AnimationTrack.prototype = Object.create(Component.prototype);

	AnimationTrack.prototype.updateKeyframes = function()
	{
		this.removeAllChildren();
		this.createKeyframes();
	};

	AnimationTrack.prototype.createKeyframes = function()
	{
		var times = this.track.times;

		for(var k = 0; k < times.length; k++)
		{
			var key = new AnimationKeyframe(this, this.editor, this, this.track, k);
			key.size.set(5, 30);
			key.position.set(this.editor.zoom * times[k], 0);
			key.updateInterface();
		}
	};

	/**
	 * Button displyed on the left side that shows the attribute track being edited.
	 *
	 * @class AnimationTrackButton
	 * @extends {Component}
	 */
	function AnimationTrackButton(parent, editor, animation, track, trackTimeline)
	{
		Component.call(this, parent, "div");

		this.element.style.position = "relative";
		this.element.style.backgroundColor = "var(--bar-color)";
		this.element.style.width = "100%";
		this.element.style.height = "30px";

		this.editor = editor;
		this.animation = animation;
		this.track = track;
		this.trackTimeline = trackTimeline;

		var self = this;

		this.element.onmouseenter = function()
		{
			this.style.backgroundColor = "var(--button-over-color)";
		};

		this.element.onmouseleave = function()
		{
			this.style.backgroundColor = "var(--bar-color)";
		};

		this.element.oncontextmenu = function(event)
		{
			var track = self.track;
			var animation = self.animation;

			var context = new ContextMenu(DocumentBody);
			context.size.set(150, 20);
			context.position.set(event.clientX, event.clientY);
			
			context.addOption("Add Keyframe", function()
			{
				self.editor.addKeyFrame(track, self.editor.object);
				self.editor.createAnimationMixer(true);
				self.trackTimeline.updateKeyframes();
			});

			context.addOption(Locale.delete, function()
			{
				if(!Editor$1.confirm("Delete track?"))
				{
					return;
				}

				var index = animation.tracks.indexOf(track);
				if(index !== -1)
				{
					animation.tracks.splice(index, 1);
				}
				else
				{
					Editor$1.alert("Unable to delete track");
				}

				self.editor.createTimeline();
				self.editor.createAnimationMixer();
			});

			context.addOption("Optimize", function()
			{
				track.optimize();

				Editor$1.alert("Track optimized");

				self.trackTimeline.updateKeyframes();
				self.editor.createAnimationMixer();
			});

			context.addOption("Shift", function()
			{
				var time = Number.parseFloat(Editor$1.prompt("Time to shift track"));

				if(isNaN(time))
				{
					Editor$1.alert("Invalid time value");
					return;
				}

				track.shift(time);

				self.trackTimeline.updateKeyframes();
				self.editor.createAnimationMixer();
			});
			
			context.addOption("Trim", function()
			{
				var start = Number.parseFloat(Editor$1.prompt("Start time"));
				var end = Number.parseFloat(Editor$1.prompt("End time"));

				if(isNaN(start) || isNaN(end))
				{
					Editor$1.alert("Invalid time value");
					return;
				}

				track.trim(start, time);

				self.trackTimeline.updateKeyframes();
				self.editor.createAnimationMixer();
			});

			context.updateInterface();
		};

		this.name = document.createElement("div");
		this.name.style.position = "absolute";
		this.name.style.textOverflow = "ellipsis";
		this.name.style.whiteSpace = "nowrap";
		this.name.style.overflow = "hidden";
		this.name.style.top = "25%";
		this.name.style.width = "100%";
		this.name.style.pointerEvents = "none";
		this.element.appendChild(this.name);

		var keyframe = document.createElement("img");
		keyframe.style.position = "absolute";
		keyframe.style.right = "4px";
		keyframe.style.top = "7px";
		keyframe.style.width = "12px";
		keyframe.style.height = "12px";
		keyframe.style.cursor = "pointer";
		keyframe.src = Global.FILE_PATH + "icons/misc/add.png";
		keyframe.onclick = function()
		{
			self.editor.addKeyFrame(self.track, self.editor.object);
			self.editor.createAnimationMixer(true);
			self.trackTimeline.updateKeyframes();
		};
		this.element.appendChild(keyframe);

		this.interpolation = new DropdownList(this);
		this.interpolation.size.set(30, 18);
		this.interpolation.position.set(22, 5);
		this.interpolation.updatePosition(Component.TOP_RIGHT);
		this.interpolation.updateSize();
		this.interpolation.addValue(Locale.linear, three.InterpolateLinear);
		this.interpolation.addValue(Locale.smooth, three.Smooth);
		this.interpolation.addValue("Discrete", three.InterpolateDiscrete);
		this.interpolation.setOnChange(function()
		{
			self.track.setInterpolation(self.interpolation.getValue());
			self.editor.createAnimationMixer();
		});

		this.color = new ColorChooser(this);
		this.color.size.set(20, 18);
		this.color.position.set(57, 5);
		this.color.updatePosition(Component.TOP_RIGHT);
		this.color.updateSize();
		this.color.setOnChange(function()
		{
			self.track.color = self.color.getValueString();
			self.trackTimeline.updateKeyframes();
		});

		this.updateTrack();
	}

	AnimationTrackButton.prototype = Object.create(Component.prototype);

	AnimationTrackButton.prototype.updateTrack = function()
	{
		this.name.appendChild(document.createTextNode(this.track.name));
		this.color.setValueString(this.track.color);
		this.interpolation.setValue(this.track.getInterpolation());
	};

	AnimationTrackButton.prototype.updateInterface = function()
	{};

	/**
	 * Animation tab menu bar with options to set the properties of the animation clip.
	 *
	 * @class AnimationClipMenuBar
	 * @extends {Component}
	 */
	function AnimationClipMenuBar(parent, editor, animation)
	{
		Component.call(this, parent, "div");

		this.element.style.backgroundColor = "var(--bar-color)";
		this.element.style.position = "relative";
		this.element.style.width = "100%";
		this.element.style.height = "30px";

		this.editor = editor;
		this.animation = animation;

		var self = this;

		var text = new Text(this);
		text.position.set(5, 5);
		text.size.set(50, 20);
		text.setText(Locale.enabled);
		text.updateInterface();

		this.enabled = new CheckBox(this);
		this.enabled.position.set(55, 5);
		this.enabled.size.set(18, 18);
		this.enabled.updateInterface();
		this.enabled.setOnChange(function()
		{
			self.animation.enabled = self.enabled.getValue();
			self.editor.createAnimationMixer(true);
		});

		var text = new Text(this);
		text.position.set(70, 5);
		text.size.set(100, 20);
		text.setText(Locale.duration);
		text.updateInterface();

		this.duration = new NumberBox(this);
		this.duration.position.set(150, 5);
		this.duration.size.set(60, 18);
		this.duration.updateInterface();
		this.duration.setOnChange(function()
		{
			self.animation.duration = self.duration.getValue();
			self.editor.createTimeline();
			self.editor.createAnimationMixer();
		});

		var text = new Text(this);
		text.position.set(190, 5);
		text.size.set(100, 20);
		text.setText(Locale.loop);
		text.updateInterface();

		this.loop = new DropdownList(this);
		this.loop.position.set(260, 5);
		this.loop.size.set(90, 18);
		this.loop.addValue("Once", three.LoopOnce);
		this.loop.addValue(Locale.repeat, three.LoopRepeat);
		this.loop.addValue("PingPong", three.LoopPingPong);
		this.loop.updateInterface();
		this.loop.setOnChange(function()
		{
			self.animation.loop = self.loop.getValue();
			self.editor.createAnimationMixer(true);
		});

		var text = new Text(this);
		text.position.set(335, 5);
		text.size.set(100, 20);
		text.setText(Locale.speed);
		text.updateInterface();

		this.timeScale = new NumberBox(this);
		this.timeScale.position.set(410, 5);
		this.timeScale.size.set(60, 18);
		this.timeScale.updateInterface();
		this.timeScale.setOnChange(function()
		{
			self.animation.timeScale = self.timeScale.getValue();
			self.editor.createAnimationMixer(true);
		});

		this.updateAnimation();
	}

	AnimationClipMenuBar.prototype = Object.create(Component.prototype);

	AnimationClipMenuBar.prototype.updateAnimation = function()
	{
		this.loop.setValue(this.animation.loop);
		this.timeScale.setValue(this.animation.timeScale);
		this.duration.setValue(this.animation.duration);
		this.enabled.setValue(this.animation.enabled);
	};

	AnimationClipMenuBar.prototype.updateInterface = function(){};

	/**
	 * Button displyed on the left side that contains the name of the animation track.
	 *
	 * Each animation has multiple attribute tracks.
	 *
	 * @class AnimationClipButton
	 * @extends {Component}
	 */
	function AnimationClipButton(parent, editor, animation)
	{
		Component.call(this, parent, "div");

		this.element.style.position = "relative";
		this.element.style.width = "100%";
		this.element.style.height = "30px";

		this.editor = editor;
		this.animation = animation;

		var self = this;

		this.element.oncontextmenu = function(event)
		{
			var animation = self.animation;
			var object = self.editor.object;

			var context = new ContextMenu(DocumentBody);
			context.size.set(150, 20);
			context.position.set(event.clientX, event.clientY);
			context.addOption(Locale.rename, function()
			{
				var value = Editor$1.prompt("Rename animation", animation.name);
				if(value !== null && value !== "")
				{
					Editor$1.addAction(new ChangeAction(animation, "name", value));
					self.updateAnimation();
				}
			});
			context.addOption("Add track", function()
			{
				var attribute = Editor$1.prompt("Attribute");
				if(!attribute.startsWith("."))
				{
					attribute = "." + attribute;
				}

				var attributes = attribute.split(".");
				var value = object;

				for(var i = 0; i < attributes.length; i++)
				{
					if(attributes !== "")
					{
						var newValue = value[attributes[i]];
						
						if(newValue !== undefined)
						{
							value = newValue;
						}
					}
				}

				if(value === object)
				{
					Editor$1.alert("Attribute not found");
				}

				if(value.isVector3)
				{
					var track = new three.VectorKeyframeTrack(attribute, [0], value.toArray());
					track.setInterpolation(three.InterpolateLinear);
				}
				else if(value instanceof three.Color)
				{
					var track = new three.ColorKeyframeTrack(attribute, [0], value.toArray());
					track.setInterpolation(three.InterpolateLinear);
				}
				else if(value.isQuaternion)
				{
					var track = new three.QuaternionKeyframeTrack(attribute, [0], value.toArray());
					track.setInterpolation(three.InterpolateLinear);
				}
				else if(typeof value === "string")
				{
					var track = new three.StringKeyframeTrack(attribute, [0], [value]);
					track.setInterpolation(three.InterpolateDiscrete);
				}
				else if(typeof value === "boolean")
				{
					var track = new three.BooleanKeyframeTrack(attribute, [0], [value]);
					track.setInterpolation(three.InterpolateDiscrete);
				}
				else if(typeof value === "number")
				{
					var track = new three.NumberKeyframeTrack(attribute, [0], [value]);
					track.setInterpolation(three.InterpolateLinear);
				}
				else
				{
					console.warn("nunuStudio: Attribute it no animable", value);
					Editor$1.alert("Attribute is not animable");
					return;
				}

				track.setColor(MathUtils.randomColor());
				animation.tracks.push(track);
				self.editor.createTimeline();
				self.editor.createAnimationMixer();
			});
			context.addOption(Locale.delete, function()
			{
				if(!Editor$1.confirm("Delete animation?"))
				{
					return;
				}

				var index = object.animations.indexOf(animation);
				if(index !== -1)
				{
					object.animations.splice(index, 1);
				}
				else
				{
					Editor$1.alert("Unable to delete animation");
				}

				self.editor.createTimeline();
				self.editor.createAnimationMixer();
			});
			context.updateInterface();
		};

		this.element.onmouseenter = function()
		{
			this.style.backgroundColor = "var(--button-over-color)";
		};

		this.element.onmouseleave = function()
		{
			this.style.backgroundColor = "var(--bar-color)";
		};
		
		this.name = document.createElement("div");
		this.name.style.position = "absolute";
		this.name.style.textOverflow = "ellipsis";
		this.name.style.whiteSpace = "nowrap";
		this.name.style.overflow = "hidden";
		this.name.style.top = "25%";
		this.name.style.pointerEvents = "none";
		this.element.appendChild(this.name);

		this.updateAnimation();
	}

	AnimationClipButton.prototype = Object.create(Component.prototype);

	AnimationClipButton.prototype.updateAnimation = function()
	{
		this.name.appendChild(document.createTextNode(this.animation.name));
	};

	AnimationClipButton.prototype.updateInterface = function(){};

	/**
	 * Animation clip track contains all the elements of an animation track.
	 *
	 * Creates the animation clip button and option bar and all the tracks buttons and timegrids.
	 *
	 * @class AnimationClipTrack
	 */
	function AnimationClipTrack(editor, animation)
	{
		this.editor = editor;
		this.animation = animation;

		var tracks = animation.tracks;

		var width = this.editor.zoom * animation.duration;
		var height = 30 * tracks.length;

		var self = this;

		/**
		 * Button of the animation clip.
		 *
		 * @attribute button
		 * @type {AnimationClipButton}
		 */
		this.button = new AnimationClipButton(this.editor.info, this.editor, animation);

		/**
		 * Options of this animation clip track.
		 *
		 * @attribute options
		 * @type {AnimationClipMenuBar}
		 */
		this.options = new AnimationClipMenuBar(this.editor.tracks, this.editor, animation);

		this.timeline = document.createElement("div");
		this.timeline.style.overflowX = "auto";
		this.timeline.style.overflowY = "hidden";
		this.timeline.style.position = "relative";
		this.timeline.style.width = "100%";
		this.timeline.style.height = (height + 1) + "px";
		this.editor.tracks.element.appendChild(this.timeline);

		/**
		 * Timeline grid canvas where the timeline is drawn into.
		 *
		 * @attribute timegrid
		 * @type {Component}
		 */
		this.timegrid = document.createElement("canvas");
		this.timegrid.width = width + 1;
		this.timegrid.height = height + 1;
		this.timeline.appendChild(this.timegrid);

		var context = this.timegrid.getContext("2d");
		context.fillStyle = "#222222";
		for(var l = 0; l <= height; l += 30)
		{
			context.fillRect(0, l, width, 1);
		}
		for(var l = 0, step = this.editor.zoom / 10; l <= width; l += step)
		{
			context.fillRect(l, 0, 1, height);
		}

		var mouse = 0, initial = 0;

		// Seekbar
		this.seek = document.createElement("div");
		this.seek.style.position = "absolute";
		this.seek.style.backgroundColor = "var(--color-light)";
		this.seek.style.zIndex = "100";
		this.seek.style.top = "0px";
		this.seek.style.left = "0px";
		this.seek.style.width = "4px";
		this.seek.style.height = "100%";
		this.seek.style.overflow = "hidden";
		this.seek.style.cursor = "e-resize";
		this.seek.onmousedown = function(event)
		{
			initial = self.editor.mixer._actions[0].time;
			mouse = event.clientX;

			self.manager.create();
		};
		this.timeline.appendChild(this.seek);

		// Seekbar manager
		this.manager = new EventManager();
		this.manager.add(window, "mousemove", function(event)
		{
			var time = initial + (event.clientX - mouse) / self.editor.zoom;

			if(time < 0)
			{
				time = 0;
			}
			else if(time > self.animation.duration)
			{
				time = self.animation.duration;
			}

			self.editor.mixer.setTime(time > 0 ? time : 0);

			Editor$1.gui.inspector.updateValues();
		});
		this.manager.add(window, "mouseup", function(event)
		{
			self.manager.destroy();
		});

		// Tracks
		for(var j = 0; j < tracks.length; j++)
		{
			var track = new AnimationTrack(this.timeline, this.editor, tracks[j]);
			track.position.set(0, j * 30);
			track.size.set(width, 30);
			track.updateInterface();
			
			var button = new AnimationTrackButton(this.editor.info, this.editor, animation, tracks[j], track);
			button.position.set(0, j * 30);
			button.size.set(0, 30);
			button.updateInterface();
		}
	}

	/**
	 * The animation tab is used to display and edit object animations timelines.
	 *
	 * Animations can be composed of multiple tracks. A object can have multiple animations.
	 *
	 * Each track is composed of keyframes that represent the states of the animation.
	 *
	 * @class AnimationTab
	 * @extends {AnimationTab}
	 * @param {Component} parent
	 */
	function AnimationTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, "Animation", Global.FILE_PATH + "icons/misc/animation.png");

		var self = this;

		this.mixer = null;
		this.object = null;
		this.clock = new three.Clock();
		
		this.zoom = 120.0; // Pixels/sec
		this.animations = [];

		/**
		 * Menu bar where the options to create animation clip, and play the animation controls are located.
		 *
		 * @attribute bar
		 * @type {Component}
		 */
		this.bar = new Component(this, "div");
		this.bar.size.set(0, 25);
		this.bar.element.style.position = "absolute";
		this.bar.element.style.height = "25px";
		this.bar.element.style.width = "100%";
		this.bar.element.style.backgroundColor = "var(--bar-color)";

		/**
		 * Add animation clip button.
		 *
		 * @attribute add
		 * @type {ButtonText}
		 */
		this.add = new ButtonText(this.bar);
		this.add.position.set(0, 0);
		this.add.size.set(100, this.bar.size.y);
		this.add.setText(Locale.add);
		this.add.updateInterface();
		this.add.setOnClick(function()
		{
			if(self.object !== null)
			{
				if(self.object.animations === undefined)
				{
					self.object.animations = [];
				}

				var clip = new AnimationClip("Animation" + self.object.animations.length, 3, []);
				
				// Object 3D
				if(self.object.isObject3D)
				{
					var position = new three.VectorKeyframeTrack(".position", [0], self.object.position.toArray());
					position.setInterpolation(three.InterpolateLinear);
					position.setColor("#FF0000");
					clip.tracks.push(position);

					var scale = new three.VectorKeyframeTrack(".scale", [0], self.object.scale.toArray());
					scale.setInterpolation(three.InterpolateLinear);
					scale.setColor("#00FF00");
					clip.tracks.push(scale);

					var quaternion = new three.QuaternionKeyframeTrack(".quaternion", [0], self.object.quaternion.toArray());
					quaternion.setInterpolation(three.InterpolateLinear);
					quaternion.setColor("#0000FF");
					clip.tracks.push(quaternion);
					
					var visible = new three.BooleanKeyframeTrack(".visible", [0], [self.object.visible]);
					visible.setInterpolation(three.InterpolateDiscrete);
					visible.setColor("#FFFF00");
					clip.tracks.push(visible);
				}
				// Material
				else if(self.object.isMaterial)
				{
					if(self.object.color !== undefined)
					{
						console.log(self.object.color);

						var color = new three.ColorKeyframeTrack(".color", [0], [self.object.color]);
						color.setInterpolation(three.InterpolateLinear);
						color.setColor("#00FF00");
						clip.tracks.push(color);
					}

					var opacity = new three.NumberKeyframeTrack(".opacity", [0], [self.object.opacity]);
					opacity.setInterpolation(three.InterpolateLinear);
					opacity.setColor("#FF0000");
					clip.tracks.push(opacity);
				}

				self.object.animations.push(clip);
				self.attach(self.object);
			}
			else
			{
				Editor$1.alert(Locale.selectObjectEditAnimation);
			}
		});

		this.play = new ButtonText(this.bar);
		this.play.position.set(100, 0);
		this.play.size.set(100, this.bar.size.y);
		this.play.setText(Locale.play);
		this.play.updateInterface();
		this.play.setOnClick(function()
		{
			if(self.mixer == null)
			{
				Editor$1.alert("No animation found!");
				return;
			}

			if(self.mixer.playing)
			{
				self.mixer.pause();
				self.play.setText(Locale.play);
			}
			else
			{
				self.mixer.play();
				self.play.setText("Pause");
			}
		});

		this.stop = new ButtonText(this.bar);
		this.stop.position.set(200, 0);
		this.stop.size.set(100, this.bar.size.y);
		this.stop.setText("Stop");
		this.stop.updateInterface();
		this.stop.setOnClick(function()
		{
			if(self.mixer == null)
			{
				Editor$1.alert("No animation playing!");
				return;
			}

			self.play.setText(Locale.play);
			self.mixer.stop();
		});

		this.zoomSlider = new Slider(this.bar);
		this.zoomSlider.size.set(100, 15);
		this.zoomSlider.position.set(30, 0);
		this.zoomSlider.setStep(10);
		this.zoomSlider.setRange(20, 1000);
		this.zoomSlider.updatePosition(Component.TOP_RIGHT);
		this.zoomSlider.updateSize();
		this.zoomSlider.setValue(this.zoom);
		this.zoomSlider.setOnChange(function()
		{
			self.zoom = self.zoomSlider.getValue();
			self.createTimeline();
		});
		this.zoomSlider.text.style.right = "5px";

		this.zoomText = new Text(this.bar);
		this.zoomText.setText(Locale.zoom);
		this.zoomText.size.set(90, 15);
		this.zoomText.position.set(110, 0);
		this.zoomText.updatePosition(Component.TOP_RIGHT);
		this.zoomText.updateSize();

		/**
		 * Timeline division (movable tab) occupies the hole tab except for the options bar.
		 *
		 * Contains the info on the left and tracks on right side.
		 *
		 * @property timeline
		 * @type {Component}
		 */
		this.timeline = new Component(this, "div");
		this.timeline.element.style.overflowY = "auto";

		/**
		 * Information button tab.
		 *
		 * @property info
		 * @type {Division}
		 */
		this.info = new Division(this.timeline);
		this.info.element.style.backgroundColor = "var(--bar-color)";

		/**
		 * Tracks section.
		 *
		 * @property info
		 * @type {Division}
		 */
		this.tracks = new Division(this.timeline);

		/**
		 * Text shown when there is no object selected to display animation timeline.
		 *
		 * @attribute emptyText
		 * @type {Text}
		 */
		this.emptyText = new Text(this);
		this.emptyText.allowWordBreak(true);
		this.emptyText.setTextSize(12);
		this.emptyText.setTextColor("var(--color-light)");
		this.emptyText.setText(Locale.selectObjectEditAnimation);

		// Temporary variables for mouse movement
		var mouse = 0, initial = 0;

		/**
		 * Resize tab placed between the info and tracks divisions
		 *
		 * @property tab
		 * @type {Component}
		 */
		this.tab = document.createElement("div");
		this.tab.style.backgroundColor = "var(--bar-color)";
		this.tab.style.position = "absolute";
		this.tab.style.cursor = "e-resize";
		this.tab.style.width = "5px";
		this.tab.style.top = "0px";
		this.tab.style.height = "100%";
		this.tab.position = 250;
		this.timeline.element.appendChild(this.tab);

		this.tab.onmousedown = function(event)
		{
			mouse = event.clientX;
			initial = this.position;
			self.tabManager.create();
		};

		/** 
		 * Tab drag event manager.
		 *
		 * @property tabManager
		 * @type {EventManager}
		 */
		this.tabManager = new EventManager();
		this.tabManager.add(window, "mousemove", function(event)
		{
			self.tab.position = initial + (event.clientX - mouse);
			self.updateInterface();
		});
		this.tabManager.add(window, "mouseup", function(event)
		{
			self.tabManager.destroy();
		});
	}

	AnimationTab.prototype = Object.create(TabComponent.prototype);

	AnimationTab.prototype.attach = function(object)
	{
		this.object = object;

		if(this.object !== null)
		{
			this.createAnimationMixer();
			this.createTimeline();
		}
		else
		{
			this.clearAnimationMixer();
			this.clearTimeline();
		}

		this.emptyText.setVisibility(this.object === null);
	};

	AnimationTab.prototype.activate = function()
	{
		TabComponent.prototype.activate.call(this);

		this.updateSelection();
	};

	AnimationTab.prototype.deactivate = function()
	{
		TabComponent.prototype.deactivate.call(this);

		if(this.mixer !== null && this.mixer.playing)
		{
			this.play.setText(Locale.play);
			this.mixer.stop();
		}
	};

	AnimationTab.prototype.updateSelection = function()
	{
		this.attach(Editor$1.selection.length > 0 ? Editor$1.selection[0] : null);
	};

	/**
	 * Clear animation mixer object.
	 *
	 * @method clearAnimationMixer
	 */
	AnimationTab.prototype.clearAnimationMixer = function(keepTime)
	{
		if(this.mixer !== null)
		{
			this.play.setText(Locale.play);
			this.mixer.stop();
			this.mixer.dispose();
			this.mixer = null;
		}
	};

	/**
	 * Create a new animation mixer for the attached object.
	 *
	 * Destroy the old animation mixed and recreate a new one.
	 *
	 * @method createAnimationMixer
	 */
	AnimationTab.prototype.createAnimationMixer = function(keepTime)
	{
		var time = 0;

		// Remove old mixer
		if(this.mixer !== null)
		{
			if(keepTime)
			{
				time = this.mixer.time;
			}

			this.clearAnimationMixer();
		}

		// Check if the object has animations
		if(this.object !== null && this.object.animations !== undefined)
		{
			this.mixer = new AnimationMixer(this.object);
			this.mixer.createActions(this.object.animations);
			this.mixer.setTime(time);
		}
	};

	AnimationTab.prototype.update = function()
	{
		if(this.mixer !== null)
		{
			for(var i = 0; i < this.mixer._actions.length; i++)
			{
				this.animations[i].seek.style.left = (this.mixer._actions[i].time * this.zoom) + "px";
			}

			this.mixer.update(this.clock.getDelta());

			// Update object panel when playing
			if(this.mixer.playing)
			{
				Editor$1.gui.inspector.updateValues();
			}
		}
	};

	/**
	 * Clear timeline GUI elements.
	 *
	 * @method clearTimeline
	 */
	AnimationTab.prototype.clearTimeline = function()
	{
		this.tracks.removeAllChildren();
		this.info.removeAllChildren();
	};

	/**
	 * Create new timeline GUI elements remove the old ones from the tab.
	 *
	 * @method createTimeline
	 */
	AnimationTab.prototype.createTimeline = function()
	{
		this.clearTimeline();
		this.animations = [];

		if(this.object !== null && this.object.animations !== undefined)
		{
			var animations = this.object.animations;

			for(var i = 0; i < animations.length; i++)
			{
				this.animations.push(new AnimationClipTrack(this, animations[i]));
			}
		}

		this.updateInterface();
	};

	/**
	 * Add a new keyframe to a specific track with a specific value.
	 *
	 * @method addKeyframe
	 * @param {Object} track
	 * @param {Object} value
	 */
	AnimationTab.prototype.addKeyFrame = function(track, value)
	{
		var attributes = track.name.split(".");

		for(var i = 0; i < attributes.length; i++)
		{
			if(attributes !== "")
			{
				var newValue = value[attributes[i]];
				
				if(newValue !== undefined)
				{
					value = newValue;
				}
			}
		}

		value = (value.toArray !== undefined) ? value.toArray() : [value];

		// Check if there is already a keyframe with same time
		for(var i = 0; i < track.times.length; i++)
		{
			if(track.times[i] === this.mixer.time)
			{
				break;
			}
		}

		// If there is already a keyframe with time update values
		if(i < track.times.length)
		{
			var valueSize = track.getValueSize();
			var index = i * valueSize;

			for(var i = 0; i < valueSize; i++)
			{
				track.values[index] = value[i];
				index++;
			}
		}
		// Add new keyframe to track
		else
		{
			var times = [];
			for(var i = 0; i < track.times.length; i++)
			{
				times.push(track.times[i]);
			}
			times.push(this.mixer.time);

			var values = [];
			for(var i = 0; i < track.values.length; i++)
			{
				values.push(track.values[i]);
			}
			values = values.concat(value);

			track.times = new Float32Array(times);
			track.values = new Float32Array(values);

			track.sort();
		}
	};

	AnimationTab.prototype.updateInterface = function()
	{
		if(this.visible)
		{
			// Timeline
			this.timeline.position.set(0, this.bar.size.y);
			this.timeline.size.set(this.size.x, this.size.y - this.bar.size.y);
			this.timeline.updateInterface();

			// Tab
			this.tab.style.left = this.tab.position + "px";

			// Information
			this.info.size.set(this.tab.position, this.size.y - this.bar.size.y);
			this.info.updateInterface();
			
			// Tracks
			this.tracks.position.set(this.tab.position + 5, 0);
			this.tracks.size.set(this.size.x - this.tracks.position.x, this.size.y - this.bar.size.y);
			this.tracks.updateInterface();
			
			// Empty text
			this.emptyText.position.set(0, 0);
			this.emptyText.size.set(this.size.x, this.size.y);
			this.emptyText.updateInterface();

			// Element
			this.element.style.display = "block";
			this.element.style.top = this.position.y + "px";
			this.element.style.left = this.position.x + "px";
			this.element.style.width = this.size.x + "px";
			this.element.style.height = this.size.y + "px";
		}
		else
		{
			this.element.style.display = "none";
		}
	};

	/**
	 * The twist modifier applies a tornado twist like deformation to the geometry.
	 *
	 * It follows a vector from a start to and end point in the vector and rotates all vertex for each point up to a defined final angle.
	 *
	 * @class TwistModifier
	 */
	function TwistModifier(angle, start, end)
	{
		/**
		 * Indicates if the output should be a buffer geometry or a regular geometry.
		 *
		 * @attribute bufferGeometry
		 * @type {boolean}
		 */
		this.bufferGeometry = false;

		/**
		 * Twist direction vector, the twist is performed around this vector in its direction.
		 *
		 * @attribute direction
		 * @type {Vector3}
		 */
		this.direction = new three.Vector3(0, 1, 0);

		/**
		 * Twist angle of rotation, applied from the start to the end of rotation.
		 *
		 * @attribute angle
		 * @type {number}
		 */
		this.angle = angle !== undefined ? angle : Math.PI;

		/**
		 * Start height of the twist rotation.
		 *
		 * This values is in geometry coordinate space.
		 *
		 * @attribute start
		 * @type {number}
		 */
		this.start = start !== undefined ? start : 0;

		/*
		 * End height of the twist rotation.
		 *
		 * This values is in geometry coordinate space.
		 *
		 * @attribute end
		 * @type {number}
		 */
		this.end = end !== undefined ? end : 1;
	}

	/**
	 * Apply the modifier to a geometry object, creates a new geometry with the result.
	 *
	 * @method modify
	 * @param {Geometry | BufferGeometry} geometry Geometry to be transformed.
	 * @return {Geometry | BufferGeometry} Result geometry after applying the modifier.
	 */
	TwistModifier.prototype.modify = function(geometry)
	{
		// Convert the geometry from buffer geometry to regular geometry
		if(geometry instanceof three.BufferGeometry)
		{
			geometry = new three.Geometry();
			geometry.fromBufferGeometry(Editor.selection[0].geometry);
			geometry.mergeVertices();
		}
		else
		{
			geometry = geometry.clone();
		}

		// Apply transformation to all vertices in the geometry.
		var quaternion = new three.Quaternion();

		for(var i = 0; i < geometry.vertices.length; i++)
		{
			var y = geometry.vertices[i].y;

			if(y >= this.start && y <= this.end)
			{
				// Calculate angle to apply interpolated from start to end
				var interpolate = (y - this.start) / (this.end - this.start);

				quaternion.setFromAxisAngle(this.direction, this.angle * interpolate);
				geometry.vertices[i].applyQuaternion(quaternion);
			}
			else if(y > this.end)
			{
				quaternion.setFromAxisAngle(this.direction, this.angle);
				geometry.vertices[i].applyQuaternion(quaternion);
			}
		}

		geometry.computeVertexNormals();
		geometry.verticesNeedUpdate = true;

		// Convert to buffer geometry if necessary
		if(this.bufferGeometry)
		{
			var bufferGeometry = new three.BufferGeometry();
			bufferGeometry.fromGeometry(geometry);
			return bufferGeometry;
		}

		return geometry;	 
	};

	function UnitsSettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.units, Global.FILE_PATH + "icons/misc/ruler.png");

		this.element.style.overflow = "auto";

		var self = this;

		// Angle
		this.form = new TableForm(this);
		this.form.defaultTextWidth = 125;
		this.form.setAutoSize(false);

		this.form.addText(Locale.units);
		this.form.nextRow();
		
		this.form.addText(Locale.angle);
		this.angle = new DropdownList(this.form);
		this.angle.size.set(150, 18);
		this.angle.addValue(Locale.radians, Settings.RADIAN);
		this.angle.addValue(Locale.degrees, Settings.DEGREE);
		this.angle.setOnChange(function()
		{
			Editor$1.settings.units.angle = self.angle.getValue();
		});
		this.form.add(this.angle);
		this.form.nextRow();

		// Distance
		this.form.addText(Locale.distance);
		this.distance = new DropdownList(this.form);
		this.distance.size.set(150, 18);
		this.distance.addValue(Locale.meters, Settings.METER);
		this.distance.setOnChange(function()
		{
			Editor$1.settings.units.distance = self.distance.getValue();
		});
		this.form.add(this.distance);
		this.form.nextRow();
	}

	UnitsSettingsTab.prototype = Object.create(TabComponent.prototype);

	UnitsSettingsTab.prototype.activate = function()
	{
		this.angle.setValue(Editor$1.settings.units.angle);
		this.distance.setValue(Editor$1.settings.units.distance);
	};

	UnitsSettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);
		
		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	function RenderSettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.render, Global.FILE_PATH + "icons/misc/particles.png");

		this.element.style.overflow = "auto";

		var self = this;

		this.form = new TableForm(this);
		this.form.setAutoSize(false);
		this.form.defaultTextWidth = 125;

		// Renderer settings
		this.form.addText("Renderer Quality");
		this.form.nextRow();

		// Use project settings
		this.form.addText("Follow project").setAltText("If checked the project rendering settings will be used, its better to preview the final result.");
		this.followProject = new CheckBox(this.form);
		this.followProject.size.set(18, 18);
		this.followProject.setOnChange(function()
		{
			Editor$1.settings.render.followProject = self.followProject.getValue();
		});
		this.form.add(this.followProject);
		this.form.nextRow();

		// Space
		this.form.addText("");
		this.form.nextRow();

		// Editor rendering quality
		this.form.addText("Editor Rendering Quality");
		this.form.nextRow();
		this.rendererConfiguration = new RendererConfigurationFormSnippet(this.form, Editor$1.settings.render);
	}

	RenderSettingsTab.prototype = Object.create(TabComponent.prototype);

	RenderSettingsTab.prototype.activate = function()
	{
		this.followProject.setValue(Editor$1.settings.render.followProject);
		this.rendererConfiguration.attach(Editor$1.settings.render);
	};

	RenderSettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);
		
		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	function JSHintSettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.javascript, Global.FILE_PATH + "icons/misc/js.png");

		this.element.style.overflow = "auto";

		var self = this;

		this.form = new TableForm(this);
		this.form.defaultTextWidth = 125;
		this.form.setAutoSize(false);
		
		// Javascript
		this.form.addText(Locale.javascript);
		this.form.nextRow();

		// Bitwise
		this.form.addText("Warn Bitwise").setAltText("Prohibit bitwise operators (&, |, ^, etc.)");
		this.bitwise = new CheckBox(this.form);
		this.bitwise.size.set(18, 18);
		this.bitwise.setOnChange(function()
		{
			Editor$1.settings.jslint.bitwise = self.bitwise.getValue();
		});
		this.form.add(this.bitwise);
		this.form.nextRow();

		// Curly
		this.form.addText("Require curly").setAltText("Require {} for every new block or scope");
		this.curly = new CheckBox(this.form);
		this.curly.size.set(18, 18);
		this.curly.setOnChange(function()
		{
			Editor$1.settings.jslint.curly = self.curly.getValue();
		});
		this.form.add(this.curly);
		this.form.nextRow();

		// Eqeqeq
		this.form.addText("Require ===").setAltText("Require triple equals (===) for comparison");
		this.eqeqeq = new CheckBox(this.form);
		this.eqeqeq.size.set(18, 18);
		this.eqeqeq.setOnChange(function()
		{
			Editor$1.settings.jslint.eqeqeq = self.eqeqeq.getValue();
		});
		this.form.add(this.eqeqeq);
		this.form.nextRow();

		// For...in
		this.form.addText("Filtering for...in").setAltText("Require filtering for..in loops with obj.hasOwnProperty()");
		this.forin = new CheckBox(this.form);
		this.forin.size.set(18, 18);
		this.forin.setOnChange(function()
		{
			Editor$1.settings.jslint.forin = self.forin.getValue();
		});
		this.form.add(this.forin);
		this.form.nextRow();

		// Freeze
		this.form.addText("Freeze").setAltText("Prohibits overwriting prototypes of native objects such as Array, Date etc");
		this.freeze = new CheckBox(this.form);
		this.freeze.size.set(18, 18);
		this.freeze.setOnChange(function()
		{
			Editor$1.settings.jslint.freeze = self.freeze.getValue();
		});
		this.form.add(this.freeze);
		this.form.nextRow();

		// Latedef
		this.form.addText("Late definition").setAltText("Require variables/functions to be defined before being used");
		this.latedef = new CheckBox(this.form);
		this.latedef.size.set(18, 18);
		this.latedef.setOnChange(function()
		{
			Editor$1.settings.jslint.latedef = self.latedef.getValue();
		});
		this.form.add(this.latedef);
		this.form.nextRow();

		// Noarg
		this.form.addText("No arguments").setAltText("Prohibit use of `arguments.caller` and `arguments.callee`");
		this.noarg = new CheckBox(this.form);
		this.noarg.size.set(18, 18);
		this.noarg.setOnChange(function()
		{
			Editor$1.settings.jslint.noarg = self.noarg.getValue();
		});
		this.form.add(this.noarg);
		this.form.nextRow();

		// Nonbsp
		this.form.addText("Non bsp").setAltText("Prohibit non-breaking whitespace characters.");
		this.nonbsp = new CheckBox(this.form);
		this.nonbsp.size.set(18, 18);
		this.nonbsp.setOnChange(function()
		{
			Editor$1.settings.jslint.nonbsp = self.nonbsp.getValue();
		});
		this.form.add(this.nonbsp);
		this.form.nextRow();

		// NoNew
		this.form.addText("No new").setAltText("Prohibit use of constructors for side-effects (without assignment)");
		this.nonew = new CheckBox(this.form);
		this.nonew.size.set(18, 18);
		this.nonew.setOnChange(function()
		{
			Editor$1.settings.jslint.nonew = self.nonew.getValue();
		});
		this.form.add(this.nonew);
		this.form.nextRow();

		// Pluplus
		this.form.addText("Warn ++").setAltText("Prohibit use of ++ and --");
		this.plusplus = new CheckBox(this.form);
		this.plusplus.size.set(18, 18);
		this.plusplus.setOnChange(function()
		{
			Editor$1.settings.jslint.plusplus = self.plusplus.getValue();
		});
		this.form.add(this.plusplus);
		this.form.nextRow();

		// Pluplus
		this.form.addText("Warn Undefined").setAltText("Require all non-global variables to be declared (prevents global leaks)");
		this.undef = new CheckBox(this.form);
		this.undef.size.set(18, 18);
		this.undef.setOnChange(function()
		{
			Editor$1.settings.jslint.undef = self.undef.getValue();
		});
		this.form.add(this.undef);
		this.form.nextRow();

		// Blank Space
		this.form.addText("");
		this.form.nextRow();

		// Relaxing options
		this.form.addText("Relaxing Options");
		this.form.nextRow();

		this.form.addText("No semicolons").setAltText("Tolerate Automatic Semicolon Insertion (no semicolons)");
		this.asi = new CheckBox(this.form);
		this.asi.size.set(18, 18);
		this.asi.setOnChange(function()
		{
			Editor$1.settings.jslint.asi = self.asi.getValue();
		});
		this.form.add(this.asi);
		this.form.nextRow();

		this.form.addText("Assign on compare").setAltText("Tolerate assignments where comparisons would be expected");
		this.boss = new CheckBox(this.form);
		this.boss.size.set(18, 18);
		this.boss.setOnChange(function()
		{
			Editor$1.settings.jslint.boss = self.boss.getValue();
		});
		this.form.add(this.boss);
		this.form.nextRow();

		this.form.addText("Debug statement").setAltText("Allow debugger statements e.g. browser breakpoints.");
		this.debug = new CheckBox(this.form);
		this.debug.size.set(18, 18);
		this.debug.setOnChange(function()
		{
			Editor$1.settings.jslint.debug = self.debug.getValue();
		});
		this.form.add(this.debug);
		this.form.nextRow();

		this.form.addText("Null compare").setAltText("Tolerate use of == null");
		this.eqnull = new CheckBox(this.form);
		this.eqnull.size.set(18, 18);
		this.eqnull.setOnChange(function()
		{
			Editor$1.settings.jslint.eqnull = self.eqnull.getValue();
		});
		this.form.add(this.eqnull);
		this.form.nextRow();

		this.form.addText("ECMAScript Version").setAltText("Specify the ECMAScript version to which the code must adhere");
		this.esversion = new DropdownList(this.form);
		this.esversion.size.set(50, 18);
		this.esversion.addValue(5, 5);
		this.esversion.addValue(6, 6);
		this.esversion.setOnChange(function()
		{
			Editor$1.settings.jslint.esversion = self.esversion.getValue();
		});
		this.form.add(this.esversion);
		this.form.nextRow();

		this.form.addText("Allow moz").setAltText("Allow Mozilla specific syntax (extends and overrides esnext features)");
		this.moz = new CheckBox(this.form);
		this.moz.size.set(18, 18);
		this.moz.setOnChange(function()
		{
			Editor$1.settings.jslint.moz = self.moz.getValue();
		});
		this.form.add(this.moz);
		this.form.nextRow();

		this.form.addText("Allow eval").setAltText("Tolerate use of eval() and new Function()");
		this.evil = new CheckBox(this.form);
		this.evil.size.set(18, 18);
		this.evil.setOnChange(function()
		{
			Editor$1.settings.jslint.evil = self.evil.getValue();
		});
		this.form.add(this.evil);
		this.form.nextRow();
	}

	JSHintSettingsTab.prototype = Object.create(TabComponent.prototype);

	JSHintSettingsTab.prototype.activate = function()
	{
		this.bitwise.setValue(Editor$1.settings.jslint.bitwise);
		this.curly.setValue(Editor$1.settings.jslint.curly);
		this.eqeqeq.setValue(Editor$1.settings.jslint.eqeqeq);
		this.forin.setValue(Editor$1.settings.jslint.forin);
		this.freeze.setValue(Editor$1.settings.jslint.freeze);
		this.latedef.setValue(Editor$1.settings.jslint.latedef);
		this.noarg.setValue(Editor$1.settings.jslint.noarg);
		this.nonbsp.setValue(Editor$1.settings.jslint.nonbsp);
		this.nonew.setValue(Editor$1.settings.jslint.nonew);
		this.plusplus.setValue(Editor$1.settings.jslint.plusplus);
		this.undef.setValue(Editor$1.settings.jslint.undef);

		this.asi.setValue(Editor$1.settings.jslint.asi);
		this.boss.setValue(Editor$1.settings.jslint.boss);
		this.debug.setValue(Editor$1.settings.jslint.debug);
		this.eqnull.setValue(Editor$1.settings.jslint.eqnull);
		this.esversion.setValue(Editor$1.settings.jslint.esversion);
		this.moz.setValue(Editor$1.settings.jslint.moz);
		this.evil.setValue(Editor$1.settings.jslint.evil);
	};

	JSHintSettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);
		
		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	/**
	 * Theme manager is where the GUI themes are registered and accessed.
	 *
	 * Themes are loaded from CSS files using variables.
	 *
	 * @static
	 * @class ThemeManager
	 */
	function ThemeManager(){}

	/**
	 * Map of themes registered in the manager by their name.
	 *
	 * Associates the theme name and its CSS selector.
	 *
	 * @static
	 * @property themes
	 * @type {Map<string, string>}
	 */
	ThemeManager.themes = [];

	/**
	 * Add theme to list to associate the theme name with its CSS selector.
	 *
	 * @static
	 * @method register
	 */
	ThemeManager.register = function(theme, name)
	{
		ThemeManager.themes[name] = theme;
	};

	/**
	 * Get the list of themes available by their name.
	 *
	 * @static
	 * @method getList
	 */
	ThemeManager.getList = function()
	{
		return Object.keys(ThemeManager.themes);
	};

	function GeneralSettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.general, Global.FILE_PATH + "icons/misc/tool.png");

		this.element.style.overflow = "auto";

		var self = this;

		this.form = new TableForm(this);
		this.form.defaultTextWidth = 125;
		this.form.setAutoSize(false);

		// General text
		this.form.addText(Locale.general);
		this.form.nextRow();
		
		// Ignore device pixel ratio
		this.form.addText(Locale.ignorePixelRatio).setAltText(Locale.hintIgnorePixelRatio);
		this.ignorePixelRatio = new CheckBox(this.form);
		this.ignorePixelRatio.size.set(18, 18);
		this.ignorePixelRatio.setOnChange(function()
		{
			Editor$1.settings.general.ignorePixelRatio = self.ignorePixelRatio.getValue();
			Editor$1.resize();
		});
		this.form.add(this.ignorePixelRatio);
		this.form.nextRow();

		// Theme
		this.form.addText(Locale.theme);
		this.theme = new DropdownList(this.form);
		this.theme.size.set(150, 18);
		this.theme.setOnChange(function()
		{
			var value = self.theme.getValue();
			Editor$1.settings.general.theme = value;
		});
		this.form.add(this.theme);
		this.form.nextRow();

		// Fill theme dropdown
		var list = ThemeManager.getList();
		for(var i = 0; i < list.length; i++)
		{
			var theme = list[i];
			this.theme.addValue(theme, theme);
		}

		// History size
		this.form.addText(Locale.historySize).setAltText(Locale.hintHistory);
		this.historySize = new NumberBox(this.form);
		this.historySize.size.set(60, 18);
		this.historySize.setRange(1.0, Number.MAX_SAFE_INTEGER);
		this.historySize.setStep(1.0);
		this.historySize.setOnChange(function()
		{
			Editor$1.settings.general.historySize = self.historySize.getValue();
			Editor$1.history.limit = Editor$1.settings.general.historySize;
		});
		this.form.add(this.historySize);
		this.form.nextRow();

		this.form.addText(Locale.reset).setAltText("Reset editor back to default settings.");
		this.resetDefault = new ButtonText(this.form);
		this.resetDefault.setText("Reset settings");
		this.resetDefault.size.set(120, 18);
		this.resetDefault.setOnClick(function()
		{
			if(Editor$1.confirm("Reset back to default settings?"))
			{
				Editor$1.settings.loadDefault();
				Editor$1.settings.store();
			}
		});
		this.form.add(this.resetDefault);
		this.form.nextRow();

		// Auto update
		if(Nunu.runningOnDesktop())
		{
			this.form.addText(Locale.autoUpdate).setAltText("If checked the editor will auto-update to the latest version.");
			this.autoUpdate = new CheckBox(this.form);
			this.autoUpdate.size.set(18, 18);
			this.autoUpdate.setOnChange(function()
			{
				Editor$1.settings.general.autoUpdate = self.autoUpdate.getValue();

				if(Editor$1.settings.general.autoUpdate)
				{
					Editor$1.updateNunu();
				}
			});
			this.form.add(this.autoUpdate);
			this.form.nextRow();	
		}
		
		// Blank Space
		this.form.addText("");
		this.form.nextRow();

		// Scene editor
		this.form.addText("Testing");
		this.form.nextRow();

		// Immediate mode
		this.form.addText("Use immediate mode").setAltText("If checked objects changed during runtime test will keep their state when the testing mode stops.");
		this.immediateMode = new CheckBox(this.form);
		this.immediateMode.size.set(18, 18);
		this.immediateMode.setOnChange(function()
		{
			Editor$1.settings.general.immediateMode = self.immediateMode.getValue();
		});
		this.form.add(this.immediateMode);
		this.form.nextRow();
	}

	GeneralSettingsTab.prototype = Object.create(TabComponent.prototype);

	GeneralSettingsTab.prototype.activate = function()
	{
		this.theme.setValue(Editor$1.settings.general.theme);
		if(this.autoUpdate !== undefined)
		{
			this.autoUpdate.setValue(Editor$1.settings.general.autoUpdate);
		}
		this.historySize.setValue(Editor$1.settings.general.historySize);
		this.ignorePixelRatio.setValue(Editor$1.settings.general.ignorePixelRatio);
		this.immediateMode.setValue(Editor$1.settings.general.immediateMode);
	};

	GeneralSettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);
		
		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	function EditorSettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.editor, Global.FILE_PATH + "icons/misc/scene.png");

		this.element.style.overflow = "auto";

		var self = this;

		this.form = new TableForm(this);
		this.form.defaultTextWidth = 125;
		this.form.setAutoSize(false);

		// Scene editor
		this.form.addText(Locale.editor);
		this.form.nextRow();

		// Show stats
		this.form.addText("Show performance").setAltText("Show performance information in the scene editor.");
		this.showStats = new CheckBox(this.form);
		this.showStats.size.set(18, 18);
		this.showStats.setOnChange(function()
		{
			Editor$1.settings.general.showStats = self.showStats.getValue();
		});
		this.form.add(this.showStats);
		this.form.nextRow();

		// Enable Grid
		this.form.addText("Show grid");
		this.gridEnabled = new CheckBox(this.form);
		this.gridEnabled.size.set(18, 18);
		this.gridEnabled.setOnChange(function()
		{
			Editor$1.settings.editor.gridEnabled = self.gridEnabled.getValue();
		});
		this.form.add(this.gridEnabled);
		this.form.nextRow();

		// Grid size 
		this.form.addText("Grid size");
		this.gridSize = new NumberBox(this.form);
		this.gridSize.size.set(60, 18);
		this.gridSize.setRange(1.0, Number.MAX_SAFE_INTEGER);
		this.gridSize.setStep(0.1);
		this.gridSize.setOnChange(function()
		{
			Editor$1.settings.editor.gridSize = self.gridSize.getValue();
		});
		this.form.add(this.gridSize);
		this.form.nextRow();

		// Grid spacing
		this.form.addText("Grid spacing");
		this.gridSpacing = new NumberBox(this.form);
		this.gridSpacing.size.set(60, 18);
		this.gridSpacing.setRange(1.0, Number.MAX_SAFE_INTEGER);
		this.gridSpacing.setStep(1.0);
		this.gridSpacing.setOnChange(function()
		{
			Editor$1.settings.editor.gridSpacing = self.gridSpacing.getValue();
		});
		this.form.add(this.gridSpacing);
		this.form.nextRow();

		// Enable Axis
		this.form.addText("Show axis");
		this.axisEnabled = new CheckBox(this.form);
		this.axisEnabled.size.set(18, 18);
		this.axisEnabled.setOnChange(function()
		{
			Editor$1.settings.editor.axisEnabled = self.axisEnabled.getValue();
		});
		this.form.add(this.axisEnabled);
		this.form.nextRow();

		// Enable orientation cube
		this.form.addText("Orientation cube");
		this.cameraRotationCube = new CheckBox(this.form);
		this.cameraRotationCube.size.set(18, 18);
		this.cameraRotationCube.setOnChange(function()
		{
			Editor$1.settings.editor.cameraRotationCube = self.cameraRotationCube.getValue();
		});
		this.form.add(this.cameraRotationCube);
		this.form.nextRow();

		// Orientation cube size
		this.form.addText("Orientation cube size");
		this.cameraRotationCubeSize = new NumberBox(this.form);
		this.cameraRotationCubeSize.size.set(60, 18);
		this.cameraRotationCubeSize.setRange(1.0, Number.MAX_SAFE_INTEGER);
		this.cameraRotationCubeSize.setStep(1.0);
		this.cameraRotationCubeSize.setOnChange(function()
		{
			Editor$1.settings.editor.cameraRotationCubeSize = self.cameraRotationCubeSize.getValue();
		});
		this.form.add(this.cameraRotationCubeSize);
		this.form.nextRow();

		// Snap to grid
		this.form.addText("Snap to grid");
		this.snap = new CheckBox(this.form);
		this.snap.size.set(18, 18);
		this.snap.setOnChange(function()
		{
			Editor$1.settings.editor.snap = self.snap.getValue();
		});
		this.form.add(this.snap);
		this.form.nextRow();

		// Snap angle
		this.form.addText("Snap angle");
		this.snapAngle = new NumberBox(this.form);
		this.snapAngle.size.set(60, 18);
		this.snapAngle.setRange(0.01, 3.14);
		this.snapAngle.setStep(0.01);
		this.snapAngle.setOnChange(function()
		{
			Editor$1.settings.editor.snapAngle = self.snapAngle.getValue();
		});
		this.form.add(this.snapAngle);
		this.form.nextRow();

		// Tranformations space
		this.form.addText("Transformations space");
		this.transformationSpace = new DropdownList(this.form);
		this.transformationSpace.size.set(150, 18);
		this.transformationSpace.addValue(Locale.local, "local");
		this.transformationSpace.addValue(Locale.world, "world");
		this.transformationSpace.setOnChange(function()
		{
			Editor$1.settings.editor.transformationSpace = self.transformationSpace.getValue();
		});
		this.form.add(this.transformationSpace);
		this.form.nextRow();

		// Tranformations space
		this.form.addText("Keep pose move").setAltText("Recalculate the object transformation to keep its global position when it is moved.");
		this.keepTransformMove = new CheckBox(this.form);
		this.keepTransformMove.size.set(18, 18);
		this.keepTransformMove.setOnChange(function()
		{
			Editor$1.settings.editor.keepTransformMove = self.keepTransformMove.getValue();
			Editor$1.gui.inspector.updateSelection();
		});
		this.form.add(this.keepTransformMove);
		this.form.nextRow();

		// Blank Space
		this.form.addText("");
		this.form.nextRow();

		// General text
		this.form.addText("Inspector panel");
		this.form.nextRow();

		// Show UUID
		this.form.addText("Show object UUID").setAltText("Show object UUID in the object panel.");
		this.showUUID = new CheckBox(this.form);
		this.showUUID.size.set(18, 18);
		this.showUUID.setOnChange(function()
		{
			Editor$1.settings.general.showUUID = self.showUUID.getValue();
			Editor$1.gui.inspector.updateSelection();
		});
		this.form.add(this.showUUID);
		this.form.nextRow();

		// Show type
		this.form.addText("Show object type");
		this.showType = new CheckBox(this.form);
		this.showType.size.set(18, 18);
		this.showType.setOnChange(function()
		{
			Editor$1.settings.general.showType = self.showType.getValue();
			Editor$1.gui.inspector.updateSelection();
		});
		this.form.add(this.showType);
		this.form.nextRow();

		// Blank Space
		this.form.addText("");
		this.form.nextRow();

		// Scene editor
		this.form.addText("Navigation");
		this.form.nextRow();

		// Navigation
		this.form.addText("Navigation Mode");
		this.navigation = new DropdownList(this.form);
		this.navigation.size.set(150, 18);
		this.navigation.addValue(Locale.firstPerson, Settings.FIRST_PERSON);
		this.navigation.addValue(Locale.orbit, Settings.ORBIT);
		this.navigation.addValue(Locale.left, Settings.PLANAR_LEFT);
		this.navigation.addValue(Locale.right, Settings.PLANAR_RIGHT);
		this.navigation.addValue(Locale.front, Settings.PLANAR_FRONT);
		this.navigation.addValue(Locale.back, Settings.PLANAR_BACK);
		this.navigation.addValue(Locale.top, Settings.PLANAR_TOP);
		this.navigation.addValue(Locale.bottom, Settings.PLANAR_BOTTOM);
		this.navigation.setOnChange(function()
		{
			Editor$1.settings.editor.navigation = self.navigation.getValue();
		});
		this.form.add(this.navigation);
		this.form.nextRow();

		// Invert navigation
		this.form.addText("Invert Vertical");
		this.invertNavigation = new CheckBox(this.form);
		this.invertNavigation.size.set(18, 18);
		this.invertNavigation.setOnChange(function()
		{
			Editor$1.settings.editor.invertNavigation = self.invertNavigation.getValue();
		});
		this.form.add(this.invertNavigation);
		this.form.nextRow();

		// Mouse look sensitivity
		this.form.addText("Mouse look");
		this.mouseLookSensitivity = new Slider(this.form);
		this.mouseLookSensitivity.size.set(120, 18);
		this.mouseLookSensitivity.setRange(0.0001, 0.02);
		this.mouseLookSensitivity.setStep(0.0001);
		this.mouseLookSensitivity.setOnChange(function()
		{
			Editor$1.settings.editor.mouseLookSensitivity = self.mouseLookSensitivity.getValue();
		});
		this.form.add(this.mouseLookSensitivity);
		this.form.nextRow();

		// Mouse move speed
		this.form.addText("Mouse move");
		this.mouseMoveSpeed = new Slider(this.form);
		this.mouseMoveSpeed.size.set(120, 18);
		this.mouseMoveSpeed.setRange(0.0001, 0.01);
		this.mouseMoveSpeed.setStep(0.0001);
		this.mouseMoveSpeed.setOnChange(function()
		{
			Editor$1.settings.editor.mouseMoveSpeed = self.mouseMoveSpeed.getValue();
		});
		this.form.add(this.mouseMoveSpeed);
		this.form.nextRow();

		// Mouse wheel speed
		this.form.addText("Mouse zoom");
		this.mouseWheelSensitivity = new Slider(this.form);
		this.mouseWheelSensitivity.size.set(120, 18);
		this.mouseWheelSensitivity.setRange(0.0001, 0.01);
		this.mouseWheelSensitivity.setStep(0.0001);
		this.mouseWheelSensitivity.setOnChange(function()
		{
			Editor$1.settings.editor.mouseWheelSensitivity = self.mouseWheelSensitivity.getValue();
		});
		this.form.add(this.mouseWheelSensitivity);
		this.form.nextRow();

		// Mouse lock on camera move
		this.form.addText("Lock mouse");
		this.lockMouse = new CheckBox(this.form);
		this.lockMouse.size.set(18, 18);
		this.lockMouse.setOnChange(function()
		{
			Editor$1.settings.editor.lockMouse = self.lockMouse.getValue();
		});
		this.form.add(this.lockMouse);
		this.form.nextRow();

		// Keyboard navigation
		this.form.addText("Keyboard navigation");
		this.keyboardNavigation = new CheckBox(this.form);
		this.keyboardNavigation.size.set(18, 18);
		this.keyboardNavigation.setOnChange(function()
		{
			Editor$1.settings.editor.keyboardNavigation = self.keyboardNavigation.getValue();
		});
		this.form.add(this.keyboardNavigation);
		this.form.nextRow();

		// Keyboard movement speed
		this.form.addText("Keyboard speed");
		this.keyboardNavigationSpeed = new Slider(this.form);
		this.keyboardNavigationSpeed.size.set(120, 18);
		this.keyboardNavigationSpeed.setRange(0.1, 3);
		this.keyboardNavigationSpeed.setStep(0.1);
		this.keyboardNavigationSpeed.setOnChange(function()
		{
			Editor$1.settings.editor.keyboardNavigationSpeed = self.keyboardNavigationSpeed.getValue();
		});
		this.form.add(this.keyboardNavigationSpeed);
		this.form.nextRow();

		// Blank Space
		this.form.addText("");
		this.form.nextRow();

		// Scene editor
		this.form.addText("Camera Preview");
		this.form.nextRow();

		// Enable camera preview
		this.form.addText("Show preview");
		this.cameraPreviewEnabled = new CheckBox(this.form);
		this.cameraPreviewEnabled.size.set(18, 18);
		this.cameraPreviewEnabled.setOnChange(function()
		{
			Editor$1.settings.editor.cameraPreviewEnabled = self.cameraPreviewEnabled.getValue();
		});
		this.form.add(this.cameraPreviewEnabled);
		this.form.nextRow();

		// Enable camera preview
		this.form.addText("Preview size");
		this.cameraPreviewSize = new Slider(this.form);
		this.cameraPreviewSize.size.set(120, 18);
		this.cameraPreviewSize.setRange(1, 600);
		this.cameraPreviewSize.setStep(0.05);
		this.cameraPreviewSize.setOnChange(function()
		{
			Editor$1.settings.editor.cameraPreviewSize = self.cameraPreviewSize.getValue();
		});
		this.form.add(this.cameraPreviewSize);
		this.form.nextRow();

		// Navigation
		this.form.addText(Locale.position);
		this.cameraPreviewPosition = new DropdownList(this.form);
		this.cameraPreviewPosition.size.set(150, 18);
		this.cameraPreviewPosition.addValue(Locale.bottomRight, Viewport.BOTTOM_RIGHT);
		this.cameraPreviewPosition.addValue(Locale.bottomLeft, Viewport.BOTTOM_LEFT);
		this.cameraPreviewPosition.addValue(Locale.topRight, Viewport.TOP_RIGHT);
		this.cameraPreviewPosition.addValue(Locale.topLeft, Viewport.TOP_LEFT);
		this.cameraPreviewPosition.setOnChange(function()
		{
			Editor$1.settings.editor.cameraPreviewPosition = self.cameraPreviewPosition.getValue();
		});
		this.form.add(this.cameraPreviewPosition);
		this.form.nextRow();

		// Blank Space
		this.form.addText("");
		this.form.nextRow();

		// Asset explorer
		this.form.addText("Asset explorer");
		this.form.nextRow();

		// Code font size
		this.form.addText("Preview size");
		this.filePreviewSize = new NumberBox(this.form);
		this.filePreviewSize.size.set(60, 18);
		this.filePreviewSize.setRange(50, 200);
		this.filePreviewSize.setStep(1);
		this.filePreviewSize.setOnChange(function()
		{
			Editor$1.settings.general.filePreviewSize = self.filePreviewSize.getValue();
			Editor$1.updateSettings();
		});
		this.form.add(this.filePreviewSize);
		
		// Update form
		this.form.updateInterface();
	}

	EditorSettingsTab.prototype = Object.create(TabComponent.prototype);

	EditorSettingsTab.prototype.activate = function()
	{
		// Inspector
		this.filePreviewSize.setValue(Editor$1.settings.general.filePreviewSize);
		this.showUUID.setValue(Editor$1.settings.general.showUUID);
		this.showType.setValue(Editor$1.settings.general.showType);
		this.showStats.setValue(Editor$1.settings.general.showStats);
		
		// Editor
		this.snap.setValue(Editor$1.settings.editor.snap);
		this.snapAngle.setValue(Editor$1.settings.editor.snapAngle);
		this.gridEnabled.setValue(Editor$1.settings.editor.gridEnabled);
		this.gridSize.setValue(Editor$1.settings.editor.gridSize);
		this.gridSpacing.setValue(Editor$1.settings.editor.gridSpacing);
		this.axisEnabled.setValue(Editor$1.settings.editor.axisEnabled);
		this.cameraRotationCube.setValue(Editor$1.settings.editor.cameraRotationCube);
		this.cameraRotationCubeSize.setValue(Editor$1.settings.editor.cameraRotationCubeSize);

		// Navigation
		this.lockMouse.setValue(Editor$1.settings.editor.lockMouse);
		this.navigation.setValue(Editor$1.settings.editor.navigation);
		this.invertNavigation.setValue(Editor$1.settings.editor.invertNavigation);
		this.keyboardNavigation.setValue(Editor$1.settings.editor.keyboardNavigation);
		this.keyboardNavigationSpeed.setValue(Editor$1.settings.editor.keyboardNavigationSpeed);
		this.mouseLookSensitivity.setValue(Editor$1.settings.editor.mouseLookSensitivity);
		this.mouseMoveSpeed.setValue(Editor$1.settings.editor.mouseMoveSpeed);
		this.mouseWheelSensitivity.setValue(Editor$1.settings.editor.mouseWheelSensitivity);

		// Camera preview
		this.cameraPreviewEnabled.setValue(Editor$1.settings.editor.cameraPreviewEnabled);
		this.cameraPreviewSize.setValue(Editor$1.settings.editor.cameraPreviewSize);
		this.cameraPreviewPosition.setValue(Editor$1.settings.editor.cameraPreviewPosition);

		// Transformations
		this.keepTransformMove.setValue(Editor$1.settings.editor.keepTransformMove);
		this.transformationSpace.setValue(Editor$1.settings.editor.transformationSpace);
	};

	EditorSettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);
		
		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	/**
	 * Static class that contains a listage of the code mirror themes (CSS) available in the platform.
	 * 
	 * @static
	 * @class CodemirrorThemes
	 */
	var CodemirrorThemes =
	[
		"3024-night",
		"3024-day",
		"abcdef",
		"ayu-dark",
		"ayu-mirage",
		"darcula",
		"ambiance",
		"gruvbox-dark",
		"idea",
		"lucario",
		"material-darker",
		"material-ocean",
		"material-palenight",
		"moxer",
		"nord",
		"ssms",
		"yonce",
		"base16-light",
		"base16-dark",
		"bespin",
		"blackboard",
		"cobalt",
		"colorforth",
		"dracula",
		"duotone-light",
		"duotone-dark",
		"eclipse",
		"elegant",
		"erlang-dark",
		"hopscotch",
		"icecoder",
		"isotope",
		"lesser-dark",
		"liquibyte",
		"material",
		"mbo",
		"mdn-like",
		"midnight",
		"monokai",
		"neat",
		"neo",
		"night",
		"oceanic-next",
		"paraiso-dark",
		"paraiso-light",
		"pastel-on-dark",
		"panda-syntax",
		"railscasts",
		"rubyblue",
		"seti",
		"shadowfox",
		"solarized",
		"the-matrix",
		"tomorrow-night-bright",
		"tomorrow-night-eighties",
		"ttcn",
		"twilight",
		"vibrant-ink",
		"xq-dark",
		"xq-light",
		"yeti",
		"zenburn"
	];

	function CodeSettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, "Code Editor", Global.FILE_PATH + "icons/script/script.png");
		
		this.element.style.overflow = "auto";

		var self = this;

		this.form = new TableForm(this);
		this.form.defaultTextWidth = 125;
		this.form.setAutoSize(false);

		// Code editor text
		this.form.addText("Code Editor");
		this.form.nextRow();

		// Code Theme
		this.form.addText("Editor theme");
		this.codeTheme = new DropdownList(this.form);
		this.codeTheme.size.set(120, 18);
		this.codeTheme.setOnChange(function()
		{
			Editor$1.settings.code.theme = self.codeTheme.getValue();
		});
		this.form.add(this.codeTheme);
		this.form.nextRow();
		
		for(var i = 0; i < CodemirrorThemes.length; i++)
		{
			this.codeTheme.addValue(CodemirrorThemes[i], CodemirrorThemes[i]);
		}

		// Code keymap
		this.form.addText("Key bindings");
		this.codeKeymap = new DropdownList(this.form);
		this.codeKeymap.size.set(120, 18);
		this.codeKeymap.addValue("codemirror", "default");
		this.codeKeymap.addValue("sublime", "sublime");
		this.codeKeymap.addValue("vim", "vim");
		this.codeKeymap.addValue("emacs", "emacs");
		this.codeKeymap.setOnChange(function()
		{
			Editor$1.settings.code.keymap = self.codeKeymap.getValue();
		});
		this.form.add(this.codeKeymap);
		this.form.nextRow();

		// Code font size
		this.form.addText("Font size");
		this.codeFontSize = new NumberBox(this.form);
		this.codeFontSize.size.set(60, 18);
		this.codeFontSize.setRange(5, 99999);
		this.codeFontSize.setStep(1);
		this.codeFontSize.setOnChange(function()
		{
			Editor$1.settings.code.fontSize = self.codeFontSize.getValue();
		});
		this.form.add(this.codeFontSize);
		this.form.nextRow();

		// Show line numbers
		this.form.addText("Show line number");
		this.codeLineNumbers = new CheckBox(this.form);
		this.codeLineNumbers.size.set(18, 18);
		this.codeLineNumbers.setOnChange(function()
		{
			Editor$1.settings.code.lineNumbers = self.codeLineNumbers.getValue();
		});
		this.form.add(this.codeLineNumbers);
		this.form.nextRow();

		// Line wrapping
		this.form.addText("Line Wrap");
		this.codeLineWrapping = new CheckBox(this.form);
		this.codeLineWrapping.size.set(18, 18);
		this.codeLineWrapping.setOnChange(function()
		{
			Editor$1.settings.code.lineWrapping = self.codeLineWrapping.getValue();
		});
		this.form.add(this.codeLineWrapping);
		this.form.nextRow();

		// Auto close brackets
		this.form.addText("Auto Close Brackets");
		this.codeAutoCloseBrackets = new CheckBox(this.form);
		this.codeAutoCloseBrackets.size.set(18, 18);
		this.codeAutoCloseBrackets.setOnChange(function()
		{
			Editor$1.settings.code.autoCloseBrackets = self.codeAutoCloseBrackets.getValue();
		});
		this.form.add(this.codeAutoCloseBrackets);
		this.form.nextRow();

		// Highlight active line
		this.form.addText("Highlight line");
		this.codeHighlightActiveLine = new CheckBox(this.form);
		this.codeHighlightActiveLine.size.set(18, 18);
		this.codeHighlightActiveLine.setOnChange(function()
		{
			Editor$1.settings.code.highlightActiveLine = self.codeHighlightActiveLine.getValue();
		});
		this.form.add(this.codeHighlightActiveLine);
		this.form.nextRow();

		// Show search match on scrollback
		this.form.addText("Show match scrollbar");
		this.showMatchesOnScrollbar = new CheckBox(this.form);
		this.showMatchesOnScrollbar.size.set(18, 18);
		this.showMatchesOnScrollbar.setOnChange(function()
		{
			Editor$1.settings.code.showMatchesOnScrollbar = self.showMatchesOnScrollbar.getValue();
		});
		this.form.add(this.showMatchesOnScrollbar);
		this.form.nextRow();
		
		// File drag
		this.form.addText("Drag files");
		this.dragFiles = new CheckBox(this.form);
		this.dragFiles.size.set(18, 18);
		this.dragFiles.setOnChange(function()
		{
			Editor$1.settings.code.dragFiles = self.dragFiles.getValue();
		});
		this.form.add(this.dragFiles);
		this.form.nextRow();

		// Indent with tabs
		this.form.addText("Indent with Tabs");
		this.indentWithTabs = new CheckBox(this.form);
		this.indentWithTabs.size.set(18, 18);
		this.indentWithTabs.setOnChange(function()
		{
			Editor$1.settings.code.indentWithTabs = self.indentWithTabs.getValue();
		});
		this.form.add(this.indentWithTabs);
		this.form.nextRow();

		// Tab size
		this.form.addText("Tab size");
		this.tabSize = new NumberBox(this.form);
		this.tabSize.size.set(60, 18);
		this.tabSize.setRange(1, 100);
		this.tabSize.setStep(1);
		this.tabSize.setOnChange(function()
		{
			Editor$1.settings.code.tabSize = self.tabSize.getValue();
		});
		this.form.add(this.tabSize);
		this.form.nextRow();

		// Indent units
		this.form.addText("Indent Unit");
		this.indentUnit = new NumberBox(this.form);
		this.indentUnit.size.set(60, 18);
		this.indentUnit.setRange(1, 100);
		this.indentUnit.setStep(1);
		this.indentUnit.setOnChange(function()
		{
			Editor$1.settings.code.indentUnit = self.indentUnit.getValue();
		});
		this.form.add(this.indentUnit);
		this.form.nextRow();

		// Match Brackets
		this.form.addText("Match Brackets");
		this.matchBrackets = new CheckBox(this.form);
		this.matchBrackets.size.set(18, 18);
		this.matchBrackets.setOnChange(function()
		{
			Editor$1.settings.code.matchBrackets = self.matchBrackets.getValue();
		});
		this.form.add(this.matchBrackets);
		this.form.nextRow();

		// Smart Indent
		this.form.addText("Smart Indent");
		this.smartIndent = new CheckBox(this.form);
		this.smartIndent.size.set(18, 18);
		this.smartIndent.setOnChange(function()
		{
			Editor$1.settings.code.smartIndent = self.smartIndent.getValue();
		});
		this.form.add(this.smartIndent);
		this.form.nextRow();

		// VIM Mode
		this.form.addText("Vim Mode");
		this.vimMode = new CheckBox(this.form);
		this.vimMode.size.set(18, 18);
		this.vimMode.setOnChange(function()
		{
			Editor$1.settings.code.vimMode = self.vimMode.getValue();
		});
		this.form.add(this.vimMode);
		this.form.nextRow();
	}

	CodeSettingsTab.prototype = Object.create(TabComponent.prototype);

	CodeSettingsTab.prototype.activate = function()
	{
		this.codeTheme.setValue(Editor$1.settings.code.theme);
		this.codeFontSize.setValue(Editor$1.settings.code.fontSize);
		this.codeKeymap.setValue(Editor$1.settings.code.keymap);
		this.codeLineNumbers.setValue(Editor$1.settings.code.lineNumbers);
		this.codeLineWrapping.setValue(Editor$1.settings.code.lineWrapping);
		this.codeAutoCloseBrackets.setValue(Editor$1.settings.code.autoCloseBrackets);
		this.codeHighlightActiveLine.setValue(Editor$1.settings.code.highlightActiveLine);
		this.showMatchesOnScrollbar.setValue(Editor$1.settings.code.showMatchesOnScrollbar);
		this.dragFiles.setValue(Editor$1.settings.code.dragFiles);
		this.indentWithTabs.setValue(Editor$1.settings.code.indentWithTabs);
		this.tabSize.setValue(Editor$1.settings.code.tabSize);
		this.indentUnit.setValue(Editor$1.settings.code.indentUnit);
		this.matchBrackets.setValue(Editor$1.settings.code.matchBrackets);
		this.smartIndent.setValue(Editor$1.settings.code.smartIndent);
		this.vimMode.setValue(Editor$1.settings.code.vimMode);
	};

	CodeSettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.form.size.copy(this.size);
		this.form.updateInterface();
	};

	function SettingsTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.settings, Global.FILE_PATH + "icons/misc/settings.png");

		this.tab = new TabGroup(this, TabGroup.LEFT);
		this.tab.element.style.backgroundColor = "var(--bar-color)";
		this.tab.buttonSize.set(200, 25);

		this.tab.addTab(GeneralSettingsTab, false).activate();
		this.tab.addTab(EditorSettingsTab, false);
		this.tab.addTab(UnitsSettingsTab, false);
		this.tab.addTab(RenderSettingsTab, false);
		this.tab.addTab(CodeSettingsTab, false);
		this.tab.addTab(JSHintSettingsTab, false);
	}

	SettingsTab.prototype = Object.create(TabComponent.prototype);

	SettingsTab.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.tab.size.copy(this.size);
		this.tab.updateInterface();
	};

	function AboutTab(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.about, Global.FILE_PATH + "icons/misc/about.png");

		this.element.style.backgroundColor = "var(--bar-color)";

		// Logo
		this.logo = document.createElement("img");
		this.logo.style.position = "absolute";
		this.logo.style.pointerEvents = "none";
		this.logo.style.top = "5%";
		this.logo.style.left = "25%";
		this.logo.style.width = "50%";
		this.logo.style.height = "20%";
		this.logo.style.objectFit = "contain";
		this.logo.src = Global.FILE_PATH + "logo.png";
		this.element.appendChild(this.logo);

		// Version
		this.name = new Text(this);
		this.name.element.style.top = "30%";
		this.name.element.style.left = "0%";
		this.name.element.style.width = "100%";
		this.name.setTextSize(25);
		this.name.setAlignment(Text.CENTER);
		this.name.setText(Nunu.NAME + " " + Nunu.VERSION + "Build " + Nunu.TIMESTAMP);

		// Libraries
		var libs = [];
		libs.push("three.js R" + three.REVISION);
		libs.push("CodeMirror V" + CodeMirror.version);
		libs.push("CannonJS V" + CANNON.version);
		libs.push("TernJS V" + tern.version);
		if(Nunu.runningOnDesktop())
		{
			libs.push("NWJS V" + process.versions['node-webkit']);
		}

		var top = 50;

		for(var i = 0; i < libs.length; i++)
		{
			var text = new Text(this);
			text.element.style.top = top + "%";
			text.element.style.left = "0%";
			text.element.style.width = "100%";
			text.setAlignment(Text.CENTER);
			text.setTextSize(20);
			text.setText(libs[i]);

			top += 6;
		}
	}

	AboutTab.prototype = Object.create(TabComponent.prototype);

	/**
	 * Responsable for package and export of project data to different platforms.
	 *
	 * @static
	 * @class Exporters
	 */
	function Exporters(){}

	Exporters.ANDROID_RUN = 100;
	Exporters.ANDROID_EXPORT_UNSIGNED = 101;
	Exporters.ANDROID_EXPORT_SIGNED = 102;

	/**
	 * Editor temporary data folder, should be used for operations that require temporary file storage.
	 *
	 * Only available on desktop.
	 *
	 * @static
	 * @attribute TEMP
	 */
	Exporters.TEMP = "./temp";

	/**
	 * Export a mobile ready web project to a folder.
	 *
	 * The mobile version of the runtime does not include any fullscreen and VR buttons, the application is run by default as fullscreen.
	 *
	 * @static
	 * @method exportCordovaProject
	 * @param {string} dir Directory to export the project to.
	 */
	Exporters.exportCordovaProject = function(dir)
	{
		FileSystem.makeDirectory(dir);
		FileSystem.copyFile(Global.RUNTIME_PATH + "logo.png", dir + "/logo.png");
		FileSystem.copyFile(Global.RUNTIME_PATH + "cordova.html", dir + "/index.html");
		FileSystem.copyFile(FileSystem.fileExists("nunu.min.js") ? "nunu.min.js" : Global.BUILD_PATH, dir + "/nunu.min.js");
		Editor$1.saveProgram(dir + "/app.nsp", true, true, true);
	};

	/**
	 * Export web project to a folder.
	 *
	 * Saves the project and exports the runtime to run the project.
	 *
	 * @static
	 * @method exportWebProject
	 * @param {string} dir Directory to export the project to.
	 */
	Exporters.exportWebProject = function(dir)
	{
		FileSystem.makeDirectory(dir);
		FileSystem.copyFile(Global.RUNTIME_PATH + "vr.png", dir + "/vr.png");
		FileSystem.copyFile(Global.RUNTIME_PATH + "fullscreen.png", dir + "/fullscreen.png");
		FileSystem.copyFile(Global.RUNTIME_PATH + "logo.png", dir + "/logo.png");
		FileSystem.copyFile(Global.RUNTIME_PATH + "index.html", dir + "/index.html");
		FileSystem.copyFile(FileSystem.fileExists("nunu.min.js") ? "nunu.min.js" : Global.BUILD_PATH, dir + "/nunu.min.js");
		Editor$1.saveProgram(dir + "/app.nsp", true, true, true);
	};

	/**
	 * Export web project as a zip package using JSZip.
	 *
	 * Used in the web version to export projects.
	 *
	 * @static
	 * @method exportWebProjectZip
	 * @param {string} fname Name of the file.
	 */
	Exporters.exportWebProjectZip = function(fname)
	{
		var zip = new JSZip();
		zip.file("index.html", FileSystem.readFile(Global.RUNTIME_PATH + "index.html"));
		zip.file("nunu.min.js", FileSystem.readFile("nunu.min.js"));
		
		var pson$1 = new pson.StaticPair();
		var data = pson$1.toArrayBuffer(Editor$1.program.toJSON());

		zip.file("app.nsp", Base64Utils.fromArraybuffer(data), {base64: true});
		zip.file("logo.png", FileSystem.readFileBase64(Global.RUNTIME_PATH + "logo.png"), {base64: true});
		zip.file("fullscreen.png", FileSystem.readFileBase64(Global.RUNTIME_PATH + "fullscreen.png"), {base64: true});
		zip.file("vr.png", FileSystem.readFileBase64(Global.RUNTIME_PATH + "vr.png"), {base64: true});

		zip.generateAsync({type:"blob"}).then(function(content)
		{
			var download = document.createElement("a");
			download.download = fname;
			download.href = window.URL.createObjectURL(content);
			download.style.display = "none";
			download.onclick = function()
			{
				document.body.removeChild(this);
			};
			document.body.appendChild(download);
			download.click();
		});
	};

	/**
	 * Export a NWJS project folder.
	 *
	 * Only the runtime and javascript portion of the project.
	 *
	 * @static
	 * @method exportNWJSProject
	 * @param {string} dir Output directory.
	 */
	Exporters.exportNWJSProject = function(dir, target)
	{
		// Export web project
		Exporters.exportWebProject(Exporters.TEMP);

		var config = Editor$1.program.targetConfig;

		// Write package json with nwjs builder configuration
		FileSystem.writeFile(Exporters.TEMP + "/package.json", JSON.stringify(
		{
			name: Editor$1.program.name,
			description: Editor$1.program.description,
			author: Editor$1.program.author,
			main: "index.html",
			window:
			{
				frame: config.desktop.frame,
				fullscreen: config.desktop.fullscreen,
				resizable: config.desktop.resizable
			},
			webkit:
			{
				plugin: false
			},
			build:
			{
				output: dir,
				outputPattern: "${PLATFORM}-${ARCH}",
				packed: true,
				// targets: ["zip", "nsis7z"],
				win:
				{
					productName: Editor$1.program.name,
					companyName: Editor$1.program.author
				},
			}
		}));

		// Build application
		var system = require("child_process");
		var output = system.execSync("build --mirror https:// dl.nwjs.io/ --with-ffmpeg --tasks " + target + " " + Exporters.TEMP);

		// Delete temporary folders
		if(FileSystem.fileExists(Exporters.TEMP))
		{
			FileSystem.deleteFolder(Exporters.TEMP);
		}
	};

	/**
	 * Export NWJS windows project.
	 *
	 * @static
	 * @method exportWindowsProject
	 * @param {string} dir Output directory.
	 */
	Exporters.exportWindows = function(dir)
	{
		Exporters.exportNWJSProject(dir, "win-x64");
	};

	/**
	 * Export NWJS linux project.
	 *
	 * @static
	 * @method exportLinuxProject
	 * @param {string} dir Output directory.
	 */
	Exporters.exportLinux = function(dir)
	{
		Exporters.exportNWJSProject(dir, "linux-x64");
	};

	/**
	 * Export NWJS macOS project.
	 *
	 * @static
	 * @method exportMacOSProject
	 * @param {string} dir Output directory.
	 */
	Exporters.exportMacOS = function(dir)
	{
		Exporters.exportNWJSProject(dir, "mac-x64");
	};

	/**
	 * Export a android project using cordova.
	 *
	 * Cordova has to be installed from NPM globaly, it is run trough the command line.
	 *
	 * @static
	 * @method exportAndroid
	 * @param {number} mode The app can be just run on the device, or exported as a signed or unsigned apk.
	 * @param {string} outputPath Path to stored the output apk file in case there is one to store.
	 */
	Exporters.exportAndroid = function(mode, outputPath)
	{
		// Clean the temporary files created under the temporary folder.
		function clenanUp()
		{
			if(FileSystem.fileExists(Exporters.TEMP))
			{
				FileSystem.deleteFolder(Exporters.TEMP);
			}
		}

		var system = require("child_process");
		var name = Editor$1.program.name !== "" ? Editor$1.program.name : "program";
		var author = Editor$1.program.author !== "" ? Editor$1.program.author : "author";
		var packageName = "com." + author + "." + name;

		// Delete old project data
		clenanUp();

		// Create cordova project
		var output = system.execSync("cordova create temp " + packageName + " " + name).toString();
		if(output.indexOf("Creating") === -1)
		{
			console.error("nunuStudio: Failed to create cordova project.");
		}

		// Export nunu project
		Exporters.exportCordovaProject(Exporters.TEMP + "/www");


		setTimeout(function()
		{
			// Android platform project
			var output = system.execSync("cordova platform add android", {cwd:Exporters.TEMP}).toString();
			if(output.indexOf("Android project created") === -1)
			{
				console.error("nunuStudio: Failed to create cordova android project.");
			}

			// Check requirements
			output = system.execSync("cordova requirements", {cwd:Exporters.TEMP}).toString();

			if(output.indexOf("Java JDK: installed") === -1)
			{
				Editor$1.alert("Missing java JDK (get it at http:// www.oracle.com/technetwork/java/javase/downloads/index.html)");
				console.error("nunuStudio: Missing java JDK (get it at http:// www.oracle.com/technetwork/java/javase/downloads/index.html)");
				clenanUp();
				return;
			}
			if(output.indexOf("Android SDK: installed true") === -1)
			{
				Editor$1.alert("Missing Android SDK (get it at https:// developer.android.com/studio/)");
				console.error("nunuStudio: Missing Android SDK (get it at https:// developer.android.com/studio/)");
				clenanUp();
				return;
			}

			// Supported Android SDK versions
			/*
			var versions = output.split("android-");
			versions.shift();
			for(var i = 0; i < versions.length; i++)
			{
				versions[i] = Number.parseInt(versions[i])
			}
			*/

			// Send code to device
			if(mode === Exporters.ANDROID_RUN)
			{
				// Build code
				output = system.execSync("cordova build android", {cwd:Exporters.TEMP}).toString();
				if(output.indexOf("SUCCESSFUL") === -1)
				{
					console.error("nunuStudio: Failed to build android project.");
					clenanUp();
					return;
				}

				// Launch on device
				output = system.execSync("cordova run android", {cwd:Exporters.TEMP}).toString();
				if(output.indexOf("SUCCESS") === -1)
				{
					console.error("nunuStudio: Failed to launch android application on device.");
					clenanUp();
					return;
				}
			}
			// Export test version
			else if(mode === Exporters.ANDROID_EXPORT_UNSIGNED)
			{
				output = system.execSync("cordova build android", {cwd:Exporters.TEMP}).toString();
				if(output.indexOf("SUCCESSFUL") === -1)
				{
					console.error("nunuStudio: Failed to build android project.");
					clenanUp();
					return;
				}

				FileSystem.copyFile(Exporters.TEMP + "/platforms/android/app/build/outputs/apk/debug/app-debug.apk", outputPath);
			}
			// Export signed version
			else if(mode === Exporters.ANDROID_EXPORT_SIGNED)
			{
				output = system.execSync("cordova build android --release -- --keystore=\"..\\android.keystore\" --storePassword=android --alias=mykey", {cwd:Exporters.TEMP}).toString();
				if(output.indexOf("SUCCESSFUL") === -1)
				{
					console.error("nunuStudio: Failed to build android project.");
					clenanUp();
					return;
				}

				// FileSystem.copyFile(Exporters.TEMP + "/platforms/android/app/build/outputs/apk/debug/app-debug.apk", outputPath);
			}

			clenanUp();

			Editor$1.alert("Android project exported!");
		}, 500);
	};

	/**
	 * Main menu of the application is displayed on top of the window, contains all global operations that can be applied to the project.
	 *
	 * Its also used to load, save project, and access editor related features.
	 *
	 * @class MainMenu
	 * @extends {Component}
	 */
	function MainMenu(parent)
	{
		Component.call(this, parent, "div");

		this.element.style.overflow = "visible";
		this.element.style.backgroundColor = "var(--bar-color)";
		this.element.style.top = "0px";
		this.element.style.left = "0px";
		this.element.style.width = "100%";
		this.element.style.height = "25px";

		this.size.set(0, 25);

		this.preventDragEvents();

		// Editor Logo
		var logo = document.createElement("img");
		logo.style.display = "block";
		logo.style.position = "absolute";
		logo.style.pointerEvents = "none";
		logo.style.width = "108px";
		logo.style.height = "18px";
		logo.style.top = "3px";
		logo.style.right = "3px";
		logo.src = Global.FILE_PATH + "logo.png";
		this.element.appendChild(logo);

		// File
		var fileMenu = new DropdownMenu(this);
		fileMenu.setText(Locale.file);
		fileMenu.size.set(120, this.size.y);
		fileMenu.position.set(0, 0);

		// New project
		fileMenu.addOption(Locale.new, function()
		{
			Editor$1.gui.newProgram();
		}, Global.FILE_PATH + "icons/misc/new.png");

		// Save project
		fileMenu.addOption(Locale.save, function()
		{
			if(Editor$1.openFile !== null)
			{
				Editor$1.saveProgram(undefined, true);
			}
			else
			{
				Editor$1.gui.saveProgram();
			}
		}, Global.FILE_PATH + "icons/misc/save.png");

		// Save project
		fileMenu.addOption(Locale.saveAs, function()
		{
			Editor$1.gui.saveProgram();
		}, Global.FILE_PATH + "icons/misc/save.png").setAltText("CTRL+S");

		// Save readable legacy format
		if(Nunu.developmentMode() && Nunu.runningOnDesktop())
		{
			fileMenu.addOption("Save ISP", function()
			{
				FileSystem.chooseFile(function(files)
				{
					Editor$1.saveProgram(files[0].path, false, true);
				}, ".isp", true);
			}, Global.FILE_PATH + "icons/misc/save.png");
		}

		// Load Project
		fileMenu.addOption(Locale.load, function()
		{
			Editor$1.gui.loadProgram();
		}, Global.FILE_PATH + "icons/misc/load.png").setAltText("CTRL+L");

		// Settings
		fileMenu.addOption(Locale.settings, function()
		{
			var tab = Editor$1.gui.tab.getTab(SettingsTab);
			if(tab === null)
			{
				tab = Editor$1.gui.tab.addTab(SettingsTab, true);
			}
			tab.select();
		}, Global.FILE_PATH + "icons/misc/settings.png");

		// Publish
		var publish = fileMenu.addMenu(Locale.publish, Global.FILE_PATH + "icons/misc/publish.png");

		if(Nunu.runningOnDesktop())
		{
			// Publish web
			publish.addOption("Web", function()
			{
				FileSystem.chooseFile(function(files)
				{
					try
					{
						Exporters.exportWebProject(files[0].path);
						Editor$1.alert(Locale.projectExported);
					}
					catch(e)
					{
						Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
					}
				}, "", Editor$1.program.name);
			}, Global.FILE_PATH + "icons/platform/web.png");

			// Android
			if(Nunu.developmentMode())
			{
				var android = publish.addMenu("Android", Global.FILE_PATH + "icons/platform/android.png");

				android.addOption(Locale.run, function()
				{
					try
					{
						Exporters.exportAndroid(Exporters.ANDROID_RUN);
					}
					catch(e)
					{
						console.error("nunuStudio: Error exporting android project.", e);
						Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
					}
				});

				android.addOption("Unsigned APK", function()
				{
					FileSystem.chooseFile(function(files)
					{
						try
						{
							Exporters.exportAndroid(Exporters.ANDROID_EXPORT_UNSIGNED, files[0].path);
						}
						catch(e)
						{
							console.error("nunuStudio: Error exporting android project.", e);
							Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
						}
					}, ".apk", Editor$1.program.name);
				});
			}

			if(Nunu.runningOnDesktop())
			{
				// Publish windows
				publish.addOption("Windows", function()
				{
					FileSystem.chooseFile(function(files)
					{
						try
						{
							Exporters.exportWindows(files[0].path);
							Editor$1.alert(Locale.projectExported);
						}
						catch(e)
						{
							console.error("nunuStudio: Error exporting windows project.", e);
							Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
						}
					}, "", Editor$1.program.name);
				}, Global.FILE_PATH + "icons/platform/windows.png");

				// Publish linux
				publish.addOption("Linux", function()
				{
					FileSystem.chooseFile(function(files)
					{
						try
						{
							Exporters.exportLinux(files[0].path);
							Editor$1.alert(Locale.projectExported);
						}
						catch(e)
						{
							console.error("nunuStudio: Error exporting linux project.", e);
							Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
						}
					}, "", Editor$1.program.name);
				}, Global.FILE_PATH + "icons/platform/linux.png");
		

				// Publish macos
				publish.addOption("macOS", function()
				{
					FileSystem.chooseFile(function(files)
					{
						try
						{
							Exporters.exportMacOS(files[0].path);
							Editor$1.alert(Locale.projectExported);
						}
						catch(e)
						{
							console.error("nunuStudio: Error exporting macOS project.", e);
							Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
						}
					}, "", Editor$1.program.name);
				}, Global.FILE_PATH + "icons/platform/osx.png");
			}
		}
		// Running on web browser
		else
		{
			publish.addOption("Web", function()
			{
				FileSystem.chooseFileName(function(fname)
				{
					try
					{
						Exporters.exportWebProjectZip(fname);
						Editor$1.alert(Locale.projectExported);
					}
					catch(e)
					{
						console.error("nunuStudio: Error exporting web project.", e);
						Editor$1.alert(Locale.errorExportingProject + "\n(" + e + ")");
					}
				}, ".zip");
			}, Global.FILE_PATH + "icons/platform/web.png");
		}

		// Import
		fileMenu.addOption(Locale.import, function()
		{
			FileSystem.chooseFile(function(files)
			{
				if(files.length > 0)
				{
					var file = files[0];
					var binary = file.name.endsWith(".nsp");

					var loader = new ObjectLoader();
					var reader = new FileReader();
					reader.onload = function()
					{
						if(true)
						{
							var pson$1 = new pson.StaticPair();
							var data = pson$1.decode(reader.result);
							var program = loader.parse(data);
						}
						else
						{
							var program;
						}

						var actions = [];

						for(var i = 0; i < program.children.length; i++)
						{
							actions.push(new AddAction(program.children[i], Editor$1.program));
						}

						Editor$1.addAction(new ActionBundle(actions));
					};

					{
						reader.readAsArrayBuffer(file);
					}
				}
			}, ".isp, .nsp");

		}, Global.FILE_PATH + "icons/misc/import.png");

		// Export menu
		var exportMenu = fileMenu.addMenu(Locale.export, Global.FILE_PATH + "icons/misc/export.png");

		// Export OBJ
		exportMenu.addOption("OBJ", function()
		{	
			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.OBJExporter();
				var data = exporter.parse(Editor$1.getScene());
				FileSystem.writeFile(fname, data);
			}, ".obj");

		}, Global.FILE_PATH + "icons/misc/scene.png");

		// Export GLTF
		exportMenu.addOption("GLTF", function()
		{
			var onlyVisible = Editor$1.confirm(Locale.exportOnlyVisibleObjects);

			var config = 
			{
				onlyVisible: onlyVisible,
				binary: false,
				forceIndices: true,
				embedImages: true,
				forcePowerOfTwoTextures: false
			};

			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.GLTFExporter();
				exporter.parse(Editor$1.getScene(), function(result)
				{
					FileSystem.writeFile(fname, JSON.stringify(result, null, "\t"));
				}, config);
			}, ".gltf");
		}, Global.FILE_PATH + "icons/gltf.png");

		// Export GLB
		exportMenu.addOption("GLB", function()
		{	
			var onlyVisible = Editor$1.confirm(Locale.exportOnlyVisibleObjects);

			var config = 
			{
				onlyVisible: onlyVisible,
				binary: true,
				forceIndices: true,
				embedImages: true,
				forcePowerOfTwoTextures: false
			};

			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.GLTFExporter();
				exporter.parse(Editor$1.getScene(), function(result)
				{
					FileSystem.writeFileArrayBuffer(fname, result);
				}, config);
			}, ".glb");
		}, Global.FILE_PATH + "icons/gltf.png");

		// Export Google Draco
		exportMenu.addOption("Draco", function()
		{
			if(Editor$1.selection.length === 0 || Editor$1.selection[0].geometry === undefined)
			{
				Editor$1.alert(Locale.needsObjectGeometry);
				return;
			}

			var geometry = Editor$1.selection[0].geometry;
			var exporter = new three.DRACOExporter();

			FileSystem.chooseFileWrite(function(fname)
			{
				var arraybuffer = exporter.parse(geometry);
				FileSystem.writeFileArrayBuffer(fname, arraybuffer);
			}, ".drc");
		}, Global.FILE_PATH + "icons/misc/scene.png");

		// Auxiliar method to export collada files
		function exportCollada(fname, config)
		{
			var path = FileSystem.getFilePath(fname);

			var exporter = new three.ColladaExporter();
			exporter.parse(Editor$1.program, function(result)
			{
				for(var i = 0; i < result.textures.length; i++)
				{
					var texture = result.textures[i];
					FileSystem.writeFileArrayBuffer(path + texture.name + "." + texture.ext, texture.data.buffer);
				}

				FileSystem.writeFile(fname, result.data);
			}, config);
		}

		// Export Collada
		exportMenu.addOption("Collada V1.4.1", function()
		{
			var config =
			{
				version: "1.4.1",
				binary: true,
				textureDirectory: ""
			};

			FileSystem.chooseFileWrite(function(fname)
			{
				exportCollada(fname, config);
			}, ".dae");

		}, Global.FILE_PATH + "icons/misc/scene.png");

		exportMenu.addOption("Collada V1.5", function()
		{
			var config =
			{
				version: "1.5.0",
				binary: true,
				textureDirectory: ""
			};

			FileSystem.chooseFileWrite(function(fname)
			{
				exportCollada(fname, config);
			}, ".dae");

		}, Global.FILE_PATH + "icons/misc/scene.png");

		// Export PLY
		exportMenu.addOption("PLY", function()
		{
			var config = {binary: false};
			
			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.PLYExporter();
				exporter.parse(Editor$1.getScene(), function(result)
				{
					FileSystem.writeFile(fname, result);
				}, config);
			}, ".ply");
		}, Global.FILE_PATH + "icons/misc/scene.png");


		exportMenu.addOption("PLY (" + Locale.binary + ")", function()
		{
			var config = {binary: true};

			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.PLYExporter();
				exporter.parse(Editor$1.getScene(), function(result)
				{
					FileSystem.writeFileArrayBuffer(fname, result);
				}, config);
			}, ".ply");
		}, Global.FILE_PATH + "icons/misc/scene.png");


		// Export STL
		exportMenu.addOption("STL", function()
		{
			var config = {binary: false};

			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.STLExporter();
				var data = exporter.parse(Editor$1.program, config);
				FileSystem.writeFile(fname, data);
			}, ".stl");
		}, Global.FILE_PATH + "icons/misc/scene.png");

		// Export Binary STL
		exportMenu.addOption("STL (" + Locale.binary + ")", function()
		{	
			var config = {binary: true};

			FileSystem.chooseFileWrite(function(fname)
			{
				var exporter = new three.STLExporter();
				var data = exporter.parse(Editor$1.program, config);
				FileSystem.writeFileArrayBuffer(fname, data.buffer);
			}, ".stl");
		}, Global.FILE_PATH + "icons/misc/scene.png");

		// Exit
		if(Nunu.runningOnDesktop())
		{
			fileMenu.addOption(Locale.exit, function()
			{
				if(Editor$1.confirm(Locale.unsavedChangesExit))
				{
					Editor$1.exit();
				}
			}, Global.FILE_PATH + "icons/misc/exit.png");
		}

		fileMenu.updateInterface();

		// Editor
		var editMenu = new DropdownMenu(this); editMenu.setText("Edit");
		editMenu.size.set(100, this.size.y);
		editMenu.position.set(120,0);

		editMenu.addOption(Locale.undo, function()
		{
			Editor$1.undo();
		}, Global.FILE_PATH + "icons/misc/undo.png");

		editMenu.addOption(Locale.redo, function()
		{
			Editor$1.redo();
		}, Global.FILE_PATH + "icons/misc/redo.png");

		editMenu.addOption(Locale.copy, function()
		{
			Editor$1.copyObject();
		}, Global.FILE_PATH + "icons/misc/copy.png");
		
		editMenu.addOption(Locale.cut, function()
		{
			Editor$1.cutObject();
		}, Global.FILE_PATH + "icons/misc/cut.png");

		editMenu.addOption(Locale.paste, function()
		{
			Editor$1.pasteObject();
		}, Global.FILE_PATH + "icons/misc/paste.png");

		editMenu.addOption(Locale.delete, function()
		{
			if(Editor$1.hasObjectSelected())
			{
				var del = Editor$1.confirm(Locale.deleteObjects);
				if(del)
				{
					Editor$1.deleteObject();
				}
			}
		}, Global.FILE_PATH + "icons/misc/delete.png");

		var csg = editMenu.addMenu(Locale.csg, Global.FILE_PATH + "icons/models/figures.png");

		// Create BSP for CSG operation
		function createBSP(object)
		{
			var geometry = object.geometry;

			if(geometry instanceof three.BufferGeometry)
			{
				geometry = new three.Geometry().fromBufferGeometry(geometry);
			}
			else
			{
				geometry = geometry.clone();
			}
			
			geometry.applyMatrix4(object.matrixWorld);

			return new ThreeBSP(geometry);
		}

		// Verify is CSG operation is possible
		function verifyCSG()
		{
			if(Editor$1.selection.length < 2)
			{
				Editor$1.alert(Locale.needsTwoObjects);
				return false;
			}

			for(var i = 0; i < 2; i++)
			{
				if(Editor$1.selection[i].geometry === undefined)
				{
					Editor$1.alert(Locale.needsTwoObjectGeometry);
					return false;
				}
			}

			return true;
		}

		// Create CSG action
		function createCSGAction(mesh, a, b)
		{
			mesh.material = Editor$1.defaultMaterial;
			mesh.name = a.name;

			var actions = [];
			actions.push(new RemoveAction(a));
			actions.push(new RemoveAction(b));
			actions.push(new AddAction(mesh, a.getScene()));

			Editor$1.addAction(new ActionBundle(actions));
		}

		csg.addOption(Locale.intersect, function()
		{
			if(verifyCSG())
			{
				var a = createBSP(Editor$1.selection[0]);
				var b = createBSP(Editor$1.selection[1]);

				createCSGAction(a.intersect(b).toMesh(), Editor$1.selection[0], Editor$1.selection[1]);
			}
		}, Global.FILE_PATH + "icons/misc/intersect.png");

		csg.addOption(Locale.subtract, function()
		{
			if(verifyCSG())
			{
				var a = createBSP(Editor$1.selection[0]);
				var b = createBSP(Editor$1.selection[1]);

				createCSGAction(a.subtract(b).toMesh(), Editor$1.selection[0], Editor$1.selection[1]);
			}
		}, Global.FILE_PATH + "icons/misc/subtract.png");

		csg.addOption(Locale.union, function()
		{
			if(verifyCSG())
			{
				var a = createBSP(Editor$1.selection[0]);
				var b = createBSP(Editor$1.selection[1]);

				createCSGAction(a.union(b).toMesh(), Editor$1.selection[0], Editor$1.selection[1]);
			}
		}, Global.FILE_PATH + "icons/misc/union.png");

		var modifiers = editMenu.addMenu(Locale.modifiers, Global.FILE_PATH + "icons/models/figures.png");

		modifiers.addOption(Locale.simplify, function()
		{
			if(Editor$1.selection.length < 1 || Editor$1.selection[0].geometry === undefined)
			{
				Editor$1.alert(Locale.needsObjectGeometry);
				return;
			}

			var simplifier = new three.SimplifyModifier();

			var level = parseFloat(Editor$1.prompt("Simplification level in %")) / 100;
			if(isNaN(level) || level > 100 || level < 0)
			{
				Editor$1.alert("Level has to be a numeric value");
				return;
			}

			var original = Editor$1.selection[0].geometry;

			if(original instanceof three.BufferGeometry)
			{
				var vertices = original.getAttribute("position").array.length / 3;
			}
			else
			{
				var vertices = original.vertices.length;
			}

			var geometry = simplifier.modify(original, Math.ceil(vertices * level));
			var mesh = new Mesh(geometry, Editor$1.defaultMaterial);
			Editor$1.addObject(mesh);

			Editor$1.alert("Reduced from " + vertices + " to " + Math.ceil(vertices * level) + " vertex.");

		}, Global.FILE_PATH + "icons/models/triangle.png");

		modifiers.addOption(Locale.subdivide, function()
		{
			if(Editor$1.selection.length < 1 || Editor$1.selection[0].geometry === undefined)
			{
				Editor$1.alert(Locale.needsObjectGeometry);
				return;
			}

			var modifier = new three.SubdivisionModifier();
			var geometry = modifier.modify(Editor$1.selection[0].geometry);
			var mesh = new Mesh(geometry, Editor$1.defaultMaterial);
			Editor$1.addObject(mesh);
		}, Global.FILE_PATH + "icons/misc/subdivide.png");

		modifiers.addOption(Locale.twist, function()
		{
			if(Editor$1.selection.length < 1 || Editor$1.selection[0].geometry === undefined)
			{
				Editor$1.alert(Locale.needsObjectGeometry);
				return;
			}

			var angle = parseFloat(Editor$1.prompt("Twist angle", UnitConverter.convert(Math.PI / 2, "r", Editor$1.settings.units.angle)));
			if(isNaN(angle) || angle < 0)
			{
				Editor$1.alert("Twist amount has to be a numeric value");
				return;
			}

			// Convert back to radians if necessary
			angle = UnitConverter.convert(angle, Editor$1.settings.units.angle, "r");


			var start = parseFloat(Editor$1.prompt("Start Point", 0));
			var end = parseFloat(Editor$1.prompt("End Point", 1));
			if(isNaN(start) || isNaN(end))
			{
				Editor$1.alert("Start and end has to be a numeric value");
				return;
			}

			var modifier = new TwistModifier(angle, start, end);
			var geometry = modifier.modify(Editor$1.selection[0].geometry);
			var mesh = new Mesh(geometry, Editor$1.defaultMaterial);
			Editor$1.addObject(mesh);
		}, Global.FILE_PATH + "icons/models/twist.png");

		// Compute mesh normals
		editMenu.addOption(Locale.computeNormals, function()
		{
			if(Editor$1.selection.length < 1)
			{
				Editor$1.alert(Locale.needsObjectMesh);
				return;
			}

			var geometry = Editor$1.selection[0].geometry.clone();
			geometry.computeVertexNormals();
			Editor$1.addAction(new ChangeAction(Editor$1.selection[0], "geometry", geometry));
		}, Global.FILE_PATH + "icons/misc/probe.png");

		// Apply tranformation
		editMenu.addOption(Locale.applyTransformation, function()
		{
			if(Editor$1.selection.length < 1)
			{
				Editor$1.alert(Locale.needsObjectMesh);
				return;
			}

			var obj = Editor$1.selection[0];
			obj.geometry.applyMatrix4(obj.matrixWorld);
			obj.position.set(0, 0, 0);
			obj.scale.set(1, 1, 1);
			obj.rotation.set(0, 0, 0);

		}, Global.FILE_PATH + "icons/tools/move.png");

		// Merge geometries
		editMenu.addOption(Locale.mergeGeometries, function()
		{
			if(Editor$1.selection.length < 2)
			{
				Editor$1.alert(Locale.needsTwoObjectMesh);
				return;
			}

			var geometry = new three.Geometry();

			for(var i = 0; i < Editor$1.selection.length; i++)
			{	
				var obj = Editor$1.selection[i];
				if(obj.geometry !== undefined)
				{
					// Convert to geometry and merge
					if(obj.geometry instanceof three.BufferGeometry)
					{
						var converted = new three.Geometry();
						converted.fromBufferGeometry(obj.geometry);
						geometry.merge(converted, obj.matrixWorld);
					}
					// Merge geometry
					else
					{
						geometry.merge(obj.geometry, obj.matrixWorld);
					}
				}
			}

			var mesh = new Mesh(geometry, Editor$1.defaultMaterial);
			mesh.name = "merged";
			Editor$1.addObject(mesh);

		}, Global.FILE_PATH + "icons/misc/union.png");

		editMenu.updateInterface();

		// Project
		var projectMenu = new DropdownMenu(this);
		projectMenu.setText(Locale.project);
		projectMenu.size.set(100, this.size.y);
		projectMenu.position.set(220,0);

		projectMenu.addOption(Locale.createScene, function()
		{
			Editor$1.addDefaultScene();
		}, Global.FILE_PATH + "icons/misc/add.png");

		projectMenu.addOption(Locale.executeScript, function()
		{
			FileSystem.chooseFile(function(files)
			{
				try
				{
					if(files.length > 0)
					{
						var code = FileSystem.readFile(files[0].path);
						var func = Function(code);
						func();
					}
				}
				catch(error)
				{
					Editor$1.alert("Error: " + error);
				}
			}, ".js");
		}, Global.FILE_PATH + "icons/script/script.png");

		projectMenu.updateInterface();

		// About
		var about = new ButtonText(this);
		about.setText(Locale.about);
		about.size.set(100, this.size.y);
		about.position.set(320, 0);
		about.updateInterface();
		about.setOnClick(function()
		{
			var tab = Editor$1.gui.tab.getTab(AboutTab);
			if(tab === null)
			{
				tab = Editor$1.gui.tab.addTab(AboutTab, true);
			}
			tab.select();
		});

		// Run
		this.run = new ButtonText(this);
		this.run.setText(Locale.run);
		this.run.size.set(100, this.size.y);
		this.run.position.set(420, 0);
		this.run.updateInterface();
		this.run.setOnClick(function()
		{
			Editor$1.runProject();
		});
	}

	MainMenu.prototype = Object.create(Component.prototype);

	MainMenu.prototype.updateInterface = function()
	{
		this.updateVisibility();
	};

	/**
	 * The full GUI of the application.
	 *
	 * All objects are GUI objects are initialized in this object.
	 *
	 * @class Interface
	 */
	function Interface()
	{
		/**
		 * Main tab container that has all the interface tabs.
		 * 
		 * @attribute tab
		 * @type {TabContainer}
		 */
		this.tab = new TabContainer(DocumentBody);
		this.tab.attach(new TabGroupSplit());

		var main = this.tab.split(TabGroup.RIGHT).parent;
		main.tabPosition = 0.7;

		var left = main.elementA.split(TabGroup.BOTTOM).parent;
		left.tabPosition = 0.7;
		var leftTop = left.elementA;
		var leftBottom = left.elementB;

		var right = main.elementB.split(TabGroup.BOTTOM).parent;
		var rightTop = right.elementA;
		var rightBottom = right.elementB;

		this.assetExplorer = leftBottom.addTab(AssetExplorer, false);

		this.console = leftBottom.addTab(ConsoleTab, false);

		this.animation = leftBottom.addTab(AnimationTab, false);

		this.profiling = leftBottom.addTab(ProfilingTab, false);

		this.tree = rightTop.addTab(TreeView, false);

		this.inspector = rightBottom.addTab(InspectorContainer, false);

		this.menuBar = new MainMenu(DocumentBody);
	}

	/**
	 * Save program into file.
	 *
	 * Dpending on the plaftorm created the required GUI elements to select save file.
	 *
	 * @method saveProgram
	 */
	Interface.prototype.saveProgram = function()
	{
		if(Nunu.runningOnDesktop())
		{
			FileSystem.chooseFile(function(files)
			{
				Editor$1.saveProgram(files[0].path, true);
			}, ".nsp", true);
		}
		else
		{
			FileSystem.chooseFileName(function(fname)
			{
				Editor$1.saveProgram(fname, true);
			}, ".nsp", Editor$1.openFile !== null ? Editor$1.openFile : "file");
		}
	};

	/** 
	 * Load new project from file.
	 *
	 * Creates the necessary GUI elements to select the file.
	 *
	 * @method loadProgram
	 */
	Interface.prototype.loadProgram = function()
	{
		if(Editor$1.confirm(Locale.changesWillBeLost + " " + Locale.loadProject))
		{
			FileSystem.chooseFile(function(files)
			{
				if(files.length > 0)
				{
					Editor$1.loadProgram(files[0], files[0].name.endsWith(".nsp"));
				}
			}, ".isp, .nsp");
		}
	};

	/**
	 * Create new program.
	 *
	 * @method newProgram
	 */
	Interface.prototype.newProgram = function()
	{
		if(Editor$1.confirm(Locale.changesWillBeLost + " " + Locale.createProject))
		{
			Editor$1.createNewProgram();
		}
	};

	Interface.prototype.updateInterface = function()
	{
		var width = window.innerWidth;
		var height = window.innerHeight;

		this.tab.position.set(0, this.menuBar.size.y);
		this.tab.size.set(width, height - this.menuBar.size.y);
		this.tab.updateInterface();
	};

	/**
	 * Component is the base object for all GUI elements.
	 * 
	 * All GUI elements are based on the Component class, components can be inserted into other componens or into DOM elements.
	 * 
	 * @class Component
	 * @param {Component} parent Parent element.
	 * @param {string} type Type of the based DOM element.
	 */
	function Component(parent, type)
	{
		/** 
		 * Base DOM element for this component.
		 *
		 * Different components may use diferent base element types.
		 * 
		 * @attribute element
		 * @type {Component}
		 */
		this.element = document.createElement(type !== undefined ? type : "div");
		this.element.style.position = "absolute";
		this.element.style.overflow = "hidden";

		/**
		 * Event manager responsible for handling all events attached to this component.
		 *
		 * Allows children object types to expand the events of the object without overlapping event names.
		 *
		 * Only the events of this component should be put here. Avoid mixing events of different components across event handlers.
		 *
		 * @attribute event
		 * @type {EventManager}
		 */
		this.event = new EventManager();

		/** 
		 * The parent element that contains this Component.
		 *
		 * Can be a DOM element or another Component.
		 * 
		 * @attribute parent
		 * @type {Component}
		 */
		this.parent = null;
		if(parent !== undefined)
		{
			this.attachTo(parent);
		}
		
		/** 
		 * True if the element is visible.
		 *
		 * @attribute visible
		 * @type {boolean}
		 */
		this.visible = true;
		
		/**
		 * Size of this component in px.
		 *
		 * @attribute size
		 * @type {Vector2}
		 */
		this.size = new three.Vector2(0, 0);
		
		/**
		 * Position of this component relatively to its parent in px.
		 *
		 * @attribute position
		 * @type {Vector2}
		 */
		this.position = new three.Vector2(0, 0);

		/**
		 * Positioning mode, indicates how to anchor the component.
		 *
		 * @attribute mode
		 * @type {number}
		 */
		this._mode = Component.TOP_LEFT;
	}

	Component.prototype.constructor = Component;

	Component.prototype.isComponent = true;

	/**
	 * Top-left positioning.
	 *
	 * @static
	 * @attribute TOP_LEFT
	 * @type {number}
	 */
	Component.TOP_LEFT = 0;

	/**
	 * Top-right positioning.
	 *
	 * @static
	 * @attribute TOP_RIGHT
	 * @type {number}
	 */
	Component.TOP_RIGHT = 1;

	/**
	 * Bottom-left positioning.
	 *
	 * @static
	 * @attribute BOTTOM_LEFT
	 * @type {number}
	 */
	Component.BOTTOM_LEFT = 2;

	/**
	 * Bottom-right positioning.
	 *
	 * @static
	 * @attribute BOTTOM_RIGHT
	 * @type {number}
	 */
	Component.BOTTOM_RIGHT = 3;

	Component.preventDefault = function(event)
	{
		event.preventDefault();
	};

	/**
	 * Add a event to the component base element. The event is registered in the component event manager.
	 *
	 * @method addEvent
	 * @param {string} event Event name.
	 * @param {Function} callback Callback function passed to the event handler.
	 */
	Component.prototype.addEvent = function(event, callback)
	{
		this.event.addAndCreate(this.element, event, callback);
	};

	/**
	 * Remove all ocurrences of a event from the component. 
	 *
	 * @method removeEvent
	 * @param {string} event Event name.
	 */
	Component.prototype.removeEvent = function(event)
	{
		this.event.remove(this.element, event);
	};

	/**
	 * Replace all instance of a specific event with a new event.
	 *
	 * @method replaceEvent
	 * @param {string} event Event name.
	 * @param {Function} callback Callback function passed to the event handler.
	 */
	Component.prototype.replaceEvent = function(event, callback)
	{
		this.event.remove(this.element, event);
		this.event.addAndCreate(this.element, event, callback);
	};

	/** 
	 * Add a CSS class to the base DOM element of this Component.
	 * 
	 * @method addClass
	 * @param {string} name Name of the class to be added.
	 */
	Component.prototype.addClass = function(name)
	{
		this.element.classList.add(name);
	};

	/** 
	 * Remove a CSS class from the base DOM element of this Component.
	 * 
	 * @method removeClass
	 * @param {string} name Name of the class to be removed.
	 */
	Component.prototype.removeClass = function(name)
	{
		if(this.element.classList.contains(name))
		{
			this.element.classList.remove(name);
		}
	};

	/**
	 * Change style of the base DOM element.
	 *
	 * @method setStyle
	 * @param {string} attribute Name of the style attribute.
	 * @param {string} value Value of the style.
	 */
	Component.prototype.setStyle = function(attribute, value)
	{
		this.element.style[attribute] = value;
	};

	/**
	 * Set the multiple styles to the DOM element.
	 *
	 * Style are described in a object that uses the same attribute names as the normal DOM access.
	 *
	 * Here is an exaple of a style object:
	 * {
	 * backgroundColor: "#FF0000",
	 * color: "#FFFFFF"
	 * }
	 *
	 * @method setStyles
	 * @param {Object} styles Object describing the style to be applied to the object.
	 */
	Component.prototype.setStyles = function(styles)
	{
		for(var i in styles)
		{
			this.element.style[i] = styles[i];
		}
	};

	/**
	 * Add and drag and drop default event prevention to this component.
	 *
	 * Usefull to avoid unwanted actions on draggable components. 
	 *
	 * @method preventDragEvents
	 */
	Component.prototype.preventDragEvents = function()
	{
		this.element.ondrop = Component.preventDefault;
		this.element.ondragover = Component.preventDefault;
	};

	/**
	 * Set alt text, that is displayed when the mouse is over the element. Returns the element created that is attached to the document body.
	 *
	 * @method setAltText
	 * @param {string} altText Alt text.
	 */
	Component.prototype.setAltText = function(altText)
	{
		var element = document.createElement("div");
		element.style.position = "absolute";
		element.style.display = "none";
		element.style.alignItems = "center";
		element.style.zIndex = "10000";
		element.style.border = "3px solid";
		element.style.borderRadius = "5px";
		element.style.color = "var(--color-light)";
		element.style.backgroundColor = "var(--bar-color)";
		element.style.borderColor = "var(--bar-color)";
		element.style.height = "fit-content";
		document.body.appendChild(element);

		// Text
		var text = document.createTextNode(altText);
		element.appendChild(text);

		// Destroy
		var destroyFunction = this.destroy;
		this.destroy = function()
		{	
			destroyFunction.call(this);

			if(document.body.contains(element))
			{
				document.body.removeChild(element);
			}
		};
		
		this.element.style.pointerEvents = "auto"; 

		this.addEvent("mousemove", function(event)
		{
			element.style.display = "flex";
			element.style.left = (event.clientX + 8) + "px";
			element.style.top = (event.clientY - 20) + "px";
		});

		this.addEvent("mouseout", function()
		{
			element.style.display = "none";
		});

		return element;
	};

	/**
	 * Set method to be called on component click.
	 *
	 * A "click" event is added to the component event manager. Multiple click events can coexist.
	 * 
	 * @method setOnClick
	 * @param {Function} callback Function called when the component is clicked.
	 */
	Component.prototype.setOnClick = function(callback)
	{
		this.addEvent("click", callback);
	};

	/**
	 * Remove all DOM children from the element.
	 * 
	 * @method removeAllChildren
	 */
	Component.prototype.removeAllChildren = function()
	{
		while(this.element.firstChild)
		{
			this.element.removeChild(this.element.firstChild);
		}
	};

	/**
	 * Attach this component to a new parent component.
	 * 
	 * Destroys the object and reataches the base DOM element to the new parent element.
	 * 
	 * @method attachTo
	 * @param {Container} parent Parent container.
	 */
	Component.prototype.attachTo = function(parent)
	{
		if(this.parent === parent || parent === undefined)
		{
			return;
		}

		if(this.parent !== null)
		{
			Component.prototype.destroy.call(this);
		}

		this.parent = parent;

		if(parent.isComponent === true)
		{
			parent.element.appendChild(this.element);
		}
		else
		{
			console.warn("nunuStudio: Parent is not a Component." , this);
			this.parent.appendChild(this.element);
		}
	};

	/**
	 * Called to destroy a component.
	 *
	 * Destroy the element and removes it from its DOM parent.
	 * 
	 * @method destroy
	 */
	Component.prototype.destroy = function()
	{
		if(this.parent !== null)
		{
			if(this.parent.isComponent === true)
			{
				if(this.parent.element.contains(this.element))
				{
					this.parent.element.removeChild(this.element);
					this.parent = null;
				}
			}
			else
			{
				console.warn("nunuStudio: Parent is not a Component.", this);
				if(this.parent.contains(this.element))
				{
					this.parent.removeChild(this.element);
					this.parent = null;
				}
			}
		}
	};

	/**
	 * Set positioning mode.
	 * 
	 * @method setMode
	 * @param {number} setMode
	 */
	Component.prototype.setMode = function(mode)
	{
		this._mode = mode;
		this.element.style.bottom = null;
		this.element.style.top = null;
		this.element.style.right = null;
		this.element.style.left = null;
	};

	/**
	 * Calculate the position of the container to make it centered.
	 *
	 * Calculated relatively to its parent size.
	 * 
	 * @method center
	 */
	Component.prototype.center = function()
	{
		this.position.set((this.parent.size.x - this.size.x) / 2, (this.parent.size.y - this.size.y) / 2);
	};

	/**
	 * Update visibility of this element.
	 *
	 * @method setVisibility
	 */
	Component.prototype.setVisibility = function(visible)
	{
		this.visible = visible;
		this.updateVisibility();
	};

	/**
	 * Update the visibility of this element.
	 *
	 * @method updateVisibility
	 */
	Component.prototype.updateVisibility = function()
	{
		this.element.style.display = this.visible ? "block" : "none";
	};

	/**
	 * Update the position of this element.
	 * 
	 * @method updatePosition
	 */
	Component.prototype.updatePosition = function(mode)
	{
		if(mode !== undefined)
		{
			this._mode = mode;
		}

		if(this._mode === Component.TOP_LEFT || this._mode === Component.TOP_RIGHT)
		{
			this.element.style.top = this.position.y + "px";
		}
		else
		{
			this.element.style.bottom = this.position.y + "px";
		}

		if(this._mode === Component.TOP_LEFT || this._mode === Component.BOTTOM_LEFT)
		{
			this.element.style.left = this.position.x + "px";
		}
		else
		{
			this.element.style.right = this.position.x + "px";
		}
	};

	/**
	 * Update the size of this element.
	 * 
	 * @method updateSize
	 */
	Component.prototype.updateSize = function()
	{
		this.element.style.width = this.size.x + "px";
		this.element.style.height = this.size.y + "px";
	};

	/**
	 * Update component appearance.
	 * 
	 * Should be called after changing size or position.
	 *
	 * Uses the updateVisibility and if the element is visible calls the updateSize and updatePosition (in this order) methods to update the interface.
	 * 
	 * @method update
	 */
	Component.prototype.updateInterface = function()
	{
		this.updateVisibility();

		if(this.visible)
		{
			this.updateSize();
			this.updatePosition();
		}
	};

	/**
	 * nunuStudio core main file.
	 *   
	 * Store nunuStudio development version and timestamp and contains global method to check browser feature support.
	 * 
	 * @class Nunu
	 * @module Runtime
	 */
	function Nunu(){}

	/**
	 * nunuStudio
	 * 
	 * @attribute NAME
	 * @type {string}
	 * @default "nunuStudio"
	 */
	Nunu.NAME = "nunuStudio";

	/**
	 * Stores the nunu runtime version.
	 * 
	 * @attribute VERSION
	 * @type {string}
	 */
	Nunu.VERSION = "<PLACEHOLDER_VERSION>";

	/**
	 * Stores the nunu runtime dev timestamp.
	 * 
	 * @attribute TIMESTAMP
	 * @type {string}
	 */
	Nunu.TIMESTAMP = "<PLACEHOLDER_TIMESTAMP>";

	/**
	 * Repository branch, used to track the version after publishing.
	 * 
	 * @static
	 * @attribute REPOSITORY_BRANCH
	 * @type {string}
	 */
	Nunu.REPOSITORY_BRANCH = "<PLACEHOLDER_REPOSITORY_BRANCH>";

	/**
	 * Repository commit uuid, used to track the version after publishing.
	 * 
	 * @static
	 * @attribute REPOSITORY_COMMIT
	 * @type {string}
	 */
	Nunu.REPOSITORY_COMMIT = "<PLACEHOLDER_REPOSITORY_COMMIT>";

	/**
	 * NWJS platform, used for desktop version.
	 *
	 * @static
	 * @attribute NWJS
	 * @type {number}
	 */
	Nunu.NWJS = 200;

	/**
	 * Running inside of a regular web browser.
	 *
	 * @static
	 * @attribute BROWSER
	 * @type {number}
	 */
	Nunu.BROWSER = 201;

	/**
	 * Cordova platform, used for mobile versions.
	 *
	 * @static
	 * @attribute CORDOVA
	 * @type {number}
	 */
	Nunu.CORDOVA = 202;

	/**
	 * Import stuff from a namespace to another target namespace.
	 *
	 * If not target is specified window is used.
	 *
	 * @static
	 * @method importFrom
	 */
	Nunu.importFrom = function(namespace, target)
	{
		if(target === undefined)
		{
			target = window;
		}

		for(var i in namespace)
		{
			if(!(i in target))
			{
				target[i] = namespace[i];
			}
		}
	};

	Nunu.importFrom(THREE);
	Nunu.importFrom(CANNON);

	/**
	 * Check if nunu if running in development mode.
	 *
	 * @method developmentMode
	 * @return {boolean} True if running as development mode.
	 */
	Nunu.developmentMode = function()
	{
		return Nunu.TIMESTAMP === "<PLACEHOLDER_TIMESTAMP>";
	};

	/**
	 * Check if there is any VR API available, on the device.
	 *
	 * Checks if there is support for WebVR or WebXR.
	 *
	 * @method vrAvailable
	 * @return {boolean} True if the browser supports vr.
	 */
	Nunu.vrAvailable = function()
	{
		return Nunu.webVRAvailable() || Nunu.webXRAvailable();
	};

	/**
	 * Enter virtual reality mode using WebXR or WebVR depending on the API available.
	 *
	 * If booth API are available the WebXR API is used.
	 *
	 * When displaying VR content the display.requestAnimationFrame should be used to call the render method.
	 *
	 * @method enterVR
	 * @param {WebGLRenderer} renderer Renderer used to draw the scene.
	 * @param {Function} onSuccess Method called if the application entered VR successfully.
	 */
	Nunu.enterVR = function(renderer, onSuccess)
	{
		if(Nunu.webXRAvailable())
		{
			Nunu.getXRSession(function(session)
			{
				renderer.xr.enabled = true;
				renderer.xr.setSession(session);

				if(onSuccess !== undefined)
				{
					onSuccess();
				}
			});
		}
		else if(Nunu.webVRAvailable())
		{
			Nunu.getVRDisplay(function(display)
			{
				if(!display.isPresenting)
				{
					renderer.xr.enabled = true;
					renderer.xr.setDevice(display);
					display.requestPresent([{source : renderer.domElement}]);
					
					if(onSuccess !== undefined)
					{
						onSuccess();
					}
				}
			});
		}
		else
		{
			console.warn("nunuStudio: VR support is not available.");
		}
	};

	/**
	 * Enter virtual reality mode, if the application is not running on VR mode does not do anything.
	 *
	 * @method exitVR
	 * @param {WebGLRenderer} renderer Renderer used to draw the scene.
	 */
	Nunu.exitVR = function(renderer)
	{
		if(Nunu.webXRAvailable())
		{
			Nunu.getXRSession(function(session)
			{
				renderer.xr.enabled = false;
				renderer.xr.setSession(null);
			});
		}
		else if(Nunu.webVRAvailable())
		{
			Nunu.getVRDisplay(function(display)
			{
				if(display.isPresenting)
				{
					renderer.xr.enabled = false;
					renderer.xr.setDevice(null);
					device.exitPresent();
				}
			});
		}
	};

	/**
	 * WebXR session created.
	 *
	 * @attribute webXRSession
	 * @type {XRSession}
	 */
	Nunu.webXRSession = null;

	/**
	 * Flag checking if there is support for XR immersive VR mode.
	 *
	 * Checked on the library startup if XR is supported, while the check does not finish it is set to null.
	 *
	 * @attribute webXRSupported
	 * @type {boolean}
	 */
	Nunu.webXRSupported = null;

	if(navigator.xr !== undefined && navigator.xr.isSessionSupported !== undefined)
	{
		navigator.xr.isSessionSupported("immersive-vr").then(function(supported)
		{
			Nunu.webXRSupported = supported;
		});
	}

	/**
	 * Check if host supports WebXR.
	 * 
	 * @method webXRAvailable
	 * @return {boolean} True is WebVR is available.
	 */
	Nunu.webXRAvailable = function()
	{
		return navigator.xr !== undefined && navigator.xr.isSessionSupported !== undefined && Nunu.webXRSupported !== false;
	};

	/**
	 * Get WebXR session.
	 *
	 * @method getXRSession
	 * @param {Function} onSession Function used to get the XR session, receives the session as argument.
	 */
	Nunu.getXRSession = function(onSession)
	{
		if(!Nunu.webXRAvailable())
		{
			console.warn("nunuStudio: WebXR support is not available.");
			return;
		}

		if(Nunu.webXRSession !== null)
		{
			onSession(Nunu.webXRSession);
		}
		else
		{	
			navigator.xr.requestSession("immersive-vr",{optionalFeatures: ["local-floor", "bounded-floor"]}).then(function(session)
			{
				Nunu.webXRSession = session;
				onSession(session);
			});
		}
	};

	/**
	 * Web VR display obtained.
	 *
	 * @attribute webVRDisplay
	 * @type {VRDisplay}
	 */
	Nunu.webVRDisplay = null;

	/**
	 * Flag indicating if there are any VR displays available.
	 *
	 * Checked on the library bootup if WebVR is available, while the check does not finish it is set to null.
	 *
	 * @attribute webVRHasDisplay
	 * @type {boolean}
	 */
	Nunu.webVRHasDisplay = null;

	if(navigator.getVRDisplays !== undefined)
	{
		navigator.getVRDisplays().then(function(displays)
		{
			Nunu.webVRHasDisplay = displays.length > 0;
		});
	}

	/**
	 * Check if host supports WebVR.
	 * 
	 * @method webVRAvailable
	 * @return {boolean} True is WebVR is available.
	 */
	Nunu.webVRAvailable = function()
	{
		return navigator.getVRDisplays !== undefined && Nunu.webVRHasDisplay !== false;
	};

	/**
	 * Used to get the first VR display available, the display is returned as argument of the onDisplay function.
	 * 
	 * @method getVRDisplays
	 * @param {Function} onDisplay Function used to get the display, receives the display as argument.
	 */
	Nunu.getVRDisplay = function(onDisplay)
	{
		if(!Nunu.webVRAvailable())
		{
			console.warn("nunuStudio: WebVR support is not available.");
			return;
		}

		if(Nunu.webVRDisplay !== null)
		{
			onDisplay(Nunu.webVRDisplay);
		}
		else
		{
			navigator.getVRDisplays().then(function(displays)
			{
				if(displays.length > 0)
				{
					Nunu.webVRDisplay = displays[0];
					onDisplay(displays[0]);
				}
				else
				{
					console.warn("nunuStudio: WebVR supported but no display is available.");
				}
			});
		}
	};

	/**
	 * Get the query parameter from the browser URL.
	 *
	 * @method getQueryParameters
	 * @return {Object} Object with parameters read from the URL.
	 */
	Nunu.getQueryParameters = function()
	{
		var values = location.search.substring(1).split("&");
		var parameters = {};
		for(var i = 0; i < values.length; i++)
		{
			var pair = values[i].split("=");
			if(pair.length > 1)
			{
				var name = unescape(pair[0]).replace(new RegExp("\"", "g"), "");
				var value = unescape(pair[1]).replace(new RegExp("\"", "g"), "");
				parameters[name] = value;
			}
		}

		return parameters;
	};


	/**
	 * Create a web worker from code written in a string.
	 *
	 * Uses a blob to inject the code and loads it from and URL object.
	 *
	 * @method createWorker
	 * @param {string} code Javascript code for this worker.
	 * @param {Function} onMessage On message worker callback.
	 * @return {Worker} Returns a worker instance (for comunication).
	 */
	Nunu.createWorker = function(code, onMessage)
	{
		var blob = new Blob([code], {type: "application/javascript"});
		var worker = new Worker(URL.createObjectURL(blob));

		if(onMessage !== undefined)
		{
			worker.onmessage = onMessage;
		}
		
		return worker;
	};

	/**
	 * Check if host supports WebAudio.
	 *
	 * @method webAudioAvailable
	 * @return {boolean} True if WebAudio is available.
	 */
	Nunu.webAudioAvailable = function()
	{
		return window.AudioContext !== undefined || window.webkitAudioContext !== undefined;
	};

	/**
	 * Check if host supports WebGL, only checks for WebGL 1.0 support.
	 *
	 * @method webglAvailable
	 * @return {boolean} True if WebGL is available.
	 */
	Nunu.webGLAvailable = function()
	{
		try
		{
			var canvas = document.createElement("canvas"); 
			var context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
			var extensions = context.getSupportedExtensions();
			return true;
		}
		catch(e)
		{
			return false;
		}

		return false;
	};

	/**
	 * Check in wich platform the enviroment is running.
	 *
	 * Possible return values are:
	 *    - Nunu.NWJS
	 *    - Nunu.BROWSER
	 *    - Nunu.CORDOVA
	 *
	 * @method getPlatform
	 * @return {number} Indicates the platform type.
	 */
	Nunu.getPlatform = function()
	{
		if(window.nw !== undefined)
		{
			return Nunu.NWJS;
		}
		else if(window.cordova !== undefined)
		{
			return Nunu.CORDOVA;
		}
		
		return Nunu.BROWSER;
	};

	/**
	 * Check if nunu is running inside NWJS.
	 *
	 * @method runningOnDesktop
	 * @return {boolean} True if running inside NWJS 
	 */
	Nunu.runningOnDesktop = function()
	{
		return window.nw !== undefined;
	};


	/**
	 * Open a webpage on a new window.
	 *
	 * On desktop and mobile it will open the default browser.
	 *
	 * On the web it will open as a popup. 
	 *
	 * @method openWebpage
	 */
	Nunu.openWebpage = function(url)
	{
		if(Nunu.runningOnDesktop())
		{
			require("nw.gui").Shell.openExternal(url);
		}
		else
		{
			window.open(url);
		}
	};

	/**
	 * Check if there is some element on fullscreen mode.
	 *
	 * Returns true even the fullscreen element is not related with the app.
	 * 
	 * @method isFullscreen
	 * @return {boolean} True if there is some element in fullscreen mode.
	 */
	Nunu.isFullscreen = function()
	{
		return document.webkitIsFullScreen === true || document.mozFullScreen === true || document.webkitIsFullScreen === true || document.webkitIsFullScreen === true || document.fullscreen === true || false;
	};


	/**
	 * Set an element into fullscreen mode or exit out of fullscreen mode.
	 *
	 * Uses isFullscreen to check if the application is running in fullscreen mode already.
	 * 
	 * @method setFullscreen
	 * @param {boolean} fullscreen If true the application will enter fullscreen mode, if false it will exit, if undefine it will toggle the value.
	 * @param {Component} element DOM element to put into fullscreen.
	 */
	Nunu.setFullscreen = function(fullscreen, element)
	{
		var isFullscreen = Nunu.isFullscreen();
		
		if(fullscreen === undefined)
		{
			fullscreen = !isFullscreen;	
		}

		if(fullscreen === true)
		{
			if(element === undefined)
			{
				element = document.body;
			}

			if(isFullscreen === false)
			{
				element.requestFullscreen = element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
				
				if(element.requestFullscreen !== undefined)
				{
					element.requestFullscreen();
				}
			}
		}
		else
		{
			if(isFullscreen === true)
			{		
				document.exitFullscreen = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen;
				
				if(document.exitFullscreen !== undefined)
				{
					document.exitFullscreen();
				}
			}
		}
	};

	/**
	 * FileSystem is used to read and write files using nunuStudio.
	 * 
	 * Its implements multiple solutions for each method depending on the platform (NodeJS, brower or cordova).
	 *
	 * Some operations are platform specific and might not work everywhere.
	 *
	 * @module Files
	 * @class FileSystem
	 * @static
	 */
	function FileSystem(){}

	try
	{
		FileSystem.fs = require("fs");
	}
	catch(e){}

	/**
	 * Check if a file corresponds to a remote location.
	 *
	 * @method isLocalFile
	 * @return {boolean} If the file is remote returns true, false otherwise.
	 */
	FileSystem.isLocalFile = function(url)
	{
		return !(url.startsWith("http") || url.startsWith("blob") || url.startsWith("data"));
	};

	/**
	 * Read a local or remote file as text data.
	 *
	 * When running on desktop uses nodejs to access files, on the web performs a http GET request.
	 * 
	 * @method readFile
	 * @param {string} fname Path or URL of the file being read.
	 * @param {boolean} sync If true the file will be read in sync.
	 * @param {Function} onLoad onLoad callback receives the read data as parameter.
	 * @param {Function} onProgress onProgress callback used to check the file reading progress.
	 * @param {Function} onError onError call is called when a error occurs while reading the file.
	 * @return {string} File text, or null if the request is async.
	 */
	FileSystem.readFile = function(fname, sync, onLoad, onProgress, onError)
	{
		if(sync === undefined)
		{
			sync = true;
		}

		// NodeJS
		if(FileSystem.fs !== undefined && FileSystem.isLocalFile(fname))
		{
			if(sync === true)
			{
				var data = FileSystem.fs.readFileSync(fname, "utf8");

				if(onLoad !== undefined)
				{
					onLoad(data);
				}
				
				return data;
			}
			else
			{
				FileSystem.fs.readFile(fname, "utf8", function(error, data)
				{
					if(error !== null)
					{
						if(onError !== undefined)
						{
							onError(error);
						}
					}
					else if(onLoad !== undefined)
					{
						onLoad(data);
					}
				});

				return null;
			}
		}
		// Browser
		else
		{
			var file = new XMLHttpRequest();
			file.overrideMimeType("text/plain");
			file.open("GET", fname, !sync);
			
			if(onLoad !== undefined)
			{
				file.onload = function()
				{
					onLoad(file.response);
				};
			}

			if(onProgress !== undefined)
			{
				file.onprogress = onProgress;
			}
			if(onError !== undefined)
			{
				file.onerror = onError;
			}

			file.send(null);

			return sync === true ? file.response : null;
		}
	};

	/**
	 * Read a local or remote file as arraybuffer data.
	 *
	 * When running on desktop uses nodejs to access files, on the web performs a http GET request.
	 * 
	 * @method readFileArrayBuffer
	 * @param {string} fname Path or URL of the file being read.
	 * @param {boolean} sync If true the file will be read in sync.
	 * @param {Function} onLoad onLoad callback receives the read data as parameter.
	 * @param {Function} onProgress onProgress callback used to check the file reading progress.
	 * @param {Function} onError onError call is called when a error occurs while reading the file.
	 * @return {ArrayBuffer} File data as array buffer, or null if the request is async.
	 */
	FileSystem.readFileArrayBuffer = function(fname, sync, onLoad, onProgress, onError)
	{
		if(sync === undefined)
		{
			sync = true;
		}

		// NodeJS
		if(FileSystem.fs !== undefined && FileSystem.isLocalFile(fname))
		{
			if(sync === true)
			{
				var buffer = FileSystem.fs.readFileSync(fname);
				return ArraybufferUtils.fromBuffer(buffer);
			}
			else
			{
				FileSystem.fs.readFile(fname, function(error, buffer)
				{
					if(error !== null)
					{
						if(onError !== undefined)
						{
							onError(error);
						}
					}
					else if(onLoad !== undefined)
					{
						onLoad(ArraybufferUtils.fromBuffer(buffer));
					}
				});

				return null;
			}
		}
		// Browser
		else
		{
			var file = new XMLHttpRequest();
			file.open("GET", fname, !sync);
			file.overrideMimeType("text/plain; charset=x-user-defined");

			if(onLoad !== undefined)
			{
				file.onload = function()
				{
					onLoad(ArraybufferUtils.fromBinaryString(file.response));
				};
			}

			if(onProgress !== undefined)
			{
				file.onprogress = onProgress;
			}
			if(onError !== undefined)
			{
				file.onerror = onError;
			}

			file.send(null);

			return sync === true ? ArraybufferUtils.fromBinaryString(file.response) : null;
		}
	};

	/**
	 * Read a local or remote file as base64 data.
	 *
	 * When running on desktop uses nodejs to access files, on the web performs a http GET request.
	 * 
	 * @method readFileBase64
	 * @param {string} fname Path or URL of the file being read.
	 * @param {boolean} sync If true the file will be read in sync.
	 * @param {Function} onLoad onLoad callback receives the read data as parameter.
	 * @param {Function} onProgress onProgress callback used to check the file reading progress.
	 * @param {Function} onError onError call is called when a error occurs while reading the file.
	 * @return {string} File data as base64, or null if the request is async.
	 */
	FileSystem.readFileBase64 = function(fname, sync, onLoad, onProgress, onError)
	{
		if(sync === undefined)
		{
			sync = true;
		}
		
		// NodeJS
		if(FileSystem.fs !== undefined && FileSystem.isLocalFile(fname))
		{
			if(sync === true)
			{
				var buffer = FileSystem.fs.readFileSync(fname);
				return new Buffer(buffer).toString("base64");
			}
			else
			{
				FileSystem.fs.readFile(fname, function(error, buffer)
				{
					if(error !== null)
					{
						if(onError !== undefined)
						{
							onError(error);
						}
					}
					else if(onLoad !== undefined)
					{
						onLoad(new Buffer(buffer).toString("base64"));
					}
				});

				return null;
			}
		}
		// Browser
		else
		{
			var file = new XMLHttpRequest();
			file.open("GET", fname, !sync);
			file.overrideMimeType("text/plain; charset=x-user-defined");
			
			if(onLoad !== undefined)
			{		
				file.onload = function()
				{
					onLoad(Base64Utils.fromBinaryString(file.response));
				};
			}
			if(onProgress !== undefined)
			{
				file.onprogress = onProgress;
			}
			if(onError !== undefined)
			{
				file.onerror = onError;
			}

			file.send(null);

			return sync === true ? Base64Utils.fromBinaryString(file.response) : null;
		}
	};

	/**
	 * Write text to a file.
	 * 
	 * When running on the web it writes file to a blob and auto downloads it.
	 *
	 * @method writeFile
	 * @param {string} fname Name/path of the file to write.
	 * @param {string} data Text to be written to the file.
	 * @param {boolean} sync If true the file is written syncronously. (Only available for Nodejs).
	 * @param {Function} onFinish Callback function called when the file is written.
	 */
	FileSystem.writeFile = function(fname, data, sync, onFinish)
	{
		if(FileSystem.fs !== undefined)
		{
			if(FileSystem.fs.writeFileSync !== undefined)
			{
				if(sync !== false)
				{
					FileSystem.fs.writeFileSync(fname, data, "utf8");
					if(onFinish !== undefined)
					{
						onFinish();
					}
				}
				else
				{
					FileSystem.fs.writeFile(fname, data, "utf8", onFinish);
				}
			}
			else
			{
				var stream = FileSystem.fs.createWriteStream(fname, "utf8");
				stream.write(data);
				stream.end();
			}
		}
		else
		{
			var blob = new Blob([data], {type:"octet/stream"});

			var download = document.createElement("a");
			download.download = fname;
			download.href = window.URL.createObjectURL(blob);
			download.style.display = "none";
			download.onclick = function()
			{
				document.body.removeChild(this);
			};
			document.body.appendChild(download);
			download.click();

			if(onFinish !== undefined)
			{
				onFinish();
			}
		}
	};

	/**
	 * Write binary file using base64 data.
	 *
	 * If running on the web writes the file into a blob and auto downloads it.
	 *
	 * @method writeFileBase64
	 * @param {string} fname Name/path of the file to write.
	 * @param {string} data Base64 data to be written into the file.
	 * @param {boolean} sync If true the file is written syncronously. (Only available for Nodejs)
	 * @param {Function} onFinish Callback function called when the file is written.
	 */
	FileSystem.writeFileBase64 = function(fname, data, sync, onFinish)
	{
		if(FileSystem.fs !== undefined)
		{
			var buffer = Buffer.from(Base64Utils.removeHeader(data), "base64");

			if(FileSystem.fs.writeFile !== undefined)
			{
				if(sync !== false)
				{
					FileSystem.fs.writeFileSync(fname, buffer);

					if(onFinish !== undefined)
					{
						onFinish();
					}
				}
				else
				{
					FileSystem.fs.writeFile(fname, buffer, onFinish);
				}
			}
			else
			{
				var stream = FileSystem.fs.createWriteStream(fname);
				stream.write(buffer);
				stream.end();
			}
		}
		else
		{
			var array = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(data));
			var blob = new Blob([array]);

			var download = document.createElement("a");
			download.download = fname;
			download.href = window.URL.createObjectURL(blob);
			download.onclick = function()
			{
				document.body.removeChild(this);
			};
			download.style.display = "none";
			document.body.appendChild(download);
			download.click();

			if(onFinish !== undefined)
			{
				onFinish();
			}
		}
	};

	/**
	 * Write binary file using arraybuffer data. 
	 *
	 * If running on the web writes the file into a blob and auto downloads it.
	 *
	 * @method writeFileArrayBuffer
	 * @param {string} fname Name/path of the file to write.
	 * @param {string} data Arraybuffer data to be written into the file.
	 * @param {boolean} sync If true the file is written syncronously. (Only available for Nodejs)
	 * @param {Function} onFinish Callback function called when the file is written.
	 */
	FileSystem.writeFileArrayBuffer = function(fname, data, sync, onFinish)
	{	
		if(FileSystem.fs !== undefined)
		{
			var buffer = BufferUtils.fromArrayBuffer(data);

			if(FileSystem.fs.writeFileSync !== undefined)
			{
				if(sync !== false)
				{
					FileSystem.fs.writeFileSync(fname, buffer);

					if(onFinish !== undefined)
					{
						onFinish();
					}
				}
				else
				{
					FileSystem.fs.writeFile(fname, buffer, onFinish);
				}
			}
			else
			{
				var stream = FileSystem.fs.createWriteStream(fname);
				stream.write(buffer);
				stream.end();
			}
		}
		else
		{
			var blob = new Blob([data]);

			var download = document.createElement("a");
			download.download = fname;
			download.href = window.URL.createObjectURL(blob);
			download.onclick = function()
			{
				document.body.removeChild(this);
			};
			download.style.display = "none";
			document.body.appendChild(download);
			download.click();
			
			if(onFinish !== undefined)
			{
				onFinish();
			}
		}
	};

	/**
	 * Choose a file path/name to create a new file and write it to the system.
	 *
	 * Depending on the platform opens a file path selection windows of a box to select the name of the file.
	 *
	 * @method chooseFileWrite
	 * @param {Function} onLoad onLoad callback that receives the path select to write the file.
	 * @param {string} filter File type filter (e.g. ".zip,.rar, etc).
	 */
	FileSystem.chooseFileWrite = function(onLoad, filter)
	{
		if(Nunu.runningOnDesktop())
		{
			FileSystem.chooseFile(function(files)
			{
				if(files.length > 0)
				{
					onLoad(files[0].path);
				}
			}, filter, true);
		}
		else
		{
			FileSystem.chooseFileName(function(fname)
			{
				onLoad(fname);
			}, filter);
		}
	};

	/**
	 * Open file chooser dialog window for the user to select files stored in the system.
	 *
	 * The files selected are retrieved using the onLoad callback that receives a array of File objects.
	 *
	 * @method chooseFile
	 * @param {Function} onLoad onLoad callback that receives array of files as parameter.
	 * @param {string} filter File type filter (e.g. ".zip,.rar, etc)
	 * @param {string} saveas File format or name to be used, optinonally it can be a boolean value indicating savemode.
	 * @param {boolean} multiFile If true the chooser will accept multiple files.
	 */
	FileSystem.chooseFile = function(onLoad, filter, saveas, multiFile)
	{
		var chooser = document.createElement("input");
		chooser.type = "file";
		chooser.style.display = "none";
		document.body.appendChild(chooser);

		if(filter !== undefined)
		{
			chooser.accept = filter;
		}

		if(multiFile === true)
		{
			chooser.multiple = true;
		}

		chooser.onchange = function(event)
		{	
			if(onLoad !== undefined)
			{
				onLoad(chooser.files);
			}

			document.body.removeChild(chooser);
		};

		if(saveas !== undefined)
		{
			chooser.nwsaveas = (saveas !== true) ? saveas : "file";
		}
		
		chooser.click();
	};

	/**
	 * Used as an alternative to chooseFile for saving files in the browser.
	 *
	 * Uses a prompt to question the user the file name.
	 * 
	 * @method chooseFileName
	 * @param {Function} onLoad onLoad callback
	 * @param {string} saveas File extension
	 */
	FileSystem.chooseFileName = function(onLoad, saveas, name)
	{
		var fname = prompt("Save As", name !== undefined ? name : "file");
		
		if(fname !== null)
		{
			if(saveas !== undefined && !fname.endsWith(saveas))
			{
				fname += saveas;
			}
			
			if(onLoad !== undefined)
			{
				onLoad(fname);
			}
		}
	};

	/**
	 * Copy file (cannot be used to copy folders).
	 * 
	 * Only works when running inside NWJS.
	 *
	 * @method copyFile
	 * @param {string} src
	 * @param {string} dst
	 */
	FileSystem.copyFile = function(src, dst)
	{
		if(FileSystem.fs !== undefined)
		{
			if(FileSystem.fs.copyFileSync !== undefined)
			{
				FileSystem.fs.copyFileSync(src, dst);
			}
			else
			{
				src.replace(new RegExp("/", 'g'), "\\");
				dst.replace(new RegExp("/", 'g'), "\\");

				FileSystem.fs.createReadStream(src).pipe(FileSystem.fs.createWriteStream(dst));
			}
		}
	};

	/**
	 * Make a directory (dont throw exeption if directory already exists).
	 * 
	 * Only works when running inside NWJS.
	 *
	 * @method makeDirectory
	 * @param {string} dir
	 */
	FileSystem.makeDirectory = function(dir)
	{
		if(FileSystem.fs !== undefined)
		{
			dir.replace(new RegExp("/", 'g'), "\\");
			FileSystem.fs.mkdirSync(dir, {recursive: true});
		}
	};

	/**
	 * Returns files in directory (returns empty array in case of error).
	 * 
	 * Only works when running inside NWJS.
	 *
	 * @method getFilesDirectory
	 * @return {Array} Files in the directory
	 */
	FileSystem.getFilesDirectory = function(dir)
	{
		if(FileSystem.fs !== undefined)
		{
			try
			{
				dir.replace(new RegExp("/", 'g'), "\\");
				return FileSystem.fs.readdirSync(dir);
			}
			catch(e)
			{
				return [];
			}
		}

		return [];
	};

	/**
	 * Delete folders and all subfolders.
	 * 
	 * Only works when running inside NWJS.
	 *
	 * @method deleteFolder
	 * @param {string} path
	 */
	FileSystem.deleteFolder = function(path)
	{
		if(FileSystem.fs !== undefined)
		{
			if(FileSystem.fs.existsSync(path))
			{
				FileSystem.fs.readdirSync(path).forEach(function(file, index)
				{
					var curPath = path + "/" + file;

					if(FileSystem.fs.lstatSync(curPath).isDirectory())
					{
						FileSystem.deleteFolder(curPath);
					}
					else
					{
						FileSystem.fs.unlinkSync(curPath);
					}
				});

				FileSystem.fs.rmdirSync(path);
			}
		}
	};

	/**
	 * Copy folder and all its files (includes symbolic links).
	 * 
	 * Only works when running inside NWJS.
	 *
	 * @method copyFolder
	 * @param {string} src
	 * @param {string} dst
	 */
	FileSystem.copyFolder = function(src, dst)
	{
		if(FileSystem.fs !== undefined)
		{
			src.replace(new RegExp("/", 'g'), "\\");
			dst.replace(new RegExp("/", 'g'), "\\");

			FileSystem.makeDirectory(dst);
			var files = FileSystem.fs.readdirSync(src);

			for(var i = 0; i < files.length; i++)
			{
				var source = src + "\\" + files[i];
				var destiny = dst + "\\" + files[i];
				var current = FileSystem.fs.statSync(source);
				
				// Directory
				if(current.isDirectory())
				{
					FileSystem.copyFolder(source, destiny);
				}
				// Symbolic link
				else if(current.isSymbolicLink())
				{
					FileSystem.fs.symlinkSync(FileSystem.fs.readlinkSync(source), destiny);
				}
				// File
				else
				{
					FileSystem.copyFile(source, destiny);
				}
			}
		}
	};

	/**
	 * Check if a file exists.
	 * 
	 * Only works inside of NWJS. When running inside the browser always returns false.
	 *
	 * @method fileExists
	 * @param {string} file File path
	 * @return {boolean} True is file exists
	 */
	FileSystem.fileExists = function(file)
	{
		if(FileSystem.fs !== undefined)
		{
			file.replace(new RegExp("/", 'g'), "\\");

			return FileSystem.fs.existsSync(file);
		}

		return false;
	};

	/**
	 * Get file name without extension from file path string.
	 * 
	 * If input is a/b/c/abc.d output is abc.
	 * 
	 * @method getFileName
	 * @param {string} file File path
	 * @return {string} File name without path and extension
	 */
	FileSystem.getFileName = function(file)
	{
		if(file !== undefined)
		{
			var a = file.lastIndexOf("\\");
			var b = file.lastIndexOf("/");

			return file.substring((a > b) ? (a + 1) : (b + 1), file.lastIndexOf("."));
		}
		
		return "";
	};

	/**
	 * Get file name with extension from file path string.
	 * 
	 * If input is a/b/c/abc.d output is abc.d.
	 * 
	 * @method getFileNameWithExtension
	 * @param {string} file File path
	 * @return {string} File name without path with extension
	 */
	FileSystem.getFileNameWithExtension = function(file)
	{
		if(file !== undefined)
		{
			var a = file.lastIndexOf("\\");
			var b = file.lastIndexOf("/");

			return file.substring((a > b) ? (a + 1) : (b + 1), file.length);
		}
		
		return "";
	};

	/**
	 * Get file name without extension.
	 * 
	 * If input is a/b/c/abc.d output is a/b/c/abc.
	 *
	 * @method getNameWithoutExtension
	 * @param {string} file File path
	 * @return {string}
	 */
	FileSystem.getNameWithoutExtension = function(file)
	{
		if(file !== undefined)
		{
			return file.substring(0, file.lastIndexOf("."));
		}

		return "";
	};

	/**
	 * Get directory where the file is placed.
	 * 
	 * If input is a/b/c/abc.d output is a/b/c/
	 *
	 * @method getFilePath
	 * @param {string} file File path
	 * @return {string}
	 */
	FileSystem.getFilePath = function(file)
	{
		if(file !== undefined)
		{
			var a = file.lastIndexOf("\\");
			var b = file.lastIndexOf("/");

			return file.substring(0, (a > b) ? (a + 1) : (b + 1));
		}

		return "";
	};

	/**
	 * Get file extension from file path string (always in lowercase).
	 * 
	 * If input is a/b/c/abc.d output is d.
	 *
	 * @method getFileExtension
	 * @param {string} file File path
	 * @return {string}
	 */
	FileSystem.getFileExtension = function(file)
	{	
		if(file !== undefined)
		{
			return file.substring(file.lastIndexOf(".") + 1, file.length).toLowerCase();
		}
		
		return "";
	};

	/**
	 * Resource class is used to represent resources.
	 * 
	 * Resources store data that is used by objects.
	 * 
	 * @class Resource
	 * @module Resources
	 */
	function Resource(name, type)
	{
		/**
		 * Resource name.
		 * 
		 * Not required to be unique.
		 * 
		 * @property name
		 * @type {string}
		 */
		this.name = name;

		/**
		 * UUID unique identifier.
		 * 
		 * @property uuid
		 * @type {string}
		 */
		this.uuid = three.Math.generateUUID();

		/**
		 * Resource type. Used to identify the type of the resource, usefull for serialization.
		 * 
		 * @property type
		 * @type {string}
		 */
		this.type = type;

		/**
		 * Data format (base64, arraybuffer, blob, url, ...).
		 * 
		 * Indicates the format used to store the data.
		 * 
		 * @property format
		 * @type {Object}
		 */
		this.format = "";

		/**
		 * Data encoding (mp3, jpg, mp4, ...).
		 * 
		 * Indicates how the data is encoded.
		 * 
		 * @property encoding
		 * @type {String, ArrayBuffer, ...}
		 */
		this.encoding = "";

		/**
		 * Resource data.
		 * 
		 * @property data
		 * @type {Object}
		 */
		this.data = null;
	}

	/**
	 * Export resource data to file.
	 *
	 * @method export
	 * @param {string} fname File name or file path.
	 */
	Resource.prototype.export = function(fname)
	{
		if(this.format === "base64")
		{
			FileSystem.writeFileBase64(fname, this.data);
		}
		else if(this.format === "arraybuffer")
		{
			FileSystem.writeFileArrayBuffer(fname, this.arraybuffer !== undefined ? this.arraybuffer : this.data);
		}
		else if(this.format === "string")
		{
			FileSystem.writeFile(fname, this.data);
		}
		else if(this.format === "json")
		{
			FileSystem.writeFile(fname, JSON.stringify(this.data));
		}
		else if(this.format === "url")
		{
			FileSystem.writeFileArrayBuffer(fname, FileSystem.readFileArrayBuffer(this.data));
		}
	};

	/**
	 * Dispose resource, should be called to free memory after its no longer required.
	 *
	 * @method dispose
	 */
	Resource.prototype.dispose = function(){};

	/**
	 * Serialize resource to json.
	 *
	 * Only serializes name, uuid and type.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	Resource.prototype.toJSON = function(meta)
	{
		var data = {};
		
		data.name = this.name;
		data.uuid = this.uuid;
		data.type = this.type;

		return data;
	};

	/**
	 * Video resources are used to store video.
	 * 
	 * Video data stored in base64.
	 * 
	 * @class Video
	 * @extends {Resource}
	 * @module Resources
	 * @param {string} url URL to video file.
	 * @param {string} encoding Image encoding, required for ArrayBuffer data.
	 */
	function Video(url, encoding)
	{
		Resource.call(this, "video", "Video");

		if(url !== undefined)
		{	
			// ArrayBuffer
			if(url instanceof ArrayBuffer)
			{
				this.loadArrayBufferData(url, encoding);
			}
			// Base64
			else if(Base64Utils.isBase64(url))
			{
				this.encoding = Base64Utils.getFileFormat(url);
				this.format = "base64";
				this.data = url;
			}
			// URL
			else
			{
				this.loadArrayBufferData(FileSystem.readFileArrayBuffer(url), FileSystem.getFileExtension(url));
			}
		}
	}

	Video.prototype = Object.create(Resource.prototype);

	/**
	 * Check if a file name refers to a supported video file.
	 *
	 * @method fileIsVideo
	 * @static
	 * @param {File} file
	 * @return {boolean} True if the file refers to a supported video format.
	 */
	Video.fileIsVideo = function(file)
	{
		if(file !== undefined)
		{
			if(file.type.startsWith("video"))
			{
				return true;
			}
		}

		return false;
	};

	/**
	 * Load arraybuffer data to this image.
	 *
	 * Creates a blob with data to be stored on data atribute and used by external objects.
	 *
	 * @method loadArrayBufferData
	 * @param {ArrayBuffer} data Data to be loaded.
	 * @param {string} encoding Video enconding (mp4, webm, etc).
	 */
	Video.prototype.loadArrayBufferData = function(data, encoding)
	{
		var view = new Uint8Array(data);
		var blob = new Blob([view], {type: "video/" + encoding});

		this.data = URL.createObjectURL(blob);
		this.arraybuffer = data;
		this.encoding = encoding;
		this.format = "arraybuffer";
	};

	/**
	 * Serialize resource to json.
	 * 
	 * Video data is stored in Base64.
	 *
	 * @method toJSON
	 * @param {Object} meta
	 * @return {Object} json
	 */
	Video.prototype.toJSON = function(meta)
	{
		if(meta.videos[this.uuid] !== undefined)
		{
			return meta.videos[this.uuid];
		}
		
		var data = Resource.prototype.toJSON.call(this, meta);
		
		data.encoding = this.encoding;

		if(this.format === "arraybuffer")
		{
			data.format = this.format;
			data.data = this.arraybuffer;
		}
		else if(this.format === "base64")
		{
			data.format = "arraybuffer";
			data.data = ArraybufferUtils.fromBase64(Base64Utils.removeHeader(this.data));
		}
		else
		{
			data.format = this.format;
			data.data = this.data;
		}

		meta.videos[this.uuid] = data;

		return data;
	};

	/**
	 * Alternative to node clipboard to enable simple copy paste inside the editor web version.
	 *
	 * When copying data also copies data to the system clipboard.
	 *
	 * @class VirtualClipboard
	 */
	function VirtualClipboard()
	{
		/**
		 * Values stored in the virtual clipboard.
		 *
		 * @attribute values
		 * @type {Array}
		 */
		this.values = [];
	}

	/**
	 * Set data to clipboard
	 * 
	 * @param {Object} data Data to insert into the clipboard
	 * @param {string} id Entry id.
	 */
	VirtualClipboard.prototype.set = function(data, id)
	{
		this.values[id] = data;
		VirtualClipboard.copy(data);
	};

	/**
	 * Get data from clipboard
	 * 
	 * @param {string} id Entry id.
	 * @return {Object} Data stored in the clipboard
	 */
	VirtualClipboard.prototype.get = function(id)
	{
		return this.values[id];
	};

	VirtualClipboard.copy = function(text)
	{
		var textArea = document.createElement("textarea");
		textArea.style.position = "fixed";
		textArea.style.top = 0;
		textArea.style.left = 0;
		textArea.style.width = "2em";
		textArea.style.height = "2em";
		textArea.style.padding = 0;
		textArea.style.border = "none";
		textArea.style.outline = "none";
		textArea.style.boxShadow = "none";
		textArea.style.background = "transparent";
		textArea.value = text;

		document.body.appendChild(textArea);
		textArea.select();

		try
		{
			var success = document.execCommand("copy");
		}
		catch(e){}

		document.body.removeChild(textArea);
	};

	/** 
	 * Tab used to preview a project running.
	 *
	 * Clones the project instance and run it. Changes appplied in other tabs are not applied to the running instance.
	 *
	 * @class RunProject
	 * @extends {TabComponent}
	 */
	function RunProject(parent, closeable, container, index)
	{
		TabComponent.call(this, parent, closeable, container, index, Locale.run, Global.FILE_PATH + "icons/misc/play.png");

		var self = this;

		/**
		 * Rendering canvas element where the program is presented.
		 *
		 * @attribute canvas
		 * @type {RendererCanvas}
		 */
		this.canvas = new RendererCanvas(this, Editor$1.program.rendererConfig);

		/**
		 * Program being run on this tab.
		 *
		 * @attribute program
		 * @type {Program}
		 */
		this.program = null;

		/**
		 * Fullscreen button used to toggle fullscreen mode.
		 *
		 * @attribute fullscreenButton
		 * @type {ButtonIcon}
		 */
		this.fullscreenButton = new ButtonIcon(this);
		this.fullscreenButton.position.set(5, 5);
		this.fullscreenButton.size.set(30, 30);
		this.fullscreenButton.setImage(Global.FILE_PATH + "icons/misc/fullscreen.png");
		this.fullscreenButton.setAltText(Locale.toggleFullscreen);
		this.fullscreenButton.setImageScale(0.8, 0.8);
		this.fullscreenButton.updateSize();
		this.fullscreenButton.updatePosition(Component.BOTTOM_RIGHT);
		this.fullscreenButton.setStyle("borderRadius", "5px");
		this.fullscreenButton.setVisibility(true);

		// TODO <USE BUTTON STYLES>
		/*
		this.fullscreenButton.setStyle("opacity", 0.5);
		this.fullscreenButton.setStyle("backgroundColor", "var(--panel-color)");
		this.fullscreenButton.element.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};
		this.fullscreenButton.element.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};
		*/

		var fullscreen = true;
		this.fullscreenButton.setOnClick(function()
		{
			self.setFullscreen(fullscreen);
			fullscreen = !fullscreen;
		});

		/**
		 * VR button used to toggle vr mode.
		 *
		 * It is only displayed when VR is available.
		 *
		 * @attribute vrButton
		 * @type {ButtonIcon}
		 */
		this.vrButton = new ButtonIcon(this);
		this.vrButton.size.set(30, 30);
		this.vrButton.position.set(40, 5);
		this.vrButton.setImage(Global.FILE_PATH + "icons/misc/vr.png");
		this.vrButton.setAltText(Locale.toggleVR);
		this.vrButton.setImageScale(0.8, 0.8);
		this.vrButton.updateSize();
		this.vrButton.updatePosition(Component.BOTTOM_RIGHT);
		this.vrButton.setVisibility(false);
		this.vrButton.setStyle("backgroundColor", "var(--panel-color)");
		this.vrButton.setStyle("borderRadius", "5px");
		this.vrButton.setStyle("opacity", 0.5);
		this.vrButton.element.onmouseenter = function()
		{
			this.style.opacity = 1.0;
		};
		this.vrButton.element.onmouseleave = function()
		{
			this.style.opacity = 0.5;
		};
	}

	RunProject.prototype = Object.create(TabComponent.prototype);

	RunProject.prototype.reloadContext = RendererCanvas.prototype.reloadContext;
	RunProject.prototype.forceContextLoss = RendererCanvas.prototype.forceContextLoss;

	RunProject.prototype.activate = function()
	{
		this.canvas.createRenderer();
		this.updateSettings();

		if(this.program === null)
		{
			this.getProgram();
			this.runProgram();
		}

		Editor$1.gui.menuBar.run.setText(Locale.stop);

		TabComponent.prototype.activate.call(this);
	};

	RunProject.prototype.deactivate = function()
	{
		TabComponent.prototype.deactivate.call(this);

		Editor$1.gui.menuBar.run.setText(Locale.run);
	};

	RunProject.prototype.isAttached = function(program)
	{
		return program === Editor$1.program;
	};

	RunProject.prototype.destroy = function()
	{
		TabComponent.prototype.destroy.call(this);

		this.stopProgram();

		this.canvas.forceContextLoss();
	};

	/**
	 * Set fullscreen mode of the tab canvas
	 *
	 * @method setFullscreen
	 * @param {boolean} fullscreen If true enters fullscreen if false exits fullscreen.
	 */
	RunProject.prototype.setFullscreen = function(fullscreen)
	{
		if(fullscreen)
		{
			Nunu.setFullscreen(true, this.element);

			this.position.set(0, 0);	
			this.size.set(window.screen.width, window.screen.height);
			this.updateInterface();
		}
		else
		{
			Nunu.setFullscreen(false);
			Editor$1.gui.updateInterface();
		}
	};

	/** 
	 * Dispose runnning program.
	 *
	 * @method stopProgram
	 */
	RunProject.prototype.stopProgram = function()
	{
		this.setFullscreen(false);

		if(this.program !== null)
		{
			this.program.dispose();
			this.program = null;
		}
	};

	/**
	 * Update the program logic and render the program to the canvas using the renderer.
	 *
	 * @method update
	 */
	RunProject.prototype.update = function()
	{
		if(this.program === null)
		{
			return;
		}

		try
		{
			this.program.update();
		}
		catch(error)
		{
			Editor$1.alert(Locale.errorRunRender + "\n(" + error + ")");
			console.warn("nunuStudio: Error while running program.", error);
			this.close();
			return;
		}

		try
		{
			this.program.render(this.canvas.renderer);
		}
		catch(error)
		{
			Editor$1.alert(Locale.errorRunRender + "\n(" + error + ")");
			console.warn("nunuStudio: Error while rendering program.", error);
			this.close();
			return;
		}
	};


	RunProject.prototype.resetCanvas = function()
	{
		RendererCanvas.prototype.resetCanvas.call(this);

		if(this.program !== null && this.program.mouse !== null)
		{
			this.program.mouse.setCanvas(this.canvas.canvas);
		}
	};

	/** 
	 * Get the Editor.program object to be run in this tab.
	 *
	 * @method getProgram
	 */
	RunProject.prototype.getProgram = function()
	{
		// Run the program directly all changed made with code are kept
		if(Editor$1.settings.general.immediateMode)
		{
			this.program = Editor$1.program;
		}
		// Run a copy of the program
		else
		{
			this.program = Editor$1.program.clone();
		}
	};

	/** 
	 * Prepare the program to be run, create a default camera.
	 *
	 * Run the initialization scripts from the object and set the renderer size.
	 *
	 * @method runProgram
	 */
	RunProject.prototype.runProgram = function()
	{
		try
		{
			// Create a default camera for program (same as runtime).
			this.program.defaultCamera = new PerspectiveCamera(60, 1, 0.1, 1e5);
			this.program.defaultCamera.position.set(0, 5, -5);
			
			// Set runtime variables
			this.program.setRenderer(this.canvas.renderer);
			this.program.initialize();
			this.program.resize(this.canvas.canvas.width, this.canvas.canvas.height);
		}
		catch(error)
		{
			Editor$1.alert(Locale.errorRunInitialize + "\n(" + error + ")");
			console.warn("nunuStudio: Error while initializing program.", error);
			this.close();
			return;
		}

		// If program uses VR set button
		if(this.program.vrAvailable())
		{
			// Show VR button
			this.vrButton.setVisibility(true);

			// Create VR switch callback
			var program = this.program;
			this.vrButton.setOnClick(function()
			{
				if(program.vrRunning)
				{
					program.exitVR();
				}
				else
				{
					program.enterVR();
				}
			});
		}
	};

	/** 
	 * Restart the program running in the tab.
	 *
	 * @method restartProgram
	 */
	RunProject.prototype.restartProgram = function()
	{
		this.stopProgram();
		this.getProgram();
		this.runProgram();
	};

	RunProject.prototype.updateSize = function()
	{
		TabComponent.prototype.updateSize.call(this);

		this.canvas.size.copy(this.size);
		this.canvas.updateSize();

		if(this.program !== null)
		{
			this.program.resize(this.canvas.size.x, this.canvas.size.y);
		}
	};

	/**
	 * nunuStudio main editor entry point. 
	 *
	 * @class Editor 
	 */
	function Editor$1(){}

	/**
	 * Initialize the editor code, creates all GUI elements, loads configuration data, starts all the event lsiteners required.
	 *
	 * Called when the application starts.
	 *
	 * @static
	 * @method initialize
	 */
	Editor$1.initialize = function()
	{
		// Check WebGL Support
		if(!Nunu.webGLAvailable())
		{
			Editor$1.alert(Locale.webglNotSupported);
			Editor$1.exit();
		}
		
		// Settings
		Editor$1.settings = new Settings();
		Editor$1.settings.load();

		// Register tern plugins
		Editor$1.ternDefinitions = [];
		Editor$1.ternDefinitions.push(JSON.parse(FileSystem.readFile(Global.FILE_PATH + "tern/threejs.json")));
		Editor$1.ternDefinitions.push(JSON.parse(FileSystem.readFile(Global.FILE_PATH + "tern/browser.json")));
		Editor$1.ternDefinitions.push(JSON.parse(FileSystem.readFile(Global.FILE_PATH + "tern/ecmascript.json")));

		// Disable body overflow
		document.body.style.overflow = "hidden";
		document.body.style.fontFamily = "var(--font-main-family)";
		document.body.style.color = "var(--font-main-color)";
		document.body.style.fontSize = "var(--font-main-size)";
		
		// Disable context menu
		document.body.oncontextmenu = function(event)
		{
			return false;
		};

		// Watch for changes in the screen pixel ratio (drag between screens)
		window.matchMedia("screen and (min-resolution: 2dppx)").addListener(function(e)
		{
			Editor$1.resize();
		});

		if(Nunu.runningOnDesktop())
		{
			var gui = require("nw.gui");
			Editor$1.clipboard = gui.Clipboard.get();
			Editor$1.args = gui.App.argv;

			// Handle window close event
			gui.Window.get().on("close", function()
			{
				if(confirm(Locale.unsavedChangesExit))
				{
					Editor$1.exit();
				}
			});

			// Try to update the editor
			if(Editor$1.settings.general.autoUpdate)
			{
				Editor$1.updateNunu();
			}
		}
		else
		{
			// Clipboard
			Editor$1.clipboard = new VirtualClipboard();
			
			// Arguments
			Editor$1.args = [];

			var parameters = Nunu.getQueryParameters();
			for(var i in parameters)
			{
				Editor$1.args.push(parameters[i]);
			}
			
			// Prevent some key combinations
			var allowedKeys = [Keyboard.C, Keyboard.V, Keyboard.A, Keyboard.X];
			document.onkeydown = function(event)
			{
				// If F1-F11 or CTRL+Key prevent default action
				if((event.keyCode > Keyboard.F1 && event.keyCode < Keyboard.F11) || (!event.altKey && event.ctrlKey && allowedKeys.indexOf(event.keyCode) === -1))
				{
					event.preventDefault();
				}
			};

			// Store settings when exiting the page
			window.onbeforeunload = function(event)
			{
				Editor$1.settings.store();

				var message = Locale.unsavedChangesExit;
				event.returnValue = message;
				return message;	
			};
		}

		// Open ISP file if dragged to the window
		document.body.ondrop = function(event)
		{
			event.preventDefault();
			
			for(var i = 0; i < event.dataTransfer.files.length; i++)
			{
				var file = event.dataTransfer.files[i];
				var extension = FileSystem.getFileExtension(file.name);

				// Project file
				if(extension === "isp" || extension === "nsp")
				{
					if(Editor$1.confirm(Locale.changesWillBeLost + " " + Locale.loadProject))
					{
						Editor$1.loadProgram(file, extension === "nsp");
						Editor$1.resetEditor();
					}
					break;
				}
				// Text file
				else if(TextFile.fileIsText(file))
				{
					Loaders.loadText(file);
				}
			}
		};

		// Open file
		Editor$1.openFile = null;

		// Selected object
		Editor$1.selection = [];

		// Program
		Editor$1.program = null;

		// History
		Editor$1.history = null;

		// Initialize User Interface
		Editor$1.gui = new Interface();
		Editor$1.gui.updateInterface();

		// Check is some project file passed as argument
		for(var i = 0; i < Editor$1.args.length; i++)
		{
			if(Editor$1.args[i].endsWith(".isp"))
			{
				Editor$1.loadProgram(Editor$1.args[i], false);
				break;
			}
			else if(Editor$1.args[i].endsWith(".nsp"))
			{
				Editor$1.loadProgram(Editor$1.args[i], true);
				break;
			}
		}

		// Create new program
		if(Editor$1.program === null)
		{	
			Editor$1.createNewProgram();
		}

		// Event manager
		Editor$1.manager = new EventManager();
		Editor$1.manager.add(document.body, "keydown", function(event)
		{
			var key = event.keyCode;

			if(event.ctrlKey)
			{
				if(key === Keyboard.S)
				{
					if(Editor$1.openFile === null)
					{
						Editor$1.gui.saveProgram();
					}
					else
					{
						Editor$1.saveProgram(undefined, true);
					}
				}
				else if(key === Keyboard.L)
				{
					Editor$1.gui.loadProgram();
				}
				else if(key === Keyboard.W || key === Keyboard.F4)
				{
					Editor$1.gui.tab.closeActual();
				}
				else if(key === Keyboard.TAB || key === Keyboard.PAGE_DOWN)
				{
					Editor$1.gui.tab.selectNextTab();
				}
				else if(key === Keyboard.PAGE_UP)
				{
					Editor$1.gui.tab.selectPreviousTab();
				}
				else if(key === Keyboard.Z)
				{
					var tabs = Editor$1.gui.tab.getActiveTab();
					for(var i = 0; i < tabs.length; i++)
					{
						if(tabs[i] instanceof CodeEditor)
						{
							return;
						}
					}
					
					Editor$1.undo();
				}
				else if(key === Keyboard.Y)
				{
					var tabs = Editor$1.gui.tab.getActiveTab();
					for(var i = 0; i < tabs.length; i++)
					{
						if(tabs[i] instanceof CodeEditor)
						{
							return;
						}
					}

					Editor$1.redo();
				}
			}
			else if(key === Keyboard.DEL)
			{
				var tabs = Editor$1.gui.tab.getActiveTab();
				for(var i = 0; i < tabs.length; i++)
				{
					if(tabs[i] instanceof CodeEditor)
					{
						return;
					}
				}

				if(Editor$1.hasObjectSelected())
				{
					var del = Editor$1.confirm(Locale.deleteObjects);
					if(del)
					{
						Editor$1.deleteObject();
					}
				}
			}
			else if(key === Keyboard.F2)
			{
				Editor$1.renameObject();
			}
			else if(key === Keyboard.F5)
			{
				Editor$1.runProject();
			}
		});
		Editor$1.manager.create();
	};

	/** 
	 * Run the project that is currently open in the editor.
	 *
	 * Opens a new tab, and sets the run button text.
	 *
	 * @static
	 * @method runProject
	 */
	Editor$1.runProject = function()
	{
		var tab = Editor$1.gui.tab.getTab(RunProject, Editor$1.program);

		if(tab === null)
		{
			tab = Editor$1.gui.tab.addTab(RunProject, true);
			tab.select();
			Editor$1.gui.menuBar.run.setText(Locale.stop);
		}
		else
		{
			tab.close();
			Editor$1.gui.menuBar.run.setText(Locale.run);
		}
	};

	/**
	 * Select single object.
	 * 
	 * @method selectObject
	 * @param {Object3D} object Object to select.
	 */
	Editor$1.selectObject = function(object)
	{
		for(var i = 0; i < Editor$1.selection.length; i++)
		{
			if(Editor$1.selection[i].gui !== undefined && Editor$1.selection[i].gui.node !== undefined)
			{
				Editor$1.selection[i].gui.node.setSelected(false);
			}
		}

		Editor$1.selection = [object];

		if(object.gui !== undefined && object.gui.node !== undefined)
		{
			if(object.gui.node.setSelected !== undefined)
			{
				object.gui.node.setSelected(true);
			}
			if(object.gui.node.expandToRoot !== undefined)
			{
				object.gui.node.expandToRoot();
			}
		}

		Editor$1.updateSelectionGUI();
	};

	/** 
	 * Add object to selection.
	 * 
	 * @method addToSelection
	 * @param {Object3D} object Object to add to selection.
	 * @param {boolean} updateClient If false does not update the management client.
	 */
	Editor$1.addToSelection = function(object)
	{
		Editor$1.selection.push(object);

		if(object.gui !== undefined && object.gui.node !== undefined)
		{
			if(object.gui.node.setSelected !== undefined)
			{
				object.gui.node.setSelected(true);
			}
			if(object.gui.node.expandToRoot !== undefined)
			{
				object.gui.node.expandToRoot();
			}
		}

		Editor$1.updateSelectionGUI();
	};

	/**
	 * Remove from selection.
	 * 
	 * @method unselectObject
	 * @param {Object3D} object Object to remove from selection.
	 */
	Editor$1.unselectObject = function(object)
	{
		for(var i = 0; i < Editor$1.selection.length; i++)
		{
			if(Editor$1.selection[i].uuid === object.uuid)
			{
				if(Editor$1.selection[i].gui !== undefined && Editor$1.selection[i].gui.node !== undefined)
				{
					if(Editor$1.selection[i].gui.node.setSelected !== undefined)
					{
						Editor$1.selection[i].gui.node.setSelected(false);
					}
				}
				
				Editor$1.selection.splice(i, 1);
				Editor$1.updateSelectionGUI();
				return;
			}
		}
	};

	/**
	 * Get device pixel ratio based on the editor configuration.
	 *
	 * @static
	 * @method getPixelRatio
	 * @return {number} Device pixel ratio.
	 */
	Editor$1.getPixelRatio = function()
	{
		return Editor$1.settings.general.ignorePixelRatio ? 1.0 : window.devicePixelRatio;
	};

	/**
	 * Check if a object is selected.
	 * 
	 * @method isSelected
	 * @param {Object3D} Check if object is selected.
	 */
	Editor$1.isSelected = function(object)
	{
		for(var i = 0; i < Editor$1.selection.length; i++)
		{
			if(Editor$1.selection[i].uuid === object.uuid)
			{
				return true;
			}
		}

		return false;
	};

	/** 
	 * Resize the editor to fit the document body.
	 *
	 * @static
	 * @method resize
	 */
	Editor$1.resize = function()
	{
		if(!Nunu.isFullscreen())
		{
			Editor$1.gui.updateInterface();
		}
	};

	/**
	 * Check if there is some object selected.
	 *
	 * @static
	 * @method hasObjectSelected
	 * @return {boolean} True if there is an object selected.
	 */
	Editor$1.hasObjectSelected = function()
	{
		return Editor$1.selection.length > 0;
	};

	/**
	 * Clear object selection.
	 * 
	 * @method clearSelection
	 */
	Editor$1.clearSelection = function()
	{
		for(var i = 0; i < Editor$1.selection.length; i++)
		{
			if(Editor$1.selection[i].gui !== undefined && Editor$1.selection[i].gui.node !== undefined)
			{
				if(Editor$1.selection[i].gui.node.setSelected !== undefined)
				{
					Editor$1.selection[i].gui.node.setSelected(false);
				}
			}
		}

		Editor$1.selection = [];
	};

	/**
	 * Add action to history.
	 *
	 * Automatically calls the change method of GUI elements.
	 * 
	 * @method addAction
	 * @param {Action} action Action to add to the history.
	 */
	Editor$1.addAction = function(action)
	{
		Editor$1.history.add(action);
	};

	/**
	 * Get currently active scene in the editor.
	 *
	 * @static
	 * @method getScene
	 * @return {Scene} The scene currently active in the editor, null if none available.
	 */
	Editor$1.getScene = function()
	{
		if(Editor$1.program.children.length > 0)
		{
			return Editor$1.program.children[0];
		}

		return null;
	};

	/**
	 * Add objects to a parent, and creates an action in the editor history. 
	 * 
	 * If no parent is specified it adds to object to the current scene. 
	 *
	 * @static
	 * @method addObject
	 * @param {Object3D} object Object to be added.
	 * @param {Object3D} parent Parent object, if undefined the program scene is used.
	 */
	Editor$1.addObject = function(object, parent)
	{
		if(parent === undefined)
		{
			parent = Editor$1.getScene();
		}

		var actions = [new AddAction(object, parent)];
		var resources = ResourceCrawler.searchObject(object, Editor$1.program);

		for(var category in resources)
		{
			for(var resource in resources[category])
			{
				actions.push(new AddResourceAction(resources[category][resource], Editor$1.program, category));
			}
		}

		Editor$1.addAction(new ActionBundle(actions));
	};

	/**
	 * Rename object, if none passed as argument selected object is used.
	 *
	 * @static
	 * @method renameObject
	 * @param {Object3D} object Object to be renamed.
	 */
	Editor$1.renameObject = function(object)
	{
		if(object === undefined)
		{
			if(Editor$1.hasObjectSelected())
			{
				object = Editor$1.selection[0];
			}
			else
			{
				return;
			}
		}

		if(!object.locked)
		{
			var name = Editor$1.prompt(Locale.renameObject, object.name);
			if(name !== null && name !== "")
			{
				Editor$1.addAction(new ChangeAction(object, "name", name));
			}
		}
	};


	/**
	 * Delete object from the editor, and creates an action in the editor history. 
	 * 
	 * @method deleteObject
	 * @param {Array} objects List of objects.
	 */
	Editor$1.deleteObject = function(object)
	{
		var selected = (object === undefined) ? Editor$1.selection : [object];
		
		// List of delete actions
		var actions = [];

		// Delect selection
		for(var i = 0; i < selected.length; i++)
		{
			// Object3D
			if(selected[i].isObject3D && !selected[i].locked && !(selected[i] instanceof Program))
			{
				actions.push(new RemoveAction(selected[i]));
			}
			// Material
			else if(selected[i] instanceof three.Material)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "materials"));
			}
			// Texture
			else if(selected[i] instanceof three.Texture)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "textures"));
			}
			// Font
			else if(selected[i] instanceof Font)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "fonts"));
			}
			// Audio
			else if(selected[i] instanceof Audio)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "audio"));
			}
			// Video
			else if(selected[i] instanceof Video)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "videos"));
			}
			// Geometries
			else if(selected[i] instanceof three.Geometry || selected[i] instanceof three.BufferGeometry)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "geometries"));
			}
			// Shapes
			else if(selected[i] instanceof three.Shape)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "shapes"));
			}
			// Resources
			else if(selected[i] instanceof Resource)
			{
				Editor$1.addAction(new RemoveResourceAction(selected[i], Editor$1.program, "resources"));
			}
			// Unknown
			else
			{
				console.warn("nunuStudio: Cant delete type of object.");
			}
		}

		// Check if any action was added
		if(actions.length > 0)
		{
			Editor$1.addAction(new ActionBundle(actions));
		}
	};

	/**
	 * Copy selected object to the clipboard.
	 *
	 * Uses the JSON serialization of the object.
	 *
	 * @static
	 * @method copyObject
	 * @param {Object3D} object Object to copy.
	 */
	Editor$1.copyObject = function(object)
	{
		// If no object passed copy selected object
		if(object === undefined)
		{
			if(Editor$1.hasObjectSelected())
			{
				object = Editor$1.selection[0];
			}
			else
			{
				return;
			}
		}

		if(object instanceof Program || object instanceof Scene)
		{
			return;
		}

		if(!object.locked)
		{
			Editor$1.clipboard.set(JSON.stringify(object.toJSON()), "text");
		}
	};

	/**
	 * Cut selected object, copy to the clipboard and delete it.
	 *
	 * Uses the JSON serialization of the object.
	 *
	 * @static
	 * @method copyObject
	 * @param {Object3D} object Object to copy.
	 */
	Editor$1.cutObject = function(object)
	{
		if(object === undefined)
		{
			if(Editor$1.hasObjectSelected())
			{
				object = Editor$1.selection[0];
			}
			else
			{
				return;
			}
		}

		// Avoid cutting program or scene objects
		if(object instanceof Program || object instanceof Scene)
		{
			return;
		}

		if(!object.locked)
		{
			Editor$1.clipboard.set(JSON.stringify(object.toJSON()), "text");
			Editor$1.addAction(new RemoveAction(object));
		}
	};

	/**
	 * Paste object as children of target object.
	 *
	 * @static
	 * @method pasteObject
	 * @param {Object3D} parent
	 */
	Editor$1.pasteObject = function(target)
	{
		try
		{
			var content = Editor$1.clipboard.get("text");
			var data = JSON.parse(content);

			// Create object
			var obj = new ObjectLoader().parse(data);
			obj.traverse(function(child)
			{
				child.uuid = three.Math.generateUUID();
			});

			// Add object to target
			if(target !== undefined && !target.locked)
			{
				Editor$1.addObject(obj, target);
			}
			else
			{
				Editor$1.addObject(obj);
			}
		}
		catch(e)
		{
			Editor$1.alert(Locale.errorPaste);
		}
	};

	/**
	 * Redo history action.
	 * 
	 * @method redo
	 */
	Editor$1.redo = function()
	{
		if(Editor$1.history.redo())
		{
			Editor$1.updateObjectsViewsGUI();
		}
		else
		{
			Editor$1.alert(Locale.nothingToRedo);
		}
	};

	/**
	 * Undo history action.
	 * 
	 * @method undo
	 */
	Editor$1.undo = function()
	{
		if(Editor$1.history.undo())
		{
			Editor$1.updateObjectsViewsGUI();
		}
		else
		{
			Editor$1.alert(Locale.nothingToUndo);
		}
	};

	/**
	 * Create default resouces to be used when creating new objects.
	 *
	 * @static
	 * @method createDefaultResouces
	 */
	Editor$1.createDefaultResouces = function()
	{
		Editor$1.defaultImage = new Image(Global.FILE_PATH + "default.png");
		Editor$1.defaultFont = new Font(Global.FILE_PATH + "default.json");
		Editor$1.defaultAudio = new Audio(Global.FILE_PATH + "default.mp3");

		Editor$1.defaultTexture = new three.Texture(Editor$1.defaultImage);
		Editor$1.defaultTexture.name = "texture";

		Editor$1.defaultTextureParticle = new three.Texture(new Image(Global.FILE_PATH + "particle.png"));
		Editor$1.defaultTextureParticle.name = "particle";

		Editor$1.defaultImageTerrain = new Image(Global.FILE_PATH + "terrain.png");
		Editor$1.defaultImageTerrain.name = "terrain";

		Editor$1.defaultGeometry = new three.BoxBufferGeometry(1, 1, 1);
		Editor$1.defaultGeometry.name = "box";

		Editor$1.defaultMaterial = new three.MeshStandardMaterial({roughness: 0.6, metalness: 0.2});
		Editor$1.defaultMaterial.name = "standard";
		
		Editor$1.defaultSpriteMaterial = new three.SpriteMaterial({map: Editor$1.defaultTexture, color: 0xFFFFFF});
		Editor$1.defaultSpriteMaterial.name = "sprite";

		Editor$1.defaultTextureLensFlare = [];
		for(var i = 0; i < 4; i++)
		{
			var texture = new three.Texture(new Image(Global.FILE_PATH + "lensflare/lensflare" + i + ".png"));
			texture.name = "lensflare" + i;
			Editor$1.defaultTextureLensFlare.push(texture);
		}
	};

	Editor$1.updateSettings = function()
	{
		Editor$1.gui.tab.updateSettings();
	};

	/**
	 * Update all object views
	 *
	 * @static
	 * @method updateObjectsViewsGUI
	 */
	Editor$1.updateObjectsViewsGUI = function()
	{
		Editor$1.gui.tab.updateObjectsView();
		Editor$1.gui.tab.updateMetadata();
	};

	/**
	 * Update tabs after changing selection.
	 *
	 * @static
	 * @method updateSelectionGUI
	 */
	Editor$1.updateSelectionGUI = function()
	{
		Editor$1.gui.tab.updateMetadata();
		Editor$1.gui.tab.updateSelection();
	};

	/**
	 * Reset the editor state.
	 *
	 * @static
	 * @method resetEditor
	 */
	Editor$1.resetEditor = function()
	{
		Editor$1.clearSelection();

		Editor$1.gui.tab.updateObjectsView();
		Editor$1.gui.tab.updateMetadata();
		Editor$1.gui.tab.updateSelection();
	};

	/**
	 * Create a program and set to the editor.
	 * 
	 * @method createNewProgram
	 */
	Editor$1.createNewProgram = function()
	{
		var program = new Program();
		
		Editor$1.createDefaultResouces();
		Editor$1.setProgram(program);
		Editor$1.addDefaultScene(Editor$1.defaultMaterial);
		Editor$1.setOpenFile(null);
	};

	/**
	 * Create a scene using a default template.
	 * 
	 * This is the scene used when creating a new program or scene inside the editor.
	 * 
	 * @method addDefaultScene
	 * @param {Material} material Default material used by objects, if empty a new material is created
	 */
	Editor$1.addDefaultScene = function(material)
	{
		if(material === undefined)
		{
			material = new three.MeshStandardMaterial({roughness: 0.6, metalness: 0.2});
			material.name = "default";
		}

		// Create new scene
		var scene = new Scene();

		// Sky
		var sky = new Sky();
		sky.autoUpdate = false;
		scene.add(sky);

		// Box
		var model = new Mesh(Editor$1.defaultGeometry, material);
		model.name = "box";
		scene.add(model);

		// Floor
		var ground = new three.BoxBufferGeometry(20, 1, 20);
		ground.name = "ground";
		
		model = new Mesh(ground, material);
	 	model.position.set(0, -1.0, 0);
		model.name = "ground";
		scene.add(model);

		// Add scene to program
		Editor$1.addObject(scene, Editor$1.program);

		// Open scene
		var tab = Editor$1.gui.tab.addTab(SceneEditor, true);
		tab.attach(scene);
	};

	/**
	 * Save program to file.
	 *
	 * @static
	 * @method saveProgram
	 * @param {string} fname
	 * @param {boolean} binary If true the file is saved as nsp.
	 * @param {boolean} keepDirectory
	 * @param {boolean} supressMessage
	 */
	Editor$1.saveProgram = function(fname, binary, keepDirectory, suppressMessage)
	{
		try
		{
			if(fname === undefined && Editor$1.openFile !== null)
			{
				fname = Editor$1.openFile;
			}

			if(binary === true)
			{
				fname = fname.replace(".isp", ".nsp");

				var pson$1 = new pson.StaticPair();
				var data = pson$1.toArrayBuffer(Editor$1.program.toJSON());
				FileSystem.writeFileArrayBuffer(fname, data);
			}
			else
			{
				fname = fname.replace(".nsp", ".isp");

				var json = JSON.stringify(Editor$1.program.toJSON(), null, "\t");
				FileSystem.writeFile(fname, json);
			}

			if(keepDirectory !== true && Editor$1.openFile !== fname)
			{
				Editor$1.setOpenFile(fname);
			}
			
			if(suppressMessage !== true)
			{
				Editor$1.alert(Locale.projectSaved);
			}
		}
		catch(e)
		{
			Editor$1.alert(Locale.errorSavingFile + "\n(" + e + ")");
			console.error("nunuStudio: Error saving file", e);
		}
	};

	/**
	 * Set a program to be edited, create new history object and clear editor windows.
	 *
	 * @static
	 * @method setProgram
	 * @param {Program} program
	 */
	Editor$1.setProgram = function(program)
	{
		if(Editor$1.program !== program)
		{
			if(Editor$1.program !== null)
			{
				Editor$1.program.dispose();
			}

			Editor$1.program = program;

			// Tree view
			Editor$1.gui.tree.attach(Editor$1.program);
			Editor$1.gui.assetExplorer.attach(Editor$1.program);

			// History
			Editor$1.history = new History(Editor$1.settings.general.historySize);
			
			// Clear tabs
			Editor$1.gui.tab.clear();

			// Reset editor
			Editor$1.resetEditor();

			// Add new scene tab to interface
			if(program.children.length > 0)
			{
				var scene = Editor$1.gui.tab.addTab(SceneEditor, true);
				scene.attach(program.children[0]);
			}
		}
	};

	/**
	 * Load program from file.
	 *
	 * Programs can be stored as textual json files, or PSON files (binary).
	 *
	 * @static
	 * @method loadProgram
	 * @param {File} file
	 * @param {boolean} binary Indicates if the file is binary.
	 */
	Editor$1.loadProgram = function(file, binary)
	{
		var modal = new LoadingModal(DocumentBody);
		modal.show();

		function onload()
		{
			try
			{
				var loader = new ObjectLoader();

				var program;

				if(binary === true)
				{
					var pson$1 = new pson.StaticPair();
					var data = pson$1.decode(reader.result);
					program = loader.parse(data);
				}
				else
				{
					program = loader.parse(JSON.parse(reader.result));
				}

				Editor$1.setOpenFile(file);
				Editor$1.setProgram(program);

				Editor$1.alert(Locale.projectLoaded);
			}
			catch(e)
			{
				Editor$1.alert(Locale.errorLoadingFile + "\n(" + e + ")");
				console.error("nunuStudio: Error loading file", e);
			}

			modal.destroy();
		}
		if(file instanceof File)
		{
			var reader = new FileReader();
			reader.onload = onload;
			if(binary === true)
			{
				reader.readAsArrayBuffer(file);
			}
			else
			{
				reader.readAsText(file);
			}
		}
		else if(typeof file === "string")
		{
			var reader = {};
			if(binary === true)
			{
				reader.result = FileSystem.readFileArrayBuffer(file);
			}
			else
			{
				reader.result = FileSystem.readFile(file);
			}
			onload();
		}
	};

	/**
	 * Set currently open file (also updates the editor title), if running in browser is not used.
	 *
	 * Used for the editor to remember the file location that it is currently working on.
	 *
	 * @static
	 * @method setOpenFile
	 * @param {string} file Path of file currently open.
	 */
	Editor$1.setOpenFile = function(file)
	{
		if(file !== undefined && file !== null)
		{	
			if(file instanceof window.File)
			{
				if(Nunu.runningOnDesktop())
				{
					Editor$1.openFile = file.path;
				}
				else
				{
					Editor$1.openFile = file.name;
				}
			}
			else
			{
				Editor$1.openFile = file;
			}

			document.title = Nunu.NAME + " " + Nunu.VERSION + " (" + Nunu.TIMESTAMP + ") (" + Editor$1.openFile + ")";
		}
		else
		{
			Editor$1.openFile = null;
			document.title = Nunu.NAME + " " + Nunu.VERSION + " (" + Nunu.TIMESTAMP + ")";
		}
	};

	/**
	 * Show a confirm dialog with a message.
	 *
	 * @static
	 * @method confirm
	 * @param {string} message
	 * @return {boolean} True or false depending on the confirm result.
	 */
	Editor$1.confirm = function(message)
	{
		return window.confirm(message);	
	};

	/**
	 * Show a alert dialog with a message.
	 *
	 * @static
	 * @method confirm
	 * @param {string} message
	 */
	Editor$1.alert = function(message)
	{
		window.alert(message);
	};

	/**
	 * Prompt the user for a value.
	 *
	 * @static
	 * @method confirm
	 * @param {string} message
	 * @param {string} defaultValue
	 * @return {string} Value inserted by the user.
	 */
	Editor$1.prompt = function(message, defaultValue)
	{
		return window.prompt(message, defaultValue);	
	};

	/**
	 * Try to update nunuStudio editor version using build from github repo.
	 *
	 * The version timestamp (Nunu.TIMESTAMP) is parsed compared to the local timestamp.
	 *
	 * @static
	 * @method updateNunu
	 */
	Editor$1.updateNunu = function(silent)
	{
		if(silent === undefined)
		{
			silent = true;
		}

		try
		{
			var url = "https:// raw.githubusercontent.com/tentone/nunuStudio/master/build/nunu.editor.min.js";

			FileSystem.readFile(url, false, function(data)
			{
				var token = "Nunu.TIMESTAMP";
				var pos = data.search(token);
				var timestamp = data.slice(pos + token.length + 2, pos + token.length + 14);

				if(parseInt(timestamp) > parseInt(Editor$1.TIMESTAMP))
				{
					FileSystem.writeFile("nunu.min.js", data);
					Editor$1.alert(Locale.updatedRestart);
				}
				else
				{
					if(!silent)
					{
						Editor$1.alert(Locale.alreadyUpdated);
					}
				}
			});
		}
		catch(e)
		{
			if(!silent)
			{
				Editor$1.alert(Locale.updateFailed);
			}
		}
	};

	/**
	 * Get the renderer configuration used for the editor elements.
	 *
	 * Is defined in the settings tab and can be overrided by the project settings.
	 *
	 * @static
	 * @method getRendererConfig
	 */
	Editor$1.getRendererConfig = function()
	{
		return Editor$1.settings.render.followProject ? Editor$1.program.rendererConfig : Editor$1.settings.render;
	};

	/**
	 * Exit the editor and close all windows.
	 *
	 * @static
	 * @method exit.
	 */
	Editor$1.exit = function()
	{
		if(Nunu.runningOnDesktop())
		{
			Editor$1.settings.store();
			
			var gui = require("nw.gui");
			var win = gui.Window.get();

			gui.App.closeAllWindows();
			win.close(true);
			gui.App.quit();
		}
	};

	exports.Editor = Editor$1;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
